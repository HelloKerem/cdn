<roblox xmlns:xmime="http://www.w3.org/2005/05/xmlmime" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://www.rbolock.tk/roblox.xsd" version="4">
	<Meta name="ExplicitAutoJoints">true</Meta>
	<External>null</External>
	<External>nil</External>
	<Item class="ModuleScript" referent="RBX654E4712217D4B418CDE067C5C6B4E7E">
		<Properties>
			<BinaryString name="AttributesSerialize"></BinaryString>
			<Content name="LinkedSource"><null></null></Content>
			<string name="Name">MainModule</string>
			<string name="ScriptGuid">{26B8E635-5080-44C2-A709-257967B3DD82}</string>
			<ProtectedString name="Source"><![CDATA[-- Used ChatGPT/AI and my mind to implement this since, y e s, i dont want to replace every ` on all of the scripts using my hands

local module = {}

--[[

	CORTEX SOURCE CODE -- 2023
	WRITTEN BY aaxtatious (540781721) & ImFirstPlace (79641334)
	DISTRIBUTION IS ALLOWED; HOWEVER, YOU MUST GIVE CREDIT TO WRITERS
	
	Module code rewrite: 08/09/2023 (aaxtatious, 540781721)
	
	Â© 2023 Cortex Elevator Co.

]]--

module.versionData = {
	['BETA'] = {
		['CORE'] = {
			['version'] = '10.0'
		},
	},
	['ALPHA'] = {
		['CORE'] = {
			['version'] = '9.1'
		},
	},
	['DEVELOPMENT'] = {
		['CORE'] = {
			['version'] = '9.1'
		},
	},
	['STABLE'] = {
		['CORE'] = {
			['version'] = '9.1'
		},
	},
}

--local ASSET_ID = 8533575827 --// DO NOT TOUCH //--

local httpService = game:GetService('HttpService')
local dependencies = script:WaitForChild('Dependencies')
local runService = game:GetService('RunService')
local marketplaceService = game:GetService('MarketplaceService')
local insertService = game:GetService('InsertService')
local replicatedFirst = game:GetService('ReplicatedFirst')
local replicatedStorage = game:GetService('ReplicatedStorage')
local players = game:GetService('Players')
--local currentAssetVersion = insertService:GetLatestAssetVersionAsync(ASSET_ID)

if (not runService:IsServer()) then return warn("Cortex MainModule can only be ran on the server!") end

local startupModules = script:WaitForChild('Startup_Modules')
local requiredStartupModules = {}
for i, v in pairs(startupModules:GetChildren()) do
	local ran,res = pcall(require, v)
	if (ran) then
		requiredStartupModules[v.Name] = {module=v,req=res}
		local ran,res = pcall(res.init_start)
		if (not ran) then warn("Cortex Startup Module Error: failed to run internal function in {v.Name} :: {res}") end
	else
		warn("Cortex Startup Module Error :: {res}")
	end
end

_G.Required_Elevator_Cache = _G.Required_Elevator_Cache or {}
_G.Elevator_Output_Storage_GLOBAL = _G.Elevator_Output_Storage_GLOBAL or {}
_G.CortexElevatorStorage = _G.CortexElevatorStorage or {}
_G.CORTEX_RC_WHITELIST = _G.CORTEX_RC_WHITELIST or {}

_G.Core_CurrentVersion = '6.0'
_G.TravelFiccient_CurrentVersion = '2.0'

_G.CORTEX_RC_WHITELIST = typeof(_G.CORTEX_RC_WHITELIST) == 'table' and _G.CORTEX_RC_WHITELIST or {}

local function keyClient(player: Player)
	--task.spawn(function()
	--	task.wait()
	--	local playerGui = player:WaitForChild('PlayerGui')
	--	local gui = player:FindFirstChild('KEY_SWITCH_HANDLERS')
	--	if (not gui) then
	--		gui = Instance.new('ScreenGui')
	--		gui.Name = 'KEY_SWITCH_HANDLERS'
	--		gui.ResetOnSpawn = false
	--		local src = dependencies.KEY_CLIENT_CONTROL:Clone()
	--		src.Parent = gui
	--		gui.Parent = playerGui
	--	end
	--end)
end

local function rcPlayerGui(player: Player)
	task.spawn(function()
		task.wait()
		local playerGui = player:FindFirstChild('PlayerGui')
		if (not _G.CORTEX_RC_WHITELIST[tostring(player.UserId)]) then return end
		local gui = playerGui:FindFirstChild('ELEVATOR_GUI')
		if (not gui) then
			gui = dependencies:WaitForChild('ELEVATOR_GUI'):Clone()
			gui.IgnoreGuiInset = true
			gui.ResetOnSpawn = false
			gui.Enabled = true
			gui.Parent = playerGui
		end
	end)
end

players.PlayerAdded:Connect(rcPlayerGui)
for _, v in pairs(players:GetChildren()) do
	rcPlayerGui(v)
end

local REMOTECONTROLS_API = game.ReplicatedStorage:FindFirstChild('CORTEX_RC_REMOTE') or Instance.new('RemoteFunction', game.ReplicatedStorage)
REMOTECONTROLS_API.Name = 'CORTEX_RC_REMOTE'
function REMOTECONTROLS_API.OnServerInvoke(USER, ELEVATOR, PARAMS)
	if (not _G.CORTEX_RC_WHITELIST[tostring(USER.UserId)]) then return end
	ELEVATOR.Cortex_API:Fire(unpack(PARAMS))
end

local globalRemote = game.ReplicatedStorage:FindFirstChild('Coretex_Remote_GLOBAL')
if (not globalRemote) then
	globalRemote = Instance.new('RemoteEvent')
	globalRemote.Name = 'Cortex_Remote_GLOBAL'
	globalRemote.Parent = game.ReplicatedStorage
end

local remoteSignal = replicatedStorage:FindFirstChild('Cortex_Remote_Signal')
if (not remoteSignal) then
	remoteSignal = Instance.new('RemoteFunction')
	remoteSignal.Name = 'Cortex_Remote_Signal'
	remoteSignal.Parent = replicatedStorage
	function remoteSignal.OnServerInvoke(user, protocol, params)
		if (protocol == 'GET_PLAYER_WELDS') then
			local signal = params:FindFirstChild('Cortex_Signal')
			if (not signal) then return end
			return signal:Invoke('GET_ELEVATOR_WELDS')
		end
	end
end

local function createErrorMsg(title: string, message: string, player: Player?)
	local function addGui(append: Instance)
		local newGui = dependencies.ErrorMsg:Clone()
		newGui.Parent = append
		newGui.Enabled = true
		newGui.Frame.Title.Text = title
		newGui.Frame.Message.Text = message
		newGui.Frame.Position = UDim2.fromOffset(0,-newGui.Frame.AbsoluteSize.Y)
		game:GetService('TweenService'):Create(newGui.Frame,TweenInfo.new(.15,Enum.EasingStyle.Quart,Enum.EasingDirection.Out),{Position=UDim2.fromScale(.5,0)}):Play()
		local tween = game:GetService('TweenService'):Create(newGui.Frame.Status,TweenInfo.new(7,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Size=UDim2.fromOffset(0,newGui.Frame.Status.AbsoluteSize.Y)})
		tween:Play()
		tween.Completed:Wait()
		local tween = game:GetService('TweenService'):Create(newGui.Frame,TweenInfo.new(.1,Enum.EasingStyle.Quart,Enum.EasingDirection.Out),{Position=UDim2.fromOffset(0,-newGui.Frame.AbsoluteSize.Y)+UDim2.fromScale(.5,0)})
		tween:Play()
		tween.Completed:Wait()
		newGui:Destroy()
	end
	if (runService:IsRunMode()) then
		local starterGui = game:GetService('StarterGui')
		starterGui.ShowDevelopmentGui = true
		local newGui = starterGui:FindFirstChild(dependencies.ErrorMsg.Name)
		if (not newGui) then
			task.spawn(addGui, starterGui)
		end
	else
		for i,v in pairs(game.Players:GetChildren()) do
			if (v == player or (not player)) then
				local newGui = v.PlayerGui:FindFirstChild(dependencies.ErrorMsg.Name)
				if (not newGui) then
					task.spawn(addGui, v.PlayerGui)
				end
			end
		end
	end
end

--[[task.spawn(function()
	while true do
		task.wait(60)
		local webVersion = insertService:GetLatestAssetVersionAsync(ASSET_ID)
		if (webVersion ~= currentAssetVersion) then
			currentAssetVersion = webVersion
			print(string.format([[
				----------------------
				>>>>>>>>>> %s <<<<<<<<<<<<
				NEW CORTEX MAINMODULE VERSION AVAILABLE
				A new version of the Cortex MainModule is available; new version will apply after server restarts.
				----------------------
			]]--[[, webVersion))
		end
	end
end)]]

return function(source, config, initProtocol, versionData)
	task.spawn(function()
		for i,v in pairs(requiredStartupModules) do
			local ran,res = pcall(v.req.init_core)
			if (not ran) then warn("Cortex Startup Module Error: failed to run internal function on initiate in module {v.module.Name} :: {res}") end
		end
	end)

	versionData = { ['BUILD'] = if (typeof(versionData) == 'table') then versionData.BUILD else 'STABLE' }

	local moduleTree = script.Modules:FindFirstChild(string.upper(versionData.BUILD))
	if (not moduleTree) then
		warn("Cortex MainModule Initiator - Elevator model {source.Parent.Name} :: Build '{versionData.BUILD}' not found! Falling back to the 'STABLE' build")
		moduleTree = script.Modules.STABLE
		versionData.BUILD = 'STABLE'
	end

	if (initProtocol == 'Core') then
		local uniqueID = source:GetAttribute('UniqueID') or "CortexElevator_"..httpService:GenerateGUID(false)
		local moduleCache = _G.Required_Elevator_Cache[uniqueID]
		local car,floors = source.Parent:FindFirstChild('Car'),source.Parent:FindFirstChild('Floors')
		if ((not car) or (not floors)) then return error(string.format('CORTEX CLASSIC %s :: INITIATION FATAL ERROR - INITIATED MODEL IS NOT source VALID ELEVATOR MODEL TO INITIATE THE \'CORE\' MODULE', _G['Core_CurrentVersion'])) end

		source.Parent:SetAttribute("CortexBuild", versionData.BUILD)

		if (not moduleCache) then
			_G.Required_Elevator_Cache[uniqueID] = moduleTree.Core:Clone()
			moduleCache = _G.Required_Elevator_Cache[uniqueID]
		end

		local ran,res = pcall(require, moduleCache)
		if (not ran) then task.spawn(createErrorMsg, "{(module.versionData[versionData.BUILD] or module.versionData.STABLE).CORE.version} Initiation Error", res) return error("Cortex MainModule :: ERROR ENCOUNTERED WHILST RUNNING {string.upper(initProtocol)} ---- {res}") end

		ran,res = pcall(res.Start, source, config, {['BUILD']=versionData.BUILD,['VERSION']=(module.versionData[versionData.BUILD] or module.versionData.STABLE).CORE.version}, dependencies)
		if (not ran) then task.spawn(createErrorMsg, "{(module.versionData[versionData.BUILD] or module.versionData.STABLE).CORE.version} Initiation Error", res) return error("Cortex MainModule :: ERROR ENCOUNTERED WHILST RUNNING {string.upper(initProtocol)} ---- {res}") end
	elseif (initProtocol == 'TravelFiccient') then
		local panels = source.Parent:FindFirstChild('Panels')
		if (not panels) then return error(string.format('CORTEX TRAVELFICCIENT %s :: INITIATION FATAL ERROR - INITIATED MODEL IS NOT source VALID TRAVELFICCIENT BANK MODEL TO INITIATE THE \'TRAVELFICCIENT\' MODULE', _G['TravelFiccient_CurrentVersion'])) end
		for i,v in pairs(panels:GetDescendants()) do
			if (v.Name == 'Panel') then
				local ran,res = pcall(require, moduleTree.TravelFiccient:Clone())
				ran,res = pcall(res, v, config, moduleTree.Core.Voice_Module)
				if (not ran) then return error("Cortex MainModule :: ERROR ENCOUNTERED WHILST RUNNING {string.upper(initProtocol)} ---- {res}") end
			end
		end
	elseif (initProtocol == 'Multi_Bay') then
		local callButtons = source.Parent:FindFirstChild('Call_Buttons')
		if (not callButtons) then return error('CORTEX MULTIBAY :: INITIATION FATAL ERROR - INITIATED MODEL IS NOT source VALID MULTIBAY BANK MODEL TO INITIATE THE \'MULTIBAY\' MODULE') end
		require(moduleTree.Multi_Bay:Clone())(source)
	elseif (config == 'Auto_Door') then
		require(moduleTree.Auto_Door_Controller:Clone())(source)
	elseif (initProtocol == 'Security_Guard') then
		require(moduleTree.Security_Guard_AI:Clone())(source, config)
	end
end]]></ProtectedString>
			<int64 name="SourceAssetId">8533575827</int64>
			<BinaryString name="Tags"></BinaryString>
		</Properties>
		<Item class="Folder" referent="RBX80A701EF518D46F28B8A3C12A9C6AFD8">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Dependencies</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ScreenGui" referent="RBX8E1E03802C3F458D97C8F5384D02A437">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<int name="DisplayOrder">0</int>
					<bool name="Enabled">true</bool>
					<bool name="IgnoreGuiInset">false</bool>
					<string name="Name">Cortex_Error_Gui</string>
					<bool name="ResetOnSpawn">false</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<token name="ZIndexBehavior">1</token>
				</Properties>
				<Item class="Frame" referent="RBX381D7A9562264B0CB13F38358A0EFAE6">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.203921586</R>
							<G>0.203921586</G>
							<B>0.203921586</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>-0.150000006</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.600000024</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>75</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIStroke" referent="RBX365CA3D753FF4FC5B29E00D01692E9D6">
						<Properties>
							<token name="ApplyStrokeMode">1</token>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Color3 name="Color">
								<R>1</R>
								<G>0</G>
								<B>0.0156862754</B>
							</Color3>
							<bool name="Enabled">true</bool>
							<token name="LineJoinMode">0</token>
							<string name="Name">UIStroke</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<float name="Thickness">1</float>
							<float name="Transparency">0</float>
						</Properties>
					</Item>
					<Item class="UICorner" referent="RBX2A0F84948B7047BB89888ADA447D7E23">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXC070F14AD05C4318AAD0A846658E9D8B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">2</token>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/Arial.json</url></Family>
								<Weight>700</Weight>
								<Style>Normal</Style>
								<CachedFaceId><url>rbxasset://fonts/arialbd.ttf</url></CachedFaceId>
							</Font>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Title</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.0500000007</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.349999994</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Title Message</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBXB7F71DDE9A704E7B81E3EF538CEE7581">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">1</token>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/Arial.json</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
								<CachedFaceId><url>rbxasset://fonts/arial.ttf</url></CachedFaceId>
							</Font>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Message</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.949999988</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.800000012</XS>
								<XO>0</XO>
								<YS>0.550000012</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Message</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UITextSizeConstraint" referent="RBX60D47F7E44B34CF8B916A473507215FD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<int name="MaxTextSize">20</int>
								<int name="MinTextSize">1</int>
								<string name="Name">UITextSizeConstraint</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBX133D53F4C977453F88EAA299BB7053DD">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<int name="DisplayOrder">0</int>
					<bool name="Enabled">false</bool>
					<bool name="IgnoreGuiInset">false</bool>
					<string name="Name">Cortex_Notice</string>
					<bool name="ResetOnSpawn">false</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<token name="ZIndexBehavior">1</token>
				</Properties>
				<Item class="Frame" referent="RBXEBA44BA5B55E4B9581AD4B15E282D483">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.180392161</R>
							<G>0.180392161</G>
							<B>0.180392161</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.100000001</XS>
							<XO>100</XO>
							<YS>0.100000001</YS>
							<YO>350</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UICorner" referent="RBX2C6A2783E2C2448BB801F799627E5D25">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="TextButton" referent="RBX9E03192C8DF242CE9244B5B242E2A6ED">
						<Properties>
							<bool name="Active">true</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoButtonColor">false</bool>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.850980461</R>
								<G>0.172549024</G>
								<B>0.184313729</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">3</token>
							<Font name="FontFace">
								<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
								<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
							</Font>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<bool name="Modal">false</bool>
							<string name="Name">Close</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">false</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">true</bool>
							<bool name="Selected">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>40</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text"></string>
							<Color3 name="TextColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<bool name="TextScaled">false</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">false</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UICorner" referent="RBX5002BFD5FF344F56A22E015B0666EB61">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ImageLabel" referent="RBX0091666CE27146BA8602DF49EA42C677">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=3192543734</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">0</int>
								<string name="Name">Img</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">3</token>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>-5</XO>
									<YS>1</YS>
									<YO>-5</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX62243B874C634E409E9CD2436528F6F4">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Content</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX48320606D1A94430BBD1A6F1925807CE">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">100</token>
								<Font name="FontFace">
									<Family><url>rbxassetid://12187365364</url></Family>
									<Weight>700</Weight>
									<Style>Normal</Style>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">Top</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.899999976</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>40</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">IMPORTANT MESSAGE</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBXE730F21087DD42EF8ECACEE8C5FB303A">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">100</token>
								<Font name="FontFace">
									<Family><url>rbxassetid://12187365364</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">Msg1</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.100000001</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.899999976</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>20</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">&lt;u&gt;UPCOMING MAJOR UPDATE&lt;/u&gt;</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="Frame" referent="RBX0E95FCFF6D23498FAF3548A3C0C20F42">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">Paragraph</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.899999976</XS>
									<XO>0</XO>
									<YS>0.649999976</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBXCDDEC670896346AE993E311CEC150FB7">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">Msg1</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.319999993</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>55</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Features such as &lt;font color=&quot;#fae900&quot;&gt;door behavior&lt;/font&gt;, &lt;font color=&quot;#fae900&quot;&gt;lantern behavior&lt;/font&gt;, &lt;font color=&quot;#fae900&quot;&gt;movement&lt;/font&gt;, &lt;font color=&quot;#fae900&quot;&gt;audio importing&lt;/font&gt;, and more will significantly change.</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXC8D038FE00CD46ACBABED43A2E45C281">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">Msg2</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.200000003</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>55</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">A new release from the ALPHA branch will soon be pushed out to the Development and Stable branch.</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXC11CA3AC12774002B44C5F48BE859B99">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">Msg3</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.430000007</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>55</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">If you wish to opt-out of these changes for any reason or desire, a copy of legacy feature plugins will be &lt;b&gt;distributed&lt;/b&gt;, or a copy of the source code is always available.</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="UIListLayout" referent="RBX2AD9A9A4913F4EB09AA4BC0A712DBC38">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="FillDirection">1</token>
									<token name="HorizontalAlignment">0</token>
									<string name="Name">UIListLayout</string>
									<UDim name="Padding">
										<S>0</S>
										<O>5</O>
									</UDim>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">0</token>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBX6F939F4ED16B45A0B3D279F3124F117B">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Option</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-10</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.899999976</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextButton" referent="RBX78E1398665724361A3A919E11641C11C">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">3</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<bool name="Modal">false</bool>
								<string name="Name">Checkbox</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>5</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.600000024</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text"></string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIAspectRatioConstraint" referent="RBX662579BE2FD44147ACFB81B42DD79B8C">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="DominantAxis">0</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBX48946129676A4CA9B1D7031E14DF486E">
								<Properties>
									<token name="ApplyStrokeMode">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">0</token>
									<string name="Name">UIStroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">1</float>
									<float name="Transparency">0</float>
								</Properties>
							</Item>
							<Item class="ImageLabel" referent="RBX1D9026B1ED55495C9B30D6749BF29BE4">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxassetid://8589545938</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<string name="Name">Img</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">3</token>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>-2</XO>
										<YS>1</YS>
										<YO>-2</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBXCF7D2B38BFA44A278F9F4541E0366CDE">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">100</token>
								<Font name="FontFace">
									<Family><url>rbxassetid://12187365364</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TextLabel</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>20</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.800000012</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Do not show this message again.</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="UIListLayout" referent="RBXB14368EE06EF40088C4FF72BED2718FB">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<token name="FillDirection">0</token>
								<token name="HorizontalAlignment">0</token>
								<string name="Name">UIListLayout</string>
								<UDim name="Padding">
									<S>0</S>
									<O>10</O>
								</UDim>
								<token name="SortOrder">2</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<token name="VerticalAlignment">0</token>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="LocalScript" referent="RBX0E00C223C5454D108B1FA69FA1BEE2FB">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{7920BFC1-61E2-4DEB-8EF9-9863CCD20E08}</string>
						<ProtectedString name="Source"><![CDATA[local this = script.Parent
local frame = this.Frame
local remote = this:WaitForChild('RemoteEvent')
local tweenService = game:GetService('TweenService')
local closeDebounce = false

frame.Close.AutoButtonColor = false
frame.Close.BackgroundTransparency = 1
frame.Close.MouseEnter:Connect(function()
	tweenService:Create(frame.Close, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=0}):Play()
end)
frame.Close.MouseLeave:Connect(function()
	tweenService:Create(frame.Close, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=1}):Play()
end)
frame.Close.MouseButton1Click:Connect(function()
	if (closeDebounce) then return end
	closeDebounce = true
	local tween = tweenService:Create(frame, TweenInfo.new(.35, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position=UDim2.new(.5, 0, 1+frame.AnchorPoint.Y, 0)})
	tween:Play()
	tween.Completed:Wait()
	remote:FireServer('destroy', {SHOW_MESSAGE=frame.Option.Checkbox:GetAttribute('isEnabled')})
end)

frame.Option.Checkbox:SetAttribute('isEnabled', false)
frame.Option.Checkbox.MouseButton1Click:Connect(function()
	local isEnabled = not frame.Option.Checkbox:GetAttribute('isEnabled')
	frame.Option.Checkbox:SetAttribute('isEnabled', isEnabled)
	tweenService:Create(frame.Option.Checkbox.Img, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {ImageTransparency=isEnabled and 0 or 1}):Play()
end)
local isEnabled = frame.Option.Checkbox:GetAttribute('isEnabled')
tweenService:Create(frame.Option.Checkbox.Img, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {ImageTransparency=isEnabled and 0 or 1}):Play()]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBX020C79E7CEDF46A6A15BC4F5DE26FB5C">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<int name="DisplayOrder">0</int>
					<bool name="Enabled">true</bool>
					<bool name="IgnoreGuiInset">false</bool>
					<string name="Name">Elevator_Audio_Handler_Client</string>
					<bool name="ResetOnSpawn">false</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<token name="ZIndexBehavior">1</token>
				</Properties>
				<Item class="LocalScript" referent="RBXC8E8D854C8494422820F7E13FC899574">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Elevator_Audio_Handler</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{584082A3-4344-4F72-AEEC-89B3249BDA16}</string>
						<ProtectedString name="Source"><![CDATA[local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local tweenService = game:GetService('TweenService')

local params = RaycastParams.new()
params.FilterType = Enum.RaycastFilterType.Whitelist
local overlapParams = OverlapParams.new()
overlapParams.FilterType = Enum.RaycastFilterType.Whitelist
local elevators = {}
local raycastDistance = 30

player.CharacterAdded:Connect(function(char)
	character = char
end)

local data = {
	['enabled'] = {0,0,0},
	['disabled'] = {-80,10,-25},
}

game:GetService('RunService'):BindToRenderStep('cortexAudioHandlerUpdate', Enum.RenderPriority.Camera.Value+1, function()
	if (not character) then return end
	local root = character:FindFirstChild('HumanoidRootPart')
	if (not root) then return end
	params.FilterDescendantsInstances = elevators
	overlapParams.FilterDescendantsInstances = {root}
	for i,elevator in next,elevators do
		local function processFar(target: Part, soundGroup: SoundGroup)
			local distance = math.clamp((target.Position-root.Position).Magnitude/raycastDistance, 0, 1)
			local result = workspace:Raycast(root.Position, (target.Position-root.Position).Unit*raycastDistance, params)
			local isEnabled = (result and result.Instance == target) or #workspace:GetPartBoundsInBox(target.CFrame, target.Size, overlapParams) > 0
			tweenService:Create(soundGroup.Muffler, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {HighGain=isEnabled and data.enabled[1] or data.disabled[1]*distance,LowGain=isEnabled and data.enabled[2] or data.disabled[2]*distance,MidGain=isEnabled and data.enabled[3] or data.disabled[3]*distance}):Play()
		end
		if (not elevator.Car:FindFirstChild('Cab_Region')) then return end
		processFar(elevator.Car.Cab_Region, elevator.Car.Cab_Region.SoundGroup)
	end
end)

task.wait()
local function checkElevator(elev)
	if ((not elev) or (not elev:FindFirstChild('Cortex_API') or (not elev:FindFirstChild('Car') or table.find(elevators, elev)))) then return end
	table.insert(elevators, elev)
end
for i,v in next,workspace:GetDescendants() do
	checkElevator(v)
end
workspace.DescendantAdded:Connect(checkElevator)
workspace.DescendantRemoving:Connect(function(elev)
	task.wait()
	local index = table.find(elevators, elev)
	if (not index) then return end
	table.remove(elevators, index)
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ScreenGui" referent="RBXBE960DA9B37449A3BEDFDCFA9CC0C7C0">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<int name="DisplayOrder">0</int>
					<bool name="Enabled">true</bool>
					<bool name="IgnoreGuiInset">false</bool>
					<string name="Name">Cortex_ClientRefresh</string>
					<bool name="ResetOnSpawn">false</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<token name="ZIndexBehavior">1</token>
				</Properties>
				<Item class="LocalScript" referent="RBX7F7E2947E14642218F013A4876ED7E1E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">true</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">ClientRefresh_Handler</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{87AC633E-AD96-497B-897C-58338075E743}</string>
						<ProtectedString name="Source"><![CDATA[--[[

	// This code was written to help smooth & butter out the Cortex elevator movements. \\\
	
	-- 
	The ideology of this is simply easing the elevators position from a given previous point and a target point,
	and moves within the time frame of the time between the last server runtime frame and the current server runtime frame.
	--

]]--

local function getService(service: string)
	return game:GetService(service)
end

local runService: RunService = getService('RunService')
local httpService: HttpService = getService('HttpService')
local collectionService: CollectionService = getService('CollectionService')
local eventRemote: RemoteEvent = game.ReplicatedStorage:WaitForChild('CORTEX_CLIENT_INSTANCES'):WaitForChild('RUNTIME_REMOTE_SIGNAL')
local whitelist = script.Parent.WHITELIST_META

local runningElevators = {}

local id = httpService:GenerateGUID() -- Randomized ID for runtime handling

local function createData(elevator: any)
	return {
		lastTick=tick(),
		elevator=elevator,
	}
end
local function initiateElevator(elevator: any)
	if (not elevator) then return end
	local elevatorID = elevator:GetAttribute('elevatorID')
	local data = runningElevators[tostring(elevatorID)]
	local platform = elevator.Car.Platform
	local startTick = tick()
	
end

eventRemote.OnClientEvent:Connect(function(dtTime)
	--print(dtTime)
	local startTick = tick()
	local alpha = 0
	while (alpha < 1) do
		alpha = math.clamp((tick()-startTick)/dtTime, 0, 1)
		for i,v in next,runningElevators do
			v.elevator.Car.Platform.CFrame = v.lastPosition:Lerp(v.elevator.Car.Platform.targetPoint.Value, alpha)
		end
		runService.PreRender:Wait()
	end
end)

local function getElevatorByIdInWL(id: any)
	local DATA_DECODED = httpService:JSONDecode(whitelist.Value)
	return typeof(DATA_DECODED) == 'table' and DATA_DECODED[tostring(id)] or nil
end

runService:BindToRenderStep('elevatorUpdate', Enum.RenderPriority.First.Value+1, function()

	for i,v in next,collectionService:GetTagged('cortexElevatorInstance') do
		local elevatorID = v:GetAttribute('elevatorID')
		if (getElevatorByIdInWL(elevatorID)) then
			if (not runningElevators[tostring(elevatorID)]) then
				runningElevators[tostring(elevatorID)] = createData(v)
				initiateElevator(v)
			end
		end
	end

end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="StringValue" referent="RBXD270F3B483844BE89ECB5E126F61B27F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">WHITELIST_META</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<string name="Value">{}</string>
					</Properties>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBXE4552C68E8FF424FB6C0BC3F91E9A052">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">DOOR_KEY_HANDLER</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{62BF6E36-FA60-47C8-B219-0B1EF3F5EB7C}</string>
					<ProtectedString name="Source"><![CDATA[repeat task.wait() until game:IsLoaded()
local this = script.Parent
local player = game.Players.LocalPlayer
local uis = game:GetService('UserInputService')
local mouse = player:GetMouse()
local camera = workspace.CurrentCamera
uis.MouseIconEnabled = true
local icon = player:GetMouse().Icon

local runService = game:GetService('RunService')

local mouseIcon = 6479191129

local params = RaycastParams.new()
params.FilterType = Enum.RaycastFilterType.Blacklist

local function findAncestor(origin: Instance, name: string)
	if (not origin) then return end
	local result = origin.Parent
	if (not result) then return end
	result = result:FindFirstChild(name)
	if (result) then return result end
	return findAncestor(origin.Parent, name)
end

local function containsDropKey()
	local char = player.Character
	if (not char) then return end
	for i,v in pairs(char:GetChildren()) do
		if (v.Name == 'Drop Key' or v:GetAttribute('CortexDoorKey')) then
			return v
		end
	end
	return
end

local scaler,lastKeyCheckStatus
runService:BindToRenderStep('DROP_KEY_CLIENT_UPDATE', Enum.RenderPriority.First.Value, function()
	local char = player.Character
	local hasDoorKey = containsDropKey()
	if (not char) then return end
	params.FilterDescendantsInstances = {char}
	local mousePos = uis:GetMouseLocation()
	local ray = camera:ScreenPointToRay(mousePos.X, mousePos.Y, 0)
	local result = workspace:Raycast(camera.CFrame.Position, ray.Direction*10, params)
	scaler = findAncestor(result and result.Instance, 'Scaler')
	local keyStatusCheck = scaler and hasDoorKey
	if (lastKeyCheckStatus ~= keyStatusCheck) then
		lastKeyCheckStatus = keyStatusCheck
		player:GetMouse().Icon = keyStatusCheck and "rbxassetid://" .. (mouseIcon) or icon
	end
end)

uis.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
	if (gameProcessed) then return end
	if (input.UserInputType == Enum.UserInputType.MouseButton1 or input.UserInputType == Enum.UserInputType.Touch) then
		local cortexRemote = findAncestor(scaler, 'Cortex_Remote')
		if (not cortexRemote) then return end
		local elevator = cortexRemote.Parent
		local oldDropKey = require(elevator.Settings).Doors.Use_Old_Drop_Key
		cortexRemote:FireServer(oldDropKey and 'dropKeyToggle' or 'addDropKeyGuiToPlayer', scaler.Parent.Parent)
	end
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ScreenGui" referent="RBXC7634939654847A99C247406DEBAEE98">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<int name="DisplayOrder">0</int>
					<bool name="Enabled">false</bool>
					<bool name="IgnoreGuiInset">false</bool>
					<string name="Name">ErrorMsg</string>
					<bool name="ResetOnSpawn">true</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<token name="ZIndexBehavior">1</token>
				</Properties>
				<Item class="Frame" referent="RBX4C8FD2B408444F0CB5A594B7AD8CFBB1">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<int name="LayoutOrder">0</int>
						<string name="Name">Frame</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>1</XS>
							<XO>0</XO>
							<YS>0</YS>
							<YO>75</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIGradient" referent="RBX70F107603CEE419CB637FC00166EBECC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<ColorSequence name="Color">0 0.0941176 0.192157 0.419608 0 1 0.0470588 0.0666667 0.207843 0 </ColorSequence>
							<bool name="Enabled">true</bool>
							<string name="Name">UIGradient</string>
							<Vector2 name="Offset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="Rotation">0</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
						</Properties>
					</Item>
					<Item class="ImageLabel" referent="RBXA9B54890530A41DFB36ABFE9CF816546">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<Content name="Image"><url>rbxassetid://9149338928</url></Content>
							<Color3 name="ImageColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<Vector2 name="ImageRectOffset">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<Vector2 name="ImageRectSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<float name="ImageTransparency">0.899999976</float>
							<int name="LayoutOrder">0</int>
							<string name="Name">Pattern</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<token name="ResampleMode">0</token>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<token name="ScaleType">2</token>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<Rect2D name="SliceCenter">
								<min>
									<X>0</X>
									<Y>0</Y>
								</min>
								<max>
									<X>0</X>
									<Y>0</Y>
								</max>
							</Rect2D>
							<float name="SliceScale">1</float>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<UDim2 name="TileSize">
								<XS>0</XS>
								<XO>10</XO>
								<YS>0</YS>
								<YO>10</YO>
							</UDim2>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIGradient" referent="RBXDB1CD44DEA4F455DBCE48517D413B7DA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
								<bool name="Enabled">true</bool>
								<string name="Name">UIGradient</string>
								<Vector2 name="Offset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="Rotation">0</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<NumberSequence name="Transparency">0 0 0 1 0.8 0 </NumberSequence>
							</Properties>
						</Item>
					</Item>
					<Item class="TextLabel" referent="RBX6834BDD569ED4B50B080D48930E8D04E">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">100</token>
							<Font name="FontFace">
								<Family><url>rbxassetid://12187365364</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Title</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.300000012</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Title</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">1</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="TextLabel" referent="RBX3B03E8EFCDD54174A323AA7968F622EC">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">100</token>
							<Font name="FontFace">
								<Family><url>rbxassetid://12187365364</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">1</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Message</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.870000005</YS>
								<YO>0</YO>
							</UDim2>
							<bool name="RichText">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0.600000024</XS>
								<XO>0</XO>
								<YS>0.449999988</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Message</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">2</token>
							<token name="TextYAlignment">0</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">2</int>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX0DFF9F1BFDB14E509DE87A20D3B000B4">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">Status</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>2</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UICorner" referent="RBX8E7964D924424DF9B34CCCB9BF5C63CE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>1</S>
									<O>0</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="LocalScript" referent="RBXEBB0757F356C4820AF69EF9AF4AF5F24">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="Disabled">false</bool>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">KEY_CLIENT_CONTROL</string>
					<token name="RunContext">0</token>
					<string name="ScriptGuid">{842B825F-9430-4A2A-AD3D-377E79DDCDE6}</string>
					<ProtectedString name="Source"><![CDATA[repeat wait() until game.Players.LocalPlayer
local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()

local Run_Service = game:GetService('RunService')
local Keys = {'Hoistway Access Key', 'Fire Service Key', 'Inspection Key', 'Logic Cabinet Key'}
local Mouse = Player:GetMouse()
local Key_Insert_Limit = false
local Target,Key_API,Hit_Target
local userInputService = game:GetService('UserInputService')

local hoverMouseCursor = 'rbxassetid://5487704161'
local mouseCursor = Player:GetMouse().Icon

local function findKeyToolInCharacter(findName)

	local result;
	if (Character) then

		for i,v in pairs(Character:GetChildren()) do
			if (v.Name:match(findName) and v:IsA('Tool')) then
				result = v;
				break;
			end
		end

	end
	return result;

end

local lastCheckBool
Run_Service.RenderStepped:Connect(function()
	Target = Mouse.Target
	local isKey = false
	local foundKey = findKeyToolInCharacter('Key');
	if (Target and foundKey) then
		Key_API = (Target.Parent:FindFirstChild('Key_API') or Target.Parent:FindFirstChild('KEYSWITCH_API'))
		Hit_Target = Target.Parent:FindFirstChild('Rotate')
	end
	local thisCheckBool = isKey and Target and foundKey and Key_API and (not Key_Insert_Limit) and Hit_Target
	if (thisCheckBool ~= lastCheckBool) then
		Player:GetMouse().Icon = thisCheckBool and hoverMouseCursor or mouseCursor
	end
	lastCheckBool = thisCheckBool
end)

Mouse.Button1Down:Connect(function()
	local foundKey = findKeyToolInCharacter('Key');
	if ((not Key_Insert_Limit) and Key_API and Hit_Target and foundKey) then
		Key_Insert_Limit = true
		local success = pcall(function()
			Key_API:InvokeServer('Activate_Key', foundKey)
		end)
		Key_Insert_Limit = false
	end
end)]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ScreenGui" referent="RBX36109912209549C69F2AB71FA4658C2B">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<bool name="AutoLocalize">true</bool>
					<int name="DisplayOrder">0</int>
					<bool name="Enabled">false</bool>
					<bool name="IgnoreGuiInset">false</bool>
					<string name="Name">ELEVATOR_GUI</string>
					<bool name="ResetOnSpawn">false</bool>
					<Ref name="RootLocalizationTable">null</Ref>
					<token name="SelectionBehaviorDown">0</token>
					<token name="SelectionBehaviorLeft">0</token>
					<token name="SelectionBehaviorRight">0</token>
					<token name="SelectionBehaviorUp">0</token>
					<bool name="SelectionGroup">false</bool>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
					<token name="ZIndexBehavior">1</token>
				</Properties>
				<Item class="LocalScript" referent="RBX622D518D7B0347E4B8FD9547BB8DD7F7">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">CLIENT</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{E7652085-7CF4-46AB-9F3A-9EA6486935EE}</string>
						<ProtectedString name="Source"><![CDATA[local THIS = script.Parent

local MAIN_FRAME = THIS.MAIN_FRAME
local CONTENT = MAIN_FRAME.CONTENT
local TOPBAR = MAIN_FRAME.TOPBAR
local UNDERLINE = CONTENT.CONTROLS.UNDER
local PLAYER = game.Players.LocalPlayer
local MOUSE = PLAYER:GetMouse()
local STYLE = require(script.STYLE)
local CHAR = nil --PLAYER.Character or PLAYER.CharacterAdded:Wait()

local TOOLTIP = THIS:FindFirstChild('TOOLTIP') or script:FindFirstChild('TOOLTIP')
TOOLTIP.Parent = THIS
TOOLTIP:GetPropertyChangedSignal('BackgroundTransparency'):Connect(function()
	TOOLTIP.TEXT.TextTransparency = TOOLTIP.BackgroundTransparency
	TOOLTIP.UIStroke.Transparency = TOOLTIP.BackgroundTransparency
end)
TOOLTIP.BackgroundTransparency = 1

--PLAYER.CharacterAdded:Connect(function(C)
--	task.wait()
--	CHAR = C
--end)

local DEPENDENCIES = script.DEPENDENCIES

local COLORFRAME = require(script.COLORFRAME)
local BACKEND = require(script.BACKEND_DATA)

local TWEEN_SERVICE = game:GetService('TweenService')
local RUN_SERVICE = game:GetService('RunService')
local COLLECTION_SERVICE = game:GetService('CollectionService')
local USER_INPUT_SERVICE = game:GetService('UserInputService')
local KEYBOARD_ENABLED = not USER_INPUT_SERVICE.KeyboardEnabled -- 09/14 Checks if keyboard is enabled to show/hide expand button
print("CORTEX REMOTECONTROLS CLIENT CHECK : KEYBOARD IS " .. (not KEYBOARD_ENABLED and 'ENABLED' or 'DISABLED'))

local CURRENT_VERSION = '2.5'

local CONNECTIONS = {}

local function TWEEN_PLAY(INSTANCE, TWEEN_INFO, PROPERTIES, WAIT_UNTIL_COMPLETION)

	local TWEEN
	local SUCCESS, RESULT = pcall(function()
		TWEEN = TWEEN_SERVICE:Create(INSTANCE, TWEEN_INFO, PROPERTIES)
		TWEEN:Play()
		if (WAIT_UNTIL_COMPLETION) then
			TWEEN.Completed:Wait()
		end
	end)
	if (not SUCCESS) then
		return warn(string.format('TWEEN CREATION ERROR :: %s', string.upper(RESULT)))
	else
		return TWEEN
	end

end

local function GET_POSITION(ELEMENT, TARGET, ANCHOR_X)

	return ((TARGET.AbsolutePosition.X+(TARGET.AbsoluteSize.X*ANCHOR_X))-ELEMENT.AbsolutePosition.X)

end
local function GET_LENGTH(ELEMENT, TARGET, ANCHOR_X)

	return math.abs(ELEMENT.AbsolutePosition.X-(TARGET.AbsolutePosition.X+(TARGET.AbsoluteSize.X*ANCHOR_X)))

end

local DEBOUNCE = false
local TOPBAR_BUTTONS = {}
local PREVIOUS_BUTTON
local CURRENT_PAGE = 'CONTROLS'
local CURRENT_ELEVATOR
local ELEVATORS = {}
local ELEVATOR_BUTTONS = {}
local REMOTE = game.ReplicatedStorage:WaitForChild('CORTEX_RC_REMOTE')
local DATA_REMOTE = THIS:WaitForChild('DATA_REMOTE')
local ELEVATOR_CONNECTIONS = {}
local READONLY_VALUES = {}
local IS_OPEN = false

MAIN_FRAME.TOPBAR.TITLE.Text = string.format('Cortex RemoteControls Hub v%s', CURRENT_VERSION)
local ADDON_DATA = {}

local LAST_FUNCTION_INVOKE = os.clock()
local function HANDLE_INPUT_TYPE(b, CONTENT_FRAME, COLOR)
	if (b.INPUT_TYPE == 'TRIGGER' or b.INPUT_TYPE == 'TRIGGER_HOLD') then
		local TRIGGER_BUTTON = DEPENDENCIES.TRIGGER_BUTTON:Clone()
		TRIGGER_BUTTON.Parent = CONTENT_FRAME
		TRIGGER_BUTTON.Name = b.LABEL
		TRIGGER_BUTTON.MASK.LABEL.Text = b.LABEL
		TRIGGER_BUTTON.LayoutOrder = b.INDEX
		local CONNECTION = TRIGGER_BUTTON.MASK.UIStroke:GetPropertyChangedSignal('Color'):Connect(function()
			TRIGGER_BUTTON.MASK.LABEL.TextColor3 = TRIGGER_BUTTON.MASK.UIStroke.Color
		end)
		local CONNECTION = TRIGGER_BUTTON.MouseEnter:Connect(function()
			TWEEN_PLAY(TRIGGER_BUTTON.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=COLOR})
		end)
		table.insert(CONNECTIONS, CONNECTION)
		local CONNECTION = TRIGGER_BUTTON.MouseLeave:Connect(function()
			TWEEN_PLAY(TRIGGER_BUTTON.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)})
		end)
		table.insert(CONNECTIONS, CONNECTION)
		if (b.INPUT_TYPE == 'TRIGGER') then
			local CONNECTION = TRIGGER_BUTTON.MouseButton1Click:Connect(function()
				if ((os.clock()-LAST_FUNCTION_INVOKE) <= .1) then return end
				LAST_FUNCTION_INVOKE = os.clock()
				b.INVOKE_FUNCTION(REMOTE, CURRENT_ELEVATOR, '')
			end)
			table.insert(CONNECTIONS, CONNECTION)
		elseif (b.INPUT_TYPE == 'TRIGGER_HOLD') then
			local CONNECTION = TRIGGER_BUTTON.MouseButton1Down:Connect(function()
				b.INVOKE_FUNCTION_DOWN(REMOTE, CURRENT_ELEVATOR, '')
			end)
			table.insert(CONNECTIONS, CONNECTION)
			local CONNECTION = TRIGGER_BUTTON.MouseButton1Up:Connect(function()
				b.INVOKE_FUNCTION_RELEASE(REMOTE, CURRENT_ELEVATOR, '')
			end)
			table.insert(CONNECTIONS, CONNECTION)
		end
	elseif (b.INPUT_TYPE == 'READONLY') then
		local READONLY_VALUE = DEPENDENCIES.READONLY_VALUE:Clone()
		READONLY_VALUE.Parent = CONTENT_FRAME
		READONLY_VALUE.Name = b.LABEL
		READONLY_VALUE.LayoutOrder = b.INDEX
		if (not b.REFRESH) then
			b.REFRESH = function(ELEVATOR)
				task.spawn(function()
					local VALUE = b.VALUE_TO_LISTEN(ELEVATOR)
					if (VALUE) then
						local UPDATE_CONNECTION = VALUE:GetPropertyChangedSignal(b.PROPERTY_CHANGED_SIGNAL_NAME):Connect(function()
							b.PROPERTY_CHANGED_INVOKE(REMOTE, ELEVATOR, READONLY_VALUE.VALUE, VALUE.Value)
						end)
						b.PROPERTY_CHANGED_INVOKE(REMOTE, ELEVATOR, READONLY_VALUE.VALUE, VALUE.Value)
						table.insert(ELEVATOR_CONNECTIONS, UPDATE_CONNECTION)
						READONLY_VALUE.NAME.Text = string.upper(b.LABEL)
					end
				end)
			end
		end
		table.insert(READONLY_VALUES, {READONLY_VALUE, b})
	elseif (b.INPUT_TYPE == 'NUMERICAL') then
		local NUMERICAL_INPUT = DEPENDENCIES.NUMERICAL_INPUT:Clone()
		NUMERICAL_INPUT.Parent = CONTENT_FRAME
		NUMERICAL_INPUT.MASK.INPUT.Text = ''
		NUMERICAL_INPUT.MASK.BUTTON.MASK.TEXT.Text = b.LABEL
		NUMERICAL_INPUT.LayoutOrder = b.INDEX
		local BUTTON_LOCKED = false
		local function VALIDATE_ENTRY()
			if (not BUTTON_LOCKED) then
				local VALUE = tonumber(NUMERICAL_INPUT.MASK.INPUT.Text)
				NUMERICAL_INPUT.MASK.INPUT.Text = ''
				if (not VALUE) then
					BUTTON_LOCKED = true
					for i=1,2 do
						TWEEN_PLAY(NUMERICAL_INPUT.MASK.UIStroke, TweenInfo.new(.23, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Color=Color3.new(1, 0.309804, 0.0784314)}, true)
						TWEEN_PLAY(NUMERICAL_INPUT.MASK.UIStroke, TweenInfo.new(.23, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Color=Color3.new(1, 1, 1)}, true)
					end
					BUTTON_LOCKED = false
					return
				end
				task.spawn(function()
					TWEEN_PLAY(NUMERICAL_INPUT.MASK.UIStroke, TweenInfo.new(.23, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Color=COLOR}, true)
					TWEEN_PLAY(NUMERICAL_INPUT.MASK.UIStroke, TweenInfo.new(.23, Enum.EasingStyle.Sine, Enum.EasingDirection.Out), {Color=Color3.new(1, 1, 1)}, true)
				end)
				b.INVOKE_FUNCTION(REMOTE, CURRENT_ELEVATOR, VALUE)
			end
		end
		local CONNECTION = NUMERICAL_INPUT.MASK.BUTTON.MASK.UIStroke:GetPropertyChangedSignal('Color'):Connect(function()
			NUMERICAL_INPUT.MASK.BUTTON.MASK.TEXT.TextColor3 = NUMERICAL_INPUT.MASK.BUTTON.MASK.UIStroke.Color
		end)
		table.insert(CONNECTIONS, CONNECTION)
		local CONNECTION = NUMERICAL_INPUT.MASK.BUTTON.MouseEnter:Connect(function()
			if (BUTTON_LOCKED) then return end
			TWEEN_PLAY(NUMERICAL_INPUT.MASK.BUTTON.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=COLOR})
		end)
		table.insert(CONNECTIONS, CONNECTION)
		local CONNECTION = NUMERICAL_INPUT.MASK.BUTTON.MouseLeave:Connect(function()
			if (BUTTON_LOCKED) then return end
			TWEEN_PLAY(NUMERICAL_INPUT.MASK.BUTTON.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)})
		end)
		table.insert(CONNECTIONS, CONNECTION)
		local CONNECTION = NUMERICAL_INPUT.MASK.BUTTON.MouseButton1Click:Connect(function()
			VALIDATE_ENTRY()
		end)
		table.insert(CONNECTIONS, CONNECTION)
		local CONNECTION = NUMERICAL_INPUT.MASK.INPUT.FocusLost:Connect(function()
			VALIDATE_ENTRY()
		end)
		table.insert(CONNECTIONS, CONNECTION)
	end
end

RUN_SERVICE:BindToRenderStep('TOOLTIP_BIND', Enum.RenderPriority.Camera.Value, function()
	TOOLTIP.Position = UDim2.new(0, MOUSE.X-((TOOLTIP.AbsoluteSize.X/2)*TOOLTIP.AnchorPoint.X), 0, 25+MOUSE.Y+((TOOLTIP.AbsoluteSize.Y/2)*TOOLTIP.AnchorPoint.Y))
end)

for i,v in pairs(BACKEND.BUTTONS) do

	local COLORFRAME_DATA = COLORFRAME.TOP_BUTTONS[i]
	local NEW_BUTTON = CONTENT.CONTROLS.BUTTONS:FindFirstChild(i) or DEPENDENCIES.TOPBAR_BUTTON:Clone()
	local DATA = {DATA=v,BUTTON=NEW_BUTTON}
	if (i == CURRENT_PAGE and (not PREVIOUS_BUTTON)) then
		PREVIOUS_BUTTON = DATA
	end
	NEW_BUTTON.LayoutOrder = v.INDEX
	NEW_BUTTON.Parent = CONTENT.CONTROLS.BUTTONS
	NEW_BUTTON.Name = i
	local CONNECTION = NEW_BUTTON.MASK.UIStroke:GetPropertyChangedSignal('Color'):Connect(function()
		NEW_BUTTON.NEON.ImageColor3 = NEW_BUTTON.MASK.UIStroke.Color
		NEW_BUTTON.MASK.IMG.ImageColor3 = NEW_BUTTON.MASK.UIStroke.Color
	end)
	table.insert(CONNECTIONS, CONNECTION)
	NEW_BUTTON.MASK.UIStroke.Color = Color3.new(1, 1, 1)
	NEW_BUTTON.MASK.IMG.Image = string.format('rbxassetid://%s', COLORFRAME_DATA.MASK_IMAGE)
	NEW_BUTTON.NEON.ImageTransparency = 1

	local COLOR = COLORFRAME_DATA.COLOR

	local CONTENT_FRAME = CONTENT.PAGES.MASK:FindFirstChild(i) or DEPENDENCIES.CONTENT_FRAME:Clone()
	CONTENT_FRAME.Parent = CONTENT.PAGES.MASK
	CONTENT_FRAME.Name = i
	CONTENT_FRAME.LayoutOrder = v.INDEX
	CONTENT_FRAME.TITLE.Text = table.concat(string.split(i, '_'), ' ')
	local UILAYOUT = (CONTENT_FRAME.BUTTONS:FindFirstChildOfClass('UIGridLayout') or CONTENT_FRAME.BUTTONS:FindFirstChildOfClass('UIListLayout'))
	local CONNECTION = UILAYOUT:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
		CONTENT_FRAME.BUTTONS.CanvasSize = UDim2.new(0, 0, 0, UILAYOUT.AbsoluteContentSize.Y)
	end)
	CONTENT_FRAME.BUTTONS.CanvasSize = UDim2.new(0, 0, 0, UILAYOUT.AbsoluteContentSize.Y)
	table.insert(CONNECTIONS, CONNECTION)

	for i,f in pairs(typeof(v.ADDONS) == 'table' and v.ADDONS or {}) do
		local DATA = f(CONTENT_FRAME, {CURRENT_ELEVATOR=CURRENT_ELEVATOR})
		DATA.CONTENT_FRAME = DATA.CONTENT_FRAME or CONTENT_FRAME
		DATA.BUTTON_HOVER_COLOR = COLOR
		ADDON_DATA[i] = DATA
		if (typeof(DATA.REFRESH) == 'function') then
			local SUCCESS, MSG = pcall(DATA.REFRESH, nil, CURRENT_ELEVATOR)
			if (not SUCCESS) then warn("RemoteControls backend addon refresh error: " .. (MSG)) end
		end
	end

	for i,b in pairs(v.BUTTONS or {}) do
		HANDLE_INPUT_TYPE(b, CONTENT_FRAME.BUTTONS, COLOR)
	end

	NEW_BUTTON.MouseEnter:Connect(function()
		TWEEN_PLAY(TOOLTIP, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=0}, false)
		TOOLTIP.TEXT.Size = UDim2.new(10, 0, 1, 0)
		TOOLTIP.TEXT.Text = table.concat(string.split(i, '_'), ' ')
		TOOLTIP.TEXT.Size = UDim2.new(1, 0, 1, 0)
		TOOLTIP.Size = UDim2.new(0, TOOLTIP.TEXT.TextBounds.X, 0, TOOLTIP.AbsoluteSize.Y)
	end)
	NEW_BUTTON.MouseLeave:Connect(function()
		TWEEN_PLAY(TOOLTIP, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=1}, false)
	end)

	local CONNECTION = NEW_BUTTON.MouseButton1Click:Connect(function()
		if ((not DEBOUNCE) and DATA ~= PREVIOUS_BUTTON) then
			DEBOUNCE = true
			for i,v in pairs(TOPBAR_BUTTONS) do
				TWEEN_PLAY(v.BUTTON.MASK.UIStroke, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}, false)
				TWEEN_PLAY(v.BUTTON.NEON, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {ImageTransparency=1}, false)
			end
			TWEEN_PLAY(NEW_BUTTON.MASK.UIStroke, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=COLOR}, false)
			TWEEN_PLAY(NEW_BUTTON.NEON, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {ImageTransparency=0}, false)

			TWEEN_PLAY(CONTENT.PAGES.MASK, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.InOut), {Position=UDim2.new(-(v.INDEX-1), 0, 0, 0)})

			task.spawn(function()
				local INDEX_M = (DATA.DATA.INDEX > PREVIOUS_BUTTON.DATA.INDEX and 1 or DATA.DATA.INDEX < PREVIOUS_BUTTON.DATA.INDEX and -1 or 0)
				UNDERLINE.AnchorPoint = Vector2.new(INDEX_M == 1 and 0 or INDEX_M == -1 and 1 or 0, 1)
				local PREV_POS = GET_POSITION(MAIN_FRAME, PREVIOUS_BUTTON.BUTTON, INDEX_M == 1 and 0 or INDEX_M == -1 and 1 or 0)
				UNDERLINE.Position = UDim2.new(0, PREV_POS, 1, 0)

				local LENGTH = (math.abs((NEW_BUTTON.AbsolutePosition.X+(NEW_BUTTON.AbsoluteSize.X*(INDEX_M == 1 and 1 or INDEX_M == -1 and 0 or 0)))-(PREVIOUS_BUTTON.BUTTON.AbsolutePosition.X+(PREVIOUS_BUTTON.BUTTON.AbsoluteSize.X*(INDEX_M == 1 and 0 or INDEX_M == -1 and 1 or 0)))))

				local POSITION = UDim2.new(0, GET_POSITION(MAIN_FRAME, NEW_BUTTON, INDEX_M == 1 and 1 or INDEX_M == -1 and 0 or 0), 1, 0)
				TWEEN_PLAY(CONTENT.CONTROLS.UNDER, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundColor3=COLOR}, false)
				TWEEN_PLAY(UNDERLINE, TweenInfo.new(.25, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Size=UDim2.new(0, LENGTH, 0, UNDERLINE.AbsoluteSize.Y)}, true)
				UNDERLINE.AnchorPoint = Vector2.new(INDEX_M == 1 and 1 or INDEX_M == -1 and 0 or 0, 1)
				UNDERLINE.Position = POSITION
				TWEEN_PLAY(UNDERLINE, TweenInfo.new(.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(0, NEW_BUTTON.AbsoluteSize.X, 0, UNDERLINE.AbsoluteSize.Y)}, true)
				DEBOUNCE = false
			end)
			PREVIOUS_BUTTON = DATA
		end
	end)
	table.insert(CONNECTIONS, CONNECTION)
	TOPBAR_BUTTONS[i] = DATA

end

CONTENT.ELEVATOR_SELECTION.Visible = true
CONTENT.PAGES.Visible = false

local CONNECTION = CONTENT.PAGES.BACK.MASK.UIStroke:GetPropertyChangedSignal('Color'):Connect(function()
	CONTENT.PAGES.BACK.MASK.TEXT.TextColor3 = CONTENT.PAGES.BACK.MASK.UIStroke.Color
end)
table.insert(CONNECTIONS, CONNECTION)

local CONNECTION = CONTENT.PAGES.BACK.MouseEnter:Connect(function()
	TWEEN_PLAY(CONTENT.PAGES.BACK.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 0.254902, 0.12549)})
end)
table.insert(CONNECTIONS, CONNECTION)
local CONNECTION = CONTENT.PAGES.BACK.MouseLeave:Connect(function()
	TWEEN_PLAY(CONTENT.PAGES.BACK.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)})
end)
table.insert(CONNECTIONS, CONNECTION)
local CONNECTION = CONTENT.PAGES.BACK.MouseButton1Click:Connect(function()

	CONTENT.ELEVATOR_SELECTION.Visible = true
	CONTENT.PAGES.Visible = false
	for i,b in pairs(ELEVATOR_BUTTONS) do
		TWEEN_PLAY(b, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(b.Size.X.Scale, b.Size.X.Offset, 0, 50)})
		TWEEN_PLAY(b.MASK, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(b.MASK.Size.X.Scale, b.MASK.Size.X.Offset, 1, 0)})
		TWEEN_PLAY(b.MASK.UIStroke, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Thickness=1})
		wait(.05)
	end

end)
table.insert(CONNECTIONS, CONNECTION)

local function HANDLE_LIST_UPDATER(UILAYOUT: any)
	if ((not UILAYOUT:IsA('UIListLayout')) and (not UILAYOUT:IsA('UIGridLayout'))) then return end
	local FRAME: ScrollingFrame = UILAYOUT.Parent:IsA('ScrollingFrame') and UILAYOUT.Parent
	if (not FRAME) then return end
	local CONNECTION = UILAYOUT:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
		FRAME.CanvasSize = UDim2.new(0, 0, 0, UILAYOUT.AbsoluteContentSize.Y)
	end)
	table.insert(CONNECTIONS, CONNECTION)
	FRAME.CanvasSize = UDim2.new(0, 0, 0, UILAYOUT.AbsoluteContentSize.Y)
end

for i,UILAYOUT in next,CONTENT:GetDescendants() do
	HANDLE_LIST_UPDATER(UILAYOUT)
end
CONTENT.DescendantAdded:Connect(HANDLE_LIST_UPDATER)

local SORT_ORDER = 'A-Z'

local DEBOUNCE = false

task.wait()
local function SORT_ELEVATOR_BUTTONS()
	if (SORT_ORDER == 'A-Z') then
		table.sort(ELEVATOR_BUTTONS, function(A, B)
			return string.lower(A.MASK.TEXT.Text) < string.lower(B.MASK.TEXT.Text)
		end)
	else
		table.sort(ELEVATOR_BUTTONS, function(A, B)
			return string.lower(A.MASK.TEXT.Text) > string.lower(B.MASK.TEXT.Text)
		end)
	end
	for i,ELEVATOR_BUTTON in next,ELEVATOR_BUTTONS do
		local TWEEN = game:GetService('TweenService'):Create(ELEVATOR_BUTTON.UIScale, TweenInfo.new(.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Scale=0})
		TWEEN:Play()
		task.delay(TWEEN.TweenInfo.Time+.2, function()
			if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
			ELEVATOR_BUTTON.LayoutOrder = i
			game:GetService('TweenService'):Create(ELEVATOR_BUTTON.UIScale, TweenInfo.new(.2, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Scale=1}):Play()
		end)
	end
end

local PREVIOUS_ELEVATOR
local function RELOAD_ADDON_DATA()
	for i,DATA in pairs(ADDON_DATA) do
		local COLORFRAME_DATA = COLORFRAME.TOP_BUTTONS[i]
		if (typeof(DATA.REFRESH) == 'function') then
			local SUCCESS, MSG = pcall(DATA.REFRESH, PREVIOUS_ELEVATOR, CURRENT_ELEVATOR)
			if (not SUCCESS) then warn("RemoteControls backend addon refresh error: " .. (MSG)) end
			if (MSG and MSG.BUTTONS) then
				local INDEX = 0
				for i,v in pairs(MSG.BUTTONS or {}) do
					if (v.INPUT_TYPE) then
						HANDLE_INPUT_TYPE(v, DATA.CONTENT_FRAME, DATA.BUTTON_HOVER_COLOR)
					else
						INDEX += 1
						if (v.LABEL_NAME) then
							local LABEL = Instance.new('TextLabel')
							LABEL.Name = 'DOOR_SIDE_LABEL'
							LABEL.Size = UDim2.new(1, 0, 0, 30)
							LABEL.BackgroundTransparency = 1
							LABEL.Text = (string.upper(v.LABEL_NAME)) .. " DOORS"
							LABEL.TextColor3 = Color3.new(1, 1, 1)
							LABEL.FontFace = Font.new("rbxassetid://" .. (STYLE.FONT_ID), Enum.FontWeight.Bold)
							LABEL.TextScaled = true
							LABEL.RichText = true
							LABEL.LayoutOrder = INDEX
							LABEL.Parent = DATA.CONTENT_FRAME
						end
						local BUTTON_GROUP_FRAME = Instance.new('Frame')
						BUTTON_GROUP_FRAME.Name = 'BUTTON_GROUP_FRAME'
						BUTTON_GROUP_FRAME.Size = UDim2.new(1, 0, 0, 0)
						BUTTON_GROUP_FRAME.BackgroundTransparency = 1
						BUTTON_GROUP_FRAME.LayoutOrder = INDEX+1
						BUTTON_GROUP_FRAME.Parent = DATA.CONTENT_FRAME
						local UILIST = Instance.new('UIListLayout')
						UILIST.FillDirection = Enum.FillDirection.Vertical
						UILIST.VerticalAlignment = Enum.VerticalAlignment.Top
						UILIST.HorizontalAlignment = Enum.HorizontalAlignment.Center
						UILIST.SortOrder = Enum.SortOrder.LayoutOrder
						UILIST.Padding = UDim.new(0, 5)
						UILIST.Parent = BUTTON_GROUP_FRAME
						UILIST:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
							BUTTON_GROUP_FRAME.Size = UDim2.new(1, 0, 0, UILIST.AbsoluteContentSize.Y)
						end)
						for i,b in pairs(v.BUTTONS) do
							HANDLE_INPUT_TYPE(b, BUTTON_GROUP_FRAME, DATA.BUTTON_HOVER_COLOR)
						end
					end
				end
			end
		end
	end
	PREVIOUS_ELEVATOR = CURRENT_ELEVATOR
end

local function CHECK_ELEVATOR(v: Model)
	task.spawn(function()
		task.wait()
		local Cortex_API = v:WaitForChild('Cortex_API', 30)
		local Car = v:WaitForChild('Car', 30)
		local Legacy = v:WaitForChild('Legacy', 30)
		if (Cortex_API and Car and Legacy and (not ELEVATORS[v])) then
			local success, message = pcall(function()
				local ELEVATOR_BUTTON = DEPENDENCIES.ELEVATOR:Clone()
				ELEVATOR_BUTTON.Parent = CONTENT.ELEVATOR_SELECTION.LIST
				ELEVATOR_BUTTON.Name = string.upper(v.Name)
				ELEVATOR_BUTTON.MASK.TEXT.Text = v:GetFullName()

				local CONNECTION = ELEVATOR_BUTTON.MASK.UIStroke:GetPropertyChangedSignal('Color'):Connect(function()
					ELEVATOR_BUTTON.MASK.TEXT.TextColor3 = ELEVATOR_BUTTON.MASK.UIStroke.Color
				end)
				table.insert(CONNECTIONS, CONNECTION)

				local CONNECTION = ELEVATOR_BUTTON.MouseEnter:Connect(function()
					TWEEN_PLAY(ELEVATOR_BUTTON.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(0.215686, 1, 0.333333)}, false)
				end)
				table.insert(CONNECTIONS, CONNECTION)
				local CONNECTION = ELEVATOR_BUTTON.MouseLeave:Connect(function()
					TWEEN_PLAY(ELEVATOR_BUTTON.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}, false)
				end)
				table.insert(CONNECTIONS, CONNECTION)
				local CONNECTION = ELEVATOR_BUTTON.MouseButton1Click:Connect(function()
					if (not DEBOUNCE) then
						DEBOUNCE = true
						for i,c in pairs(ELEVATOR_CONNECTIONS) do
							c:Disconnect()
						end
						ELEVATOR_CONNECTIONS = {}
						for i,r in pairs(READONLY_VALUES) do
							r[2].REFRESH(v)
						end
						--if (CURRENT_ELEVATOR) then return end
						for i,e in pairs(ELEVATOR_BUTTONS) do
							if (e ~= ELEVATOR_BUTTON) then
								TWEEN_PLAY(e.MASK.CHECK, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=1}, false)
								TWEEN_PLAY(e.MASK.CHECK.IMG.UIScale, TweenInfo.new(.5, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Scale=0}, false)
							end
						end
						local PREVIOUS_ELEVATOR = CURRENT_ELEVATOR
						CURRENT_ELEVATOR = v
						RELOAD_ADDON_DATA()
						if (PREVIOUS_ELEVATOR ~= CURRENT_ELEVATOR) then
							TWEEN_PLAY(ELEVATOR_BUTTON.MASK.CHECK, TweenInfo.new(.5, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=.5}, false)
							TWEEN_PLAY(ELEVATOR_BUTTON.MASK.CHECK.IMG.UIScale, TweenInfo.new(.5, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {Scale=1}, true)
						end
						for i,b in pairs(ELEVATOR_BUTTONS) do
							TWEEN_PLAY(b, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(b.Size.X.Scale, b.Size.X.Offset, 0, 0)})
							TWEEN_PLAY(b.MASK, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(b.MASK.Size.X.Scale, b.MASK.Size.X.Offset, 0, 0)})
							TWEEN_PLAY(b.MASK.UIStroke, TweenInfo.new(.5, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Thickness=0})
							wait(.05)
						end
						task.delay(PREVIOUS_ELEVATOR ~= CURRENT_ELEVATOR and .25 or 0, function()
							CONTENT.ELEVATOR_SELECTION.Visible = false
							CONTENT.PAGES.Visible = true
							DEBOUNCE = false
						end)
					end
				end)
				table.insert(CONNECTIONS, CONNECTION)
				ELEVATOR_BUTTON.MASK.CHECK.IMG.UIScale.Scale = 0
				ELEVATOR_BUTTON.MASK.CHECK.BackgroundTransparency = 1
				ELEVATOR_BUTTON:SetAttribute('ELEVATOR_PATH_NAME', v:GetFullName())
				ELEVATOR_BUTTON:SetAttribute('SIZE_FULL', ELEVATOR_BUTTON.Size)
				ELEVATOR_BUTTON:SetAttribute('MASK_SIZE_FULL', ELEVATOR_BUTTON.MASK.Size)
				ELEVATOR_BUTTON:SetAttribute('BORDER_THICKNESS', ELEVATOR_BUTTON.MASK.UIStroke.Thickness)
				table.insert(ELEVATOR_BUTTONS, ELEVATOR_BUTTON)
				task.spawn(SORT_ELEVATOR_BUTTONS)

				ELEVATORS[v] = {ELEVATOR_BUTTON}
			end)
			
			if not success then
				warn("[Cortex RC] - Init Fail: Elevator: " .. (v:GetFullName()) .. ", error: " .. (message))
			end
		end
	end)
end

--//AUDIT 02/11/2023: ADD ABILITY TO CHANGE SORT ORDER TO ASCENDING OR DESCENDING
CONTENT.ELEVATOR_SELECTION.SORT_BUTTON.BTN.MouseButton1Click:Connect(function()
	if (CONTENT.ELEVATOR_SELECTION.SORT_BUTTON.BTN:GetAttribute('DISABLED')) then return end
	CONTENT.ELEVATOR_SELECTION.SORT_BUTTON.BTN:SetAttribute('DISABLED', true)
	SORT_ORDER = SORT_ORDER == 'A-Z' and 'Z-A' or 'A-Z'
	CONTENT.ELEVATOR_SELECTION.SORT_BUTTON.BTN.Text = SORT_ORDER
	task.spawn(SORT_ELEVATOR_BUTTONS)
	task.delay(.4, function()
		CONTENT.ELEVATOR_SELECTION.SORT_BUTTON.BTN:SetAttribute('DISABLED', false)
	end)
end)
CONTENT.ELEVATOR_SELECTION.SORT_BUTTON.BTN.Text = SORT_ORDER

local SEARCH_INPUT = CONTENT.ELEVATOR_SELECTION.SEARCH.INPUT
SEARCH_INPUT:GetPropertyChangedSignal('Text'):Connect(function()
	for i,b in pairs(ELEVATOR_BUTTONS) do
		task.spawn(function()
			local IS_SHOWN = string.match(string.upper(b:GetAttribute('ELEVATOR_PATH_NAME')), string.upper(SEARCH_INPUT.Text)) ~= nil
			local TWEEN = TWEEN_PLAY(b, TweenInfo.new(.35, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=IS_SHOWN and b:GetAttribute('SIZE_FULL') or UDim2.new()})
			TWEEN_PLAY(b.MASK, TweenInfo.new(.35, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=IS_SHOWN and b:GetAttribute('MASK_SIZE_FULL') or UDim2.new()})
			TWEEN_PLAY(b.MASK.UIStroke, TweenInfo.new(.35, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Thickness=IS_SHOWN and b:GetAttribute('BORDER_THICKNESS') or 0})
			if (not IS_SHOWN) then
				TWEEN.Completed:Wait()
				if (TWEEN.PlaybackState == Enum.PlaybackState.Completed) then
					b.Visible = IS_SHOWN
				end
			else
				b.Visible = IS_SHOWN
			end
		end)
	end
end)

local DRAG_START,START_POS,DRAG_INPUT
local IS_DRAGGING = false
local IS_TOGGLED = false

local function UPDATE_DRAG(INPUT)

	local DELTA = INPUT.Position-DRAG_START
	TWEEN_SERVICE:Create(MAIN_FRAME, TweenInfo.new(.04, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Position=UDim2.new(START_POS.X.Scale, START_POS.X.Offset+DELTA.X, START_POS.Y.Scale, START_POS.Y.Offset+DELTA.Y)}):Play()

end

TOPBAR.InputBegan:Connect(function(INPUT)

	if (INPUT.UserInputState == Enum.UserInputState.Begin and (INPUT.UserInputType == Enum.UserInputType.MouseButton1 or INPUT.UserInputType == Enum.UserInputType.Touch)) then
		DRAG_START = INPUT.Position
		START_POS = MAIN_FRAME.Position
		IS_DRAGGING = true
		local CONNECTION,UPDATE_CONNECTION
		CONNECTION = INPUT.Changed:Connect(function()
			if (INPUT.UserInputState == Enum.UserInputState.End) then
				IS_DRAGGING = false
				CONNECTION:Disconnect()
				UPDATE_CONNECTION:Disconnect()
			end
		end)
		UPDATE_CONNECTION = RUN_SERVICE.RenderStepped:Connect(function()
			if (IS_DRAGGING) then
				UPDATE_DRAG(DRAG_INPUT)
			end
		end)
	end

end)
TOPBAR.InputChanged:Connect(function(INPUT)
	DRAG_INPUT = INPUT
end)

local function TOGGLE_GUI(BOOL: boolean)
	if (BOOL) then
		THIS.MAIN_FRAME.Visible = true
		if (THIS.KeyCodeHint.Visible) then
			THIS.KeyCodeHint.Visible = false
		end
	end
	IS_TOGGLED = BOOL
	local TWEEN = TWEEN_SERVICE:Create(THIS.MAIN_FRAME, TweenInfo.new(.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {GroupTransparency=BOOL and 0 or 1})
	TWEEN:Play()
	TWEEN.Completed:Wait()
	TOGGLE_DEBOUNCE = false
	if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
	if (not BOOL) then
		THIS.MAIN_FRAME.Visible = false
	end
end

if (IS_TOGGLED) then
	THIS.MAIN_FRAME.Visible = true
	if (THIS.KeyCodeHint.Visible) then
		THIS.KeyCodeHint.Visible = false
	end
end
local TWEEN = TWEEN_SERVICE:Create(THIS.MAIN_FRAME, TweenInfo.new(.25, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {GroupTransparency=IS_TOGGLED and 0 or 1})
TWEEN:Play()
TWEEN.Completed:Wait()
TOGGLE_DEBOUNCE = false
if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
if (not IS_TOGGLED) then
	THIS.MAIN_FRAME.Visible = false
end

THIS.EXPAND.Position = UDim2.new(1, 5, .5, 0)
THIS.EXPAND.MouseButton1Click:Connect(function()
	TOGGLE_GUI(true)
	TWEEN_PLAY(THIS.EXPAND, TweenInfo.new(.4, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Position=UDim2.new(1, IS_TOGGLED and 55 or 5, .5, 0)}, false)
end)

THIS.EXPAND.MASK.UIStroke:GetPropertyChangedSignal('Color'):Connect(function()
	THIS.EXPAND.MASK.TEXT.TextColor3 = THIS.EXPAND.MASK.UIStroke.Color
end)
THIS.EXPAND.MouseEnter:Connect(function()
	TWEEN_PLAY(THIS.EXPAND.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(0.290196, 1, 0.513725)}, false)
end)
THIS.EXPAND.MouseLeave:Connect(function()
	TWEEN_PLAY(THIS.EXPAND.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}, false)
end)

TOPBAR.CLOSE.MouseButton1Click:Connect(function()
	TOGGLE_GUI(false)
	TWEEN_PLAY(THIS.EXPAND, TweenInfo.new(.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position=UDim2.new(1, IS_TOGGLED and 50 or 5, .5, 0)}, false)
end)

task.wait()
local NEW_BUTTON = TOPBAR_BUTTONS[CURRENT_PAGE]
NEW_BUTTON.BUTTON.MASK.UIStroke.Color = COLORFRAME.TOP_BUTTONS[CURRENT_PAGE].COLOR
NEW_BUTTON.BUTTON.NEON.ImageTransparency = 0

UNDERLINE.Size = UDim2.new(0, NEW_BUTTON.BUTTON.AbsoluteSize.X, 0, UNDERLINE.AbsoluteSize.Y)
UNDERLINE.AnchorPoint = Vector2.new(1, 1)
UNDERLINE.Position = UDim2.new(0, GET_POSITION(MAIN_FRAME, NEW_BUTTON.BUTTON, 1), 1, 0)
UNDERLINE.BackgroundColor3 = COLORFRAME.TOP_BUTTONS[CURRENT_PAGE].COLOR

COLLECTION_SERVICE:GetInstanceAddedSignal('CortexElevatorInstance'):Connect(CHECK_ELEVATOR)
COLLECTION_SERVICE:GetInstanceRemovedSignal('CortexElevatorInstance'):Connect(function(elev: Instance)
	task.wait()
	if (not ELEVATORS[elev]) then return end
	for _,v in pairs(ELEVATORS[elev]) do
		v:Destroy()
	end
	ELEVATORS[elev] = nil
end)

for _, v in COLLECTION_SERVICE:GetTagged('CortexElevatorInstance') do
	CHECK_ELEVATOR(v)
end

MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MouseEnter:Connect(function()
	TWEEN_PLAY(MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(0.290196, 1, 0.513725)}, false)
	TWEEN_PLAY(MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MASK.TEXT, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextColor3=Color3.new(0.290196, 1, 0.513725)}, false)
end)
MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MouseLeave:Connect(function()
	TWEEN_PLAY(MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}, false)
	TWEEN_PLAY(MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MASK.TEXT, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextColor3=Color3.new(1, 1, 1)}, false)
end)
MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MouseEnter:Connect(function()
	TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(0.290196, 1, 0.513725)}, false)
	TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MASK.TEXT, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextColor3=Color3.new(0.290196, 1, 0.513725)}, false)
end)
MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MouseLeave:Connect(function()
	TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MASK.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}, false)
	TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MASK.TEXT, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextColor3=Color3.new(1, 1, 1)}, false)
end)

local IS_OPENED = false
local PARAMS = OverlapParams.new()
PARAMS.FilterType = Enum.RaycastFilterType.Whitelist
PARAMS.MaxParts = 1
MAIN_FRAME.CONTENT.ELEVATOR_SELECTION.PROX_SELECT.MouseButton1Click:Connect(function()
	CHAR = PLAYER.Character
	if not CHAR or not CHAR.Parent then return end
	if (IS_OPENED) then return end
	MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.Visible = true
	TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {Position=UDim2.new(.5, 0, 0, 0)}, false)
	IS_OPENED = true
	PARAMS.FilterDescendantsInstances = {CHAR}
	local PREV_ELEVATOR
	local function GET_ELEVATORS_IN_BOUNDS()
		local NEAR_ELEVATORS = {}
		for ELEVATOR,_ in pairs(ELEVATORS) do
			local CAR: Model? = ELEVATOR:FindFirstChild('Car')
			if (not CAR) then return end
			local IS_IN_PROXIMITY = #workspace:GetPartBoundsInBox(CAR.Platform.CFrame, (2*CAR.Platform.Size)+CAR.Platform.CFrame.UpVector*28, PARAMS) > 0
			if (IS_IN_PROXIMITY) then
				table.insert(NEAR_ELEVATORS, ELEVATOR)
			end
		end
		return NEAR_ELEVATORS
	end
	local function GET_NEAREST_ELEVATOR(PROPOSED_ELEVATORS: {any})
		if (typeof(PROPOSED_ELEVATORS) ~= 'table') then return end
		local DIST = math.huge
		local ELEVATOR
		for i,v in pairs(PROPOSED_ELEVATORS) do
			local THIS_DIST = (v.Car.Platform.Position-CHAR.HumanoidRootPart.Position).Magnitude
			if (THIS_DIST <= DIST) then
				DIST = THIS_DIST
				ELEVATOR = v
			end
		end
		return ELEVATOR
	end

	while (IS_OPENED) do
		task.wait()
		local NEAREST_ELEVATORS = GET_ELEVATORS_IN_BOUNDS()
		local NEAREST_ELEVATOR = GET_NEAREST_ELEVATOR(NEAREST_ELEVATORS)
		if (NEAREST_ELEVATOR ~= PREV_ELEVATOR) then
			for i,v in pairs(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME:GetChildren()) do
				if (v:IsA('Frame')) then
					v:Destroy()
				end
			end
			PREV_ELEVATOR = NEAREST_ELEVATOR
			CONTENT.PROX_ELEVATOR_FRAME.NO_ELEVATOR.Visible = not NEAREST_ELEVATOR
			if (NEAREST_ELEVATOR) then
				local NEW_PROX_ITEM = DEPENDENCIES.PROX_ITEM:Clone()
				NEW_PROX_ITEM.Name = string.format('%s_PROX_ITEM', string.upper(NEAREST_ELEVATOR.Name))
				NEW_PROX_ITEM.Parent = MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME
				NEW_PROX_ITEM.ELEVATOR_NAME.Text = NEAREST_ELEVATOR:GetFullName()
				NEW_PROX_ITEM.BUTTON.MouseEnter:Connect(function()
					TWEEN_PLAY(NEW_PROX_ITEM.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(0.290196, 1, 0.513725)}, false)
					TWEEN_PLAY(NEW_PROX_ITEM.ELEVATOR_NAME, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextColor3=Color3.new(0.290196, 1, 0.513725)}, false)
				end)
				NEW_PROX_ITEM.BUTTON.MouseLeave:Connect(function()
					TWEEN_PLAY(NEW_PROX_ITEM.UIStroke, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}, false)
					TWEEN_PLAY(NEW_PROX_ITEM.ELEVATOR_NAME, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextColor3=Color3.new(1, 1, 1)}, false)
				end)
				NEW_PROX_ITEM.BUTTON.MouseButton1Click:Connect(function()
					TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position=UDim2.new(.5, 0, -1, 0)}, false)
					CONTENT.ELEVATOR_SELECTION.Visible = false
					CONTENT.PAGES.Visible = true
					DEBOUNCE = false
					IS_OPENED = false
					local PREVIOUS_ELEVATOR = CURRENT_ELEVATOR
					CURRENT_ELEVATOR = NEAREST_ELEVATOR
					RELOAD_ADDON_DATA()
					for i,c in pairs(ELEVATOR_CONNECTIONS) do
						c:Disconnect()
					end
					ELEVATOR_CONNECTIONS = {}
					for i,r in pairs(READONLY_VALUES) do
						r[2].REFRESH(NEAREST_ELEVATOR)
					end
					for i,b in pairs(ELEVATOR_BUTTONS) do
						TWEEN_PLAY(b, TweenInfo.new(0, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(b.Size.X.Scale, b.Size.X.Offset, 0, 0)})
						TWEEN_PLAY(b.MASK, TweenInfo.new(0, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(b.MASK.Size.X.Scale, b.MASK.Size.X.Offset, 0, 0)})
						TWEEN_PLAY(b.MASK.UIStroke, TweenInfo.new(0, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Thickness=0})
						if (NEAREST_ELEVATOR.Name ~= b.Name) then
							TWEEN_PLAY(b.MASK.CHECK, TweenInfo.new(0, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {BackgroundTransparency=1}, false)
							TWEEN_PLAY(b.MASK.CHECK.IMG.UIScale, TweenInfo.new(0, Enum.EasingStyle.Sine, Enum.EasingDirection.In), {Scale=0}, false)
						end
					end
				end)
			end
		end
	end
	for i,v in pairs(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME:GetChildren()) do
		if (v:IsA('Frame')) then
			v:Destroy()
		end
	end
end)
MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.CANCEL.MouseButton1Click:Connect(function()
	TWEEN_PLAY(MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.In), {Position=UDim2.new(.5, 0, -1, 0)}, false)
	IS_OPENED = false
end)

MAIN_FRAME.CONTENT.PROX_ELEVATOR_FRAME.Position = UDim2.new(.5, 0, -1, 0)

-- 09/14 Add keyboard support; disable the expand button for PC clients
THIS.EXPAND.Visible = KEYBOARD_ENABLED
local CURRENT_SIZE = THIS.MAIN_FRAME.Size
local TOGGLE_DEBOUNCE = false

THIS.MAIN_FRAME.GroupTransparency = IS_TOGGLED and 0 or 1
THIS.KeyCodeHint.Visible = not KEYBOARD_ENABLED

USER_INPUT_SERVICE.InputBegan:Connect(function(INPUT: InputObject, GAME_PROCESSED_EVENT: boolean)
	if (GAME_PROCESSED_EVENT or INPUT.UserInputType ~= Enum.UserInputType.Keyboard or INPUT.KeyCode ~= Enum.KeyCode.R or TOGGLE_DEBOUNCE) then return end
	TOGGLE_GUI(not IS_TOGGLED)
end)

THIS.Enabled = true -- 09/14 Update UI to enable after loading]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX933ABCCD8DA044C5BB62F8368467B3BB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">COLORFRAME</string>
							<string name="ScriptGuid">{D6132965-5032-4684-B6EB-2DC13DFE9E71}</string>
							<ProtectedString name="Source"><![CDATA[return {
	
	['TOP_BUTTONS'] = {
		['CONTROLS']={['COLOR']=Color3.new(0.219608, 1, 0.545098),['MASK_IMAGE']=8808338177};
		['FIRE_SERVICE']={['COLOR']=Color3.new(1, 0.372549, 0.160784),['MASK_IMAGE']=8810130185};
		['INDEPENDENT_SERVICE']={['COLOR']=Color3.new(1, 0.909804, 0.45098),['MASK_IMAGE']=8808753524};
		['INSPECTION']={['COLOR']=Color3.new(0.309804, 0.376471, 1),['MASK_IMAGE']=8808717948};
		['STOP_ELEVATOR']={['COLOR']=Color3.new(1, 0.2, 0.211765),['MASK_IMAGE']=10296166919};
		['STATISTICS']={['COLOR']=Color3.new(1, 0.72549, 0.486275),['MASK_IMAGE']=8810964384};
		['OUTPUT']={['COLOR']=Color3.new(0.780392, 1, 0.572549),['MASK_IMAGE']=12403326706};
		['LOCKING_MANAGER']={['COLOR']=Color3.new(1, 0.607843, 0.054902),['MASK_IMAGE']=12482962568};
	};
	
};]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Folder" referent="RBX0CECCB8CBE2F4251993465471CE19301">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">DEPENDENCIES</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Frame" referent="RBXF083981BE1FC4687827BAB51BC3CFACE">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">CONTENT_FRAME</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX836446FF21164EF98FD17534926E7583">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>700</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">TITLE</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.100000001</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">CONTROLS</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="ScrollingFrame" referent="RBX1913D9C63D8A4BA496F554B3F0C371BC">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticCanvasSize">0</token>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
									<Vector2 name="CanvasPosition">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<UDim2 name="CanvasSize">
										<XS>0</XS>
										<XO>0</XO>
										<YS>2</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Draggable">false</bool>
									<token name="ElasticBehavior">0</token>
									<token name="HorizontalScrollBarInset">0</token>
									<int name="LayoutOrder">0</int>
									<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
									<string name="Name">BUTTONS</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.150000006</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<Color3 name="ScrollBarImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="ScrollBarImageTransparency">0</float>
									<int name="ScrollBarThickness">5</int>
									<token name="ScrollingDirection">4</token>
									<bool name="ScrollingEnabled">true</bool>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>0.670000017</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
									<token name="VerticalScrollBarInset">0</token>
									<token name="VerticalScrollBarPosition">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBXA195D6F8A020434BB5DF9068F2096A11">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">0</token>
										<string name="Name">UIListLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>10</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXB24FE935D3914ED9B5F1FD50AF2D8157">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">NUMERICAL_INPUT</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBXFA4B08465E4941BA8AC3B95E408F2C19">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">MASK</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIScale" referent="RBX6DB35E98A56641259B1DF55D9D30484C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">UIScale</string>
										<float name="Scale">0.949999988</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="UIStroke" referent="RBXA3588A6603874FE383AD12A1C8005C7F">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">2</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBXB03F567680354EF1A1952D0239612082">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>8</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextBox" referent="RBX93FEDA5EBDB84E41AE434553B04659A2">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClearTextOnFocus">false</bool>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">1</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Arial.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/arial.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="MultiLine">false</bool>
										<string name="Name">INPUT</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<Color3 name="PlaceholderColor3">
											<R>0.699999988</R>
											<G>0.699999988</G>
											<B>0.699999988</B>
										</Color3>
										<string name="PlaceholderText">Enter Value...</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<bool name="ShowNativeInput">true</bool>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text"></string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextEditable">true</bool>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBXA13320FE1EC84B04B979C31B11931572">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">3</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">BUTTON</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>-5</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.400000006</XS>
											<XO>0</XO>
											<YS>0.800000012</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">ACTION</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">1</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
									<Item class="Frame" referent="RBX0FA1F5AB3A06446EA892B9C0DB3D0873">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.192156866</R>
												<G>0.192156866</G>
												<B>0.192156866</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">MASK</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIStroke" referent="RBX30A2D638AE894AC3BB96750BC6C38CAB">
											<Properties>
												<token name="ApplyStrokeMode">1</token>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<Color3 name="Color">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<bool name="Enabled">true</bool>
												<token name="LineJoinMode">0</token>
												<string name="Name">UIStroke</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<float name="Thickness">2</float>
												<float name="Transparency">0</float>
											</Properties>
										</Item>
										<Item class="UIScale" referent="RBX5E7FBF01709A49F785D516C27D1DAAA8">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<string name="Name">UIScale</string>
												<float name="Scale">0.899999976</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="TextLabel" referent="RBX1C9DF7A82CD64D35928E104566854774">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>0.5</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<token name="Font">100</token>
												<Font name="FontFace">
													<Family><url>rbxassetid://12187365364</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
												</Font>
												<int name="LayoutOrder">0</int>
												<float name="LineHeight">1</float>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="Name">TEXT</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0.5</YS>
													<YO>0</YO>
												</UDim2>
												<bool name="RichText">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0.899999976</XS>
													<XO>0</XO>
													<YS>0.600000024</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<string name="Text">ACTION</string>
												<Color3 name="TextColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<bool name="TextScaled">true</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">true</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
										</Item>
										<Item class="UICorner" referent="RBX8164A0B2253F4E369E259D4C0260044E">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<UDim name="CornerRadius">
													<S>0.200000003</S>
													<O>0</O>
												</UDim>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBXACA1EF85CEB8459E9805A3A548C9045D">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">3</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<bool name="Modal">false</bool>
								<string name="Name">TRIGGER_BUTTON</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Button</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">1</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBXBFC3FD92C8FB4D84AD82DFEA6C570976">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">MASK</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>-4</XO>
										<YS>1</YS>
										<YO>-4</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBX9DA21B562B204DFF8D234AD7E90E3727">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">2</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBX4F104618A0F24C3BB77CD7F777FCBD19">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>5</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX821A9F0C0AB24E0F8D18635732E49FF3">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">100</token>
										<Font name="FontFace">
											<Family><url>rbxassetid://12187365364</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">LABEL</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">LABEL</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UITextSizeConstraint" referent="RBXCB4492DC474B4512904C920515DDEA2A">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<int name="MaxTextSize">30</int>
											<int name="MinTextSize">1</int>
											<string name="Name">UITextSizeConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX08A0F5D4D6AD4F4FBD0358DEC69634FE">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.196078435</R>
									<G>0.196078435</G>
									<B>0.196078435</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">3</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<bool name="Modal">false</bool>
								<string name="Name">TOPBAR_BUTTON</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.850000024</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Button</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">1</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBXAB34E782E82C4266A7931F69EA959958">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxassetid://8697780388</url></Content>
									<Color3 name="ImageColor3">
										<R>0.290196091</R>
										<G>1</G>
										<B>0.572549045</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<string name="Name">NEON</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">0</token>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIScale" referent="RBX2E9B5B31A00B4CD29204BE16384FC665">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">UIScale</string>
										<float name="Scale">1.60000002</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX0ADCFAB4070143CC8E906778EE864814">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.196078435</R>
										<G>0.196078435</G>
										<B>0.196078435</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">MASK</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBX3888025DC1BC4AB7BC883FDDEFDAE8C4">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>0.290196091</R>
											<G>1</G>
											<B>0.572549045</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">1</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBXBD50EDB343A24AA98094CA25614C8B29">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://8808338177</url></Content>
										<Color3 name="ImageColor3">
											<R>0.290196091</R>
											<G>1</G>
											<B>0.572549045</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">IMG</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
									<Item class="UIScale" referent="RBXF03E3BDCA7C540D18FE3B2496E7E5340">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<string name="Name">UIScale</string>
											<float name="Scale">0.699999988</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="UICorner" referent="RBX789399B585CE4957B0773A72A1587231">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0.200000003</S>
												<O>0</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="UICorner" referent="RBXC95C1B61E0744939ABDD0CE3952C817F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0.200000003</S>
											<O>0</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
							<Item class="UIScale" referent="RBX9EA44044BA8642E8BF4EDA54113C04BB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">UIScale</string>
									<float name="Scale">0.899999976</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIAspectRatioConstraint" referent="RBXAF23B9E5AAAE4A5AA49916BDEC6A9B19">
								<Properties>
									<float name="AspectRatio">1</float>
									<token name="AspectType">0</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="DominantAxis">1</token>
									<string name="Name">UIAspectRatioConstraint</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextButton" referent="RBX2457AEBAE7C8437ABF1A60B1215BC891">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">3</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<bool name="Modal">false</bool>
								<string name="Name">ELEVATOR</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Button</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">1</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBX9ABABCE8D6374FA489572358DECCC320">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.192156866</R>
										<G>0.192156866</G>
										<B>0.192156866</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">MASK</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBXA8FB1D8DA26148EBBF1EA9F32BD46E8F">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">2</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="UIScale" referent="RBXA8ACF08731AE434D8E2C2898CF63EB5C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">UIScale</string>
										<float name="Scale">0.899999976</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBX4F1268A9860840F693FB8CDDF23209B1">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">100</token>
										<Font name="FontFace">
											<Family><url>rbxassetid://12187365364</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">TEXT</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.899999976</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">TEXT</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX1FE1D3FDF63C4B72BFABE587943ECDCE">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.192156866</R>
											<G>0.192156866</G>
											<B>0.192156866</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">CHECK</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="ImageLabel" referent="RBX26B2EE23810542D895F590B770A31311">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.192156866</R>
												<G>0.192156866</G>
												<B>0.192156866</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<Content name="Image"><url>rbxassetid://5853990158</url></Content>
											<Color3 name="ImageColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<Vector2 name="ImageRectOffset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<Vector2 name="ImageRectSize">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="ImageTransparency">0</float>
											<int name="LayoutOrder">0</int>
											<string name="Name">IMG</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<token name="ResampleMode">0</token>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<token name="ScaleType">3</token>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<Rect2D name="SliceCenter">
												<min>
													<X>0</X>
													<Y>0</Y>
												</min>
												<max>
													<X>0</X>
													<Y>0</Y>
												</max>
											</Rect2D>
											<float name="SliceScale">1</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UDim2 name="TileSize">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIScale" referent="RBX3C7F856078024DE08B121FD7A372F736">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<string name="Name">UIScale</string>
												<float name="Scale">1</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
							</Item>
							<Item class="UIScale" referent="RBX99BCA9B165114037AE1A421826AEE903">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">UIScale</string>
									<float name="Scale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXF992E81AA6F840D181A7027C0C5CD3C8">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">READONLY_VALUE</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBXA5B198AAAC8044879A17D18B591E758F">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">NAME</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.600000024</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Label</string>
									<Color3 name="TextColor3">
										<R>0.70588237</R>
										<G>0.70588237</G>
										<B>0.70588237</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXB4F8A6E0F99346F48D6ADCEA6824F730">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">VALUE</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.400000006</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Label</string>
									<Color3 name="TextColor3">
										<R>0.70588237</R>
										<G>0.70588237</G>
										<B>0.70588237</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBX30D148BC34B741229E70DDFDF49583A8">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.70588237</R>
										<G>0.70588237</G>
										<B>0.70588237</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Frame</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>2</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX00AA40789F7A4519932D545FB2744AB1">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">PROX_ITEM</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.850000024</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>75</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UICorner" referent="RBXED55733479004B81AA9657D82CA9A058">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim name="CornerRadius">
										<S>0</S>
										<O>8</O>
									</UDim>
									<string name="Name">UICorner</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="UIStroke" referent="RBX9EB02B53A554480CBD431B38D89D1F72">
								<Properties>
									<token name="ApplyStrokeMode">1</token>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Color3 name="Color">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="Enabled">true</bool>
									<token name="LineJoinMode">0</token>
									<string name="Name">UIStroke</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<float name="Thickness">2</float>
									<float name="Transparency">0</float>
								</Properties>
							</Item>
							<Item class="TextButton" referent="RBX668EB8AE2C324C08A2690FCF84FF7CEE">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">3</token>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
										<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">BUTTON</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Button</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">1</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBXC2A72A14A8194FDAA4FD97DD176BA6EA">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">ELEVATOR_NAME</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.800000012</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">ELEVATOR_NAME</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXE56C74F1C625414F80DA2FCF28F6489E">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">OUTPUT_FRAME</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.850000024</XS>
									<XO>0</XO>
									<YS>0.800000012</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX00BFDCB60AB2412AAE1628A35A3E5A29">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">NO_MESSAGES</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">No messages</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.699999988</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="ScrollingFrame" referent="RBXF518D4619F9D4C67BACA30E28213CF94">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticCanvasSize">0</token>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882354</R>
										<G>0.164705887</G>
										<B>0.20784314</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
									<Vector2 name="CanvasPosition">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<UDim2 name="CanvasSize">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>1000</YO>
									</UDim2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Draggable">false</bool>
									<token name="ElasticBehavior">0</token>
									<token name="HorizontalScrollBarInset">0</token>
									<int name="LayoutOrder">0</int>
									<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
									<string name="Name">LIST</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.150000006</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<Color3 name="ScrollBarImageColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="ScrollBarImageTransparency">0</float>
									<int name="ScrollBarThickness">12</int>
									<token name="ScrollingDirection">4</token>
									<bool name="ScrollingEnabled">true</bool>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.670000017</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
									<token name="VerticalScrollBarInset">0</token>
									<token name="VerticalScrollBarPosition">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX6F5FE701DF734B188091D70A134722A5">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">1</token>
										<string name="Name">UIListLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>10</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBXF1293CFF52C142A0B0A941BD6840D50E">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">LM_MAIN_FRAME</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.850000024</XS>
									<XO>0</XO>
									<YS>0.800000012</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX8D863318CA8C4805A94D12BABEA60A53">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">NO_FLOORS</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">No floors</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.699999988</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="ScrollingFrame" referent="RBXA5A2B1C56D074CDCB388876762C61B4D">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticCanvasSize">0</token>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882354</R>
										<G>0.164705887</G>
										<B>0.20784314</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
									<Vector2 name="CanvasPosition">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<UDim2 name="CanvasSize">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>1000</YO>
									</UDim2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Draggable">false</bool>
									<token name="ElasticBehavior">0</token>
									<token name="HorizontalScrollBarInset">0</token>
									<int name="LayoutOrder">0</int>
									<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
									<string name="Name">LIST</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.150000006</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<Color3 name="ScrollBarImageColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="ScrollBarImageTransparency">0</float>
									<int name="ScrollBarThickness">12</int>
									<token name="ScrollingDirection">4</token>
									<bool name="ScrollingEnabled">true</bool>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.670000017</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
									<token name="VerticalScrollBarInset">0</token>
									<token name="VerticalScrollBarPosition">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX4F85B6298122494C8F99328BF1CD7242">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">0</token>
										<string name="Name">UIListLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>10</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX88D62E64B67643FCAC312FDD41792172">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.196078435</R>
										<G>0.196078435</G>
										<B>0.196078435</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">LM_BUTTONS</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">3</int>
								</Properties>
								<Item class="UIStroke" referent="RBX3340E54C4B194EA9B0207E527A4D0DCA">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">1</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBXEF59B6F6FE35431E9886BCB5AD01EF01">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">3</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">BACK</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.449999988</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Button</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">1</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
									<Item class="Frame" referent="RBXED4A295F71B54CA6B17DA69D4F4B5CDE">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.192156866</R>
												<G>0.192156866</G>
												<B>0.192156866</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">MASK</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIStroke" referent="RBX1BE5FA96298D41A997C7F6257FE1678B">
											<Properties>
												<token name="ApplyStrokeMode">1</token>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<Color3 name="Color">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<bool name="Enabled">true</bool>
												<token name="LineJoinMode">0</token>
												<string name="Name">UIStroke</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<float name="Thickness">2</float>
												<float name="Transparency">0</float>
											</Properties>
										</Item>
										<Item class="UIScale" referent="RBX4B10D492F948409DA5E51C4A71A241F5">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<string name="Name">UIScale</string>
												<float name="Scale">0.899999976</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
										<Item class="TextLabel" referent="RBX620A740CAAE547BCA90211BB54E84EB4">
											<Properties>
												<bool name="Active">false</bool>
												<Vector2 name="AnchorPoint">
													<X>0.5</X>
													<Y>0.5</Y>
												</Vector2>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<bool name="AutoLocalize">true</bool>
												<token name="AutomaticSize">0</token>
												<Color3 name="BackgroundColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<float name="BackgroundTransparency">1</float>
												<Color3 name="BorderColor3">
													<R>0.105882362</R>
													<G>0.164705887</G>
													<B>0.207843155</B>
												</Color3>
												<token name="BorderMode">0</token>
												<int name="BorderSizePixel">1</int>
												<bool name="ClipsDescendants">false</bool>
												<bool name="Draggable">false</bool>
												<token name="Font">100</token>
												<Font name="FontFace">
													<Family><url>rbxassetid://12187365364</url></Family>
													<Weight>400</Weight>
													<Style>Normal</Style>
												</Font>
												<int name="LayoutOrder">0</int>
												<float name="LineHeight">1</float>
												<int name="MaxVisibleGraphemes">-1</int>
												<string name="Name">TEXT</string>
												<Ref name="NextSelectionDown">null</Ref>
												<Ref name="NextSelectionLeft">null</Ref>
												<Ref name="NextSelectionRight">null</Ref>
												<Ref name="NextSelectionUp">null</Ref>
												<UDim2 name="Position">
													<XS>0.5</XS>
													<XO>0</XO>
													<YS>0.5</YS>
													<YO>0</YO>
												</UDim2>
												<bool name="RichText">true</bool>
												<Ref name="RootLocalizationTable">null</Ref>
												<float name="Rotation">0</float>
												<bool name="Selectable">false</bool>
												<token name="SelectionBehaviorDown">0</token>
												<token name="SelectionBehaviorLeft">0</token>
												<token name="SelectionBehaviorRight">0</token>
												<token name="SelectionBehaviorUp">0</token>
												<bool name="SelectionGroup">false</bool>
												<Ref name="SelectionImageObject">null</Ref>
												<int name="SelectionOrder">0</int>
												<UDim2 name="Size">
													<XS>0.899999976</XS>
													<XO>0</XO>
													<YS>0.5</YS>
													<YO>0</YO>
												</UDim2>
												<token name="SizeConstraint">0</token>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<string name="Text">BACK</string>
												<Color3 name="TextColor3">
													<R>1</R>
													<G>1</G>
													<B>1</B>
												</Color3>
												<bool name="TextScaled">true</bool>
												<float name="TextSize">14</float>
												<Color3 name="TextStrokeColor3">
													<R>0</R>
													<G>0</G>
													<B>0</B>
												</Color3>
												<float name="TextStrokeTransparency">1</float>
												<float name="TextTransparency">0</float>
												<token name="TextTruncate">0</token>
												<bool name="TextWrapped">true</bool>
												<token name="TextXAlignment">2</token>
												<token name="TextYAlignment">1</token>
												<bool name="Visible">true</bool>
												<int name="ZIndex">1</int>
											</Properties>
										</Item>
										<Item class="UICorner" referent="RBX165E996F3CE74386BC776399DF3BA9BE">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<UDim name="CornerRadius">
													<S>0</S>
													<O>8</O>
												</UDim>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="Frame" referent="RBX0192C336EB4F413CB96C170DF462B941">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">LIST</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>-55</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIListLayout" referent="RBX8A31B0747A464C15872C46754096FE0F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="FillDirection">1</token>
											<token name="HorizontalAlignment">0</token>
											<string name="Name">UIListLayout</string>
											<UDim name="Padding">
												<S>0</S>
												<O>8</O>
											</UDim>
											<token name="SortOrder">2</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<token name="VerticalAlignment">0</token>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBXDA34A7FB2E3D46CFB864426E24075AF4">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">3</token>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
										<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">SUBMIT</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.449999988</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Button</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">1</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">2</int>
								</Properties>
								<Item class="Frame" referent="RBX23884A7C4683426CAC010A5FF39EA08F">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.192156866</R>
											<G>0.192156866</G>
											<B>0.192156866</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">MASK</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIStroke" referent="RBX0B6022B1A8EE4F568BF32117FB7F11BF">
										<Properties>
											<token name="ApplyStrokeMode">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Color3 name="Color">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="Enabled">true</bool>
											<token name="LineJoinMode">0</token>
											<string name="Name">UIStroke</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<float name="Thickness">2</float>
											<float name="Transparency">0</float>
										</Properties>
									</Item>
									<Item class="UIScale" referent="RBX9BC47447B9EE4853BA7ACC07CE4E3EBF">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<string name="Name">UIScale</string>
											<float name="Scale">0.899999976</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="TextLabel" referent="RBXB9BAFA052A0840689BE8FC5FC142DEE3">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">100</token>
											<Font name="FontFace">
												<Family><url>rbxassetid://12187365364</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<string name="Name">TEXT</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">true</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.899999976</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">SUBMIT</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UICorner" referent="RBX86DC464C7F7F4EDA972D796395F1313F">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX24647FAA151B40AD814D1EADB017EA9C">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">LEGACY_VALUE</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>250</XO>
									<YS>0</YS>
									<YO>100</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX630F69864AA84C39ADA932316A006185">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>700</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">NAME</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.600000024</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">VALUE</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextLabel" referent="RBX89DACDE845E44ED6BEE271E2596305E9">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">VALUE</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>0.400000006</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">VALUE</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX68A92DFD6174422A8C3499784C3E4F0B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BACKEND_DATA</string>
							<string name="ScriptGuid">{D8B93A9F-7E02-40DD-92D9-27E79725FCEA}</string>
							<ProtectedString name="Source"><![CDATA[local STYLE = require(script.Parent.STYLE)
local BUTTON_SYS = require(script.Parent.BUTTON_SYS)
local TWEEN_SERVICE = game:GetService('TweenService')

return {

	['BUTTONS'] = {
		['CONTROLS'] = {
			['INDEX']=1;
			['ADDONS'] = {
				['CONTROLS_FRAME'] = function(FRAME, DATA)
					local ELEVATOR
					local MAIN_FRAME = FRAME:FindFirstChild('MAIN_FRAME') or Instance.new('ScrollingFrame')
					MAIN_FRAME.Parent = FRAME
					MAIN_FRAME.Name = 'MAIN_FRAME'
					MAIN_FRAME.Position = UDim2.new(.5, 0, .15, 0)
					MAIN_FRAME.Size = UDim2.new(.8, 0, .67, 0)
					MAIN_FRAME.BackgroundTransparency = 1
					MAIN_FRAME.AnchorPoint = Vector2.new(1, 0)*.5
					local UI_LIST = MAIN_FRAME:FindFirstChildOfClass('UIListLayout') or Instance.new('UIListLayout')
					UI_LIST.Parent = MAIN_FRAME
					UI_LIST.FillDirection = Enum.FillDirection.Vertical
					UI_LIST.VerticalAlignment = Enum.VerticalAlignment.Top
					UI_LIST.HorizontalAlignment = Enum.HorizontalAlignment.Center
					UI_LIST.Padding = UDim.new(0, 15)
					UI_LIST.SortOrder = Enum.SortOrder.LayoutOrder

					UI_LIST:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
						MAIN_FRAME.CanvasSize = UDim2.new(0, 0, 0, UI_LIST.AbsoluteContentSize.Y)
					end)

					return {
						REFRESH=function(PREVIOUS_ELEVATOR, NEW_ELEVATOR)
							local BUTTONS = {}
							ELEVATOR = NEW_ELEVATOR
							if (not NEW_ELEVATOR) then return [[error('NEW_ELEVATOR is nil', 2)]] end
							for i,v in pairs(MAIN_FRAME:GetChildren()) do
								if (not v:IsA('UIListLayout')) then
									v:Destroy()
								end
							end
							BUTTONS.CALL_BUTTON = {
								['INDEX']=1;
								['LABEL']='CALL';
								['INPUT_TYPE']='NUMERICAL';
								['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
									REMOTE:InvokeServer(ELEVATOR, {'Request_Call_F', VALUE});
								end;
							};
							for i,v in pairs(ELEVATOR.Legacy:GetChildren()) do
								if (string.match(v.Name, 'Door_State')) then
									local SIDE = string.split(string.split(v.Name, 'Door_State')[1], '_')[1]
									if (not BUTTONS[SIDE]) then
										BUTTONS[SIDE] = {}
									end
									BUTTONS[SIDE].LABEL_NAME = SIDE
									BUTTONS[SIDE].BUTTONS = {
										["OPEN_" .. (string.upper(SIDE)) .. "_DOORS"]={
											['INDEX']=1;
											['LABEL']="OPEN " .. (string.upper(SIDE)) .. " DOORS";
											['INPUT_TYPE']='TRIGGER';
											['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
												REMOTE:InvokeServer(ELEVATOR, {'Door_Open', SIDE});
											end;
										},
										["CLOSE_" .. (string.upper(SIDE)) .. "_DOORS"]={
											['INDEX']=2;
											['LABEL']="CLOSE " .. (string.upper(SIDE)) .. " DOORS";
											['INPUT_TYPE']='TRIGGER';
											['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
												REMOTE:InvokeServer(ELEVATOR, {'Door_Close', SIDE});
											end;
										},
										["NUDGE_" .. (string.upper(SIDE)) .. "_DOORS"]={
											['INDEX']=3;
											['LABEL']="NUDGE " .. (string.upper(SIDE)) .. " DOORS";
											['INPUT_TYPE']='TRIGGER';
											['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
												REMOTE:InvokeServer(ELEVATOR, {'Door_Nudge', SIDE});
											end;
										}
									}
								end
							end
							return {BUTTONS=BUTTONS}
						end,
						CONTENT_FRAME=MAIN_FRAME
					}
				end,
			}
		};
		['FIRE_SERVICE'] = {
			['INDEX']=2;
			['BUTTONS']={
				['RECALL']={
					['INDEX']=1;
					['LABEL']='RECALL';
					['INPUT_TYPE']='NUMERICAL';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'Fire_Recall', true, VALUE});
					end;
				};
				['DISABLE_RECALL']={
					['INDEX']=2;
					['LABEL']='DISABLE RECALL';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'Fire_Recall', false, ELEVATOR.Legacy.Floor.Value});
					end;
				};
				['ENABLE_PHASE_2']={
					['INDEX']=3;
					['LABEL']='ENABLE PHASE 2';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'Phase_2', true});
					end;
				};
				['DISABLE_PHASE_2']={
					['INDEX']=4;
					['LABEL']='DISABLE PHASE 2';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'Phase_2', false});
					end;
				};
			};
		};
		['INDEPENDENT_SERVICE'] = {
			['INDEX']=3;
			['BUTTONS']={
				['ENABLE']={
					['INDEX']=1;
					['LABEL']='ENABLE';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'invokeIndependentService', true});
					end;
				};
				['DISABLE']={
					['INDEX']=2;
					['LABEL']='DISABLE';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'invokeIndependentService', false});
					end;
				};
			};
		};
		['INSPECTION'] = {
			['INDEX']=4;
			['BUTTONS']={
				['ENABLE']={
					['INDEX']=1;
					['LABEL']='TURN ON INSPECTION';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'setInspection', true});
					end;
				};
				['DISABLE']={
					['INDEX']=2;
					['LABEL']='TURN OFF INSPECTION';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'setInspection', false});
					end;
				};

				['DRIVE_UP']={
					['INDEX']=3;
					['LABEL']='DRIVE CAR UP';
					['INPUT_TYPE']='TRIGGER_HOLD';
					['INVOKE_FUNCTION_DOWN']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'inspectionMove', {'Up', require(ELEVATOR.Settings).Movement.Travel_Speed/2.5}});
					end;
					['INVOKE_FUNCTION_RELEASE']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'inspectionStop', 'U'});
					end;
				};
				['DRIVE_DOWN']={
					['INDEX']=4;
					['LABEL']='DRIVE CAR DOWN';
					['INPUT_TYPE']='TRIGGER_HOLD';
					['INVOKE_FUNCTION_DOWN']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'inspectionMove', {'Down', require(ELEVATOR.Settings).Movement.Travel_Speed/2.5}});
					end;
					['INVOKE_FUNCTION_RELEASE']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'inspectionStop', 'D'});
					end;
				};
			};
		};
		['STOP_ELEVATOR'] = {
			['INDEX']=5;
			['BUTTONS']={
				['ENABLE']={
					['INDEX']=1;
					['LABEL']='STOP';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'Stop', true});
					end;
				};
				['DISABLE']={
					['INDEX']=2;
					['LABEL']='RELEASE';
					['INPUT_TYPE']='TRIGGER';
					['INVOKE_FUNCTION']=function(REMOTE, ELEVATOR, VALUE)
						REMOTE:InvokeServer(ELEVATOR, {'Stop', false});
					end;
				};
			};
		};
		['STATISTICS'] = {
			['INDEX']=6;
			['BUTTONS']={
				
			};
			['ADDONS'] = {
				['STATISTICS_FRAME'] = function(FRAME, DATA)
					local ELEVATOR
					local STATISTICS_FRAME = FRAME:FindFirstChild('STATISTICS_FRAME')
					if (not STATISTICS_FRAME) then
						STATISTICS_FRAME = Instance.new('ScrollingFrame')
						STATISTICS_FRAME.Size = UDim2.fromScale(.85, .7)
						STATISTICS_FRAME.AnchorPoint = Vector2.new(1,0)*.5
						STATISTICS_FRAME.Position = UDim2.fromScale(STATISTICS_FRAME.AnchorPoint.X, .1)
						STATISTICS_FRAME.BackgroundTransparency = 1
						STATISTICS_FRAME.Name = 'STATISTICS_FRAME'
						local UILISTLAYOUT = Instance.new('UIListLayout')
						UILISTLAYOUT.FillDirection = Enum.FillDirection.Vertical
						UILISTLAYOUT.VerticalAlignment = Enum.VerticalAlignment.Top
						UILISTLAYOUT.HorizontalAlignment = Enum.HorizontalAlignment.Center
						UILISTLAYOUT.SortOrder = Enum.SortOrder.LayoutOrder
						UILISTLAYOUT.Padding = UDim.new(0, 25)
						UILISTLAYOUT.Parent = STATISTICS_FRAME
						STATISTICS_FRAME.Parent = FRAME
						UILISTLAYOUT:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
							STATISTICS_FRAME.CanvasSize = UDim2.new(0, 0, 0, UILISTLAYOUT.AbsoluteContentSize.Y)
						end)
					end
					local CONNECTIONS = {}
					
					return {
						REFRESH=function(PREVIOUS_ELEVATOR, NEW_ELEVATOR)
							ELEVATOR = NEW_ELEVATOR
							for i,v in pairs(STATISTICS_FRAME:GetChildren()) do
								if (v.Name == 'LEGACY_VALUE') then
									v:Destroy()
								end
							end
							for _,v in pairs(CONNECTIONS) do
								if (v.Connected) then
									v:Disconnect()
								end
							end
							if (not NEW_ELEVATOR) then return [[error('NEW_ELEVATOR is nil', 2)]] end
							local legacyValues = {}
							for _,v in pairs(ELEVATOR:WaitForChild('Legacy'):GetChildren()) do
								table.insert(legacyValues, v)
							end
							table.sort(legacyValues, function(a,b) return a.Name < b.Name end)
							for _,v in ipairs(legacyValues) do
								local NEW_VALUE_FRAME = script.Parent.DEPENDENCIES.LEGACY_VALUE:Clone()
								NEW_VALUE_FRAME.Name = 'LEGACY_VALUE'
								local gsubName = select(1, string.gsub(v.Name, '_', ' '))
								NEW_VALUE_FRAME.NAME.Text = string.upper(gsubName)
								NEW_VALUE_FRAME.LayoutOrder = _
								NEW_VALUE_FRAME.Size = UDim2.new(.75, 0, 0, 40)
								NEW_VALUE_FRAME.Parent = STATISTICS_FRAME
								local CONNECTION: RBXScriptConnection
								CONNECTION = v:GetPropertyChangedSignal('Value'):Connect(function()
									NEW_VALUE_FRAME.VALUE.Text = string.upper(tonumber(v.Value) and math.round(tonumber(v.Value)*1000)/1000 or tostring(v.Value))
								end)
								NEW_VALUE_FRAME.VALUE.Text = string.upper(tonumber(v.Value) and math.round(tonumber(v.Value)*1000)/1000 or tostring(v.Value))
								table.insert(CONNECTIONS, CONNECTION)
							end
						end,
					}
				end,
			},
		};
		['LOCKING_MANAGER'] = {
			['INDEX']=7;
			['BUTTONS']={

			};
			['ADDONS'] = {
				['MAIN_FRAME'] = function(FRAME)
					local ELEVATOR
					local MAIN_FRAME = FRAME:FindFirstChild('MAIN_FRAME') or script.Parent.DEPENDENCIES.LM_MAIN_FRAME:Clone()
					MAIN_FRAME.Parent = FRAME
					local IS_IN_MENU = false
					local MENU_DEBOUNCE = false
					local SELECTED_FLOORS = {}

					local BUTTON_META = {
						['LOCK'] = {
							['LOCK_CAR'] = {
								['LABEL']='LOCK CAR',
								['ACTIVATE_FUNCTION']=function(PARAMS)
									local RAN,RES = pcall(function()
										script.Parent.Parent.DATA_REMOTE:InvokeServer('CORTEX_API_FIRE', {ELEVATOR=ELEVATOR,PROTOCOL='Lock_Floors',PARAMS=SELECTED_FLOORS})
									end)
									if (not RAN) then
										warn("RemoteControls :: Locking Manager Error - " .. (RES))
									end
								end,
							},
							['LOCK_HALL'] = {
								['LABEL']='LOCK HALL',
								['ACTIVATE_FUNCTION']=function(PARAMS)
									local RAN,RES = pcall(function()
										script.Parent.Parent.DATA_REMOTE:InvokeServer('CORTEX_API_FIRE', {ELEVATOR=ELEVATOR,PROTOCOL='Lock_Hall_Floors',PARAMS=SELECTED_FLOORS})
									end)
									if (not RAN) then
										warn("RemoteControls :: Locking Manager Error - " .. (RES))
									end
								end,
							}
						},
						----
						['UNLOCK'] = {
							['UNLOCK_CAR'] = {
								['LABEL']='UNLOCK CAR',
								['ACTIVATE_FUNCTION']=function(PARAMS)
									local RAN,RES = pcall(function()
										script.Parent.Parent.DATA_REMOTE:InvokeServer('CORTEX_API_FIRE', {ELEVATOR=ELEVATOR,PROTOCOL='Unlock_Floors',PARAMS=SELECTED_FLOORS})
									end)
									if (not RAN) then
										warn("RemoteControls :: Locking Manager Error - " .. (RES))
									end
								end,
							},
							['UNLOCK_HALL'] = {
								['LABEL']='UNLOCK HALL',
								['ACTIVATE_FUNCTION']=function(PARAMS)
									local RAN,RES = pcall(function()
										script.Parent.Parent.DATA_REMOTE:InvokeServer('CORTEX_API_FIRE', {ELEVATOR=ELEVATOR,PROTOCOL='Unlock_Hall_Floors',PARAMS=SELECTED_FLOORS})
									end)
									if (not RAN) then
										warn("RemoteControls :: Locking Manager Error - " .. (RES))
									end
								end,
							}
						},
					}

					local TYPE_INDEX = 0
					for TYPE,BUTTONS in next,BUTTON_META do
						TYPE_INDEX += 1
						local LABEL = MAIN_FRAME.LM_BUTTONS.LIST:FindFirstChild((TYPE) .. "_LABEL") or Instance.new('TextLabel')
						LABEL.Parent = MAIN_FRAME.LM_BUTTONS.LIST
						LABEL.Size = UDim2.new(1, 0, 0, 35)
						LABEL.AnchorPoint = Vector2.new(1, 1)*.5
						LABEL.Name = (TYPE) .. "_LABEL"
						LABEL.BackgroundTransparency = 1
						LABEL.Text = TYPE
						LABEL.FontFace = Font.new("rbxassetid://" .. (STYLE.FONT_ID), Enum.FontWeight.Regular, Enum.FontStyle.Normal)
						LABEL.TextColor3 = Color3.new(1, 1, 1)
						LABEL.TextScaled = true
						LABEL.RichText = true
						LABEL.LayoutOrder = TYPE_INDEX
						for LOCKING_TYPE,BUTTON in next,BUTTONS do
							local NEW_BUTTON = BUTTON_SYS.ADD_BUTTON(MAIN_FRAME.LM_BUTTONS.LIST, table.concat(string.split(LOCKING_TYPE, '_'), ' '))
							NEW_BUTTON.LayoutOrder = TYPE_INDEX+1
							NEW_BUTTON.Size = UDim2.new(0, NEW_BUTTON.AbsoluteSize.X, 0, 35)
							NEW_BUTTON.MouseButton1Click:Connect(function()
								BUTTON.ACTIVATE_FUNCTION({FLOORS=SELECTED_FLOORS})
							end)
							NEW_BUTTON.MouseEnter:Connect(function()
								TWEEN_SERVICE:Create(NEW_BUTTON.MASK.UIStroke, TweenInfo.new(.4, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=require(script.Parent.COLORFRAME).TOP_BUTTONS.LOCKING_MANAGER.COLOR}):Play()
							end)
							NEW_BUTTON.MouseLeave:Connect(function()
								TWEEN_SERVICE:Create(NEW_BUTTON.MASK.UIStroke, TweenInfo.new(.4, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}):Play()
							end)
						end
					end

					MAIN_FRAME.LIST.UIListLayout:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
						MAIN_FRAME.NO_FLOORS.Visible = #MAIN_FRAME.LIST:GetChildren() < 2
					end)
					MAIN_FRAME.NO_FLOORS.Visible = #MAIN_FRAME.LIST:GetChildren() < 2

					MAIN_FRAME.SUBMIT.MouseButton1Click:Connect(function()
						if (IS_IN_MENU or MENU_DEBOUNCE) then return end
						IS_IN_MENU = true
						MENU_DEBOUNCE = true
						local TWEEN = TWEEN_SERVICE:Create(MAIN_FRAME.LM_BUTTONS, TweenInfo.new(.4, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Position=UDim2.new(.5, 0, .5, 0)})
						TWEEN:Play()
						TWEEN.Completed:Wait()
						if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
						local TWEEN = TWEEN_SERVICE:Create(MAIN_FRAME.LM_BUTTONS, TweenInfo.new(.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Size=UDim2.new(1, -MAIN_FRAME.LM_BUTTONS.UIStroke.Thickness, 1, -MAIN_FRAME.LM_BUTTONS.UIStroke.Thickness)})
						TWEEN:Play()
						TWEEN.Completed:Wait()
						if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
						MENU_DEBOUNCE = false
					end)
					MAIN_FRAME.SUBMIT.MouseEnter:Connect(function()
						TWEEN_SERVICE:Create(MAIN_FRAME.SUBMIT.MASK.UIStroke, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=require(script.Parent.COLORFRAME).TOP_BUTTONS.LOCKING_MANAGER.COLOR}):Play()
					end)
					MAIN_FRAME.SUBMIT.MouseLeave:Connect(function()
						TWEEN_SERVICE:Create(MAIN_FRAME.SUBMIT.MASK.UIStroke, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}):Play()
					end)
					MAIN_FRAME.LM_BUTTONS.Size = UDim2.new(1, 0, 0, 0)

					MAIN_FRAME.LM_BUTTONS.BACK.MouseButton1Click:Connect(function()
						if ((not IS_IN_MENU) or MENU_DEBOUNCE) then return end
						IS_IN_MENU = false
						MENU_DEBOUNCE = true
						local TWEEN = TWEEN_SERVICE:Create(MAIN_FRAME.LM_BUTTONS, TweenInfo.new(.4, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Size=UDim2.new(1, -MAIN_FRAME.LM_BUTTONS.UIStroke.Thickness, 0, 0)})
						TWEEN:Play()
						TWEEN.Completed:Wait()
						if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
						local TWEEN = TWEEN_SERVICE:Create(MAIN_FRAME.LM_BUTTONS, TweenInfo.new(.4, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {Position=UDim2.new(.5, 0, 1.5, 0)})
						TWEEN:Play()
						TWEEN.Completed:Wait()
						if (TWEEN.PlaybackState ~= Enum.PlaybackState.Completed) then return end
						MENU_DEBOUNCE = false
					end)
					MAIN_FRAME.LM_BUTTONS.BACK.MouseEnter:Connect(function()
						TWEEN_SERVICE:Create(MAIN_FRAME.LM_BUTTONS.BACK.MASK.UIStroke, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=require(script.Parent.COLORFRAME).TOP_BUTTONS.LOCKING_MANAGER.COLOR}):Play()
					end)
					MAIN_FRAME.LM_BUTTONS.BACK.MouseLeave:Connect(function()
						TWEEN_SERVICE:Create(MAIN_FRAME.LM_BUTTONS.BACK.MASK.UIStroke, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}):Play()
					end)

					return {
						REFRESH=function(PREVIOUS_ELEVATOR, NEW_ELEVATOR)
							ELEVATOR = NEW_ELEVATOR
							for i,v in pairs(MAIN_FRAME.LIST:GetChildren()) do
								if (v:IsA('Frame')) then
									v:Destroy()
								end
							end
							if (not NEW_ELEVATOR) then return [[error('NEW_ELEVATOR is nil', 2)]] end
							for i,v in pairs(ELEVATOR.Floors:GetChildren()) do
								local FLOOR_NAME = tonumber(string.split(v.Name, 'Floor_')[2])
								local NEW_FRAME = MAIN_FRAME.LIST:FindFirstChild("FLOOR_" .. (FLOOR_NAME) .. "_FRAME") or Instance.new('Frame')
								NEW_FRAME.Parent = MAIN_FRAME.LIST
								NEW_FRAME.Name = "FLOOR_" .. (FLOOR_NAME) .. "_FRAME"
								NEW_FRAME.Size = UDim2.new(1, -20, 0, 50)
								NEW_FRAME.AnchorPoint = Vector2.new(1, 1)*.5
								NEW_FRAME.BackgroundTransparency = 1
								NEW_FRAME.BorderSizePixel = 0
								NEW_FRAME.LayoutOrder = FLOOR_NAME
								local TICK_BOX_FRAME = NEW_FRAME:FindFirstChild('TICK_BOX_FRAME') or Instance.new('Frame')
								TICK_BOX_FRAME.Parent = NEW_FRAME
								TICK_BOX_FRAME.Name = 'TICK_BOX_FRAME'
								TICK_BOX_FRAME.Position = UDim2.new(0, 10, .5, 0)
								TICK_BOX_FRAME.AnchorPoint = Vector2.new(0, 1)*.5
								TICK_BOX_FRAME.Size = UDim2.new(0, NEW_FRAME.AbsoluteSize.Y-20, 0, NEW_FRAME.AbsoluteSize.Y-20)
								TICK_BOX_FRAME.BackgroundTransparency = 1
								local UICORNER = TICK_BOX_FRAME:FindFirstChildOfClass('UICorner') or Instance.new('UICorner')
								UICORNER.Parent = TICK_BOX_FRAME
								UICORNER.CornerRadius = UDim.new(0, 5)
								local UISTROKE = TICK_BOX_FRAME:FindFirstChildOfClass('UIStroke') or Instance.new('UIStroke')
								UISTROKE.Parent = TICK_BOX_FRAME
								UISTROKE.Color = Color3.new(1, 1, 1)
								UISTROKE.Thickness = 2
								local TICK_IMG = TICK_BOX_FRAME:FindFirstChildOfClass('ImageButton') or Instance.new('ImageButton')
								TICK_IMG.Parent = TICK_BOX_FRAME
								TICK_IMG.Position = UDim2.new(.5, 0, .5, 0)
								TICK_IMG.AnchorPoint = Vector2.new(1, 1)*.5
								TICK_IMG.Size = UDim2.new(1, -3, 1, -3)
								TICK_IMG.BackgroundTransparency = 1
								TICK_IMG.Image = 'rbxassetid://5853990158'
								local UISCALE = TICK_BOX_FRAME:FindFirstChildOfClass('UIScale') or Instance.new('UIScale')
								UISCALE.Parent = TICK_IMG
								UISCALE.Scale = 0
								local MASK_FRAME = NEW_FRAME:FindFirstChild('MASK') or Instance.new('Frame')
								MASK_FRAME.Parent = NEW_FRAME
								MASK_FRAME.Name = 'MASK'
								MASK_FRAME.Size = UDim2.new(1, -5, 1, -5)
								MASK_FRAME.Position = UDim2.new(.5, 0, .5, 0)
								MASK_FRAME.AnchorPoint = Vector2.new(1, 1)*.5
								MASK_FRAME.BackgroundTransparency = 1
								MASK_FRAME.BorderSizePixel = 0
								local UICORNER = MASK_FRAME:FindFirstChildOfClass('UICorner') or Instance.new('UICorner')
								UICORNER.Parent = MASK_FRAME
								UICORNER.CornerRadius = UDim.new(0, 8)
								local UISTROKE = MASK_FRAME:FindFirstChildOfClass('UIStroke') or Instance.new('UIStroke')
								UISTROKE.Parent = MASK_FRAME
								UISTROKE.Color = Color3.new(1, 1, 1)
								UISTROKE.Thickness = 2
								local LABEL = MASK_FRAME:FindFirstChild("Floor " .. (FLOOR_NAME)) or Instance.new('TextButton')
								LABEL.Parent = MASK_FRAME
								LABEL.Size = UDim2.new(.95, 0, .75, 0)
								LABEL.Position = UDim2.new(.5, 0, .5, 0)
								LABEL.AnchorPoint = Vector2.new(1, 1)*.5
								LABEL.BackgroundTransparency = 1
								LABEL.Text = "Floor " .. (FLOOR_NAME)
								LABEL.FontFace = Font.new("rbxassetid://" .. (STYLE.FONT_ID), Enum.FontWeight.Regular, Enum.FontStyle.Normal)
								LABEL.TextScaled = true
								LABEL.RichText = true
								LABEL.TextColor3 = Color3.new(1, 1, 1)

								LABEL.MouseButton1Click:Connect(function()
									if (not table.find(SELECTED_FLOORS, FLOOR_NAME)) then
										table.insert(SELECTED_FLOORS, FLOOR_NAME)
										TWEEN_SERVICE:Create(TICK_IMG.UIScale, TweenInfo.new(.3, Enum.EasingStyle.Elastic, Enum.EasingDirection.Out), {Scale=1}):Play()
									else
										local INDEX = table.find(SELECTED_FLOORS, FLOOR_NAME)
										table.remove(SELECTED_FLOORS, INDEX)
										TWEEN_SERVICE:Create(TICK_IMG.UIScale, TweenInfo.new(.15, Enum.EasingStyle.Quart, Enum.EasingDirection.In), {Scale=0}):Play()
									end
								end)
								LABEL.MouseEnter:Connect(function()
									TWEEN_SERVICE:Create(UISTROKE, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=require(script.Parent.COLORFRAME).TOP_BUTTONS.LOCKING_MANAGER.COLOR}):Play()
									TWEEN_SERVICE:Create(TICK_BOX_FRAME.UIStroke, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=require(script.Parent.COLORFRAME).TOP_BUTTONS.LOCKING_MANAGER.COLOR}):Play()
								end)
								LABEL.MouseLeave:Connect(function()
									TWEEN_SERVICE:Create(UISTROKE, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}):Play()
									TWEEN_SERVICE:Create(TICK_BOX_FRAME.UIStroke, TweenInfo.new(.25, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {Color=Color3.new(1, 1, 1)}):Play()
								end)

							end
						end,
					}
				end,
			}
		};
		['OUTPUT'] = {
			['INDEX']=8;
			['BUTTONS']={

			};
			['ADDONS'] = {
				['OUTPUT_FRAME'] = function(FRAME, DATA)
					local ELEVATOR
					local OUTPUT_FRAME = FRAME:FindFirstChild('OUTPUT_FRAME') or script.Parent.DEPENDENCIES.OUTPUT_FRAME:Clone()
					OUTPUT_FRAME.Parent = FRAME
					local CANVAS_BOTTOM = Vector2.new(0, 999999999)

					local LAST_CANVAS_POSITION = OUTPUT_FRAME.LIST.CanvasPosition
					OUTPUT_FRAME.LIST.UIListLayout:GetPropertyChangedSignal('AbsoluteContentSize'):Connect(function()
						OUTPUT_FRAME.NO_MESSAGES.Visible = OUTPUT_FRAME.LIST.UIListLayout.AbsoluteContentSize.Y <= 0
						local NEW_CANVAS_POS = Vector2.new(0, OUTPUT_FRAME.LIST.UIListLayout.AbsoluteContentSize.Y-OUTPUT_FRAME.LIST.AbsoluteSize.Y)
						local LAST_CANVAS_POS = OUTPUT_FRAME.LIST.CanvasPosition
						OUTPUT_FRAME.LIST.CanvasPosition = CANVAS_BOTTOM
						local NEW_CANVAS_POS = OUTPUT_FRAME.LIST.CanvasPosition
						OUTPUT_FRAME.LIST.CanvasSize = UDim2.new(0, 0, 0, OUTPUT_FRAME.LIST.UIListLayout.AbsoluteContentSize.Y)
						OUTPUT_FRAME.LIST.CanvasPosition = LAST_CANVAS_POS
						if (OUTPUT_FRAME.LIST.CanvasPosition.Y >= NEW_CANVAS_POS.Y) then
							game:GetService('TweenService'):Create(OUTPUT_FRAME.LIST, TweenInfo.new(.15, Enum.EasingStyle.Quart, Enum.EasingDirection.Out), {CanvasPosition=CANVAS_BOTTOM}):Play()
						end
						LAST_CANVAS_POSITION = OUTPUT_FRAME.LIST.CanvasPosition
					end)
					OUTPUT_FRAME.NO_MESSAGES.Visible = OUTPUT_FRAME.LIST.UIListLayout.AbsoluteContentSize.Y <= 0
					OUTPUT_FRAME.LIST.CanvasSize = UDim2.new(0, 0, 0, OUTPUT_FRAME.LIST.UIListLayout.AbsoluteContentSize.Y)

					local function ADD_OUTPUT_LABEL(DATA: any)
						local UID = game:GetService('HttpService'):GenerateGUID(false)
						local TIMESTAMP = DATA.timestamp:FormatLocalTime('HH:MM:ss', 'en-us')
						local MASK_FRAME = OUTPUT_FRAME.LIST:FindFirstChild("OUTPUT_LABEL_MASK_" .. (UID)) or Instance.new('Frame')
						MASK_FRAME.Parent = OUTPUT_FRAME.LIST
						MASK_FRAME.Name = "OUTPUT_LABEL_MASK_" .. (UID)
						MASK_FRAME.Size = UDim2.new(1, -OUTPUT_FRAME.LIST.ScrollBarThickness, 0, 45)
						MASK_FRAME.BackgroundTransparency = 1
						MASK_FRAME:SetAttribute('MESSAGE_ID', DATA.message.id)
						local LABEL = MASK_FRAME:FindFirstChild('OUTPUT_LABEL') or Instance.new('TextLabel')
						LABEL.Name = 'OUTPUT_LABEL'
						LABEL.Parent = MASK_FRAME
						LABEL.AnchorPoint = Vector2.new(0, .5)
						LABEL.Position = UDim2.new(-1, 0, .5, 0)
						LABEL.Size = UDim2.new(1, 0, 1, 0)
						LABEL.FontFace = Font.new('rbxassetid://12187365364')
						LABEL.BackgroundTransparency = 1
						LABEL.TextSize = 20
						LABEL.TextWrapped = true
						LABEL.RichText = true
						local r,g,b = DATA.color.R,DATA.color.G,DATA.color.B
						LABEL.Text = "<font color="#ffffff"><b>[" .. (TIMESTAMP) .. "]: </b>" .. (DATA.elevator.Name) .. "</font><font color="rgb(" .. (math.ceil(r*255)) .. "," .. (math.ceil(g*255)) .. "," .. (math.ceil(b*255)) .. ")"> - " .. (DATA.message.content) .. "</font>"
						LABEL.TextXAlignment = Enum.TextXAlignment.Left
						MASK_FRAME.Size = UDim2.new(MASK_FRAME.Size.X.Scale, MASK_FRAME.Size.X.Offset, 0, LABEL.TextBounds.Y)
						game:GetService('TweenService'):Create(LABEL, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {Position=UDim2.new(0, 0, .5, 0)}):Play()
					end

					local GLOBAL_REMOTE = game.ReplicatedStorage:WaitForChild('Cortex_Remote_GLOBAL')
					GLOBAL_REMOTE.OnClientEvent:Connect(function(PROTOCOL, PARAMS)
						if (PARAMS.elevator ~= ELEVATOR) then return end
						if (not ELEVATOR) then return [[error('ELEVATOR is nil', 2)]] end
						if (PROTOCOL == 'Cortex_Output_Message_Broadcast') then
							ADD_OUTPUT_LABEL(PARAMS)
						elseif (PROTOCOL == 'Cortex_Output_Message_Remove') then
							for i,v in pairs(OUTPUT_FRAME.LIST:GetChildren()) do
								if (v:GetAttribute('MESSAGE_ID') == PARAMS.message.id) then
									v:Destroy()
								end
							end
						end
					end)

					return {
						REFRESH=function(PREVIOUS_ELEVATOR, NEW_ELEVATOR)
							ELEVATOR = NEW_ELEVATOR
							for i,v in pairs(OUTPUT_FRAME.LIST:GetChildren()) do
								if (v.Name == 'OUTPUT_LABEL_MASK') then
									v:Destroy()
								end
							end
							if (not NEW_ELEVATOR) then return [[error('NEW_ELEVATOR is nil', 2)]] end
							local OUTPUT_STORAGE = script.Parent.Parent.DATA_REMOTE:InvokeServer('GET_ELEVATOR_OUTPUT_STORAGE')
							for KEY,DATA in pairs(OUTPUT_STORAGE[NEW_ELEVATOR.Name]) do
								ADD_OUTPUT_LABEL(DATA)
							end
						end,
					}

				end,
			}
		};
	};

};]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXB7CA08CCA37E4798A1F1F6C3698862A1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">STYLE</string>
							<string name="ScriptGuid">{F75CF73B-E24E-4648-861A-BB86034FC8B8}</string>
							<ProtectedString name="Source"><![CDATA[return {
	
	['FONT_ID']=12187365364
	
}]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBX96C9F0DF23794D09847FB6FB9E53123E">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">BUTTON_SYS</string>
							<string name="ScriptGuid">{73B9793D-0D68-44D9-826A-43E3B2873E82}</string>
							<ProtectedString name="Source"><![CDATA[local MODULE = {}
local DEPENDENCIES = script.Parent.DEPENDENCIES

function MODULE.ADD_BUTTON(APPEND: any?, LABEL: string?)
	
	local NEW_BUTTON = DEPENDENCIES.TRIGGER_BUTTON:Clone()
	NEW_BUTTON.Parent = APPEND
	NEW_BUTTON.Name = LABEL
	NEW_BUTTON.MASK.LABEL.Text = LABEL
	return NEW_BUTTON
	
end

return MODULE]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBXF6E968D7B1DD4B2392A55544205800F7">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0</X>
								<Y>1</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.196078435</R>
								<G>0.196078435</G>
								<B>0.196078435</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">TOOLTIP</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.200000003</XS>
								<XO>0</XO>
								<YS>0.400000006</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>90</XO>
								<YS>0</YS>
								<YO>25</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="TextLabel" referent="RBX957CA23E01EC4B258798477A96345905">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">100</token>
								<Font name="FontFace">
									<Family><url>rbxassetid://12187365364</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TEXT</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Controls</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">20</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="UIStroke" referent="RBX4E85B9E531DE4F189BD3F943E1FEB30C">
							<Properties>
								<token name="ApplyStrokeMode">1</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Color3 name="Color">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="Enabled">true</bool>
								<token name="LineJoinMode">0</token>
								<string name="Name">UIStroke</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="Thickness">1</float>
								<float name="Transparency">0</float>
							</Properties>
						</Item>
						<Item class="UICorner" referent="RBXB359C819443948C78261F7700A90128D">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>5</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextButton" referent="RBX0DCAA3980FB841A5AA50177CD118D164">
					<Properties>
						<bool name="Active">true</bool>
						<Vector2 name="AnchorPoint">
							<X>1</X>
							<Y>0.5</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoButtonColor">false</bool>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>0.239215702</R>
							<G>0.239215702</G>
							<B>0.239215702</B>
						</Color3>
						<float name="BackgroundTransparency">0</float>
						<Color3 name="BorderColor3">
							<R>0.105882362</R>
							<G>0.164705887</G>
							<B>0.207843155</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">1</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">3</token>
						<Font name="FontFace">
							<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
							<Weight>400</Weight>
							<Style>Normal</Style>
							<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
						</Font>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">1</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<bool name="Modal">false</bool>
						<string name="Name">EXPAND</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>5</XO>
							<YS>0.5</YS>
							<YO>0</YO>
						</UDim2>
						<bool name="RichText">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">true</bool>
						<bool name="Selected">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>50</XO>
							<YS>0</YS>
							<YO>100</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<token name="Style">0</token>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Button</string>
						<Color3 name="TextColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<bool name="TextScaled">false</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">1</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">false</bool>
						<token name="TextXAlignment">2</token>
						<token name="TextYAlignment">1</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">2</int>
					</Properties>
					<Item class="Frame" referent="RBX4E7BA3F0101746E082F701929A25E281">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.192156866</R>
								<G>0.192156866</G>
								<B>0.192156866</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">1</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">MASK</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0.5</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>0</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="UIStroke" referent="RBX1304C7550927433EB4C8A09D696344B7">
							<Properties>
								<token name="ApplyStrokeMode">1</token>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Color3 name="Color">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="Enabled">true</bool>
								<token name="LineJoinMode">0</token>
								<string name="Name">UIStroke</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="Thickness">2</float>
								<float name="Transparency">0</float>
							</Properties>
						</Item>
						<Item class="TextLabel" referent="RBX0A558CE7EEAF480DAC5F64AACB2B40E8">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">100</token>
								<Font name="FontFace">
									<Family><url>rbxassetid://12187365364</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TEXT</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.899999976</XS>
									<XO>0</XO>
									<YS>0.400000006</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">&lt;</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="UICorner" referent="RBXEC2B88D101DA4A6C981D2549EBCB3588">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<UDim name="CornerRadius">
									<S>0</S>
									<O>8</O>
								</UDim>
								<string name="Name">UICorner</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="UICorner" referent="RBXAB48830B273C41DCA94328B6E17E57F8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<UDim name="CornerRadius">
								<S>0</S>
								<O>8</O>
							</UDim>
							<string name="Name">UICorner</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="Script" referent="RBXF35059248EFD4806BB6DE9F1A21D9E52">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">SERVER</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{05CDA40E-4C0F-4514-9AC9-97ED1AB13839}</string>
						<ProtectedString name="Source"><![CDATA[local THIS = script.Parent
local DATA_REMOTE = THIS:WaitForChild('DATA_REMOTE')

function DATA_REMOTE.OnServerInvoke(USER, PROTOCOL, PARAMS)
	if (not _G.CORTEX_RC_WHITELIST[tostring(USER.UserId)]) then return end
	if (PROTOCOL == 'GET_ELEVATOR_STORAGE') then
		return _G.CortexElevatorStorage
	elseif (PROTOCOL == 'GET_ELEVATOR_OUTPUT_STORAGE') then
		return _G.Elevator_Output_Storage_GLOBAL
	elseif (PROTOCOL == 'CORTEX_API_FIRE') then
		if (not PARAMS.ELEVATOR) then return end
		PARAMS.ELEVATOR.Cortex_API:Fire(PARAMS.PROTOCOL, PARAMS.PARAMS)
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="RemoteFunction" referent="RBX39EF9EB845224965827456CF5FAA3B68">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<string name="Name">DATA_REMOTE</string>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="CanvasGroup" referent="RBX1E154BFDDB7A4987848DED22499A79B5">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>0.5</X>
							<Y>0</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">true</bool>
						<bool name="Draggable">false</bool>
						<Color3 name="GroupColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="GroupTransparency">0</float>
						<int name="LayoutOrder">0</int>
						<string name="Name">MAIN_FRAME</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>0.5</XS>
							<XO>0</XO>
							<YS>0.100000001</YS>
							<YO>0</YO>
						</UDim2>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0.100000001</XS>
							<XO>200</XO>
							<YS>0.699999988</YS>
							<YO>50</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="UIListLayout" referent="RBXA85C7176ADF741A98C01FC35C2BAADF8">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<token name="FillDirection">1</token>
							<token name="HorizontalAlignment">1</token>
							<string name="Name">UIListLayout</string>
							<UDim name="Padding">
								<S>0</S>
								<O>0</O>
							</UDim>
							<token name="SortOrder">2</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<token name="VerticalAlignment">1</token>
						</Properties>
					</Item>
					<Item class="UISizeConstraint" referent="RBX13DA93DD135E4C8FB39ED6E5E53500F7">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Vector2 name="MaxSize">
								<X>400</X>
								<Y>650</Y>
							</Vector2>
							<Vector2 name="MinSize">
								<X>0</X>
								<Y>0</Y>
							</Vector2>
							<string name="Name">UISizeConstraint</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Frame" referent="RBX9A8EFFC1B0DA4A9B9A2E9CC415A411C2">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.196078435</R>
								<G>0.196078435</G>
								<B>0.196078435</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">1</int>
							<string name="Name">CONTENT</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>1</YS>
								<YO>-20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
						<Item class="Frame" referent="RBXFBA24A4B262E41F8A0CDF0B155A0DC53">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>1</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">PAGES</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.850000024</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBX2E64867FE2DE4E169CA49975E124CB33">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">MASK</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX8202F1C97A7F44EDBE6826B53DF7A68A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="FillDirection">0</token>
										<token name="HorizontalAlignment">1</token>
										<string name="Name">UIListLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>0</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">0</token>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX79880E71F32541A3B6CB8A6276EA8432">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">3</token>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
										<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">BACK</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.949999988</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">Button</string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">1</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">2</int>
								</Properties>
								<Item class="Frame" referent="RBX14772B237DDC4AE2AA8F4AE02CA27669">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.192156866</R>
											<G>0.192156866</G>
											<B>0.192156866</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">MASK</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIStroke" referent="RBX05F1B13927B6460BA736BDF08B2D4BDF">
										<Properties>
											<token name="ApplyStrokeMode">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Color3 name="Color">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="Enabled">true</bool>
											<token name="LineJoinMode">0</token>
											<string name="Name">UIStroke</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<float name="Thickness">2</float>
											<float name="Transparency">0</float>
										</Properties>
									</Item>
									<Item class="UIScale" referent="RBX57315DBEE3FE4992809312F73894870D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<string name="Name">UIScale</string>
											<float name="Scale">0.899999976</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="TextLabel" referent="RBX042F142EC4EF4BDF91CEE52AFA839A49">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">100</token>
											<Font name="FontFace">
												<Family><url>rbxassetid://12187365364</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<string name="Name">TEXT</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">true</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.899999976</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">BACK</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UICorner" referent="RBX1C96DB96704F44B6890FA00F10069F1A">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX9FE4ACABF5FA48BDB13FC532291F5FE4">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">CONTROLS</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.100000001</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="Frame" referent="RBX9D20E92DC22B44F886846272E831A90A">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">BUTTONS</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>-10</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBXEBBF789F086D44209E62CD076C897CC4">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="FillDirection">0</token>
										<token name="HorizontalAlignment">0</token>
										<string name="Name">UIListLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>10</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">2</token>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXC9F9B7F2C65343DEB3A08CC95DC81336">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">UNDER</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>61</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UICorner" referent="RBX557904401B854508A242FD094AE2A1F7">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>1</S>
											<O>0</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX59B75F7C0F184128990420B141D08183">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.192156881</R>
									<G>0.192156881</G>
									<B>0.192156881</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">ELEVATOR_SELECTION</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX5A50DA5581894958B8701A8784F4CC7F">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>700</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">TITLE</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>5</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.899999976</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>25</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">ELEVATOR SELECTION</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="ScrollingFrame" referent="RBX9FFE5101887A4A5EAF1790F0A2884FCB">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticCanvasSize">0</token>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
									<Vector2 name="CanvasPosition">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<UDim2 name="CanvasSize">
										<XS>0</XS>
										<XO>0</XO>
										<YS>2</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="ClipsDescendants">true</bool>
									<bool name="Draggable">false</bool>
									<token name="ElasticBehavior">0</token>
									<token name="HorizontalScrollBarInset">0</token>
									<int name="LayoutOrder">0</int>
									<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
									<string name="Name">LIST</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.150000006</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<Color3 name="ScrollBarImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="ScrollBarImageTransparency">0</float>
									<int name="ScrollBarThickness">5</int>
									<token name="ScrollingDirection">4</token>
									<bool name="ScrollingEnabled">true</bool>
									<bool name="Selectable">true</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">true</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>0.699999988</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
									<token name="VerticalScrollBarInset">0</token>
									<token name="VerticalScrollBarPosition">0</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIListLayout" referent="RBX91F1D00944384C948B811375DECB1EE2">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<token name="FillDirection">1</token>
										<token name="HorizontalAlignment">0</token>
										<string name="Name">UIListLayout</string>
										<UDim name="Padding">
											<S>0</S>
											<O>10</O>
										</UDim>
										<token name="SortOrder">2</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<token name="VerticalAlignment">1</token>
									</Properties>
								</Item>
							</Item>
							<Item class="TextButton" referent="RBX9DA8B85CF13249C4BD98AD7208ED102B">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">3</token>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
										<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">PROX_SELECT</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.949999988</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text"></string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">1</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">2</int>
								</Properties>
								<Item class="Frame" referent="RBX6EC3811A1A54414A9DEAC12E925E12D5">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.192156866</R>
											<G>0.192156866</G>
											<B>0.192156866</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">MASK</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIStroke" referent="RBX911155CD436340A29A0AEB635E093127">
										<Properties>
											<token name="ApplyStrokeMode">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Color3 name="Color">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="Enabled">true</bool>
											<token name="LineJoinMode">0</token>
											<string name="Name">UIStroke</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<float name="Thickness">2</float>
											<float name="Transparency">0</float>
										</Properties>
									</Item>
									<Item class="UIScale" referent="RBXF1E7BFB511FC4E71900FA8C25BA6763D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<string name="Name">UIScale</string>
											<float name="Scale">0.899999976</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="TextLabel" referent="RBXC89516C0C07F4DD6BFAE126D68DFB58A">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">100</token>
											<Font name="FontFace">
												<Family><url>rbxassetid://12187365364</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<string name="Name">TEXT</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.899999976</XS>
												<XO>0</XO>
												<YS>0.800000012</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">SELECT VIA PROXIMITY...</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UICorner" referent="RBX094FF76582FC4E07AD5E6010922A63D1">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXBB9CFF1CDF1C44AEAB5AC5771A59A080">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">SEARCH</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.100000001</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>20</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBXA52F38BF0F3448E7892A83B24FECFB9B">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">1</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="TextBox" referent="RBX93C1C9014CF649AC8A577985EBCD9572">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClearTextOnFocus">false</bool>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">100</token>
										<Font name="FontFace">
											<Family><url>rbxassetid://12187365364</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="MultiLine">false</bool>
										<string name="Name">INPUT</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<Color3 name="PlaceholderColor3">
											<R>0.699999988</R>
											<G>0.699999988</G>
											<B>0.699999988</B>
										</Color3>
										<string name="PlaceholderText">Search...</string>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>5</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<bool name="ShowNativeInput">true</bool>
										<UDim2 name="Size">
											<XS>0.949999988</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text"></string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextEditable">true</bool>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">0</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX03DDA99D837E435394B2D6CECF6405F2">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>1</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">SORT_BUTTON</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>1</XS>
										<XO>-5</XO>
										<YS>0</YS>
										<YO>10</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0</XS>
										<XO>25</XO>
										<YS>0</YS>
										<YO>25</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UIStroke" referent="RBX0374A81C99924B349F4536CE80317CE9">
									<Properties>
										<token name="ApplyStrokeMode">1</token>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Color3 name="Color">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="Enabled">true</bool>
										<token name="LineJoinMode">0</token>
										<string name="Name">UIStroke</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<float name="Thickness">2</float>
										<float name="Transparency">0</float>
									</Properties>
								</Item>
								<Item class="UICorner" referent="RBX4EF8CB3EA1054E089AB8868F46C469DD">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>7</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBXE572C41346BC4FBBB36ED1E4B1D09D31">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">100</token>
										<Font name="FontFace">
											<Family><url>rbxassetid://12187365364</url></Family>
											<Weight>700</Weight>
											<Style>Normal</Style>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">BTN</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">true</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>-2</XO>
											<YS>1</YS>
											<YO>-2</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">A-Z</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Frame" referent="RBX74BD5ED8FA7D41F6B21168C18C18D38B">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.192156881</R>
									<G>0.192156881</G>
									<B>0.192156881</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<int name="LayoutOrder">0</int>
								<string name="Name">PROX_ELEVATOR_FRAME</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>-1</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Visible">false</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="TextLabel" referent="RBX5C510B3BEC4A4D689BC6616C74D11861">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>700</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">TITLE</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.899999976</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>25</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">ELEVATOR PROXIMITY SELECTION</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
							<Item class="TextButton" referent="RBX0D55CCADA0A945E882A2DB702D463FBD">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoButtonColor">true</bool>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">3</token>
									<Font name="FontFace">
										<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
										<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<bool name="Modal">false</bool>
									<string name="Name">CANCEL</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.949999988</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">false</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">true</bool>
									<bool name="Selected">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.400000006</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text"></string>
									<Color3 name="TextColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<bool name="TextScaled">false</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">1</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">false</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">2</int>
								</Properties>
								<Item class="Frame" referent="RBXC4BAF89E5A26495EA3D0EFE6BD5FC263">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.192156866</R>
											<G>0.192156866</G>
											<B>0.192156866</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">MASK</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIStroke" referent="RBXCCF1C552C62B441BA93C8DC147BD419D">
										<Properties>
											<token name="ApplyStrokeMode">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Color3 name="Color">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="Enabled">true</bool>
											<token name="LineJoinMode">0</token>
											<string name="Name">UIStroke</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<float name="Thickness">2</float>
											<float name="Transparency">0</float>
										</Properties>
									</Item>
									<Item class="UIScale" referent="RBXF44CE28CAEEE4BA28896F557402E69C4">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<string name="Name">UIScale</string>
											<float name="Scale">0.899999976</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="TextLabel" referent="RBX85403DB1593C41F7A0064EA121AFD774">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">100</token>
											<Font name="FontFace">
												<Family><url>rbxassetid://12187365364</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<string name="Name">TEXT</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.899999976</XS>
												<XO>0</XO>
												<YS>0.800000012</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">CANCEL</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UICorner" referent="RBX40F3831CAFE646F3BAAE64A335D6F383">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>8</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="TextLabel" referent="RBX75A7D25A738F4ECFB000D37E0780BF15">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<token name="Font">100</token>
									<Font name="FontFace">
										<Family><url>rbxassetid://12187365364</url></Family>
										<Weight>400</Weight>
										<Style>Normal</Style>
									</Font>
									<int name="LayoutOrder">0</int>
									<float name="LineHeight">1</float>
									<int name="MaxVisibleGraphemes">-1</int>
									<string name="Name">NO_ELEVATOR</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="RichText">true</bool>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.800000012</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>30</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Text">No elevator found</string>
									<Color3 name="TextColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<bool name="TextScaled">true</bool>
									<float name="TextSize">14</float>
									<Color3 name="TextStrokeColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<float name="TextStrokeTransparency">1</float>
									<float name="TextTransparency">0.600000024</float>
									<token name="TextTruncate">0</token>
									<bool name="TextWrapped">true</bool>
									<token name="TextXAlignment">2</token>
									<token name="TextYAlignment">1</token>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Frame" referent="RBXE1123F98F9A34DB3B2BC4D56710F8B0E">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>1</X>
								<Y>0</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>0.301960796</R>
								<G>0.301960796</G>
								<B>0.301960796</B>
							</Color3>
							<float name="BackgroundTransparency">0</float>
							<Color3 name="BorderColor3">
								<R>0.105882362</R>
								<G>0.164705887</G>
								<B>0.207843155</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<int name="LayoutOrder">0</int>
							<string name="Name">TOPBAR</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>0</YO>
							</UDim2>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>1</XS>
								<XO>0</XO>
								<YS>0</YS>
								<YO>20</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<token name="Style">0</token>
							<BinaryString name="Tags"></BinaryString>
							<bool name="Visible">true</bool>
							<int name="ZIndex">5</int>
						</Properties>
						<Item class="TextButton" referent="RBX03E9EA960B7A430D84ADA7C619BB17D9">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>1</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">3</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<bool name="Modal">false</bool>
								<string name="Name">CLOSE</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>1</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>20</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Button</string>
								<Color3 name="TextColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<bool name="TextScaled">false</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">1</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">false</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="ImageLabel" referent="RBX808BBA93401743CFA5EE468449BCD600">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxassetid://5851035537</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<string name="Name">IMG</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">3</token>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
							</Item>
						</Item>
						<Item class="ImageLabel" referent="RBX07F577E7C6E34C53A8ED41556F29E2FA">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>http://www.roblox.com/asset/?id=12403672850</url></Content>
								<Color3 name="ImageColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0</float>
								<int name="LayoutOrder">0</int>
								<string name="Name">IMG</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">3</token>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>20</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIScale" referent="RBX41EDC6D674EB49C28EFBAD5BF761E503">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">UIScale</string>
									<float name="Scale">0.699999988</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
						</Item>
						<Item class="TextLabel" referent="RBX53CFC3ABA17E4629B2734F6855601E31">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">100</token>
								<Font name="FontFace">
									<Family><url>rbxassetid://12187365364</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">TITLE</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>20</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>200</XO>
									<YS>0.5</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">Cortex RemoteControls V0</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">0</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="TextLabel" referent="RBX413A155386B14B1D8D2B574425F065DD">
					<Properties>
						<bool name="Active">false</bool>
						<Vector2 name="AnchorPoint">
							<X>1</X>
							<Y>1</Y>
						</Vector2>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<token name="AutomaticSize">0</token>
						<Color3 name="BackgroundColor3">
							<R>1</R>
							<G>1</G>
							<B>1</B>
						</Color3>
						<float name="BackgroundTransparency">1</float>
						<Color3 name="BorderColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<token name="BorderMode">0</token>
						<int name="BorderSizePixel">0</int>
						<bool name="ClipsDescendants">false</bool>
						<bool name="Draggable">false</bool>
						<token name="Font">100</token>
						<Font name="FontFace">
							<Family><url>rbxassetid://12187361378</url></Family>
							<Weight>400</Weight>
							<Style>Normal</Style>
						</Font>
						<int name="LayoutOrder">0</int>
						<float name="LineHeight">3</float>
						<int name="MaxVisibleGraphemes">-1</int>
						<string name="Name">KeyCodeHint</string>
						<Ref name="NextSelectionDown">null</Ref>
						<Ref name="NextSelectionLeft">null</Ref>
						<Ref name="NextSelectionRight">null</Ref>
						<Ref name="NextSelectionUp">null</Ref>
						<UDim2 name="Position">
							<XS>1</XS>
							<XO>-15</XO>
							<YS>1</YS>
							<YO>-15</YO>
						</UDim2>
						<bool name="RichText">true</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<float name="Rotation">0</float>
						<bool name="Selectable">false</bool>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<Ref name="SelectionImageObject">null</Ref>
						<int name="SelectionOrder">0</int>
						<UDim2 name="Size">
							<XS>0</XS>
							<XO>350</XO>
							<YS>0</YS>
							<YO>35</YO>
						</UDim2>
						<token name="SizeConstraint">0</token>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<string name="Text">Press R To Open RemoteControls</string>
						<Color3 name="TextColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<bool name="TextScaled">true</bool>
						<float name="TextSize">14</float>
						<Color3 name="TextStrokeColor3">
							<R>0</R>
							<G>0</G>
							<B>0</B>
						</Color3>
						<float name="TextStrokeTransparency">1</float>
						<float name="TextTransparency">0.5</float>
						<token name="TextTruncate">0</token>
						<bool name="TextWrapped">true</bool>
						<token name="TextXAlignment">1</token>
						<token name="TextYAlignment">2</token>
						<bool name="Visible">true</bool>
						<int name="ZIndex">1</int>
					</Properties>
					<Item class="TextLabel" referent="RBXB037CABE7F904A83970C698B64F02700">
						<Properties>
							<bool name="Active">false</bool>
							<Vector2 name="AnchorPoint">
								<X>0.5</X>
								<Y>0.5</Y>
							</Vector2>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="AutoLocalize">true</bool>
							<token name="AutomaticSize">0</token>
							<Color3 name="BackgroundColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<float name="BackgroundTransparency">1</float>
							<Color3 name="BorderColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<token name="BorderMode">0</token>
							<int name="BorderSizePixel">0</int>
							<bool name="ClipsDescendants">false</bool>
							<bool name="Draggable">false</bool>
							<token name="Font">100</token>
							<Font name="FontFace">
								<Family><url>rbxassetid://12187361378</url></Family>
								<Weight>400</Weight>
								<Style>Normal</Style>
							</Font>
							<int name="LayoutOrder">0</int>
							<float name="LineHeight">3</float>
							<int name="MaxVisibleGraphemes">-1</int>
							<string name="Name">Text</string>
							<Ref name="NextSelectionDown">null</Ref>
							<Ref name="NextSelectionLeft">null</Ref>
							<Ref name="NextSelectionRight">null</Ref>
							<Ref name="NextSelectionUp">null</Ref>
							<UDim2 name="Position">
								<XS>0.5</XS>
								<XO>-2</XO>
								<YS>0.5</YS>
								<YO>-2</YO>
							</UDim2>
							<bool name="RichText">true</bool>
							<Ref name="RootLocalizationTable">null</Ref>
							<float name="Rotation">0</float>
							<bool name="Selectable">false</bool>
							<token name="SelectionBehaviorDown">0</token>
							<token name="SelectionBehaviorLeft">0</token>
							<token name="SelectionBehaviorRight">0</token>
							<token name="SelectionBehaviorUp">0</token>
							<bool name="SelectionGroup">false</bool>
							<Ref name="SelectionImageObject">null</Ref>
							<int name="SelectionOrder">0</int>
							<UDim2 name="Size">
								<XS>0</XS>
								<XO>350</XO>
								<YS>0</YS>
								<YO>35</YO>
							</UDim2>
							<token name="SizeConstraint">0</token>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<string name="Text">Press R To Open RemoteControls</string>
							<Color3 name="TextColor3">
								<R>1</R>
								<G>1</G>
								<B>1</B>
							</Color3>
							<bool name="TextScaled">true</bool>
							<float name="TextSize">14</float>
							<Color3 name="TextStrokeColor3">
								<R>0</R>
								<G>0</G>
								<B>0</B>
							</Color3>
							<float name="TextStrokeTransparency">1</float>
							<float name="TextTransparency">0</float>
							<token name="TextTruncate">0</token>
							<bool name="TextWrapped">true</bool>
							<token name="TextXAlignment">1</token>
							<token name="TextYAlignment">2</token>
							<bool name="Visible">true</bool>
							<int name="ZIndex">1</int>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBXA91A0757D65B484AAC69B78D792CA369">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBX6E143F23E4044E8FA167745AA1FE10CF">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Blacklist</string>
					<string name="ScriptGuid">{6D4863BB-4952-4125-8AAD-70A489666355}</string>
					<ProtectedString name="Source"><![CDATA[local module = {}

module.blacklistedUsers = {
	
	--[User ID] = {DISABLE_ELEVATORS=true;EXPIRE_TIME=0};
	
};

module.blacklistedGames = {
	
	--[Place ID] = {DISABLE_ELEVATORS=true;EXPIRE_TIME=0};
	
};

module.blacklistedGroups = {

	--[Group ID] = {DISABLE_ELEVATORS=true;EXPIRE_TIME=0};

};

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="Folder" referent="RBX486712E0F93D437F8A0140BA54CC834D">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">ALPHA</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXE0D0B8E89D1B47F4B17A8D8A1C80AC55">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Multi_Bay</string>
						<string name="ScriptGuid">{35D08833-5406-4DB4-9B05-F7BABF1D2793}</string>
						<ProtectedString name="Source"><![CDATA[--[[

CORTEX MULTIBAY - VER. 4
10/03/23

WRITTEN BY aaxtatious (540781721)

]]--

local module = {}
module.callFloorData = {}

return function(source)

	local collectionService = game:GetService('CollectionService')
	local replicatedStorage = game:GetService('ReplicatedStorage')

	local this = source.Parent
	local callButtons = this:FindFirstChild('Call_Buttons')
	if (not callButtons) then return warn("Cortex Multibay // GroupCalling :: " .. (this:GetFullName()) .. " :: Missing required instance Call_Buttons") end
	local elevators = this:FindFirstChild('Elevators')
	if (not callButtons) then return warn("Cortex Multibay // GroupCalling :: " .. (this:GetFullName()) .. " :: Missing required instance Elevators") end

	local allocator = require(script:WaitForChild('Allocator'))

	local configAvailable = source:FindFirstChild('Settings') ~= nil
	local config = configAvailable and require(source.Settings)

	local function setButton(button: Model, config: any, state: string, includeAllButtonsInFloorGroup: boolean?)
		if (typeof(config) ~= 'table') then return end
		local cfg = config[state]
		if (not cfg) then return end
		for _,v in pairs((includeAllButtonsInFloorGroup == true and button.Parent or button):GetDescendants()) do
			if ((includeAllButtonsInFloorGroup and v.Name == button.Name) or (not includeAllButtonsInFloorGroup)) then
				for _,light in pairs(v:GetDescendants()) do
					if ((not light:IsA('BasePart')) or light.Name ~= 'Light') then continue end
					light.Color = cfg.Color
					light.Material = cfg.Material
				end
			end
		end
	end

	for _,v in pairs(callButtons:GetChildren()) do
		local floorName = tonumber(string.split(v.Name, 'Floor_')[2]) or tonumber(string.split(v.Name, 'Floor')[2]) or tonumber(v.Name)
		if (not floorName) then continue end
		if (not module.callFloorData[tostring(floorName)]) then
			module.callFloorData[tostring(floorName)] = {}
		end
		for _,btnModel in pairs(v:GetDescendants()) do
			local buttonDirection = string.split(btnModel.Name, '_')[1]
			if (buttonDirection ~= 'Up' and buttonDirection ~= 'Down') then continue end
			local buttonPart: Part
			for _,v in pairs(btnModel:GetChildren()) do
				if ((not v:IsA('BasePart')) or v.Name ~= 'Button') then continue end
				buttonPart = v
				break
			end
			if (not buttonPart) then continue end
			buttonPart:SetAttribute('isACortexElevButton', true)
			--buttonPart.CollisionGroup = 'elevatorCollisionGroup'
			if (not module.callFloorData[tostring(floorName)][btnModel.Name]) then
				module.callFloorData[tostring(floorName)][btnModel.Name] = {
					elevator = nil,
					arrivalConnection = nil,
					otherConnections = {}
				}
			end
			if (config) then
				setButton(btnModel, config.Color_Config[btnModel.Name], 'Neutral_State', false)
			else
				local function getElevatorSettings(index)
					local elev = elevators:GetChildren()[index]
					if (((not elev) or (not elev:FindFirstChild('Settings'))) and elevators:GetChildren()[index+1]) then return getElevatorSettings(index+1) end
					return require(elev.Settings)
				end
				local newConfig = getElevatorSettings(1)
				if (not newConfig) then continue end
				setButton(btnModel, newConfig.Color_Database.Floor[btnModel.Name], 'Neautral_State', false)
			end
		end
	end

	local function addSound(append: Instance, name: string, soundId: number, volume: number, pitch: number, looped: boolean?, minDistance: number?, maxDistance: number?, playOnRemove: boolean?)
		if (typeof(append) ~= 'Instance') then return end
		local result = append:FindFirstChild(name)
		if (not result) then
			result = Instance.new('Sound')
			result.Name = name
			result.SoundId = "rbxassetid://" .. (soundId)
			result.Volume = volume
			result.PlaybackSpeed = pitch
			result.Looped = looped
			result.RollOffMinDistance = minDistance
			result.RollOffMaxDistance = maxDistance
			result.Parent = append
			if (playOnRemove == true) then
				result.PlayOnRemove = true
				result:Destroy()
			end
		end
		return result
	end

	local function handleButtonInput(user: Player? | any?, protocol: string, params: any)
		if (protocol ~= 'onButtonPressed' and protocol ~= 'onButtonReleased') then return end
		local button = params.button
		if (not button) then return end
		local buttonPart = button:FindFirstChild('Button')
		if (not buttonPart) then return end
		local buttonDirection = string.split(button.Name, '_')[1]
		local buttonSide = string.split(button.Name, '_')[2]
		local callFloor = tonumber(string.split(button.Parent.Name, 'Floor_')[2]) or tonumber(string.split(button.Parent.Name, 'Floor')[2]) or tonumber(button.Parent.Name)
		if (not callFloor) then return end
		local callFloorData = module.callFloorData[tostring(callFloor)][buttonDirection]
		if (not callFloorData) then return end
		local callDirection = buttonDirection == 'Up' and 1 or buttonDirection == 'Down' and -1 or nil
		if (not callDirection) then return end

		if (protocol == 'onButtonPressed') then
			if (config) then
				setButton(button, config.Color_Config[buttonDirection], 'Active_State', true)
				addSound(buttonPart, 'Button_Click', config.Sound_Config.Click.Sound_Id, config.Sound_Config.Click.Volume, config.Sound_Config.Click.Pitch, false, config.Sound_Config.Click.Roll_Off.Min, config.Sound_Config.Click.Roll_Off.Max, true)
			end

			local elevator = params.elevator or allocator.findElevator(elevators:GetChildren(), callFloor, callDirection)
			if ((not config) and (elevator or callFloorData.elevator)) then
				-- // No config located in the script? Use the elevator's config // --
				local elevator = callFloorData.elevator or elevator
				local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
				local soundConfig = require(elevator.Settings).Sound_Database.Others.Call_Button_Beep or require(elevator.Settings).Sound_Database.Others.Button_Beep
				addSound(buttonPart, 'Button_Click', soundConfig.Sound_Id, soundConfig.Volume, soundConfig.Pitch, false, 2, 50, true)
				setButton(button, newConfig, 'Lit_State', true)
			end
			--print(elevator, callFloorData.elevator)
			--print(callFloorData.elevator == elevator)
			--print(callFloorData.elevator and callFloorData.elevator:GetFullName(), elevator:GetFullName())
			if ((not elevator) or callFloorData.elevator) then return end
			if (not config) then
				-- // No config located in the script? Use the elevator's config // --
				local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
				local soundConfig = require(elevator.Settings).Sound_Database.Others.Call_Button_Beep or require(elevator.Settings).Sound_Database.Others.Button_Beep
				addSound(buttonPart, 'Button_Click', soundConfig.Sound_Id, soundConfig.Volume, soundConfig.Pitch, false, 2, 50, true)
				setButton(button, newConfig, 'Lit_State', true)
			end
			callFloorData.elevator = elevator
			--print("added call")
			elevator.Cortex_API:Fire('Add_Call', { ['call'] = callFloor, ['direction'] = callDirection, ['side'] = (buttonSide ~= '' and buttonSide ~= nil) and buttonSide or nil})
			if (callFloorData.arrivalConnection) then return end
			local isIdle = (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value) and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Queue_Direction.Value == string.sub(button.Name, 1, 1) or elevator.Legacy.Queue_Direction.Value == 'N')
			if (not isIdle) then
				callFloorData.arrivalConnection = elevator.Cortex_API.Event:Connect(function(protocol, params)
					if (protocol ~= 'onCallRespond') then return end
					--print(params)
					if (params.floor == callFloor and params.direction == string.sub(button.Name, 1, 1)) then
						for i, v in pairs(callFloorData.otherConnections) do
							callFloorData.otherConnections[i]:Disconnect()
							callFloorData.otherConnections[i] = nil
						end
						callFloorData.arrivalConnection:Disconnect()
						callFloorData.arrivalConnection = nil
						callFloorData.elevator = nil
						if (not config) then
							-- // No config located in the script? Use the elevator's config // --
							local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
							setButton(button, newConfig, 'Neautral_State', true)
						else
							setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
						end
					end
				end)
			end

			for _, v in pairs(elevator.Legacy:GetChildren()) do
				if v.Name == 'Independent_Service' or v.Name == 'Fire_Service' or v.Name == 'Stop' or v.Name == 'Inspection' or v.Name == 'Out_Of_Service' then
					table.insert(callFloorData.otherConnections, v:GetPropertyChangedSignal('Value'):Connect(function()
						if v.Value then
							for i, v in pairs(callFloorData.otherConnections) do
								callFloorData.otherConnections[i]:Disconnect()
								callFloorData.otherConnections[i] = nil
							end
							callFloorData.arrivalConnection:Disconnect()
							callFloorData.arrivalConnection = nil
							callFloorData.elevator = nil
							if (not config) then
								-- // No config located in the script? Use the elevator's config // --
								local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
								setButton(button, newConfig, 'Neautral_State', true)
							else
								setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
							end
						end
					end))
				end
			end
			--print("added call")
			--elevator.Cortex_API:Fire('Add_Call', { ['call'] = callFloor, ['direction'] = callDirection, ['side'] = (buttonSide ~= '' and buttonSide ~= nil) and buttonSide or nil})
		else
			local elevator = callFloorData.elevator
			if (not elevator) then
				local function getElevatorSettings(index)
					local elev = elevators:GetChildren()[index]
					if (((not elev) or (not elev:FindFirstChild('Settings'))) and elevators:GetChildren()[index+1]) then return getElevatorSettings(index+1) end
					return require(elev.Settings)
				end
				if config then
					setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
				else
					local newConfig = getElevatorSettings(1)
					if (not newConfig) then return end
					setButton(button, newConfig.Color_Database.Floor[buttonDirection], 'Neautral_State', false)
				end
				return
			end
			-- // Let's do an idle check, only reset the button and its values if this check passes // --
			local isIdle = (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value) and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Queue_Direction.Value == string.sub(button.Name, 1, 1) or elevator.Legacy.Queue_Direction.Value == 'N')
			if (isIdle) then
				for i, v in pairs(callFloorData.otherConnections) do
					callFloorData.otherConnections[i]:Disconnect()
					callFloorData.otherConnections[i] = nil
				end
				if (callFloorData.arrivalConnection) then
					callFloorData.arrivalConnection:Disconnect()
					callFloorData.arrivalConnection = nil
				end
				callFloorData.elevator = nil
				if (config) then
					setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
				else
					-- // No config located in the script? Use the elevator's config // --
					local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
					setButton(button, newConfig, 'Neautral_State', true)
				end
			end
		end
	end

	local buttonAPI,buttonRemote,allocatorAPI = this:FindFirstChild('Button_API'),this:FindFirstChild('Button_Remote'),this:FindFirstChild('Cortex_Allocator_API')
	if (not buttonAPI) then
		buttonAPI = Instance.new('BindableEvent')
		buttonAPI.Name = 'Button_API'
		buttonAPI.Parent = this
	end
	if (not buttonRemote) then
		buttonRemote = Instance.new('RemoteEvent')
		buttonRemote.Name = 'Button_Remote'
		buttonRemote.Parent = this
	end
	if (not allocatorAPI) then
		allocatorAPI = Instance.new('BindableFunction')
		allocatorAPI.Name = 'Cortex_Allocator_API'
		allocatorAPI.Parent = this
		function allocatorAPI.OnInvoke(params)
			local elevator = allocator.findElevator(params.elevators, params.floor, params.direction)
			handleButtonInput(nil, 'onButtonPressed', {button = params.callButton, elevator = elevator})
			task.delay(.35, function()
				handleButtonInput(nil, 'onButtonReleased', {button = params.callButton})
			end)
			return elevator
		end
	end

	buttonAPI.Event:Connect(function(protocol, params)
		handleButtonInput(nil, protocol, params)
	end)
	buttonRemote.OnServerEvent:Connect(handleButtonInput)

end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX62D3C8CF5ED84EE88E5272AF188EE6EA">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Allocator</string>
							<string name="ScriptGuid">{8D14DD3C-7715-4721-BA33-DE179474FAD2}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

local function absoluteDifference(a, b)
	return math.abs(a-b)
end

local function checkElevatorStatValue(elevator, name)
	if (not elevator) then return nil end
	if ((not elevator:FindFirstChild('Legacy'))) then return nil end
	if (elevator.Legacy:FindFirstChild(name)) then return elevator.Legacy:FindFirstChild(name).Value end
	return nil
end

local function isElevatorOutOfService(elevator)
	return (checkElevatorStatValue(elevator, 'Independent_Service')
		or checkElevatorStatValue(elevator, 'Fire_Service')
		or checkElevatorStatValue(elevator, 'Stop')
		or checkElevatorStatValue(elevator, 'Inspection')
		or checkElevatorStatValue(elevator, 'Out_Of_Service')
	)
end

function module.findElevator(elevators: {}, callFloor: number, callDirection: number)
	local CALL_DIRECTION = callDirection
	local availableElevators = {}
	for i,v in pairs(elevators) do
		if isElevatorOutOfService(v) then continue end
		local floor,destination,moveDirection,queueDirection = checkElevatorStatValue(v,'Floor'),checkElevatorStatValue(v,'Destination'),checkElevatorStatValue(v,'Move_Value'),checkElevatorStatValue(v,'Queue_Direction')
		if ((not floor) or (not destination) or (not moveDirection) or (not queueDirection)) then continue end
		table.insert(availableElevators, v)
	end
	--table.sort(availableElevators, function(a,b)
	--	return a.Name < b.Name
	--end)
	local sortedElevators = {}
	for _, elevator in availableElevators do
		if (((elevator.Legacy.Queue_Direction.Value == 'U' and callDirection == 1) or (elevator.Legacy.Queue_Direction.Value == 'D' and callDirection == -1) or elevator.Legacy.Queue_Direction.Value == 'N') and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value))
			or (elevator.Legacy.Move_Value.Value ~= -1 and elevator.Legacy.Queue_Direction.Value ~= 'D' and callDirection == 1 and elevator.Legacy.Raw_Floor.Value <= callFloor)
			or (elevator.Legacy.Move_Value.Value ~= 1 and elevator.Legacy.Queue_Direction.Value ~= 'U' and callDirection == -1 and elevator.Legacy.Raw_Floor.Value >= callFloor)
			or (elevator.Legacy.Queue_Direction.Value == 'N' and elevator.Legacy.Move_Value.Value == 0)
		then
			--print(elevator.Legacy.Move_Value.Value, elevator.Legacy.Queue_Direction.Value, callDirection, callFloor)
			--print(1, ((elevator.Legacy.Queue_Direction.Value == 'U' and callDirection == 1) or (elevator.Legacy.Queue_Direction.Value == 'D' and callDirection == -1) or elevator.Legacy.Queue_Direction.Value == 'N') and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value))
			--print(2, elevator.Legacy.Move_Value.Value == 1 and elevator.Legacy.Queue_Direction.Value == 'U' and callDirection == 1 and elevator.Legacy.Raw_Floor.Value <= callFloor)
			--print(3, elevator.Legacy.Move_Value.Value == -1 and elevator.Legacy.Queue_Direction.Value == 'D' and callDirection == -1 and elevator.Legacy.Raw_Floor.Value >= callFloor)
			--print(4, elevator.Legacy.Queue_Direction.Value == 'N' and elevator.Legacy.Move_Value.Value == 0)
			table.insert(sortedElevators, elevator)
		end
		
		--if (elevator.Legacy.Queue_Direction.Value == 'N'
		--	or ((elevator.Legacy.Queue_Direction.Value == 'U' and elevator.Legacy.Move_Value.Value ~= 1 and elevator.Legacy.Raw_Floor.Value <= callFloor and destinationCall > callFloor)
		--	or (elevator.Legacy.Queue_Direction.Value == 'D' and elevator.Legacy.Move_Value.Value ~= -1 and elevator.Legacy.Raw_Floor.Value >= callFloor --[[and destinationCall < callFloor]]))) then
		--	table.insert(sortedElevators, elevator)
		--end
	end

	if (#sortedElevators == 0) then
		--print("fallback")
		table.insert(sortedElevators, availableElevators[1])
	end

	table.sort(sortedElevators, function(a, b)
		if (absoluteDifference(a.Legacy.Raw_Floor.Value, callFloor) == absoluteDifference(b.Legacy.Raw_Floor.Value, callFloor)) then
			return a.Name < b.Name
		else
			return absoluteDifference(a.Legacy.Raw_Floor.Value, callFloor) < absoluteDifference(b.Legacy.Raw_Floor.Value, callFloor)
		end
	end)

	return sortedElevators[1]
	
	--local sortedElevators = {}
	--local nearestElevator
	--local minDistance = math.huge
	--for _, elevator in ipairs(availableElevators) do
	--	if isElevatorOutOfService(elevator) then continue end
	--	local statValues = elevator.Legacy
	--	local floor,direction,queueDirection = statValues.Floor.Value,statValues.Move_Value.Value,statValues.Queue_Direction.Value
	--	queueDirection = queueDirection == 'U' and 1 or queueDirection == 'D' and -1 or 0 --// Correct queue direction
	--	local distance = math.abs(floor-callFloor)
	--	if (distance < minDistance) then
	--		-- // If elevator is idle on call floor
	--		if ((floor == callFloor and direction == 0) and (queueDirection == callDirection or queueDirection == 0)) then
	--			nearestElevator = elevator
	--			minDistance = distance
	--			--// Check for elevators in direction & check for their queue direction
	--		elseif ((callDirection == 1 and floor <= callFloor and (direction == -1 or direction == 0) and (queueDirection == 1 or queueDirection == 0)) or (callDirection == -1 and floor >= callFloor and (direction == 1 or direction == 0) and ((queueDirection == -1 or queueDirection == 0)))) then
	--			nearestElevator = elevator
	--			minDistance = distance
	--			-- // Check for any elevator that is idle on any floor
	--		elseif (direction == 0 and (queueDirection == callDirection or queueDirection == 0)) then
	--			nearestElevator = elevator
	--			minDistance = distance
	--		end
	--	end
	--end
	--if (not nearestElevator) then
	--	return availableElevators[1]
	--end
	
	--return nearestElevator
end

return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX38B57B7D3B22487FA135E5C55FE17C3C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Legacy</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="StringValue" referent="RBXEA80F951D661430983FBB0C2A1A4FBB3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Queue</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">[]</string>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX58592054A2BE48EC96B9232E8DB9474F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXF48779B1C3D8449E82CBF99B7E147261">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Raw_Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXE41A01EE9CB7480F8CBBD560791BB8C9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Move_Value</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBXFF6882F8D6F64901ADD0116405261183">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Arrow_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX4F9E48EC4D9E4C6CBD247DC1FDA22ECE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Queue_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX673BF3A753E34CDFA3CA933611A8B0C0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Destination</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX8062ACF557D74F9BB2A8C1422C5DA05C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Remote_Call</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX432EAE714EB84DA6BF7F3F2FEF175613">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Fire_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXF992957E39944D7E945CFA5FCB3CE70C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Phase_1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXF87065898A7140F2861EAC038045784E">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Phase_2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXD7071D85C4B94B898C0FE5719992107A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Inspection</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX1D924BF21CD845DB869DE4789A223DD6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Out_Of_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXB0088C9E6E2742DBA33124EEF9454476">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Independent_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXF0219A8EAD9F475CB481A9FC9C801F40">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Current_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXD77940D7B1B3444B82E819E17B1CDB25">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Velocity</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX2854EC020C8342D6948AE9724709F688">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Arrive_Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">-100000</double>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXBE8DD1FAD69A4207873B143B6838D024">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Leveling</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX6EADACAC0F0F4F5FB22267A2A1966DF9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Nudge</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXFAF72A0F14184B2C8854EEFC70B8133D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Stop</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBXED01728DB1C649759FC9F391F53ACD21">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Move_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX279639E9B9084399A5AD8585750017C5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Pre_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX4F50F40122FF453498A96E5D84AC7366">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_State</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">Closed</string>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXC652039DBCE240A293E5211FF003C6D9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Hold</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX6B1591C4D6CD45C5AB31AF7E60E1FCCC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Nudging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX668B962C2BDD466689499B0628A47C2F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX5AB1584419284748919DEADC8C141B4C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_State</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">Closed</string>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXE83E9EE848804AA7A282826602489C4D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Hold</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXFC0F30D3F5EF4B4D925578C5D5DF8570">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Nudging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX03E8A66FAA1846B59BE86FEFB4F5EB5D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXCBFB621665BB4A0AB07E35319C2ED34E">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core</string>
						<string name="ScriptGuid">{DCD1F290-5697-41F6-8A12-786753448F29}</string>
						<ProtectedString name="Source"><![CDATA[--[[

	CORTEX CLASSIC V10 // OCTOBER 2023 REWRITE
	START DATE: 10/09/2023
	
	WRITTEN BY: aaxtatious (540781721) & ImFirstPlace (79641334)
	
	Â© 2024 Cortex Elevator Company.

]]--

local module = {
	['doorData'] = {},
	['statValues'] = {
		['Floor'] = 1,
		['Raw_Floor'] = 1,
		['Arrive_Floor'] = 1,
		['Move_Value'] = 0,
		['Move_Direction'] = 'N',
		['Direction'] = 'N',
		['Leveling'] = false,
		['Arriving'] = false,
		['Destination'] = 1,
		['Queue_Direction'] = 'N',
		['Arrow_Direction'] = 'N',
		['Stop'] = false,
		['Inspection'] = false,
		['Independent_Service'] = false,
		['Out_Of_Service'] = false,
		['Fire_Service'] = false,
		['Fire_Recall'] = false,
		['Phase_1'] = false,
		['Phase_2'] = false,
		['Parking'] = false,
		['Current_Speed'] = 0,
		['Velocity'] = 0,
		['Nudge'] = false,
	},
	['coreFunctions'] = {},
	['statFolderValues'] = {},
	['queue'] = {},
	['pluginModules'] = {},
	['sounds'] = {},
	['lockedCalls'] = {
		['car'] = {},
		['hall'] = {
			['up'] = {},
			['down'] = {}
		}
	},
	['safetyEnaged'] = true,
	['dropKeyCheckValues'] = {},
	['dropKeyHandlers'] = {}
}

local dependencies = script:WaitForChild('Dependencies')
local modules = script:WaitForChild('Modules')

local elevatorID = math.random(0, 1e5)

local heartbeat = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

local function checkIndependentService()
	return (not module.statValues.Fire_Service and module.statValues.Independent_Service)
end

local function checkFireServicePhase2()
	return (not module.statValues.Fire_Recall and module.statValues.Fire_Service and module.statValues.Phase_2)
end

local function weldModel(model, weldPart, ignoreList, append)
	if (typeof(model) ~= 'Instance') then return end
	local welds = {}
	for _,v in pairs(model:GetDescendants()) do
		if (not v:IsA('BasePart')) then continue end
		if (not weldPart) then weldPart = v end
		if (weldPart ~= v and (typeof(ignoreList) ~= 'table' or (not table.find(ignoreList, v)))) then
			local weld = Instance.new('Weld')
			weld.Name = (v.Name) .. "_To_" .. (weldPart.Name) .. "_Weld"
			weld.Part0, weld.Part1 = v, weldPart
			weld.C0, weld.C1 = CFrame.new(), weldPart.CFrame:ToObjectSpace(v.CFrame)
			weld.Parent = if (typeof(append) == 'Instance') then append else weldPart
			table.insert(welds, weld)
			v.Anchored = false
		end
	end
	return welds
end

local function weldParts(append, part0, part1, joinInPlace, animatable)
	if (typeof(append) ~= 'Instance') then append = part0 end
	local weld = Instance.new('Weld')
	weld.Name = (part0.Name) .. "_To_" .. (part1.Name) .. "_Weld"
	weld.Part0, weld.Part1 = part0, part1
	weld.C0, weld.C1 = CFrame.new(), part1.CFrame:ToObjectSpace(part0.CFrame)
	weld.Parent = if (typeof(append) == 'Instance') then append else part1
	return weld
end

module.coreFunctions.weldModel = weldModel
module.coreFunctions.weldParts = weldParts

local function createInstance(append, name, type, replaceByName, properties)
	if (typeof(append) ~= 'Instance') then return end
	if (typeof(name) ~= 'string') then return end
	local result = replaceByName == true and append:FindFirstChild(name)
	if (not result) then
		result = Instance.new(type)
		result.Name = name
		for property, value in if (typeof(properties) == 'table') then properties else {} do
			pcall(function()
				--if ((not result[property]) or typeof(result[property] ~= typeof(value))) then return end
				result[property] = value
			end)
		end
	end

	result.Parent = append
	return result
end

local function addSound(append, name, config, looped, minDistance, maxDistance)
	if (typeof(append) ~= 'Instance' or typeof(name) ~= 'string') then return end
	local newSound = append:FindFirstChild(name)
	if (not newSound) then
		newSound = createInstance(append, name, 'Sound', false, {
			SoundId = if (typeof(config.Sound_Id) == 'number' and config.Sound_Id ~= 0) then "rbxassetid://" .. (config.Sound_Id) else '',
			Volume = config.Volume,
			PlaybackSpeed = config.Pitch,
			Looped = if (typeof(config.Looped) == 'boolean') then config.Looped elseif (typeof(looped) == 'boolean') then looped else false,
			RollOffMinDistance = minDistance,
			RollOffMaxDistance = maxDistance
		})
	end
	return newSound
end

local function addPlayingSound(append, sound, pitchOffset)
	if (typeof(sound) ~= 'Instance' or (not sound:IsA('Sound'))) then return end
	local newSound = sound:Clone()
	newSound.Playing = true
	newSound.PlaybackSpeed = typeof(pitchOffset) == 'number' and newSound.PlaybackSpeed+pitchOffset or newSound.PlaybackSpeed
	newSound.Parent = append
	game:GetService('Debris'):AddItem(newSound, newSound.TimeLength + 0.1)
end

local function recursiveTable(t, callback)
	if (typeof(t) ~= 'table') then return end
	for i, v in pairs(t) do
		if (typeof(callback) == 'function') then callback(i, v) end
		if (typeof(v) == 'table') then recursiveTable(v, callback) end
	end
end

module.coreFunctions.recursiveTable = recursiveTable
module.coreFunctions.addSound = addSound
module.coreFunctions.addPlayingSound = addPlayingSound

module.coreFunctions.createInstance = createInstance

module.registeredFloors = {}

local function findRegisteredFloor(floor)
	floor = tostring(floor)
	return module.registeredFloors[floor]
end
module.coreFunctions.findRegisteredFloor = findRegisteredFloor

local coreFunctions = require(modules.Core_Functions)
local signal = require(modules.Signal)

local httpService = game:GetService('HttpService')
local runService = game:GetService('RunService')
local tweenService = game:GetService('TweenService')
local collectionService = game:GetService('CollectionService')
local players = game:GetService('Players')

function module.Start(source, config, buildData, moduleDependencies)

	local _VERSION = "Cortex Classic v" .. (buildData.VERSION)

	assert(typeof(source) == 'Instance', (_VERSION) .. " :: Source not valid for initiation")

	local ran, config = pcall(require, config)
	assert(ran, (_VERSION) .. " :: " .. (source.Parent:GetFullName()) .. " :: Config not valid for initiation: " .. (config))

	local elevator = source.Parent
	local configFile = require(dependencies.ConfigFile)(config, script)

	local newConfigFileClone = script.Dependencies.LiveSettings:Clone()
	local newConfigFile = require(newConfigFileClone)
	newConfigFile.Settings = configFile
	newConfigFileClone.Parent = elevator
	configFile = newConfigFile.Settings

	--assert(ran == true, (_VERSION) .. " :: " .. (source.Parent:GetFullName()) .. " :: ConfigFile not found | " .. (configFile))

	if (configFile.Sound_Database.Voice_Config.Voice_Clips == 'STOCK') then
		configFile.Sound_Database.Voice_Config.Voice_Clips = require(script.Voice_Module.DefaultVoiceModule)(require(script.Voice_Module.STOCK_VoiceModule), source)
	elseif typeof(configFile.Sound_Database.Voice_Config.Voice_Clips) == 'table' then
		configFile.Sound_Database.Voice_Config.Voice_Clips = require(script.Voice_Module.DefaultVoiceModule)(configFile.Sound_Database.Voice_Config.Voice_Clips, source)
	end



	local voiceConfig = configFile.Sound_Database.Voice_Config.Voice_Clips
	local voiceModule = require(script.Voice_Module).new(voiceConfig)

	local car = elevator:FindFirstChild('Car')
	local floors = elevator:FindFirstChild('Floors')
	local platform = car:FindFirstChild('Platform')
	local level = car:FindFirstChild('Level') or platform

	local counterweight = elevator:FindFirstChild('Counterweight')

	local fireServiceRecallFloor = -99999

	local elevatorPosition = platform.CFrame

	local elevatorMovementThread
	local elevatorRelevelThread

	--newConfigFile.Doors = configFile.Doors
	--liveModule.Parent = source.Parent

	dependencies.ConfigFile.Parent = elevator

	_G.Elevator_Output_Storage_GLOBAL[elevator.Name] = {}

	local pluginModuleData = {}
	for i, v in pairs(modules:GetChildren()) do
		task.spawn(function()
			local ran, res = pcall(require, v)
			if (not ran) then return end
			if (not res.isPluginModule) then return end
			res.config = configFile
			res.elevator = elevator
			pluginModuleData[v.Name] = { content=res, instance=v }
		end)
	end

	for i, v in pairs(source:FindFirstChild('Plugins_INTERNAL') and source.Plugins_INTERNAL:GetChildren() or {}) do
		local ran, res = pcall(require, v)
		if (not ran) then return print("INTERNAL PLUGIN MODULE '" .. (v.Name) .. "' SETUP FAILED :: " .. (res)) end
		local ran, res2 = pcall(function()
			return task.spawn(function() return res:INITIATE_PLUGIN_INTERNAL(script, source) end)
		end)
		if (not ran) then print("INTERNAL PLUGIN MODULE '" .. (v.Name) .. "' INITIATION FAILED :: " .. (res))
		else
			module.pluginModules[v.Name] = { content = res, module = v }
		end
	end

	-- // Check for any floors being added/removed // --
	floors.ChildAdded:Connect(function(child)
		task.wait()
		local floorName = tonumber(string.split(child.Name, 'Floor_')[2])
		if (not floorName) then return end
		if (findRegisteredFloor(floorName)) then return end
		local level = child:FindFirstChild('Level')
		if (not level) then return end
		module.registeredFloors[floorName] = nil
	end)
	floors.ChildRemoved:Connect(function(child)
		task.wait()
		local floorName = tonumber(string.split(child.Name, 'Floor_')[2])
		if (not floorName) then return end
		if (not findRegisteredFloor(floorName)) then return end
		local level = child:FindFirstChild('Level')
		if (not level) then return end
		module.registeredFloors[floorName] = { floorNumber = floorName, floorInstance = child, level = level }
	end)

	elevator:SetAttribute('elevatorID', elevatorID)
	collectionService:AddTag(elevator, 'CortexElevatorInstance')

	-- // Internal variables // --
	local doorEngine = pluginModuleData.Door_Engine.content
	local moveLock = false
	local preDooring = false
	local inspectionEnabled = false
	local inspectionLocked = false
	local releveling = false

	local inspectionMoving = false
	local inspectionStopping = false

	local inspectionMoveThread
	local inspectionStopThread

	local statValuesFolder = createInstance(elevator, 'Legacy', 'Folder', true)
	local valueTypes = {
		['boolean'] = 'Bool',
		['number'] = 'Number',
		['CFrame'] = 'CFrame',
		['string'] = 'String',
		['Vector3'] = 'Vector3',
	}

	local remoteCallValue = createInstance(statValuesFolder, 'Remote_Call', 'NumberValue', true)

	local api = createInstance(elevator, 'Cortex_API', 'BindableEvent', true)
	local remote = createInstance(elevator, 'Cortex_Remote', 'RemoteEvent', true)
	local elevatorSignal = createInstance(elevator, 'Cortex_Signal', 'BindableFunction', true)

	local carWeldsFolder = createInstance(car, 'Car_Welds', 'Folder', true)

	local playerWeldsFolder = createInstance(platform, 'Player_Welds', 'Folder', true)

	for i, v in pairs(floors:GetChildren()) do
		local floorNumber, level = tonumber(string.split(v.Name, 'Floor_')[2]), v:FindFirstChild('Level')
		if ((not floorNumber) or (not level)) then continue end
		module.registeredFloors[tostring(floorNumber)] = { floorNumber = floorNumber, floorInstance = v, level = level }
	end

	local startLoadTime = os.clock()

	-- // Cab region part // --
	local size = platform.Size+Vector3.new(0, 15, 0)
	local cabRegion = createInstance(car, 'Cab_Region', 'Part', true, {
		Anchored = false,
		CanCollide = false,
		CanTouch = false,
		CanQuery = false,
		Transparency = 1,
		CFrame = CFrame.new(platform.Position.X, platform.Position.Y+size.Y/2, platform.Position.Z)*CFrame.Angles(platform.CFrame:ToEulerAnglesXYZ()),
		Size = size,
	})

	cabRegion.Anchored = false
	cabRegion.CanCollide = false
	cabRegion.CanQuery = false

	for i,v in pairs(floors:GetChildren()) do
		if v:FindFirstChild('Level') then
			createInstance(v.Level, 'Drop_Key_Sound', 'Sound', true, {
				SoundId = 'rbxassetid://4496280365',
				Volume = 1,
				RollOffMaxDistance = 200,
				RollOffMinDistance = 5,
				Pitch = 2.55/config.Doors.Door_Open_Speed
			})
		end
	end

	local dropKeySound = createInstance(level, 'Drop_Key_Sound', 'Sound', true, {
		SoundId = 'rbxassetid://4496280365',
		Volume = 1,
		RollOffMaxDistance = 200,
		RollOffMinDistance = 5,
		Pitch = 2.55/config.Doors.Door_Open_Speed
	})

	weldParts(cabRegion, cabRegion, platform, true, false)
	local soundGroup = cabRegion:FindFirstChildOfClass('SoundGroup') or Instance.new('SoundGroup')
	soundGroup.Parent = cabRegion
	local equalizer = soundGroup:FindFirstChildOfClass('EqualizerSoundEffect') or Instance.new('EqualizerSoundEffect')
	equalizer.Name = 'Muffler'
	equalizer.Parent = soundGroup
	equalizer.HighGain = 0
	equalizer.LowGain = 0
	equalizer.MidGain = 0

	-- // Get bottom & top floor // --
	local bottomFloor, topFloor
	local bottomPoint, topPoint = math.huge, -math.huge
	for i, v in pairs(module.registeredFloors) do
		if (v.level.Position.Y > topPoint) then
			topPoint = v.level.Position.Y
			topFloor = v
		end
		if (v.level.Position.Y < bottomPoint) then
			bottomPoint = v.level.Position.Y
			bottomFloor = v
		end
	end

	local doorsIgnoreList = {}
	for i, v in pairs(car:GetChildren()) do
		local side = string.split(v.Name, 'Doors')[2] and string.split(v.Name, 'Doors')[1]
		if (not side) then continue end
		side = string.split(side, '_')[1]
		if (not side) then continue end
		if (side == '') then side = 'Front' end
		for i, v in pairs(v:GetDescendants()) do
			if (not v:IsA('BasePart')) then continue end
			table.insert(doorsIgnoreList, v)
		end
		doorEngine.setUp(v)
		local data = doorEngine.new(v)
		module.doorData[side] = data
	end

	for i, f in pairs(module.registeredFloors) do
		for i, v in pairs(f.floorInstance:GetChildren()) do
			local side = string.split(v.Name, 'Doors')[2] and string.split(v.Name, 'Doors')[1]
			if (not side) then continue end
			doorEngine.setUp(v)
		end
	end

	recursiveTable(configFile, function(i, v)
		if (typeof(v) == 'table' and v.Voice_ID) then v.Sound_Id = v.Voice_ID i = 'Voice_Audio' end
		if (typeof(v) == 'table' and v.Sound_Id and i ~= 'Door_Obstruction_Signal') then
			local newSound = addSound(cabRegion, i, v, i == 'Alarm' or i == 'Nudge_Buzzer' or (string.match(i, 'Motor_Run') ~= nil) or i == 'Traveling_Sound', 3, 25)
			newSound:SetAttribute('originalPitch', newSound.PlaybackSpeed)
			module.sounds[i] = newSound
		end
	end)

	module.sounds.Voice_Audio = addSound(cabRegion, 'Voice_Audio', {['Sound_Id'] = voiceConfig.SoundId, ['Volume'] = voiceConfig.Volume, ['Pitch'] = voiceConfig.Pitch}, false, 3, 25)

	for side, data in pairs(module.doorData) do
		local valueName = side == '' and '' or side.."_".."Door_State"
		module.statValues[valueName] = data.state
		module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
	end

	for i, v in pairs(module.statValues) do
		if (i == 'Queue_Direction' or i == 'Move_Direction' or i == 'Arrow_Direction' or i == 'Direction') then
			module.statValues[i] = 0
		end
		local val = createInstance(statValuesFolder, i, (valueTypes[typeof(v)]) .. "Value", true, { Value = v })
		module.statFolderValues[i] = { value = val, update = function()
			if (i == 'Current_Speed') then
				val.Value = math.rad(module.statValues[i])
			elseif (i == 'Queue_Direction' or i == 'Move_Direction' or i == 'Arrow_Direction' or i == 'Direction') then
				val.Value = module.statValues[i] == 1 and 'U' or module.statValues[i] == -1 and 'D' or 'N'
			else
				val.Value = module.statValues[i]
			end
		end}
	end
	local queueValue = createInstance(statValuesFolder, 'Queue', 'StringValue', true, {Value = httpService:JSONEncode(module.queue)})

	remoteCallValue:GetPropertyChangedSignal('Value'):Connect(function()
		if (not findRegisteredFloor(remoteCallValue.Value)) then return end
		task.spawn(addCall, {call = remoteCallValue.Value})
		remoteCallValue.Value = -math.huge
	end)

	local voiceSequenceQueue = {}
	local voiceSequenceIndex = 0

	local function playVoiceSequenceProtocolWithQueue(clipSequence, pauseThread, playCondition)
		if (not configFile.Sound_Database.Voice_Config.Enabled or not playCondition) then return end
		task.spawn(function()
			local length = #voiceSequenceQueue
			if (not table.find(voiceSequenceQueue, clipSequence)) then table.insert(voiceSequenceQueue, clipSequence) end
			if (length <= 0) then
				local function run()
					while (#voiceSequenceQueue > 0) do
						voiceSequenceIndex += 1
						local sequence = voiceSequenceQueue[voiceSequenceIndex]
						for index,item in pairs(sequence) do
							voiceModule:PlayClip(module.sounds.Voice_Audio, voiceConfig.Voice_Clips[item[1]], true)
							task.wait(item.Delay)
						end
						local tindex = table.find(voiceSequenceQueue, sequence)
						if (tindex) then table.remove(voiceSequenceQueue, tindex) voiceSequenceIndex -= 1 end
					end
					voiceSequenceIndex = 0
				end
				if (pauseThread) then
					run()
				else
					task.spawn(run)
				end
			end
		end)
	end

	function resetButtons(floor)
		for i, v in pairs(car:GetChildren()) do
			if (v.Name == 'Buttons') then
				for i, button in pairs(v:GetChildren()) do
					local buttonFloor = tonumber(string.split(button.Name, '_')[2]) or tonumber(string.split(button.Name, 'Floor')[2])
					if (buttonFloor and buttonFloor == floor) then
						setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
					end
				end
			end
		end
		local registeredFloor = findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		local direction = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down' or 'Neutral'
		for i, v in pairs(registeredFloor.floorInstance:GetChildren()) do
			if (v.Name == 'Call_Buttons') then
				for i, button in pairs(v:GetChildren()) do
					if (string.sub(button.Name, 1, 1) == (module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 0)) then
						setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
						updateButton(button, configFile.Color_Database.Floor[direction], 'Neautral_State')
					end
				end
			end
		end
	end

	function removeAllCalls()
		for i, floor in pairs(module.registeredFloors) do
			removeCall(floor.floorNumber)
			pcall(function()
				resetLanterns(floor.floorNumber, 'all')
				resetButtons(floor.floorNumber)
			end)
		end
	end

	local function updateStatValues()
		module.statValues.Arrow_Direction = module.statValues.Queue_Direction
		for i, v in pairs(module.statFolderValues) do
			v.update()
		end
	end

	local function updateFloor()
		local nearFloor, nearRawFloor, dist = nil, nil, math.huge
		for i, floor in pairs(module.registeredFloors) do
			local distance = math.abs(floor.level.Position.Y-level.Position.Y)
			if (distance < dist) then
				dist = distance
				local min = (module.statValues.Move_Value == 1 or module.statValues.Move_Value == 0) and module.statValues.Raw_Floor or module.statValues.Destination
				local max = (module.statValues.Move_Value == 1 or module.statValues.Move_Value == 0) and module.statValues.Destination or module.statValues.Raw_Floor
				nearFloor = (configFile.Movement.Accelerated_Floor_Config.Enabled and not module.statValues.Inspection) and math.clamp(floor.floorNumber+(configFile.Movement.Accelerated_Floor_Config.Offset*module.statValues.Move_Value), min, max) or floor.floorNumber
				nearRawFloor = floor.floorNumber
			end
		end

		module.statValues.Raw_Floor = nearRawFloor

		if (nearFloor ~= module.statValues.Floor) then
			module.statValues.Floor = nearFloor
			if (configFile.Sound_Database.Others.Enable_Floor_Pass_Chime) then
				task.delay(configFile.Sound_Database.Others.Floor_Pass_Chime_Delay, function()
					module.sounds.Floor_Pass_Chime:Play()
				end)
			end
			task.spawn(updateStatValues)
		end
	end
	updateFloor()

	function findAncestor(model, name)
		if (not model or typeof(model) ~= 'Instance') then return end
		local result = model:FindFirstChild(name)
		if (result) then
			return result
		else
			return findAncestor(model.Parent, name)
		end
	end

	module.coreFunctions.updateStatValues = updateStatValues

	weldModel(car, platform, doorsIgnoreList, carWeldsFolder)

	local cwStart,cwOffset
	if (counterweight and counterweight:FindFirstChild('Main')) then
		for i,v in pairs(counterweight:GetDescendants()) do
			if (string.match(v.ClassName, 'Weld') or v:IsA('Sound') or (string.match(v.ClassName, 'Script') and v.Parent == counterweight)) then
				v:Destroy()
			end
		end
		weldModel(counterweight, counterweight.Main, {})
		local travelingSound = addSound(counterweight.Main, 'Traveling_Sound', {Sound_Id=6003695467,Volume=0,Pitch=1.15}, true, false, 50, .2)
		local equalizer: EqualizerSoundEffect = travelingSound:FindFirstChildOfClass('EqualizerSoundEffect') or Instance.new('EqualizerSoundEffect')
		equalizer.HighGain = -8
		equalizer.LowGain = 7
		equalizer.MidGain = -2
		equalizer.Parent = travelingSound
		travelingSound:Play()
		counterweight.Main.Anchored = true

		local cwPos = counterweight.Main.CFrame.Y+(topFloor.level.Position.Y-level.Position.Y)
		local oriX,oriY,oriZ = counterweight.Main.CFrame:ToOrientation()
		--counterweight.Main.CFrame = CFrame.new(counterweight.Main.CFrame.X, cwPos, counterweight.Main.CFrame.Z)*CFrame.Angles(oriX, oriY, oriZ)
		cwStart = counterweight.Main.CFrame
		cwOffset = counterweight.Main.Position
	end
	local elevatorHeight = math.abs(topFloor.level.Position.Y-bottomFloor.level.Position.Y)

	local endLoadTime = os.clock()
	print((_VERSION) .. " :: " .. (elevator:GetFullName()) .. " :: Initiated in build " .. (buildData.BUILD) .. ", load time: " .. (math.round((endLoadTime-startLoadTime)*1000)/1000) .. "s")

	local prevIndependentServiceValue = module.statValues.Independent_Service
	local function setIndependentService(bool)
		module.statValues.Independent_Service = bool
		--outputElevMessage("Elevator has been placed " .. (bool and 'into' or 'out of') .. " independent service", 'warning')
		if (prevIndependentServiceValue ~= module.statValues.Independent_Service) then
			prevIndependentServiceValue = module.statValues.Independent_Service
			removeAllCalls()
			task.spawn(updateStatValues)
			if (bool) then
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Independent_Service_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Independent_Service_Announcement.Enabled)
				--If the elevator is already on the recall floor, open the doors (if closed or closing)
				for i, doorData in pairs(module.doorData) do
					if (doorData.state == 'Closed' or doorData.state == 'Closing' or doorData.state == 'Stopped') then
						task.spawn(runDoorOpen, module.statValues.Raw_Floor, doorData.side, true)
						if doorData.nudging and not module.statValues.Fire_Recall then
							module.sounds.Nudge_Buzzer.Playing = false
						end
					end
				end
			end
		end
	end

	-- // Safety core check // --
	function isElevatorSafe()
		if (module.statValues.Out_Of_Service or module.statValues.Stop or module.statValues.Inspection or (not checkDropKeyState())) then return false end
		return true
	end

	-- // Door handling // --
	local function checkAllNudge() -- // false - At least one set of doors are nudging, do not return true. true - No doors are nudging, all clear!
		for i, v in pairs(module.doorData) do
			if (v.nudging) then return false end
		end
		return true
	end

	function getFloorDistance(floor: number, absolute: boolean?)
		absolute = if (absolute == nil) then true else absolute
		if (not findRegisteredFloor(floor)) then return 0 end
		local dist = level.Position.Y-findRegisteredFloor(floor).floorInstance.Level.Position.Y
		return absolute and math.abs(dist) or dist
	end

	local sensorParams = OverlapParams.new()
	sensorParams.FilterType = Enum.RaycastFilterType.Whitelist
	function runDoorOpen(floor, side, doorTimer, bypassNudge)
		local registeredFloor = findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		local function runDoor(data)
			if (not data:IsValid(floor)) then return end
			--if bypassNudge then
			--	data.nudging = false
			--end
			if ((data.nudging and (not bypassNudge)) or (data.state ~= 'Closed' and data.state ~= 'Closing' and data.state ~= 'Stopped')) then return end
			playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Open_Announcement.Sequence, false, voiceConfig.Settings.Door_Announcements.Open_Announcement.Enabled)
			data.obstructionSignal.Playing = false
			local isObstructed = false
			local startingState = data.state
			api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
			api:Fire('onDoorOpening', { ['side'] = data.side, ['state'] = data.state })
			api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = 'Opening' })

			data.Opened:Once(function()
				data.doorTimestamp = os.clock()
				if (startingState == 'Closed') then
					data.nudgeTimestamp = os.clock()
					task.spawn(runChime, module.statValues.Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.After_Open)
					task.spawn(doLanterns, module.statValues.Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_After_Door_Open)

					if module.statValues.Queue_Direction ~= 0 then
						local dir = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down'
						local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
						if clip then
							playVoiceSequenceProtocolWithQueue(clip.Sequence, false, clip.Enabled)
						end
					end
				end

				api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = data.state })
				api:Fire('onDoorOpened', { ['side'] = data.side, ['state'] = data.state, ['floor'] = module.statValues.Raw_Floor })
				api:Fire('onDoorOpen', { ['side'] = data.side, ['state'] = data.state, ['floor'] = module.statValues.Raw_Floor }) -- Depricated API

				if (data.nudging) then return task.spawn(runDoorClose, module.statValues.Raw_Floor, side) end

				while ((os.clock()-data.doorTimestamp)/(configFile.Doors.Door_Timers[doorTimer] or configFile.Doors.Door_Timers.Open_On_Stop) < 1 and data.state == 'Open') do
					sensorParams.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
					local obstructed = #workspace:GetPartBoundsInBox(data.doorSensorPart.CFrame, data.doorSensorPart.Size, sensorParams) > 0
					if (obstructed ~= isObstructed) then
						isObstructed = obstructed
						data.obstructionSignal.Playing = not module.statValues.Fire_Service and obstructed
						api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
					end
					if (data.buttonHold or obstructed or checkIndependentService() or module.statValues.Fire_Service) then
						data.doorTimestamp = os.clock()
						if (checkIndependentService() or module.statValues.Fire_Service) then
							data.nudgeTimestamp = os.clock()
						end
					end
					if ((os.clock()-data.nudgeTimestamp)/configFile.Doors.Nudge_Timer > 1 and (not data.nudging) and (not checkIndependentService())) then
						module.statValues.Nudge = true
						data.nudging = true
						module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
						module.sounds.Nudge_Buzzer.Playing = true
						task.spawn(updateStatValues)
						task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
					end
					heartbeat:Wait()
				end
				if (data.state ~= 'Open') then return end
				task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
			end)
			data:Open(floor)
		end
		if ((moveLock and (not preDooring)) or (not isElevatorSafe()) or getFloorDistance(module.statValues.rawFloor) > .35) then return end
		if (string.upper(side) == 'ALL') then
			for _, v in pairs(module.doorData) do
				task.spawn(runDoor, v)
			end
		else
			local data = module.doorData[side]
			if (not data) then return end
			task.spawn(runDoor, data)
		end
	end

	function runDoorClose(floor, side, nudge)
		local function runDoor(data)
			if (not data:IsValid(floor)) then return end
			if (data.state ~= 'Open' and data.state ~= 'Stopped' and not module.statValues.Fire_Recall and (not (data.state == 'Opening' and (checkIndependentService() or checkFireServicePhase2())))) then return end
			if nudge then
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Nudge_Announcement.Sequence, false, voiceConfig.Settings.Door_Announcements.Nudge_Announcement.Enabled)
			else
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Close_Announcement.Sequence, false, voiceConfig.Settings.Door_Announcements.Close_Announcement.Enabled)
			end

			local startingState = data.state
			if nudge and data.state ~= 'Closed' then
				module.statValues.Nudge = true
				data.nudging = true
				module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
				module.sounds.Nudge_Buzzer.Playing = true
				task.spawn(updateStatValues)
			end
			local runTask
			data.obstructionSignal.Playing = false
			data.buttonHold = false
			local isObstructed = false
			local startingState = data.state

			api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
			api:Fire('onDoorClosing', { ['side'] = data.side, ['nudge'] = nudge, ['state'] = data.state })
			api:Fire('onDoorClose', { ['side'] = data.side, ['nudge'] = nudge, ['floor'] = module.statValues.Raw_Floor })
			api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = 'Closing' })

			task.spawn(runChime, module.statValues.Arrive_Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Door_Close, false)
			task.spawn(doLanterns, module.statValues.Arrive_Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Door_Close, true)
			data.Closed:Once(function()
				api:Fire('onDoorClosed', { ['side'] = data.side, ['state'] = data.state })
				api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = data.state })
				data.nudging = false
				if ((not checkDoorStates('Closed')) or moveLock) then return end
				pcall(task.cancel, runTask)
				module.statValues.Nudge = (not checkAllNudge())
				if (not module.statValues.Fire_Recall) then
					module.sounds.Nudge_Buzzer.Playing = module.statValues.Nudge
				end
				module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
				data.obstructionSignal.Playing = false
				task.spawn(updateStatValues)
				local nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))

				-- // No call in current direction? Check in the opposite direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, -module.statValues.Queue_Direction)) end

				-- // Still no call? Check in any direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end

				-- // Yet still no call? Let's look for any calls on the current floor // --
				local thisCall = select(2, findCallInQueue(module.statValues.Raw_Floor, -module.statValues.Queue_Direction))

				if ((not select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))) and thisCall) then
					module.statValues.Queue_Direction = 0
					task.spawn(updateStatValues)
					local hasCompleted = coreFunctions.conditionalWait(1, function() return {not moveLock} end)
					if (not hasCompleted) then return end
					module.statValues.Queue_Direction = thisCall.directions[1]
					api:Fire('onCallRespond', { floor = module.statValues.Raw_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })

					local lanternSides = {}
					for _, side in thisCall and thisCall.sides or {} do
						if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
							table.insert(lanternSides, string.split(side, '_')[2])
						end
					end
					task.spawn(updateStatValues)
					task.spawn(runChime, module.statValues.Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.Exterior_Call_Only)
					task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Exterior_Call, true)


					if (getTotalDirectionSides(thisCall.sides, thisCall and thisCall.directions[1] or 0) == 0) then
						task.spawn(runDoorOpen, floor, 'all', thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
					else
						local callSidesCopy = table.clone(thisCall.sides)
						for _, side in pairs(callSidesCopy) do
							local dir = #thisCall.directions > 0 and thisCall.directions[1] or 0
							if dir then
								if tonumber(string.split(side, '_')[1]) == dir or tonumber(string.split(side, '_')[1]) == 0 then
									table.remove(module.queue[select(1, findCallInQueue(thisCall.call))].sides, table.find(module.queue[select(1, findCallInQueue(thisCall.call))].sides, side))
									task.spawn(runDoorOpen, floor, string.split(side, '_')[2], thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
								end
							end
						end
					end

					removeCall(module.statValues.Raw_Floor, module.statValues.Queue_Direction)
					return
				end
				if (not nextQueue) then
					module.statValues.Queue_Direction = 0
					parkTimer()
					task.spawn(updateStatValues)
					return
				end
				task.spawn(goToFloor, nextQueue.call)
			end)
			data.LanternsReset:Once(function(types)
				task.spawn(resetLanterns, module.statValues.Raw_Floor, data.side, module.statValues.Queue_Direction, types)
				local nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))
				-- // No call in current direction? Check in the opposite direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, -module.statValues.Queue_Direction)) end
				-- // Still no call? Check in any direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end
				if (not nextQueue and checkDoorStates('Closed')) then
					--module.statValues.Queue_Direction = 0
					task.spawn(updateStatValues)
					return
				end
			end)
			data:Close(floor)
			runTask = task.spawn(function()
				while (data.state == 'Closing') do
					sensorParams.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
					local obstructed = #workspace:GetPartBoundsInBox(data.doorSensorPart.CFrame, data.doorSensorPart.Size, sensorParams) > 0
					if (obstructed ~= isObstructed) then
						isObstructed = obstructed
						api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
						data.obstructionSignal.Playing = obstructed
						task.spawn(runDoorOpen, module.statValues.Raw_Floor, data.side, 'Open_No_Call')
					end
					if ((os.clock()-data.nudgeTimestamp)/configFile.Doors.Nudge_Timer > 1 and (not data.nudging) and data.state == 'Closing' and (not checkIndependentService()) and (not module.statValues.Fire_Service)) then
						module.statValues.Nudge = true
						data.nudging = true
						module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
						module.sounds.Nudge_Buzzer.Playing = true
						task.spawn(updateStatValues)
					end
					heartbeat:Wait()
				end
			end)
		end
		if (module.statValues.Out_Of_Service or module.statValues.Stop) then return end
		if (string.upper(side) == 'ALL') then
			for _, v in pairs(module.doorData) do
				task.spawn(runDoor, v)
			end
		else
			local data = module.doorData[side]
			if (not data) then return end
			task.spawn(runDoor, data)
		end
	end

	function checkDoorStates(state, params)
		local thisFloor = findRegisteredFloor(module.statValues.Raw_Floor)
		if (not thisFloor) then return end
		local dontRequireAll = params and params.dontRequireAll or false
		local onlyPresentDoors = params and params.onlyPresentDoors or false
		local isAllStates = true

		for i, v in pairs(module.doorData) do
			if (not dontRequireAll) and v.state ~= state and ((not onlyPresentDoors) and true or thisFloor.floorInstance:FindFirstChild((v.side == '' and '' or v.side.."_").."Doors")) then
				isAllStates = false
				break
			elseif dontRequireAll and v.state == state then
				return true
			end
		end
		if (dontRequireAll) then
			return false
		elseif (not dontRequireAll) then
			return isAllStates
		end

		--for i, v in pairs(module.doorData) do
		--	if (v.state ~= state) then return false end
		--end
		--return true
	end

	-- // Queue handling // --

	function findCallInQueue(call, direction)
		for i, v in pairs(module.queue) do
			if (v.call == call and (typeof(direction) ~= 'number' or direction == 0 or table.find(v.directions, direction) or #v.directions == 0)) then return i, v end
		end

		return nil
	end
	function checkNearestCallInDirection(call, direction, requireDirectionInCall)
		local function checkForDirection(call, direction)
			for i, v in pairs(call.directions) do
				if (v == direction) then return true end
			end
			if (requireDirectionInCall == false) then return true end
			return false
		end

		local highestDownCall, lowestUpCall = -math.huge, math.huge
		local lowestDownCall, highestUpCall = math.huge, -math.huge
		for _, v in module.queue do
			-- Highest down call
			if table.find(v.directions, -1) and v.call >= highestDownCall then
				highestDownCall = v.call
			end

			-- Lowest up call
			if table.find(v.directions, 1) and v.call <= lowestUpCall then
				lowestUpCall = v.call
			end

			-- Lowest down call
			if #v.directions == 0 or table.find(v.directions, -1) and v.call <= lowestDownCall then
				lowestDownCall = v.call
			end

			-- Highest up call
			if #v.directions == 0 or table.find(v.directions, 1) and v.call >= highestUpCall then
				highestUpCall = v.call
			end
		end

		local nearResult, nearDist = {}, math.huge
		for i, v in next, module.queue do
			if (math.abs(v.call-call) <= nearDist
				and (((v.call > call and direction == 1 and (checkForDirection(v, direction) or #module.queue <= 1 or #v.directions == 0 or (v.call > highestUpCall and v.call == highestDownCall) or v.isCarCall))
					or (v.call < call and direction == -1 and (checkForDirection(v, direction) or #module.queue <= 1 or #v.directions == 0 or (v.call < lowestDownCall and v.call == lowestUpCall) or v.isCarCall)))
					or (direction == 0 and v.call ~= call)))
			then
				nearResult = {i, v}
				nearDist = math.abs(v.call-call)
			end
		end
		return table.unpack(nearResult)
	end

	function getTotalDirectionSides(sides, direction)
		local count = 0
		for _, side in sides do
			local sideDirection = tonumber(string.split(side, '_')[1])
			if sideDirection == direction or sideDirection == 0 then
				count += 1
			end
		end

		return count
	end

	function addCall(callParams)
		local regFloor = findRegisteredFloor(callParams.call)
		if ((not regFloor) or (module.statValues.Fire_Recall and not callParams.bypassFireRecall)) then return end
		local callIndex, callExists = findCallInQueue(callParams.call)
		local direction = if (typeof(callParams.direction) == 'string') then callParams.direction == 'U' and 1 or callParams.direction == 'D' and -1 elseif (typeof(callParams.direction) == 'number') then callParams.direction else nil
		local newTemplate = {
			['call'] = callParams.call,
			['directions'] = {},
			['sides'] = {},
			['isCarCall'] = if (typeof(callParams.isCarCall) == 'boolean') then callParams.isCarCall else false
		}
		if (callExists) then
			if (callExists.isCarCall == nil or callExists.isCarCall == false) then
				callExists.isCarCall = if (typeof(callParams.isCarCall) == 'boolean') then callParams.isCarCall else false
			end

			if callParams.side and not table.find(callExists.sides, (callParams.direction or 0) .. "_" .. (callParams.side)) then
				table.insert(callExists.sides, (callParams.direction or 0) .. "_" .. (callParams.side))
			end

			if not (table.find(callExists.directions, direction)) then
				table.insert(callExists.directions, direction)
			end

		else
			if callParams.side and not table.find(newTemplate.sides, (callParams.direction or 0) .. "_" .. (callParams.side)) then
				table.insert(newTemplate.sides, (callParams.direction or 0) .. "_" .. (callParams.side))
			end
			if (not table.find(newTemplate.directions, direction)) then 
				table.insert(newTemplate.directions, direction)
			end
			table.insert(module.queue, newTemplate)
		end

		-- // Set queue direction if idle // --
		if (module.statValues.Queue_Direction == 0) then
			module.statValues.Queue_Direction = callParams.call > module.statValues.Raw_Floor and 1 or callParams.call < module.statValues.Raw_Floor and -1 or 0
			task.spawn(updateStatValues)
		end

		local nextCall = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))
		if not nextCall then nextCall = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end
		if not nextCall then nextCall = select(2, findCallInQueue(module.statValues.Arrive_Floor)) end

		-- // Set the destination to call if within range // --
		if ((not module.statValues.Destination) or (
			(module.statValues.Queue_Direction == 'U' or module.statValues.Move_Value == 1) and
				nextCall.call > module.statValues.Raw_Floor and
				nextCall.call <= module.statValues.Destination
			) or
				(
					(module.statValues.Queue_Direction == 'D' or module.statValues.Move_Value == -1) and
					nextCall.call < module.statValues.Raw_Floor and
					nextCall.call >= module.statValues.Destination
				)
			) then
			module.statValues.Destination = nextCall.call
		end
		--module.statValues.Destination = nextCall.call
		task.spawn(updateStatValues)

		if (not moveLock) then
			task.spawn(goToFloor, callParams.call)
		end

		if (not callExists) then
			api:Fire('onCallAdded', { call = callParams.call, direction = callParams.direction })
		end
		queueValue.Value = httpService:JSONEncode(module.queue)
		return true
	end

	function removeCall(call, direction)
		local removed = false
		local q = module.queue

		for i, v in q do
			if (v.call == call and ((direction == 0 or typeof(direction) ~= 'number') or table.find(v.directions, direction) or #v.directions == 0 or v.isCarCall)) then
				local dirs = v.directions
				v.isCarCall = false

				for i, d in dirs do
					if (d ~= direction) then continue end
					table.remove(v.directions, i)
					removed = true
				end

				if (#v.directions == 0 or direction == 0 or typeof(direction) ~= 'number') then
					table.remove(module.queue, i)
					removed = true
					api:Fire('onCallRemoved', { call = call, direction = direction })
				end

				for i, b in car:GetDescendants() do
					local buttonFloor = tonumber(string.split(b.Name, '_')[2]) or tonumber(string.split(b.Name, 'Floor')[2])
					if ((not buttonFloor) or buttonFloor ~= call) then continue end

					setButton(b, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
				end

				local regFloor = findRegisteredFloor(call)
				if (not regFloor) then continue end

				for i, c in regFloor.floorInstance:GetChildren() do
					if (c.Name ~= 'Call_Buttons') then continue end
					for _, b in pairs(c:GetDescendants()) do
						local buttonName = string.split(b.Name, '_')[1]
						if (buttonName ~= 'Up' and buttonName ~= 'Down') then continue end

						local buttonDirection = buttonName == 'Up' and 1 or buttonName == 'Down' and -1 or 0
						if (buttonDirection ~= direction) then continue end

						setButton(b, configFile.Color_Database.Floor[buttonName], 'Neautral_State', b.Parent)
					end
				end
			end
		end

		queueValue.Value = httpService:JSONEncode(module.queue)
		return removed
	end

	-- // Motor sound handling // --
	function doMotorSound()
		local dirIndex = module.statValues.Move_Value == 1 and 'Up' or module.statValues.Move_Value == -1 and 'Down' or nil
		if (not dirIndex) then return end
		for i, v in pairs(module.sounds) do
			if (string.match(v.Name, 'Motor_Start_')) then
				v.Playing = i == "Motor_Start_" .. (dirIndex)
			end
		end
		statValuesFolder.Leveling:GetPropertyChangedSignal('Value'):Once(function()
			if (not statValuesFolder.Leveling.Value) then return end
			module.sounds["Motor_Start_" .. (dirIndex)]:Stop()
			module.sounds["Motor_Run_" .. (dirIndex)]:Stop()
			module.sounds["Motor_Stop_" .. (dirIndex)]:Play()
		end)
		local connection: RBXScriptConnection
		connection = api.Event:Connect(function(protocol)
			if (protocol ~= 'On_Safety_Brake') then return end
			connection:Disconnect()
			for i, v in pairs(module.sounds) do
				if (string.match(v.Name, 'Motor_')) then
					v:Stop()
				end
			end
		end)
		module.sounds["Motor_Start_" .. (dirIndex)].Ended:Wait()
		if (statValuesFolder.Leveling.Value) then return end
		module.sounds["Motor_Run_" .. (dirIndex)]:Play()
	end

	-- // Player welding // --
	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Whitelist
	local elevatorPlayerWelds = {}
	local elevatorPlayerRidingValues = {}
	function playerWeld(weld)
		if (weld) then
			params.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
			local parts = workspace:GetPartBoundsInBox(cabRegion.CFrame, cabRegion.Size, params)
			for _, v in parts do
				local humanoid, root = v.Parent:FindFirstChildOfClass('Humanoid'), v.Parent:FindFirstChild('HumanoidRootPart')
				if (not (humanoid and root)) then continue end

				if (configFile.Movement.Weld_On_Move and not root:FindFirstChild('Cortex_Elevator_Weld')) then
					local weld = Instance.new('Weld')
					weld.Name = humanoid.Parent.Name
					--weld.Part0, weld.Part1 = (not configFile.Movement.Enable_New_Player_Sticking) and root or nil, platform
					weld.Part0, weld.Part1 = root, platform
					weld.C0, weld.C1 = CFrame.new(), weld.Part0 and weld.Part1.CFrame:ToObjectSpace(weld.Part0.CFrame) or CFrame.new()
					humanoid.PlatformStand = not configFile.Movement.Enable_New_Player_Sticking
					weld.Parent = playerWeldsFolder
					local yOffset = math.abs(root.CFrame.Position.Y-platform.CFrame.Position.Y)
					--local att0, att1 = Instance.new('Attachment'), Instance.new('Attachment')
					--att0.Parent, att1.Parent = root, platform
					--att1.WorldPosition += Vector3.new(0, yOffset, 0)
					--local ap = Instance.new('AlignPosition')
					--ap.Attachment0, ap.Attachment1 = att0, att1
					--ap.Responsiveness = math.huge
					--ap.ForceLimitMode = Enum.ForceLimitMode.PerAxis
					--ap.MaxAxesForce = Vector3.new(0, 1, 0)*math.huge
					--ap.Parent = players:GetPlayerFromCharacter(root.Parent) and root or nil
					table.insert(elevatorPlayerWelds, { weld = weld, humanoid = humanoid, root = root, yOffset = yOffset, extras = { ap, att0, att1 }, jumpPower = humanoid.JumpPower, jumpHeight = humanoid.JumpHeight })
					--humanoid.JumpPower = 0
					--humanoid.JumpHeight = 0
				end

				if not root:FindFirstChild('Cortex_Elevator_Riding') then
					local elevatorRidingValue = Instance.new("ObjectValue")
					elevatorRidingValue.Name = 'Cortex_Elevator_Riding'
					elevatorRidingValue.Value = elevator
					elevatorRidingValue.Parent = humanoid.Parent

					table.insert(elevatorPlayerRidingValues, { value = elevatorRidingValue })
				end
			end
		else
			for i, v in elevatorPlayerWelds do
				for _, s in v.extras do
					s:Destroy()
				end
				v.humanoid.PlatformStand = false
				v.weld:Destroy()
				--v.humanoid.JumpPower = v.jumpPower
				--v.humanoid.JumpHeight = v.jumpHeight
				elevatorPlayerWelds[i] = nil
			end

			for i, v in elevatorPlayerRidingValues do
				v.value:Destroy()
				elevatorPlayerRidingValues[i] = nil
			end
		end
	end

	local targetPointVal: CFrameValue = platform:FindFirstChild('TARGET_POSITION_FRAME') or Instance.new('CFrameValue')
	targetPointVal.Name = 'TARGET_POSITION_FRAME'
	targetPointVal.Parent = platform
	targetPointVal:GetPropertyChangedSignal('Value'):Connect(function()
		platform.CFrame = targetPointVal.Value
	end)

	local lastPlatformPosition = platform.CFrame.Position
	function moveElevator(dtTime)
		elevatorPosition *= CFrame.new(0, module.statValues.Move_Value*module.statValues.Current_Speed*dtTime, 0)
		platform.CFrame = elevatorPosition
		targetPointVal.Value = elevatorPosition
		module.statValues.Velocity = module.statValues.Current_Speed

		local carSpeed = (platform.CFrame.Position-lastPlatformPosition)
		lastPlatformPosition = platform.CFrame.Position
		if (counterweight and cwStart) then
			cwOffset -= carSpeed
			local oriX,oriY,oriZ = cwStart:ToOrientation()
			counterweight.Main.CFrame = CFrame.new(cwOffset)*CFrame.Angles(oriX, oriY, oriZ)
			counterweight.Main.Traveling_Sound.Volume = math.clamp(math.abs(module.statValues.Current_Speed)/15, 0, 2)
		end

		if configFile.Sound_Database.Others.Traveling_Sound.Enable then
			local tSpeedFactor = configFile.Sound_Database.Others.Traveling_Sound.Speed_Factor*(module.statValues.Current_Speed/configFile.Movement.Travel_Speed)
			local volumeConstraint = configFile.Sound_Database.Others.Traveling_Sound.Constraints.Volume
			local pitchConstraint = configFile.Sound_Database.Others.Traveling_Sound.Constraints.Pitch
			if (not module.sounds.Traveling_Sound.Playing) then
				module.sounds.Traveling_Sound.Playing = true
			end
			module.sounds.Traveling_Sound.Volume = configFile.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio' and ((volumeConstraint.Max-volumeConstraint.Min)*tSpeedFactor)+volumeConstraint.Min or math.abs(module.statValues.Current_Speed)/30
			module.sounds.Traveling_Sound.PlaybackSpeed = configFile.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio' and ((pitchConstraint.Max-pitchConstraint.Min)*tSpeedFactor)+pitchConstraint.Min or math.clamp(.5+math.abs(module.statValues.Current_Speed)/30, pitchConstraint.Min, pitchConstraint.Max)
		end
		task.spawn(updateStatValues)
		task.spawn(updateFloor)
		return dtTime, carSpeed.Y > 0 and 1 or carSpeed.Y < 0 and -1 or 0
	end

	-- // Safety brake // --
	local safetyBraking = false

	function safetyBrake()
		if (safetyBraking) then return end
		safetyBraking = true
		preDooring = false
		local initialSpeed = module.statValues.Current_Speed
		local rate = 1.35
		local dtTime = 0
		pcall(task.cancel, elevatorMovementThread)
		pcall(task.cancel, elevatorRelevelThread)
		if (module.statValues.Current_Speed > 0) then
			module.sounds.Safety_Brake_Sound:Play()
		end

		while (module.statValues.Current_Speed > 0 and safetyBraking) do
			module.statValues.Current_Speed = math.max(0, module.statValues.Current_Speed-rate*math.deg(dtTime))
			moveElevator(dtTime)
			dtTime = heartbeat:Wait()
		end

		api:Fire('On_Safety_Brake')
		playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Safety_Brake_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Safety_Brake_Announcement.Enabled)

		if (initialSpeed > 0) then
			local threshold = (initialSpeed/2)/rate^2
			local bounceThreshold = 1
			local dtTime = 0
			while (bounceThreshold > 0) do
				module.statValues.Current_Speed = math.sin(tick()*20)*bounceThreshold*threshold
				moveElevator(dtTime)
				bounceThreshold = math.max(0, bounceThreshold-.035*math.deg(dtTime))
				dtTime = heartbeat:Wait()
			end
		end
		module.statValues.Current_Speed = 0
		module.statValues.Move_Value = 0
		moveLock = false
		safetyBraking = false
		task.spawn(updateStatValues)
		releveling = false
	end

	local parkTimerRunning = false
	function parkTimer()
		if parkTimerRunning then return end
		task.spawn(function()
			if (configFile.Movement.Parking_Config.Enable and module.statValues.Raw_Floor ~= configFile.Movement.Parking_Config.Park_Floor) then
				parkTimerRunning = true
				local startTime = os.clock()
				while (os.clock()-startTime <= configFile.Movement.Parking_Config.Idle_Time) do
					task.wait(.5)
					if (module.statValues.Move_Value ~= 0 or (not checkDoorStates('Closed')) or (module.statValues.Fire_Service or checkIndependentService() or module.statValues.Inspection or module.statValues.Out_Of_Service)) then
						parkTimerRunning = false
						return
					end
				end
				parkTimerRunning = false

				if checkDoorStates('Closed') then
					goToFloor(configFile.Movement.Parking_Config.Park_Floor, true)
				else
					local connections = {}
					for i, v in module.doorData do
						connections[v] = v.Closed:Once(function()
							if (not checkDoorStates('Closed')) then return end
							for i, v in pairs(connections) do
								v:Disconnect()
							end
							goToFloor(configFile.Movement.Parking_Config.Park_Floor, true)
						end)
					end
				end
			end
		end)
	end

	local dropKeyUpdaters = {}

	-- // Drop key system // --
	function isDropKeyOnElevator()
		for i,v in pairs(module.dropKeyCheckValues) do
			if (v.Value) then return false end
		end
		return true
	end

	local function doDropKey(params)
		--local doorSide = string.split(params.Name, 'Doors')[2] and string.split(params.Name, 'Doors')[1] or string.split(params.Name, '_')

		local doorSide = string.split(string.split(params.Name, 'Doors')[1], '_')[1]
		if doorSide == '' then doorSide = string.split(params.Name, 'Doors')[1] ~= '' and string.split(params.Name, 'Doors')[1] or string.split(params.Name, 'Doors')[2] ~= '' and string.split(params.Name, 'Doors')[2] end

		local foundFloorNumber, floorNumberPosition = string.gsub(params.Parent.Name, '%D', '')
		local floorNumber = tonumber(foundFloorNumber)

		local function getWelds()
			local welds = {}

			for i, v in next, module.doorData do
				for i, w in params:IsDescendantOf(car) and car.Door_Engine_Welds:FindFirstChild(doorSide):GetChildren() or findRegisteredFloor(floorNumber) and findRegisteredFloor(floorNumber).floorInstance:FindFirstChild('Door_Engine_Welds'):FindFirstChild(doorSide):GetChildren() or {} do
					table.insert(welds, w)
				end
			end

			return welds
		end

		local landingLevel = findAncestor(params, 'Level')
		if (not landingLevel) then return end

		if ((landingLevel.Parent == car and module.doorData[doorSide].state == 'Closed') or (landingLevel.Parent ~= car and (((module.doorData[doorSide].state == 'Closed' and tonumber(landingLevel.Parent.Name:sub(7)) == module.statValues.Raw_Floor) or tonumber(landingLevel.Parent.Name:sub(7)) ~= module.statValues.Raw_Floor)))) then
			local closedOnce = false
			for i,weld in pairs(getWelds()) do
				if (weld.C0 == weld:GetAttribute('closedPoint')) then
					landingLevel.Drop_Key_Sound:Play()
					task.spawn(function()
						pluginModuleData.Legacy_Easing.content.interpolate(weld, weld:GetAttribute('openPoint'), 'Out_Bounce', configFile.Doors.Door_Open_Speed * 1.3)
					end)
					if module.statValues.Move_Value ~= 0 and checkDropKeyState() then
						module.sounds.Safety_Brake_Sound.PlaybackSpeed = module.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
						task.spawn(safetyBrake)
						playerWeld(false)
					end
					module.statValues.Out_Of_Service = true
					params:SetAttribute('Drop_Key_Open', true)
					params.Drop_Key_Open.Value = true
					module.doorData[doorSide].isEnabled = false
					task.spawn(updateStatValues)
				elseif (weld.C0 == weld:GetAttribute('openPoint')) then
					landingLevel.Drop_Key_Sound:Play()
					task.spawn(function()
						pluginModuleData.Legacy_Easing.content.interpolate(weld, weld:GetAttribute('closedPoint'), 'Out_Sine', configFile.Doors.Door_Open_Speed * 1.3)
						params:SetAttribute('Drop_Key_Open', false)
						params.Drop_Key_Open.Value = false
						module.doorData[doorSide].isEnabled = true
						module.statValues.Out_Of_Service = not checkDropKeyState()
						task.spawn(updateStatValues)

						if checkDropKeyState() and not closedOnce then
							closedOnce = true
							task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
						end
					end)
				end
			end
		end
	end

	local dropKeyHandlers = {}
	function checkDropKeyState()
		for i, v in module.doorData do
			if (not v.isEnabled) then return false end
		end

		for _, v in car:GetDescendants() do
			if v:GetAttribute('Drop_Key_Open') then return false end
		end

		for _, v in floors:GetDescendants() do
			if v:GetAttribute('Drop_Key_Open') then return false end
		end

		return true
	end

	local function dismountDropKeyClient(user,params)
		local doorSet = params
		if (not collectionService:HasTag(doorSet, 'IsInUse')) then return end
		local thisFloorName = doorSet:IsDescendantOf(floors) and string.split(doorSet.Parent.Name, 'Floor_')[2]
		local landingLevel = doorSet.Parent.Level
		local sideIndex = doorSet.Name:split('Doors')[1]:split('_')[1]
		local fullSideName = (sideIndex == '' and 'Front' or sideIndex)

		for i,v in pairs(dropKeyHandlers[doorSet] or {}) do
			v:Disconnect()
		end
		local index = table.find(dropKeyHandlers,user)
		if (index) then
			table.remove(dropKeyHandlers,index)
		end
		local doorBounds = doorSet:FindFirstChild('Door_Bounds')
		if (doorBounds) then doorBounds:Destroy() end
		dropKeyHandlers[doorSet] = nil

		local welds = {}
		local data = module.doorData[sideIndex]
		local welds = {}
		for i,v in next,data and (doorSet:IsDescendantOf(car) and car.Door_Engine_Welds:FindFirstChild(sideIndex):GetChildren() or findRegisteredFloor(thisFloorName).floorInstance:FindFirstChild('Door_Engine_Welds'):FindFirstChild(sideIndex):GetChildren()) or {} do
			table.insert(welds, { ['weld'] = v })
		end
		local function checkIfDoorIsClosed()
			for i,v in pairs(welds) do
				if (v.weld.C0 ~= v.weld:GetAttribute('closedPoint')) then return false end
			end
			return true
		end

		local isClosed = checkIfDoorIsClosed()

		local function check()
			module.statValues.Out_Of_Service = not checkDropKeyState()
			preDooring = false
			api:Fire('onElevDoorKey',{doorSet=doorSet,status='release'})
			task.spawn(updateStatValues)
			task.spawn(function()
				local isCompleted = coreFunctions.conditionalWait(1, function() return {not module.statValues.Out_Of_Service} end)
				if (not isCompleted) then return end
				task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
			end)
		end
		addPlayingSound(landingLevel, addSound(landingLevel, 'Interlock_Click', {
			Sound_Id = 9116323848,
			Volume = 1,
			Pitch = 1.35
		}, false, 40, 3))
		if (isClosed) then
			check()
		elseif (not isClosed) then
			local hasCompleted = coreFunctions.conditionalWait(2, function() return {collectionService:HasTag(doorSet, 'IsInUse')} end)
			if (not hasCompleted) then return end
			local connection: RBXScriptConnection

			local i = 0
			for _,v in pairs(welds) do
				v.startPosition = v.weld.C0
				v.alpha = 0
			end

			connection = heartbeat:Connect(function(dtTime)
				i += .025*dtTime
				for _,v in pairs(welds) do
					v.alpha += i
					v.weld.C0 = v.startPosition:Lerp(v.weld:GetAttribute('closedPoint'), math.min(v.alpha,1))
				end
				if (dropKeyHandlers[doorSet]) then return connection:Disconnect() end

				if checkIfDoorIsClosed() then
					local doorSide = string.split(doorSet.Name, '_')[1]
					module.doorData[doorSide].isEnabled = true
				end

				if (checkIfDoorIsClosed()) then connection:Disconnect() return check() end
			end)
		end

		collectionService:RemoveTag(doorSet, 'IsInUse')
	end

	function stopAtFloor(floor, park)
		local regFloor = findRegisteredFloor(floor)
		if (not regFloor) then return end
		local direction = module.statValues.Move_Value
		local floorQueue

		local distanceToFloor = module.statValues.Move_Value*(regFloor.level.Position.Y-level.Position.Y)
		local offsetDistanceToFloor = module.statValues.Move_Value*((regFloor.level.Position.Y+direction*(configFile.Sensors.Stop_Offset+configFile.Movement.Braking_Data["Linear_Mode_Offset_" .. (direction == 1 and 'Up' or direction == -1 and 'Down')]))-level.Position.Y)
		local stopped = false
		local weldsRemoved = false
		local levelingStage = 0
		local customLevelingStage = 1
		local minSpeed = configFile.Movement.Level_Speed

		local landingLevel = regFloor.floorInstance.Level

		local INITIAL_SPEED, DISTANCE_TO_DECELERATE = module.statValues.Current_Speed, offsetDistanceToFloor

		local dtTime = 0

		while (not stopped) do
			distanceToFloor = module.statValues.Move_Value*(regFloor.level.Position.Y-level.Position.Y)
			offsetDistanceToFloor = module.statValues.Move_Value*((regFloor.level.Position.Y+direction*(configFile.Sensors.Stop_Offset+configFile.Movement.Braking_Data["Linear_Mode_Offset_" .. (direction == 1 and 'Up' or direction == -1 and 'Down')]))-level.Position.Y)
			if (not module.statValues.Leveling) then
				module.statValues.Leveling = true
				module.statValues.Arrive_Floor = floor

				-- // Get nearest call in direction
				local nextCall = select(2, checkNearestCallInDirection(module.statValues.Arrive_Floor, module.statValues.Queue_Direction))

				--// No calls? Check in the opposite direction
				if (not nextCall) then nextCall = select(2, checkNearestCallInDirection(module.statValues.Arrive_Floor, -module.statValues.Queue_Direction)) end

				-- // Still no calls? Check in any direction
				if (not nextCall) then nextCall = select(2, checkNearestCallInDirection(module.statValues.Arrive_Floor, 0)) end

				-- // Yet still no calls? Let's look for any directional calls on current floor
				local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))

				local callDirection
				for _, v in pairs(thisCall and thisCall.directions or {}) do
					if (v == module.statValues.Queue_Direction or (module.statValues.Arrive_Floor == topFloor.floorNumber or module.statValues.Arrive_Floor == bottomFloor.floorNumber) or #module.queue <= 1) then
						callDirection = v
						break
					end
				end

				module.statValues.Queue_Direction = callDirection or (nextCall and (nextCall.call > module.statValues.Arrive_Floor and 1 or nextCall.call < module.statValues.Arrive_Floor and -1)) or 0

				local lanternSides = {}
				for _, side in thisCall and thisCall.sides or {} do
					if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
						table.insert(lanternSides, string.split(side, '_')[2])
					end
				end

				api:Fire('onCallRespond', { floor = module.statValues.Arrive_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })
				api:Fire('onElevatorArrive', { floor = module.statValues.Arrive_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })

				if (not park or module.statValues.Queue_Direction ~= 0) and (not checkIndependentService()) and (not module.statValues.Fire_Service) then
					task.spawn(runChime, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Arrival, true)
					task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Arrival, true)

					playVoiceSequenceProtocolWithQueue(voiceConfig.Floor_Announcements[tostring(floor)] or {}, true, voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Arrival)

					if (voiceConfig.Settings.Directional_Announcements.Announce_After_Floor_Announcement and module.statValues.Queue_Direction ~= 0) then
						local dir = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down'
						local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
						if clip then
							playVoiceSequenceProtocolWithQueue(clip.Sequence, false, clip.Enabled)
						end
					end
				end
				--removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
			end
			if (module.statValues.Current_Speed > configFile.Movement.Level_Speed) then
				if (configFile.Movement.Braking_Data.Mode == 'Linear') then
					local currentSpeed = module.statValues.Current_Speed
					local gradualDecelRatio = math.min(1, math.max(.1, ((offsetDistanceToFloor/(DISTANCE_TO_DECELERATE*configFile.Movement.Smooth_Stop_V2.Threshold)))/(currentSpeed/INITIAL_SPEED)))
					local rate = currentSpeed^2/(2*offsetDistanceToFloor*(configFile.Movement.Smooth_Stop_V2.Enable and gradualDecelRatio or 1))
					local newSpeed = math.max(0, currentSpeed-rate*dtTime)
					
					module.statValues.Current_Speed = math.max(newSpeed, configFile.Movement.Level_Speed)
				elseif (configFile.Movement.Braking_Data.Mode == 'SmartLinear') then
					if (offsetDistanceToFloor > configFile.Movement.Braking_Data.Smart_Linear_Transition_Dist*(INITIAL_SPEED/(configFile.Movement.Travel_Speed/3)) and levelingStage ~= 2) then
						levelingStage = 1
						local currentSpeed = module.statValues.Current_Speed
						local gradualDecelRatio = math.min(1, math.max(.1, ((offsetDistanceToFloor/(DISTANCE_TO_DECELERATE*configFile.Movement.Smooth_Stop_V2.Threshold)))/(currentSpeed/INITIAL_SPEED)))
						local rate = currentSpeed^2/(2*offsetDistanceToFloor*(configFile.Movement.Smooth_Stop_V2.Enable and gradualDecelRatio or 1))
						local newSpeed = math.max(0, currentSpeed-rate*dtTime)
						
						module.statValues.Current_Speed = math.max(newSpeed, configFile.Movement.Level_Speed)
					elseif (levelingStage == 1) then
						levelingStage = 2
						INITIAL_SPEED,DISTANCE_TO_DECELERATE = module.statValues.Current_Speed,offsetDistanceToFloor
						
						api:Fire('levelingStageChange', { brakingMode = configFile.Movement.Braking_Data.Mode, stage=levelingStage })
					elseif (levelingStage == 2) then
						module.statValues.Current_Speed = math.clamp((INITIAL_SPEED/DISTANCE_TO_DECELERATE)*offsetDistanceToFloor, configFile.Movement.Level_Speed, if (INITIAL_SPEED) < configFile.Movement.Level_Speed then INITIAL_SPEED+configFile.Movement.Level_Speed else INITIAL_SPEED)
					end
				elseif (configFile.Movement.Braking_Data.Mode == 'Default') then
					module.statValues.Current_Speed = math.max(configFile.Movement.Level_Speed, (INITIAL_SPEED/DISTANCE_TO_DECELERATE)*distanceToFloor)
				elseif (configFile.Movement.Braking_Data.Mode == 'Manual') then
					module.statValues.Current_Speed = math.max(configFile.Movement.Level_Speed, module.statValues.Current_Speed-configFile.Movement.Braking_Data.Increment*math.deg(dtTime))
					--elseif (configFile.Movement.Braking_Data.Mode == 'Custom') then
					--	local currentLevelingStage = configFile.Movement.Braking_Data.Custom_Leveling_Stages[customLevelingStage]
					--	local nextLevelingStage = configFile.Movement.Braking_Data.Custom_Leveling_Stages[customLevelingStage+1]
					--	if (currentLevelingStage) then
					--		if (nextLevelingStage and nextLevelingStage.Transition_Distance >= getFloorDistance(module.statValues.Arrive_Floor)) then
					--			customLevelingStage += 1
					--			INITIAL_SPEED = module.statValues.Current_Speed
					--			distanceToFloor = (math.abs((landingLevel.Position.Y + (module.statValues.Move_Value * currentLevelingStage.Offset)) - level.Position.Y))
					--		end
					--		print(currentLevelingStage.Rate)
					--		if (currentLevelingStage.Rate == 'Constant') then
					--			local currentSpeed = module.statValues.Current_Speed
					--			local deceleration = currentSpeed^2/(2*math.max(distanceToFloor, .001))
					--			local SPEED = math.max(0, currentSpeed-deceleration*dtTime)
					--			module.statValues.Current_Speed = math.max(SPEED, .015)
					--		else
					--			module.statValues.Current_Speed = math.clamp((INITIAL_SPEED/distanceToFloor) * getFloorDistance(module.statValues.Arrive_Floor), minSpeed, if (INITIAL_SPEED) < minSpeed then INITIAL_SPEED+minSpeed else INITIAL_SPEED)
					--		end
					--	end
				end
			elseif (not weldsRemoved) then
				weldsRemoved = true
				playerWeld(false)
			end

			if (distanceToFloor <= configFile.Sensors.Pre_Door_Data.Offset and configFile.Sensors.Pre_Door_Data.Enable and (not preDooring)) then
				local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))

				local lanternSides = {}
				for _, side in thisCall and thisCall.sides or {} do
					if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
						table.insert(lanternSides, string.split(side, '_')[2])
					end
				end

				api:Fire('onElevatorOpen', {floor = module.statValues.Arrive_Floor})
				if (not park or module.statValues.Queue_Direction ~= 0) then
					task.spawn(runChime, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Open, true)
					task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Door_Open, true)
				end
				local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))
				if ((((not module.statValues.Fire_Service) or (module.statValues.Fire_Recall and fireServiceRecallFloor == module.statValues.Raw_Floor))) and (not preDooring)) then
					preDooring = true
					if (getTotalDirectionSides(thisCall and thisCall.sides or {}, thisCall and thisCall.directions[1] or 0) == 0) then
						task.spawn(runDoorOpen, floor, 'all', thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
					else
						local callSidesCopy = table.clone(thisCall.sides)
						for _, side in pairs(callSidesCopy) do
							local dir = #thisCall.directions > 0 and thisCall.directions[1] or 0
							if dir then
								if tonumber(string.split(side, '_')[1]) == dir or tonumber(string.split(side, '_')[1]) == 0 then
									table.remove(module.queue[select(1, findCallInQueue(thisCall.call))].sides, table.find(module.queue[select(1, findCallInQueue(thisCall.call))].sides, side))
									task.spawn(runDoorOpen, floor, string.split(side, '_')[2], thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
								end
							end
						end
					end
				end

				removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
			end
			if (distanceToFloor <= 0) then
				stopped = true
				api:Fire('onCallRespond', {floor = floor, direction = module.statValues.Queue_Direction, parking = module.statValues.Parking})
				api:Fire('onElevatorStop', {floor = module.statValues.Arrive_Floor})
				break
			end
			moveElevator(dtTime)
			dtTime = heartbeat:Wait()
		end

		module.statValues.Move_Value = 0
		module.statValues.Move_Direction = 0
		module.statValues.Velocity = 0
		module.statValues.Current_Speed = 0
		module.statValues.Leveling = false
		module.statValues.Arrow_Direction = 0
		module.statValues.Parking = false
		parkTimer()
		task.spawn(updateStatValues)
		task.spawn(updateFloor)

		if voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Stop and (not park or module.statValues.Queue_Direction ~= 0) and (not checkIndependentService()) and (module.statValues.Fire_Service) then
			playVoiceSequenceProtocolWithQueue(voiceConfig.Floor_Announcements[tostring(floor)] or {}, true, voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Stop)

			if (voiceConfig.Settings.Directional_Announcements.Announce_After_Floor_Announcement and module.statValues.Queue_Direction ~= 0) then
				local dir = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down'
				local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
				if clip then
					playVoiceSequenceProtocolWithQueue(clip.Sequence, false, clip.Enabled)
				end
			end
		end

		local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))
		local hasPassed = coreFunctions.conditionalWait(configFile.Movement.Stop_Delay, function() return {module.statValues.Move_Value == 0} end)
		if (not hasPassed) then return end
		releveling = false
		moveLock = false

		if ((((not module.statValues.Fire_Service) or (module.statValues.Fire_Recall and fireServiceRecallFloor == module.statValues.Raw_Floor))) and (not preDooring)) then
			api:Fire('onElevatorOpen', {floor = module.statValues.Arrive_Floor})

			local lanternSides = {}
			for _, side in thisCall and thisCall.sides or {} do
				if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
					table.insert(lanternSides, string.split(side, '_')[2])
				end
			end

			task.spawn(runChime, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Open, true)
			task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Door_Open, true)

			if (getTotalDirectionSides(thisCall and thisCall.sides or {}, thisCall and thisCall.directions[1] or 0) == 0) then
				task.spawn(runDoorOpen, floor, 'all', thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
			else
				local callSidesCopy = table.clone(thisCall and thisCall.sides or {})
				for _, side in pairs(callSidesCopy) do
					local dir = #thisCall.directions > 0 and thisCall.directions[1] or 0
					if dir then
						if tonumber(string.split(side, '_')[1]) == dir or tonumber(string.split(side, '_')[1]) == 0 then
							table.remove(module.queue[select(1, findCallInQueue(thisCall.call))].sides, table.find(module.queue[select(1, findCallInQueue(thisCall.call))].sides, side))
							task.spawn(runDoorOpen, floor, string.split(side, '_')[2], thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
						end
					end
				end
			end

			removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
		elseif (module.statValues.Fire_Recall and not preDooring or module.statValues.Phase_2) then
			removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
		end
		preDooring = false

		local hasPassed = coreFunctions.conditionalWait(2, function() return {module.statValues.Move_Value == 0 and checkDoorStates('Closed')} end)
		if (not hasPassed) then return end

		local nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))

		-- // No call in current direction? Check in the opposite direction
		if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, -module.statValues.Queue_Direction)) end

		-- // Still no call? Check in any direction
		if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end

		-- // Yet still no call? Let's look for any calls on the current floor // --
		local thisCall = select(2, findCallInQueue(module.statValues.Raw_Floor, -module.statValues.Queue_Direction))
		if ((not select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))) and thisCall) then
			module.statValues.Queue_Direction = 0
			task.spawn(updateStatValues)
			local hasCompleted = coreFunctions.conditionalWait(1, function() return {not moveLock} end)
			if (not hasCompleted) then return end
			module.statValues.Queue_Direction = thisCall.directions[1]
			api:Fire('onCallRespond', { floor = module.statValues.Raw_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })
			task.spawn(updateStatValues)
			task.spawn(runDoorOpen, floor, 'all', 'Open_By_Call')
			removeCall(module.statValues.Raw_Floor, module.statValues.Queue_Direction)
			return
		end


		if (not nextQueue) then
			module.statValues.Queue_Direction = 0
			task.spawn(updateStatValues)
			return
		end
		task.spawn(goToFloor, nextQueue.call)
	end

	function goToFloor(floor, park)
		local ran,res = pcall(function()
			if (not isElevatorSafe()) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'MOVE_NOT_SAFE' } end
			local regFloor = findRegisteredFloor(floor)
			if (not regFloor) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'INVALID_FLOOR' } end
			if (floor == module.statValues.Raw_Floor or moveLock or (not checkDoorStates('Closed')) or module.statValues.Out_Of_Service or module.statValues.Stop) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'NOT_MOVE_SAFE' } end

			module.statValues.Parking = park
			elevatorMovementThread = task.spawn(function()
				local direction = floor > module.statValues.Raw_Floor and 1 or floor < module.statValues.Raw_Floor and -1 or nil
				if (not direction) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'UNKNOWN_DIRECTION' } end
				module.statValues.Move_Value = direction
				module.statValues.Queue_Direction = direction
				module.statValues.Move_Direction = direction
				module.statValues.Current_Speed = 0
				module.statValues.Destination = floor
				module.statValues.Leveling = false
				preDooring = false
				moveLock = true
				playerWeld(true)
				task.spawn(updateStatValues)

				api:Fire('onElevatorMoveBegin', { directionString = direction == 1 and 'U' or direction == -1 and 'D' or nil, directionValue = direction })

				task.spawn(function()
					local hasPassed = coreFunctions.conditionalWait(configFile.Movement.Motor_Start_Delay[direction == 1 and 'Up' or direction == -1 and 'Down'], function() return {module.statValues.Move_Value == direction} end)
					if (not hasPassed) then return end
					doMotorSound()
				end)
				local hasCompleted = coreFunctions.conditionalWait(configFile.Movement[direction == 1 and 'Start_Delay' or direction == -1 and 'Down_Start_Delay'], function() return {module.statValues.Move_Value == direction} end)
				if (not hasCompleted) then return task.cancel(elevatorMovementThread) end

				api:Fire('onDepartStart', { directionString = direction == 1 and 'U' or direction == -1 and 'D' or nil, directionValue = direction })
				if (configFile.Movement.Jolt_Start_Data.Enable) then
					local hasPassed = coreFunctions.conditionalWait(configFile.Movement.Jolt_Start_Data.Start_Delay, function() return {module.statValues.Move_Value == direction} end)
					if (not hasPassed) then return end

					local done = false
					local checked = false
					local lastSpeed = module.statValues.Current_Speed
					local startTime = os.clock()
					local dtTime = 0
					while (not checked) do
						module.statValues.Current_Speed = -(math.sin(math.abs(os.clock()-startTime)*math.pi*configFile.Movement.Jolt_Start_Data.Speed)*configFile.Movement.Jolt_Start_Data.Ratio)/math.pi
						--module.statValues.Current_Speed = -(math.sin(math.abs(os.clock()-startTime)*configFile.Movement.Jolt_Start_Data.Speed)*configFile.Movement.Jolt_Start_Data.Ratio)
						local spd = module.statValues.Current_Speed
						if ((lastSpeed-spd) > 0) then
							lastSpeed = spd
						elseif (spd >= 0) then
							checked = true
						end
						elevatorPosition *= CFrame.new(0, module.statValues.Move_Value*module.statValues.Current_Speed*dtTime, 0)
						platform.CFrame = elevatorPosition
						module.statValues.Velocity = module.statValues.Current_Speed
						task.spawn(updateStatValues)
						dtTime = heartbeat:Wait()
					end
				end

				local topSpeed = configFile.Movement.Travel_Speed
				local initialSpeed = module.statValues.Current_Speed
				local accelerationRate = configFile.Movement[direction == 1 and 'Acceleration' or direction == -1 and 'Down_Acceleration'] or configFile.Movement.Acceleration
				local accelTime = coreFunctions.getAccelerationTime(initialSpeed, configFile.Movement.Travel_Speed, accelerationRate)
				local startTime = os.clock()

				local dtTime = 0
				local lvlOffset = configFile.Sensors[module.statValues.Move_Value == 1 and 'Up_Level_Offset' or module.statValues.Move_Value == -1 and 'Down_Level_Offset']

				local dynamicAccelRate = 1/math.deg(configFile.Movement.Dynamic_Acceleration_Time)
				local dynamicAccelValue = 0

				while true do
					regFloor = findRegisteredFloor(module.statValues.Destination)
					if (not regFloor) then continue end
					local distanceToFloor = module.statValues.Move_Value*(regFloor.level.Position.Y-level.Position.Y)
					local offsetDistanceToFloor = module.statValues.Move_Value*((regFloor.level.Position.Y+direction*(configFile.Sensors.Stop_Offset+configFile.Movement.Braking_Data["Linear_Mode_Offset_" .. (direction == 1 and 'Up' or direction == -1 and 'Down')]))-level.Position.Y)
					if (not module.statValues.Leveling) then
						dynamicAccelValue = math.clamp(dynamicAccelValue+dynamicAccelRate*math.deg(dtTime), 0, 1)
						--module.statValues.Current_Speed = coreFunctions.lerp(initialSpeed, configFile.Movement.Travel_Speed*dynamicAccelValue, math.min((os.clock()-startTime)/accelTime, 1))
						module.statValues.Current_Speed = math.clamp(module.statValues.Current_Speed+accelerationRate*dynamicAccelValue*math.deg(dtTime), 0, topSpeed)
					end

					if (distanceToFloor <= lvlOffset*(module.statValues.Current_Speed*configFile.Movement.Level_Offset_Ratio)) then
						return stopAtFloor(module.statValues.Destination, park)
					end

					local carMovementDirection = select(2, moveElevator(dtTime))
					if ((carMovementDirection == 1 and level.Position.Y >= topFloor.level.Position.Y+1.5) or (carMovementDirection == -1 and level.Position.Y <= bottomFloor.level.Position.Y-1.5)) then
						safetyBraking = false
						safetyBrake()
					end
					dtTime = heartbeat:Wait()
				end
			end)
		end)
		if (not ran) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'RUNTIME_ERROR', ['MESSAGE'] = res } end
		return { ['RUN_STATUS'] = true, ['RUN_CODE'] = 'RUNTIME_SUCCESS' }
	end

	-- // Relevel // --
	function relevel(floor, tolerance, openDoorsIfLeveled)
		if (not isElevatorSafe()) then return end

		if (typeof(tolerance) ~= 'number') then tolerance = 0 end
		local registeredFloor = findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		if (releveling) then return end

		elevatorRelevelThread = task.spawn(function()
			local levelOffset = (registeredFloor.level.Position.Y-level.Position.Y)
			local directionToTravelTo = levelOffset < 0 and -1 or levelOffset > 0 and 1 or 0
			if (math.abs(levelOffset) <= tolerance) then
				if not openDoorsIfLeveled then return end

				for i, v in pairs(module.doorData) do
					task.spawn(runDoorOpen, module.statValues.Raw_Floor, v.side, 'Open_No_Call')
				end

				return
			end

			releveling = true
			module.statValues.Leveling = true
			task.spawn(updateStatValues)

			module.statValues.Move_Value = directionToTravelTo
			module.statValues.Move_Direction = directionToTravelTo
			moveLock = true
			task.spawn(updateStatValues)

			local dtTime = 0

			local lvlOffset = configFile.Sensors[directionToTravelTo == 1 and 'Up_Level_Offset' or directionToTravelTo == -1 and 'Down_Level_Offset']

			while true do
				local thisLevelOffset = (registeredFloor.level.Position.Y-level.Position.Y)
				local currentDirTravel = thisLevelOffset < 0 and -1 or thisLevelOffset > 0 and 1 or 0
				module.statValues.Current_Speed = math.min(configFile.Movement.Travel_Speed, module.statValues.Current_Speed+configFile.Movement[currentDirTravel == 1 and 'Acceleration' or 'Down_Acceleration'])
				local distanceToFloor = module.statValues.Move_Value*thisLevelOffset
				if (distanceToFloor <= lvlOffset*(module.statValues.Current_Speed*configFile.Movement.Level_Offset_Ratio)) then
					return stopAtFloor(floor, false)
				end
				moveElevator(dtTime)
				dtTime = heartbeat:Wait()
			end
		end)
	end

	-- // Fire Recall // --
	local allFireRecallEventListeners = {}

	function fireRecall(bool, recallFloor)
		local regFloor = findRegisteredFloor(recallFloor)

		module.statValues.Phase_1 = bool
		task.spawn(updateStatValues)

		--outputElevMessage("Elevator has been placed " .. (bool and 'into' or 'out of') .. " fire service to floor " .. (floor), 'warning')

		if (bool) then
			if (not regFloor) then return end
			fireServiceRecallFloor = recallFloor
			module.statValues.Fire_Recall = true
			module.statValues.Fire_Service = true

			playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Fire_Recall_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Fire_Recall_Announcement.Enabled)

			local function handleDoors()
				if (checkDoorStates('Open', {dontRequireAll = true, onlyPresentDoors = false})) then
					module.sounds.Nudge_Buzzer.Playing = false
					module.statValues.Fire_Recall = false
					task.spawn(updateStatValues)
					return
				end

				for i, doorData in pairs(module.doorData) do
					if (not regFloor.floorInstance:FindFirstChild((doorData.side == '' and '' or doorData.side.."_").."Doors")) then continue end
					if (doorData.state ~= 'Open') then
						local connection: RBXScriptConnection
						connection = doorData.Opened:Connect(function()
							connection:Disconnect()
							if (not checkDoorStates('Open', {dontRequireAll = true, onlyPresentDoors = false})) then return end
							module.sounds.Nudge_Buzzer.Playing = false
							module.statValues.Fire_Recall = false
							task.spawn(updateStatValues)
						end)
						table.insert(allFireRecallEventListeners, connection)
					end
				end
			end

			removeAllCalls()
			module.statValues.Queue_Direction = 0
			module.sounds.Nudge_Buzzer.Playing = true
			task.spawn(updateStatValues)


			local isOnFloor = module.statValues.Raw_Floor == recallFloor and (module.statValues.Move_Value == 0 or module.statValues.Leveling)
			if (isOnFloor) then
				task.spawn(runDoorOpen, recallFloor, 'all', 'Open_No_Call', true)
				handleDoors()
			else
				local direction = module.statValues.Move_Value
				local nearFloor, nearDist = nil, math.huge
				for _, floor in pairs(module.registeredFloors) do
					local thisDist = math.abs(floor.floorInstance.Level.Position.Y - level.Position.Y)
					if (thisDist < nearDist and ((direction == 1 and floor.floorNumber > module.statValues.Raw_Floor) or (direction == -1 and floor.floorNumber < module.statValues.Raw_Floor))) then
						nearDist = thisDist
						nearFloor = floor
					end
				end

				--if (nearFloor and module.statValues.Move_Value ~= 0) then
				--	addCall({call = nearFloor.floorNumber, direction = nil, bypassFireRecall = true})
				--end

				if ((module.statValues.Move_Value == -1 and module.statValues.Raw_Floor >= fireServiceRecallFloor) or (module.statValues.Move_Value == 1 and module.statValues.Raw_Floor <= fireServiceRecallFloor)) then
					addCall({call = recallFloor, direction = nil, bypassFireRecall = true})
				elseif module.statValues.Move_Value == 0 or module.statValues.Leveling then
					task.spawn(runDoorClose, module.statValues.Raw_Floor, 'all', true)
					addCall({call = recallFloor, direction = nil, bypassFireRecall = true})
				elseif (nearFloor) then
					addCall({call = nearFloor.floorNumber, direction = nil, bypassFireRecall = true})
				end

				local connection: RBXScriptConnection
				connection = api.Event:Connect(function(protocol, params)
					if (protocol == 'onElevatorStop') then
						if (module.statValues.Raw_Floor ~= recallFloor) then
							addCall({call = recallFloor, direction = nil, bypassFireRecall = true})
						else
							connection:Disconnect()
							handleDoors()
						end
					end
				end)
				table.insert(allFireRecallEventListeners, connection)
			end
		elseif (not bool and module.statValues.Fire_Service) then
			if module.statValues.Fire_Recall then
				module.sounds.Nudge_Buzzer.Playing = false
			end
			module.statValues.Fire_Recall = false
			module.statValues.Fire_Service = false
			task.spawn(updateStatValues)
			for i, v in allFireRecallEventListeners do
				v:Disconnect()
			end
			allFireRecallEventListeners = {}
		end
	end

	-- // Chime & Lantern Handling // --
	function runChime(floor, sides, direction, indexes, cfg, requireCallOnlyParam)
		local regFloor = findRegisteredFloor(floor)
		if #sides == 0 then sides = { "all" } end
		if ((not regFloor) or (direction ~= 1 and direction ~= -1)) then return end
		for index, value in pairs(indexes) do
			local thisData = cfg[value]
			local thisCall = select(2, findCallInQueue(floor, direction))
			local callOnlyMet = (requireCallOnlyParam and thisData.Call_Only and (thisCall and table.find(thisCall.directions, direction))) or (not thisData.Call_Only) or (not requireCallOnlyParam)
			if ((not thisData) or (not thisData.Enable) or (not callOnlyMet)) then continue end
			local directionStr = direction == 1 and 'Up' or direction == -1 and 'Down' or nil

			for i, v in pairs((value == 'Exterior' and regFloor.floorInstance or car):GetChildren()) do
				local sideData = sides[1] == 'all' and module.doorData or sides
				for i, rawSide in (sideData) do
					local side = typeof(i) == "string" and i or rawSide
					--if (v.Name ~= 'Lanterns') then continue end
					local lanternPart
					if (v.Name == 'Lanterns') or (v.Name == "Lanterns_" .. (side) and floors["Floor_" .. (floor)]:FindFirstChild((side) .. "_Doors")) then
						for _, l in pairs(v:GetChildren()) do
							if (l.Name ~= directionStr and l.Name ~= 'Both') then continue end
							for _, v in pairs(l:GetDescendants()) do
								if ((not v:IsA('BasePart')) or v.Name ~= 'Light') then continue end
								lanternPart = v
								break
							end
						end
						if ((not lanternPart) or lanternPart:GetAttribute('Is_Chiming')) then continue end
						lanternPart:SetAttribute('Is_Chiming', true)
						task.delay(thisData.Delay, addPlayingSound, lanternPart, module.sounds[(value) .. "_" .. (directionStr) .. "_Chime"], math.random(-10,10)/6000)
					end
				end
			end

		end
	end

	-- // Lantern handling // --
	function doLanterns(floor, sides, direction, indexes, cfg, requireCallOnlyParam)
		local regFloor = findRegisteredFloor(floor)
		if #sides == 0 then sides = { "all" } end
		if ((not regFloor) or (direction ~= 1 and direction ~= -1)) then return end
		for index, value in pairs(indexes) do
			local thisData = cfg[value]
			local thisCall = select(2, findCallInQueue(floor, direction))
			local callOnlyMet = (requireCallOnlyParam and thisData.Call_Only and (thisCall and table.find(thisCall.directions, direction))) or (not thisData.Call_Only) or (not requireCallOnlyParam)
			if ((not thisData) or (not thisData.Enable) or (not callOnlyMet)) then continue end
			local directionStr = direction == 1 and 'Up' or direction == -1 and 'Down' or nil
			local lanternCfgOut = configFile.Color_Database.Lanterns[value]
			local lanternCfg = lanternCfgOut[directionStr]

			task.delay(thisData.Delay, function()
				api:Fire('onElevatorLanternApi', {
					['state'] = 'active',
					['floor'] = floor,
					['sides'] = sides,
					['direction'] = string.sub(directionStr, 1, 1),
					['type'] = string.lower(value),
					['eventData'] = thisData,
					['conditionMet'] = callOnlyMet
				})
				for i, v in pairs((value == 'Exterior' and regFloor.floorInstance or car):GetChildren()) do
					local sideData = sides[1] == 'all' and module.doorData or sides
					for i, rawSide in (sideData) do
						local side = typeof(i) == "string" and i or rawSide
						if (v.Name == 'Lanterns') or (v.Name == "Lanterns_" .. (side) and floors["Floor_" .. (floor)]:FindFirstChild((side) .. "_Doors")) then
							for _, l in pairs(v:GetChildren()) do
								if (l.Name ~= directionStr and l.Name ~= 'Both') then continue end
								for _, v in pairs(l:GetDescendants()) do
									if ((not v:IsA('BasePart')) or v.Name ~= 'Light') then continue end
									v.Color = lanternCfg.Lit_State.Color
									v.Material = lanternCfg.Lit_State.Material
									for i, l in pairs(v:GetDescendants()) do
										if (not string.match(l.ClassName, 'Light')) then continue end
										l.Enabled = true
									end

									if ((not lanternCfgOut.Repeat_Data.Enable) or (not table.find(lanternCfgOut.Repeat_Data.Allowed_Directions, string.sub(directionStr, 1, 1))) or v:GetAttribute('Active')) then continue end

									v:SetAttribute('Active', true)
									task.spawn(function()
										for i = 1, lanternCfgOut.Repeat_Data.Times do
											task.wait(lanternCfgOut.Repeat_Data.Delay)
											v.Color = lanternCfg.Neautral_State.Color
											v.Material = lanternCfg.Neautral_State.Material
											for i, l in pairs(v:GetDescendants()) do
												if (not string.match(l.ClassName, 'Light')) then continue end
												l.Enabled = false
											end

											task.wait(lanternCfgOut.Repeat_Data.Delay)
											if not v:GetAttribute('Active') then break end

											v.Color = lanternCfg.Lit_State.Color
											v.Material = lanternCfg.Lit_State.Material
											for i, l in pairs(v:GetDescendants()) do
												if (not string.match(l.ClassName, 'Light')) then continue end
												l.Enabled = true
											end
										end
									end)
								end
							end
						end
					end
				end
			end)

		end
	end

	function resetLanterns(floor, side, direction, indexes)
		local regFloor = findRegisteredFloor(floor)
		if ((not regFloor) or (direction ~= 1 and direction ~= -1)) then return end
		if not side then side = 'all' end

		for index, value in pairs(indexes) do
			local directionStr = direction == 1 and 'Up' or direction == -1 and 'Down' or nil
			local lanternCfgOut = configFile.Color_Database.Lanterns[value]
			local lanternCfg = lanternCfgOut[directionStr]

			task.delay(configFile.Color_Database.Lanterns[value].Lantern_Reset_Delay, function()
				api:Fire('onElevatorLanternApi', {
					['state'] = 'neutral',
					['floor'] = floor,
					['direction'] = string.sub(directionStr, 1, 1),
					['type'] = string.lower(value)
				})

				for i, v in pairs((value == 'Exterior' and regFloor.floorInstance or car):GetChildren()) do
					local sideData = side == 'all' and module.doorData or {side}
					for i, rawSide in (sideData) do
						local side = typeof(i) == "string" and i or rawSide
						if (v.Name == 'Lanterns') or (v.Name == "Lanterns_" .. (side) and floors["Floor_" .. (floor)]:FindFirstChild((side) .. "_Doors")) then
							for _, l in pairs(v:GetChildren()) do
								if (l.Name ~= directionStr and l.Name ~= 'Both') then continue end
								for _, v in pairs(l:GetDescendants()) do
									if ((not v:IsA('BasePart')) or v.Name ~= 'Light') then continue end
									v.Color = lanternCfg.Neautral_State.Color
									v.Material = lanternCfg.Neautral_State.Material
									for i, l in pairs(v:GetDescendants()) do
										if (not string.match(l.ClassName, 'Light')) then continue end
										l.Enabled = false
									end
									v:SetAttribute('Active', false)
									v:SetAttribute('Is_Chiming', false)
								end
							end
						end
					end
				end
			end)

		end
	end

	for i, v in pairs(module.registeredFloors) do
		resetLanterns(v.floorNumber, 'all', 1, {'Exterior'})
		resetLanterns(v.floorNumber, 'all', -1, {'Exterior'})
	end
	resetLanterns(module.statValues.Raw_Floor, 'all', 1, {'Interior'})
	resetLanterns(module.statValues.Raw_Floor, 'all', -1, {'Interior'})

	-- // Button handling // --
	function setButton(button, config, state, from)
		local config = config[state]
		if (not config) then return end

		local buttonFloor = tonumber(string.split(button.Name, 'Floor')[2]) or tonumber(string.split(button.Name, 'Floor_')[2])
		local colorConfig = buttonFloor and configFile.Color_Database.Car.Custom_Color_Data[buttonFloor] or configFile.Color_Database.Car.Custom_Color_Data[tostring(buttonFloor)]
		if (colorConfig) then
			config = { Color = colorConfig[state].Color, Material = colorConfig[state].Material }
		end

		for i, v in pairs(from:GetDescendants()) do
			if (v.Name ~= button.Name) then continue end
			for _, led in pairs(v:GetDescendants()) do
				if ((not led:IsA('BasePart')) or led.Name ~= 'Light') then continue end
				led.Color = config.Color
				led.Material = config.Material
			end
		end
	end

	for _, button in pairs(elevator:GetDescendants()) do
		if (not button:FindFirstChild('Button')) then continue end
		button.Button:SetAttribute('isACortexElevButton', true)
		local buttonFloor = tonumber(string.split(button.Name, '_')[2]) or tonumber(string.split(button.Name, 'Floor')[2])
		if (buttonFloor) then
			setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
		elseif (string.match(button.Name, 'DoorOpen') or string.match(button.Name, 'Door_Open')) then
			setButton(button, configFile.Color_Database.Car.Doors.Open, 'Neutral', car)
		elseif (string.match(button.Name, 'DoorClose') or string.match(button.Name, 'Door_Close')) then
			setButton(button, configFile.Color_Database.Car.Doors.Close, 'Neutral', car)
		elseif (button.Name == 'DoorHold' or button.Name == 'Door_Hold') then
			setButton(button, configFile.Color_Database.Car.Doors.Hold, 'Neautral_State', car)
		elseif (button.Name == 'Alarm') then
			setButton(button, configFile.Color_Database.Car.Alarm_Button, 'Neautral_State', car)
		elseif (button.Name == 'CallCancel' or button.Name == 'Call_Cancel') then
			setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
		end
	end

	for i,v in pairs(module.registeredFloors) do
		for _, f in pairs(v.floorInstance:GetChildren()) do
			if (f.Name ~= 'Call_Buttons') then continue end
			for _, b in pairs(f:GetDescendants()) do
				local buttonName = string.split(b.Name, '_')[1]
				if (buttonName ~= 'Up' and buttonName ~= 'Down') then continue end
				setButton(b, configFile.Color_Database.Floor[buttonName], 'Neautral_State', b.Parent)
			end
		end
	end

	-- // Welding inspection control buttons // --
	for i,v in pairs(elevator:GetDescendants()) do
		if (v.Name ~= 'Inspection_Controls') then continue end
		for i, button in pairs(v:GetDescendants()) do
			if (button.Name ~= 'Up' and button.Name ~= 'Down' and button.Name ~= 'Stop' and button.Name ~= 'Inspection_Switch' and button.Name ~= 'Common' and button.Name ~= 'Enable' and button.Name ~= 'Alarm') then continue end
			if (button:IsA('BasePart')) then
				local model = Instance.new('Model')
				model.Name = button.Name
				model.Parent = button.Parent
				button.Name = 'Button'
				button.Parent = model
				button = model
			end
			local buttonPart
			for i, v in pairs(button:GetDescendants()) do
				if ((not v:IsA('BasePart')) or v.Name ~= 'Button') then continue end
				buttonPart = v
			end
			if (not buttonPart) then continue end

			buttonPart:SetAttribute('isACortexElevButton', true)
			for i, weld in pairs(carWeldsFolder:GetChildren()) do
				if (weld.Part0:IsDescendantOf(button)) then
					weld:Destroy()
				end
			end
			local buttonAttachment = buttonPart:FindFirstChild('Pressed_Point')
			if (not buttonAttachment) then
				buttonAttachment = Instance.new('Part')
				buttonAttachment.Name = 'Pressed_Point'
				buttonAttachment.CFrame, buttonAttachment.Size = if (button.Name == 'Inspection_Switch') then buttonPart.CFrame*CFrame.Angles(0, 0, math.rad(90)) else if (button.Name == 'Stop') then buttonPart.CFrame*CFrame.new(0, -.02, 0) else buttonPart.CFrame*CFrame.new(-.02, 0, 0), buttonPart.Size
				buttonAttachment.Transparency = 1
				buttonAttachment.CanCollide = false
				buttonAttachment.CanTouch = false
				buttonAttachment.CanQuery = false
				buttonAttachment.Parent = buttonPart

				local animWeld = weldParts(buttonAttachment, buttonAttachment, buttonPart, false, false)
				animWeld.Name = 'Button_Weld'
				animWeld:SetAttribute('down', animWeld.C1)
				animWeld:SetAttribute('up', animWeld.C0)
				weldModel(button, buttonPart, {buttonAttachment})
				weldParts(buttonAttachment, buttonAttachment, platform, true, false)
			end
		end
	end

	local function isButtonALockedFloor(tablePath, buttonFloor, buttonSide)
		for i, v in pairs(tablePath) do
			if (buttonSide and ((i == (buttonFloor) .. "_" .. (buttonSide) or i == buttonFloor) and v == true) or (not buttonSide and (string.split(i, '_')[1] == buttonFloor and v == true))) then
				return true
			end
		end

		return false
	end

	--local function isAllLockedFloorCallsInQueue(tablePath, floor, queue) -- WIP do not use
	--	for i, v in pairs(tablePath) do
	--		if string.split(i, "_")[1] == floor and not table.find(queue.sides, "0_" .. (string.split(i, "_")[2])) then
	--			print("not all in queue")
	--			return false
	--		end
	--	end
	--end

	local lastButtonPressedtick = tick()

	local function btnDelay(button: any, duration: number, callback: any, bypassCheckInRecurse: boolean?)
		if (button:GetAttribute('litDelayCooldown') and bypassCheckInRecurse == false) then return end
		button:SetAttribute('litDelayCooldown', true) -- Prevents multiple loops from running per button
		task.delay(duration, function()
			if ((tick()-lastButtonPressedtick)/duration < 1) then return btnDelay(button, duration, callback, true) end
			if (typeof(callback) == 'function') then callback() end
			button:SetAttribute('litDelayCooldown', false)
		end)
	end

	local function handleButtonInput(user, protocol, params)
		if (protocol ~= 'onButtonPressed' and protocol ~= 'onButtonReleased') then return end

		local button = params.button
		if (not button) then return end

		local buttonPart = button:FindFirstChild('Button')
		if (not buttonPart) then return end

		if (protocol == 'onButtonPressed') then
			addPlayingSound(buttonPart, buttonPart:IsDescendantOf(car) and module.sounds.Button_Beep or module.sounds.Call_Button_Beep)
		end

		local buttonFloor = tonumber(string.split(button.Name, '_')[1] == 'Floor' and string.split(button.Name, '_')[2]) or tonumber(string.split(button.Name, 'Floor')[2])
		local buttonSide = string.split(button.Name, '_')[3]

		if (buttonFloor) then -- Car Floor buttons
			local isOnFloor = (buttonFloor == module.statValues.Raw_Floor and (module.statValues.Move_Value == 0 or module.statValues.Leveling))
			local callQueue = findCallInQueue(buttonFloor) and select(2, findCallInQueue(buttonFloor))
			local callFound = callQueue and (buttonSide and table.find(callQueue.sides, "0_" .. (buttonSide)) or (not buttonSide and callQueue)) -- This works but non floor side buttons will light up but wont open all doors due to the way the queue system is scripted, this will be improved soon.
			local lockResetStatement = (isButtonALockedFloor(module.lockedCalls.car, tostring(buttonFloor), buttonSide) and not checkFireServicePhase2() and (callFound and not callQueue.isCarCall or not callFound) --[[findCallInQueue(buttonFloor)]])
			local resetStatement = (lockResetStatement or (not findRegisteredFloor(buttonFloor)) or (module.statValues.Fire_Service and not module.statValues.Phase_2) or module.statValues.Fire_Recall or module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service)

			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Floor_Button, 'Lit_State', car)
				if (resetStatement) then return end

				if (isOnFloor) then
					if moveLock then return end
					task.spawn(runDoorOpen, module.statValues.Raw_Floor, buttonSide or 'all', 'Open_No_Call')
				else
					if not findCallInQueue(buttonFloor) then
						task.delay(configFile.Sound_Database.Others.Call_Recognition_Beep.Delay, function()
							addPlayingSound(cabRegion, module.sounds.Call_Recognition_Beep)
						end)
					end
					
					local newCallAdded = addCall({call = buttonFloor, side = buttonSide, isCarCall = true})
					if ((not newCallAdded) or moveLock) then return end
					task.spawn(runChime, module.statValues.Raw_Floor, { buttonSide }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.New_Call_Input)
					task.spawn(doLanterns, module.statValues.Raw_Floor, { buttonSide }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Call_Enter)
				end
			elseif (resetStatement or isOnFloor) then
				btnDelay(button, configFile.Color_Database.Car.Lit_Delay, function() setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car) end, false)
			end
		elseif (string.match(button.Name, 'DoorOpen') or string.match(button.Name, 'Door_Open')) then -- Door Open buttons
			local side = (string.split(button.Name, 'DoorOpen')[2] and string.split(button.Name, 'DoorOpen')[1]) or (string.split(button.Name, '_Door_Open')[2] and string.split(button.Name, '_Door_Open')[1])
			if button.Name == 'Door_Open' then side = '' end
			if (not side) then return end
			side = string.split(side, '_')[1]
			if (not side) then return end
			local rawSide = side
			if (side == '') then side = 'Front' end

			local doorData = module.doorData[side]

			local Disable_Door_Open_On_Locked_Floor = configFile.Locking.Disable_Door_Open_On_Locked_Floor

			local function checkLockedStatement(doorSide)
				local doorSideData = module.doorData[doorSide]
				return (Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and not checkFireServicePhase2() and doorSideData.state == 'Closing')
					or (Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and not checkFireServicePhase2() and doorSideData.state == 'Closed')
					or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (doorSide)])) and doorSideData.state == 'Closing')
					or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (doorSide)])) and doorSideData.state == 'Closed')
			end

			--local lockResetStatement = (
			--	(Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (side)]) and not checkFireServicePhase2() and doorData.state == 'Closing')
			--		or (Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (side)]) and not checkFireServicePhase2() and doorData.state == 'Closed')
			--		or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (side)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (side)])) and doorData.state == 'Closing')
			--		or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (side)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (side)])) and doorData.state == 'Closed')
			--)
			local resetStatement = (module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service)

			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Doors.Open, 'Active', car)
				if resetStatement then return end

				doorData.buttonHold = true
				if rawSide == '' then
					for _, v in pairs(module.doorData) do
						if checkLockedStatement(v.side) then continue end
						task.spawn(runDoorOpen, module.statValues.Raw_Floor, v.side, 'Open_No_Call')
					end
				else
					if checkLockedStatement(side) then return end
					task.spawn(runDoorOpen, module.statValues.Raw_Floor, side, 'Open_No_Call')
				end
			else
				doorData.buttonHold = false
				btnDelay(button, configFile.Color_Database.Car.Lit_Delay, function() setButton(button, configFile.Color_Database.Car.Doors.Open, 'Neutral', car) end, false)
				if (checkFireServicePhase2() and doorData.state == 'Opening') then
					task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
				end
			end
		elseif (string.match(button.Name, 'DoorClose') or string.match(button.Name, 'Door_Close')) then -- Door Close buttons
			local side = (string.split(button.Name, 'DoorClose')[2] and string.split(button.Name, 'DoorClose')[1]) or (string.split(button.Name, '_Door_Close')[2] and string.split(button.Name, '_Door_Close')[1])
			if button.Name == 'Door_Close' then side = '' end
			if (not side) then return end
			side = string.split(side, '_')[1]
			if (not side) then return end
			local rawSide = side
			if (side == '') then side = 'Front' end
			local doorData = module.doorData[side]

			local resetStatement = (module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service or (module.statValues.Fire_Service and not checkFireServicePhase2()))
			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Doors.Close, 'Active', car)
				if resetStatement then return end
				if rawSide == '' then
					for _, v in pairs(module.doorData) do
						task.spawn(runDoorClose, module.statValues.Raw_Floor, v.side)
					end
				else
					task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
				end
			else
				btnDelay(button, configFile.Color_Database.Car.Lit_Delay, function() setButton(button, configFile.Color_Database.Car.Doors.Close, 'Neutral', car) end, false)
				if ((checkIndependentService() or checkFireServicePhase2())) then
					if side == '' then
						for _, v in pairs(module.doorData) do
							if v.state == 'Closing' then
								task.spawn(runDoorOpen, module.statValues.Raw_Floor, side, 'Open_No_Call')
							end
						end
					else
						if doorData.state == 'Closing' then
							task.spawn(runDoorOpen, module.statValues.Raw_Floor, side, 'Open_No_Call')
						end
					end
				end
			end
		elseif (button.Name == 'Alarm') then
			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Alarm_Button, 'Lit_State', car)
				module.sounds.Alarm.Playing = true
			else
				setButton(button, configFile.Color_Database.Car.Alarm_Button, 'Neautral_State', car)
				module.sounds.Alarm.Playing = false
				module.sounds.Alarm_Release:Play()
			end
		elseif (button.Name == 'CallCancel' or button.Name == 'Call_Cancel') then
			if (checkIndependentService() or checkFireServicePhase2()) then
				removeAllCalls()
				if (module.statValues.Move_Value ~= 0) then
					removeCall(module.statValues.Raw_Floor)
				end
			end
		end

		if (button:IsDescendantOf(floors)) then -- Hall Call buttons
			local buttonFloor = tonumber(string.split(button.Parent.Parent.Name, '_')[2]) or tonumber(string.split(button.Parent.Parent.Name, 'Floor')[2])
			local buttonName = string.split(button.Name, '_')[1]
			local buttonDirection = string.sub(buttonName, 1, 1)
			local buttonSide = string.split(button.Name, '_')[2]

			if (not buttonFloor or (buttonDirection ~= 'U' and buttonDirection ~= 'D')) then return end

			buttonDirection = buttonDirection == 'U' and 1 or buttonDirection == 'D' and -1 or nil
			local isOnFloor = (buttonFloor == module.statValues.Raw_Floor and (module.statValues.Move_Value == 0 or module.statValues.Leveling) and (module.statValues.Queue_Direction == buttonDirection or module.statValues.Queue_Direction == 0))
			local lockResetStatement = isButtonALockedFloor(module.lockedCalls.hall[string.lower(buttonName)], tostring(buttonFloor), buttonSide) --[[module.lockedCalls.hall[string.lower(buttonName)][tostring(buttonFloor)]] and (not findCallInQueue(buttonFloor, buttonDirection))
			local resetStatement = (lockResetStatement or module.statValues.Fire_Service or module.statValues.Independent_Service or module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service)

			if (protocol == 'onButtonPressed') then

				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Floor[buttonName], 'Lit_State', button.Parent)
				if (resetStatement) then return end

				if (isOnFloor) then
					task.spawn(runChime, buttonFloor, { buttonSide }, buttonDirection, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.Exterior_Call_Only)
					task.spawn(doLanterns, buttonFloor, { buttonSide }, buttonDirection, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Exterior_Call)
					for _, v in pairs(module.doorData) do
						if (not v:IsValid(module.statValues.Raw_Floor)) then continue end
						if buttonSide and buttonSide ~= v.side then continue end

						v.buttonHold = true
						if (module.statValues.Queue_Direction == 0) then
							module.statValues.Queue_Direction = buttonDirection
							task.spawn(updateStatValues)
						end

						task.spawn(runDoorOpen, module.statValues.Raw_Floor, v.side, 'Open_By_Call')
					end
				else
					local newCallAdded = addCall({call = buttonFloor, side = buttonSide, direction = buttonDirection})
				end
			elseif (resetStatement or isOnFloor) then
				for _, v in pairs(module.doorData) do
					if (not v:IsValid(module.statValues.Raw_Floor)) then continue end
					v.buttonHold = false
				end
				btnDelay(button, configFile.Color_Database.Floor.Active_Duration, function()
					setButton(button, configFile.Color_Database.Floor[buttonName], 'Neautral_State', button.Parent)
				end, false)
			end
		elseif (button:FindFirstAncestor('Inspection_Controls')) then
			if (inspectionLocked) then return end
			if (button.Name == 'Stop') then
				if (protocol == 'onButtonPressed') then
					local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
					if (not animWeld) then return end
					tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = module.statValues.Stop and animWeld:GetAttribute('up') or animWeld:GetAttribute('down')}):Play()
					api:Fire('Stop', not module.statValues.Stop)
				end
			elseif (button.Name == 'Inspection_Switch') then
				if (protocol == 'onButtonPressed') then
					local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
					if (not animWeld) then return end
					tweenService:Create(animWeld, TweenInfo.new(.15, Enum.EasingStyle.Linear), {C0 = module.statValues.Inspection and animWeld:GetAttribute('up') or animWeld:GetAttribute('down')}):Play()
					api:Fire('Inspection_Service', not module.statValues.Inspection)
				end
			elseif (button.Name == 'Alarm') then
				local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
				if (not animWeld) then return end
				tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = protocol == 'onButtonPressed' and animWeld:GetAttribute('down') or animWeld:GetAttribute('up')}):Play()
				module.sounds.Alarm.Playing = protocol == 'onButtonPressed'
				if protocol == 'onButtonReleased' then
					module.sounds.Alarm_Release:Play()
				end
			elseif (button.Name == 'Enable' or button.Name == 'Common') then
				if (protocol == 'onButtonPressed') then
					local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
					if (not animWeld) then return end
					inspectionEnabled = not inspectionEnabled
					tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = inspectionEnabled and animWeld:GetAttribute('down') or animWeld:GetAttribute('up')}):Play()
				end
			elseif (button.Name == 'Up' or button.Name == 'Down') then
				local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
				if (not animWeld) then return end
				tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = protocol == 'onButtonPressed' and animWeld:GetAttribute('down') or animWeld:GetAttribute('up')}):Play()
				if (protocol == 'onButtonPressed') then
					if inspectionEnabled then
						api:Fire('Inspection_Service_Move', { ['direction'] = string.sub(button.Name, 1, 1), ['maxSpeed'] = configFile.Movement.Inspection_Config.Max_Speed})
					end
				else
					if inspectionEnabled then
						api:Fire('Inspection_Service_Stop', true)
					end
				end
			end
		end
	end

	local inspectionStopped = signal.new()

	api.Event:Connect(function(protocol, params, ...)
		handleButtonInput(nil, protocol, params)

		if (protocol == 'Add_Call' or protocol == 'Request_Call_F' or protocol == 'Add_Hall_Call' or protocol == 'addHallCall') then
			local call = typeof(params) == 'table' and (tonumber(params.call) or tonumber(params.floor)) or (typeof(params) == 'number') and params or nil
			if (not call) then return end
			if ((typeof(params) == 'table' and not params.bypassFireRecall or true) and (module.statValues.Fire_Recall or module.statValues.Phase_1)) then return end

			--if params.floor and not params.call then params.call = params.floor end -- Legacy API support
			local direction = typeof(params) == 'table' and (if (typeof(params.direction) == 'string') then params.direction == 'U' and 1 or params.direction == 'D' and -1 or 0 else params.direction) or if (typeof(... and select(1, ...)) == 'number') then ... and select(1, ...) else nil

			local isOnFloor = (call == module.statValues.Raw_Floor and (module.statValues.Move_Value == 0 or module.statValues.Leveling) and (module.statValues.Queue_Direction == direction or module.statValues.Queue_Direction == 0 or (not direction)))
			if (isOnFloor) then
				task.spawn(runChime, call, { typeof(params) == 'table' and params.side or 'all' }, direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.Exterior_Call_Only)
				task.spawn(doLanterns, call, { typeof(params) == 'table' and params.side or 'all' }, direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Exterior_Call)

				task.spawn(runDoorOpen, module.statValues.Raw_Floor, typeof(params) == 'table' and params.side or 'all', 'Open_By_Call')
				module.statValues.Queue_Direction = direction or call > module.statValues.Raw_Floor and 1 or call < module.statValues.Raw_Floor and -1 or 0
				task.spawn(updateStatValues)
				api:Fire('onCallRespond', { floor = module.statValues.Raw_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })
			else
				addCall({call = call, direction = direction, side = typeof(params) == 'table' and params.side, isCarCall = typeof(params) == 'table' and params.isCarCall or (not direction), bypassFireRecall = typeof(params) == 'table' and params.bypassFireRecall or false})
				if (typeof(params) == 'table' and params.activateCarButtons == true) then
					local carButton = car:FindFirstChild('Buttons') and (car.Buttons:FindFirstChild("Floor" .. (call)) or car.Buttons:FindFirstChild("Floor_" .. (call)))
					if (not carButton) then return end
					setButton(carButton, configFile.Color_Database.Car.Floor_Button, 'Lit_State', car)
				end
			end
		elseif (protocol == 'Independent_Service' or protocol == 'invokeIndependentService' or protocol == 'invokeIS') then
			setIndependentService(params)
		elseif (protocol == 'Fire_Recall' or protocol == 'Fire_Service_Phase_1') then
			if (typeof(params) ~= 'table') then
				params = {
					floor = ... and select(1, ...),
					enable = params
				}
			end

			fireRecall(params.enable, params.floor)
		elseif (protocol == 'Phase_2' or protocol == 'Fire_Service_Phase_2') then
			--outputElevMessage((module.MODULE_STORAGE.statValues.phase1) .. ", " .. (module.MODULE_STORAGE.statValues.phase2), 'debug')
			module.statValues.Phase_2 = params
			task.spawn(updateStatValues)
			if (module.statValues.Fire_Service and not module.statValues.Phase_2) then
				fireRecall(false, fireServiceRecallFloor)
				fireRecall(true, fireServiceRecallFloor)
			end
		elseif (protocol == 'Stop') then
			if (params) then
				removeAllCalls()
				module.statValues.Stop = true
				safetyBraking = false
				for i, v in pairs(module.doorData) do
					if (v.state == 'Opening' or v.state == 'Closing') then
						for _, vl in pairs(v.velocity) do
							v.velocity[_] = 0
						end
						v.state = 'Stopped'
						module.statValues[(v.sideJoin) .. "Door_State"] = v.state
					end
				end
				task.spawn(updateStatValues)
				safetyBrake()
				playerWeld(false)
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Out_Of_Service_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Out_Of_Service_Announcement.Enabled)
			else
				if (not module.statValues.Stop) then return end
				moveLock = false
				module.statValues.Stop = false
				while (safetyBraking) do task.wait() end
				task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
				task.spawn(updateStatValues)
			end
		elseif (protocol == 'Inspection_Service' or protocol == 'setInspection') then
			if (params) then
				task.spawn(safetyBrake)
				playerWeld(false)
				module.statValues.Inspection = true

				if (not checkDoorStates('Closed', {dontRequireAll = false, onlyPresentDoors = true})) then
					module.statValues.Nudge = true
				end

				for i, v in pairs(module.doorData) do
					if (v.state == 'Closed') then continue end
					v.nudging = true
				end
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Inspection_Service_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Inspection_Service_Announcement.Enabled)
			else
				if (not module.statValues.Inspection) then return end
				module.statValues.Inspection = false
				moveLock = false
				while (safetyBraking) do task.wait() end
				task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
			end
			task.spawn(updateStatValues)
		elseif (protocol == 'Inspection_Service_Lock' or protocol == 'inspectionLock') then
			inspectionLocked = params
		elseif (protocol == 'Inspection_Service_Common') then
			inspectionEnabled = params
		elseif (protocol == 'Inspection_Service_Move' or protocol == 'inspectionMove') then
			if ((not module.statValues.Inspection)) then return end -- // Inspection is not enabled! Do not run inspection

			if not params.direction then
				params.direction = params[1] == 'Up' and 'U' or params[1] == 'Down' and 'D'
			end
			if not params.maxSpeed then
				params.maxSpeed = params[2]
			end

			local moveDir = params.direction == 'U' and 1 or params.direction == 'D' and -1 or nil

			pcall(task.cancel, inspectionStopThread)
			inspectionMoveThread = task.spawn(function()
				if (inspectionMoving and module.statValues.Move_Value ~= moveDir or inspectionStopping) then
					api:Fire('Inspection_Service_Stop')
					inspectionStopped:Wait()
				end
				if ((moveDir == 1 and level.Position.Y >= topFloor.level.Position.Y+1.5) or (moveDir == -1 and level.Position.Y <= bottomFloor.level.Position.Y-1.5)) then return end

				module.statValues.Move_Value = moveDir
				module.statValues.Move_Direction = moveDir
				updateStatValues()

				inspectionMoving = true

				local initialSpeed = module.statValues.Current_Speed
				local finalSpeed = params.maxSpeed or configFile.Movement.Inspection_Config.Max_Speed
				local duration = coreFunctions.getAccelerationTime(initialSpeed, finalSpeed, configFile.Movement.Inspection_Config.Accceleration_Rate)
				local startTime = os.clock()
				while (inspectionMoving) do
					module.statValues.Current_Speed = coreFunctions.lerp(initialSpeed, finalSpeed, math.min((os.clock()-startTime)/duration, 1))
					updateStatValues()
					local dtTime, carMovementDirection = moveElevator(heartbeat:Wait())
					if ((carMovementDirection == 1 and level.Position.Y >= topFloor.level.Position.Y+1.5) or (carMovementDirection == -1 and level.Position.Y <= bottomFloor.level.Position.Y-1.5)) then
						safetyBraking = false
						safetyBrake()
						playerWeld(false)
					end
				end
			end)

		elseif (protocol == 'Inspection_Service_Stop' or protocol == 'inspectionStop') then
			if ((not module.statValues.Inspection)) then return end -- // Inspection is not enabled! Do not run inspection
			pcall(task.cancel, inspectionMoveThread)
			inspectionStopThread = task.spawn(function()
				local initialSpeed = module.statValues.Current_Speed
				local duration = coreFunctions.getAccelerationTime(initialSpeed, 0, configFile.Movement.Inspection_Config.Deceleration_Rate)
				local startTime = os.clock()
				inspectionMoving = false
				inspectionStopping = true
				while ((os.clock()-startTime)/duration < 1) do
					module.statValues.Current_Speed = coreFunctions.lerp(initialSpeed, 0, math.min((os.clock()-startTime)/duration, 1))
					updateStatValues()
					moveElevator(heartbeat:Wait())
				end
				module.statValues.Move_Value = 0
				module.statValues.Current_Speed = 0
				updateStatValues()
				inspectionStopping = false
				inspectionStopped:Fire()
			end)

		elseif (protocol == 'Lock_Floors') then
			if (typeof(params) ~= 'table') then return --[[debugWarn((event) .. " API :: Paramrters is not of type table")]] end
			--outputElevMessage("Elevator floors locked with calls " .. (table.concat(params, ', ')), 'debug')
			for _, v in pairs(params) do
				module.lockedCalls.car[tostring(v)] = true
			end
		elseif (protocol == 'Unlock_Floors') then
			if (typeof(params) ~= 'table') then return --[[debugWarn((event) .. " API :: Paramrters is not of type table")]] end
			--outputElevMessage("Elevator floors unlocked with calls " .. (table.concat(params, ', ')), 'debug')
			for _, v in pairs(params) do
				module.lockedCalls.car[tostring(v)] = false
			end
		elseif (protocol == 'Lock_Hall_Floors') then
			--if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
			--outputElevMessage("Elevator floors hall locked with calls " .. (table.concat(params, ', ')), 'debug')
			if params['up'] then
				for _, v in pairs(params.up) do
					module.lockedCalls.hall.up[tostring(v)] = true
				end
			end

			if params['down'] then
				for _, v in pairs(params.down) do
					module.lockedCalls.hall.down[tostring(v)] = true
				end
			end

			if not params['up'] and not params['down'] then
				for _, v in pairs(params) do
					if tonumber(v) then
						module.lockedCalls.hall.up[tostring(v)] = true
						module.lockedCalls.hall.down[tostring(v)] = true
					end
				end
			end
		elseif (protocol == 'Unlock_Hall_Floors') then
			--if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
			--outputElevMessage("Elevator floors hall locked with calls " .. (table.concat(params, ', ')), 'debug')
			if (params['up']) then
				for _, v in pairs(params.up) do
					module.lockedCalls.hall.up[tostring(v)] = false
				end
			end
			if (params['down']) then
				for _, v in pairs(params.down) do
					module.lockedCalls.hall.down[tostring(v)] = false
				end
			end
			if ((not params['up']) and (not params['down'])) then
				for _, v in pairs(params) do
					if tonumber(v) then
						module.lockedCalls.hall.up[tostring(v)] = false
						module.lockedCalls.hall.down[tostring(v)] = false
					end
				end
			end
		elseif (protocol == 'Door_Open') then
			runDoorOpen(module.statValues.Raw_Floor, typeof(params) == 'table' and params or 'ALL')
		elseif (protocol == 'Door_Close') then
			runDoorClose(module.statValues.Raw_Floor, typeof(params) == 'table' and params or 'ALL')
		elseif (protocol == 'Door_Nudge') then
			runDoorClose(module.statValues.Raw_Floor, typeof(params) == 'table' and params or 'ALL', true)
		elseif (protocol == 'Fire_Button_Event') then
			handleButtonInput(nil, params.protocol, { ['button'] = params.button })
		elseif (protocol == 'Drop_Key_Toggle' or protocol == 'dropKeyToggle') then
			doDropKey(params)
		end
	end)

	remote.OnServerEvent:Connect(function(user, protocol, params)
		handleButtonInput(user, protocol, params)
		if (protocol == 'dropKeyToggle') then
			local isHoldingKey = user.Character and user.Character:FindFirstChild('Drop Key')
			if (not isHoldingKey) then return end
			doDropKey(params)
		elseif (protocol == 'addDropKeyGuiToPlayer') then
			local containsDropKey
			for i,v in pairs(user.Character:GetChildren()) do
				if (v.Name == 'Drop Key' or v:FindFirstChild('Cortex_Drop_Key')) then
					containsDropKey = v
					break
				end
			end
			local isHoldingKey = user.Character and containsDropKey
			if (not isHoldingKey) then return end
			if (user.PlayerGui:FindFirstChild('DOOR_KEY_UI')) then return end
			local doorSet = params
			local thisFloorName = doorSet:IsDescendantOf(floors) and string.split(doorSet.Parent.Name, 'Floor_')[2]
			local landingLevel = doorSet.Parent.Level
			local sideIndex = doorSet.Name:split('Doors')[1]:split('_')[1]
			local fullSideName = (sideIndex == '' and 'Front' or sideIndex)
			local data = module.doorData[sideIndex]
			if (collectionService:HasTag(doorSet, 'IsInUse') or table.find(dropKeyHandlers,user) or (not ((landingLevel:IsDescendantOf(car) and data.state == 'Closed') or ((not landingLevel:IsDescendantOf(car)) and ((data.state == 'Closed' and tonumber(landingLevel.Parent.Name:sub(7)) == module.statValues.Raw_Floor) or tonumber(landingLevel.Parent.Name:sub(7)) ~= module.statValues.Raw_Floor))))) then return end
			table.insert(dropKeyHandlers,user)
			collectionService:AddTag(doorSet, 'IsInUse')
			local boundsCFrame,boundsSize = doorSet:GetBoundingBox()
			local doorBounds = doorSet:FindFirstChild('Door_Bounds')
			if (not doorBounds) then
				doorBounds = Instance.new('Part')
				doorBounds.Name = 'Door_Bounds'
				doorBounds.CFrame,doorBounds.Size = boundsCFrame,boundsSize
				doorBounds.CanCollide = false
				doorBounds.CanTouch = false
				doorBounds.CanQuery = false
				doorBounds.Transparency = 1
				weldParts(doorBounds, doorBounds, landingLevel, true, false)
				doorBounds.Anchored = false
				doorBounds.Parent = doorSet
			end
			local gui = dependencies.DOOR_KEY_UI:Clone()
			gui.DOOR_SET.Value = doorSet
			gui.Adornee = doorBounds
			gui.Enabled = true
			gui.Parent = user.PlayerGui:WaitForChild('DOOR_KEY_UIS')
			collectionService:AddTag(gui,'ACTIVE')
			local function getOrientation(cf)
				return cf:ToOrientation()
			end
			local welds = {}
			for i,v in next,data and (doorSet:IsDescendantOf(car) and car.Door_Engine_Welds:FindFirstChild(sideIndex):GetChildren() or findRegisteredFloor(thisFloorName).floorInstance:FindFirstChild('Door_Engine_Welds'):FindFirstChild(sideIndex):GetChildren()) or {} do
				table.insert(welds, v)
			end
			local function checkIfDoorIsClosed()
				for i,v in pairs(welds) do
					if (v.C0 ~= v:GetAttribute('closedPoint')) then return false end
				end
				return true
			end
			addPlayingSound(landingLevel, addSound(landingLevel, 'Interlock_Click', {
				Sound_Id = 9116323848,
				Volume = 1,
				Pitch = 1.35
			}, false, 40, 3))
			for i,v in pairs(module.doorData) do
				v.nudging = false
			end
			module.statValues.Nudge = false
			task.spawn(updateStatValues)
			local val = gui:WaitForChild('RATIO')
			local hasStopped = false
			local lastChecked = checkIfDoorIsClosed()
			api:Fire('onElevDoorKey',{doorSet=doorSet,status='insert'})

			local update: RBXScriptConnection
			update = heartbeat:Connect(function(dtTime)
				local value = val.Value
				for i,weld in pairs(welds) do
					weld.C0 = weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'),value)
				end
				local checked = checkIfDoorIsClosed()
				if (lastChecked ~= checked) then
					lastChecked = checked
					data.isEnabled = checked
					if (not checked) then
						if (not hasStopped) then
							hasStopped = true
							module.statValues.Out_Of_Service = true
							module.sounds.Safety_Brake_Sound.PlaybackSpeed = module.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
							task.spawn(safetyBrake)
							playerWeld(false)
						end
					else
						hasStopped = false
						module.statValues.Out_Of_Service = not checkDropKeyState()
						if (not module.statValues.Out_Of_Service) then
							task.spawn(function()
								local isCompleted = coreFunctions.conditionalWait(1, function() return {module.statValues.Out_Of_Service} end)
								if (not isCompleted) then return end
								--task.spawn(safeCheckRelevel)
							end)
						end
						task.spawn(updateStatValues)
					end
				end
			end)
			if (not dropKeyHandlers[doorSet]) then dropKeyHandlers[doorSet] = {} end
			table.insert(dropKeyHandlers[doorSet], update)
		elseif (protocol == 'exit') then
			for i,v in pairs(user.PlayerGui:WaitForChild('DOOR_KEY_UIS'):GetChildren()) do
				if (collectionService:HasTag(v,'ACTIVE')) then
					v:Destroy()
				end
			end
			dismountDropKeyClient(user, params)
		end
	end)

	function elevatorSignal.OnInvoke(protocol, params)
		if (protocol == 'GET_ELEVATOR_WELDS') then
			return elevatorPlayerWelds
		end
	end

	players.PlayerRemoving:Connect(function(plr: Player)
		if (not table.find(dropKeyHandlers,plr)) then return end
		for i,v in pairs(collectionService:GetTagged('IsInUse')) do
			if (v:IsDescendantOf(elevator)) then
				dismountDropKeyClient(plr,v)
			end
		end
	end)

	api:Fire('Lock_Floors', (configFile.Locking.Locked_Floors) or {})
	api:Fire('Lock_Hall_Floors', (configFile.Locking.Locked_Hall_Floors) or {})

	task.spawn(updateFloor)
	task.spawn(updateStatValues)
	parkTimer()
end

return module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX9837AE849A0746C7A88FF81DE1CABA6F">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Dependencies</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXC489DA6CFBEE4283AB1BF3B7C7EB56C0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ConfigFile</string>
								<string name="ScriptGuid">{9623C30B-3FDB-4361-8114-31F659D159EE}</string>
								<ProtectedString name="Source"><![CDATA[return function(config, coreScript)
	local DefaultConfig = {
		['Doors'] = {
			['Door_Open_Speed'] = config.Doors.Door_Open_Speed, -- Doors take 1.68 seconds to open fully.
			['Door_Close_Speed'] = config.Doors.Door_Close_Speed, -- Doors take 2.48 seconds to close fully.
			['Door_Close_Delay'] = config.Doors.Door_Close_Delay or 0,
			['Nudge_Speed'] = config.Doors.Nudge_Speed or config.Doors.Door_Close_Speed,

			['Door_Timers'] = {
				['Open_No_Call'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Open_No_Call) == 'number') then config.Doors.Door_Timers.Open_No_Call else config.Doors.Door_Timer,
				['Open_On_Stop'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Open_On_Stop) == 'number') then config.Doors.Door_Timers.Open_On_Stop else config.Doors.Door_Timer,
				['Open_By_Call'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Open_By_Call) == 'number') then config.Doors.Door_Timers.Open_By_Call else config.Doors.Door_Timer,
				['Handicap_Call'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Handicap_Call) == 'number') then config.Doors.Door_Timers.Handicap_Call else config.Doors.Door_Timer,
			},
			['Nudge_Timer'] = config.Doors.Nudge_Timer,

			['Use_Old_Door_Sensors'] = config.Doors.Use_Old_Door_Sensors,

			['Open_Easing_Style'] = config.Doors.Open_Easing_Style or 'In_Out_Quad',
			['Close_Easing_Style'] = config.Doors.Close_Easing_Style or 'In_Out_Sine',

			['Door_Sensors'] = config.Doors.Door_Sensors,

			['Door_Open_Delay_Pattern'] = config.Doors.Door_Open_Delay_Pattern, -- Example: ['Door_Open_Delay_Pattern'] = {'Outer', 'Inner'} - Outer doors open, then the inner doors
			['Door_Close_Delay_Pattern'] = config.Doors.Door_Close_Delay_Pattern, -- Example: ['Door_Close_Delay_Pattern'] = {'Inner', 'Outer'} - Inner doors close, then the outer doors

			['Door_Open_Pattern_Delay'] = config.Doors.Door_Open_Pattern_Delay,
			['Door_Close_Pattern_Delay'] = config.Doors.Door_Close_Pattern_Delay,

			['Door_Delay_Sequence_Config'] = {
				['Opening'] = {
					['Enable'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Enable) == 'boolean') then config.Doors.Door_Delay_Sequence_Config.Opening.Enable elseif (typeof(config.Doors.Door_Open_Delay_Pattern) == 'table') then config.Doors.Door_Open_Delay_Pattern ~= nil else false, --// Enable or disable the door delay sequence
					['Sequence_Order'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) == 'table') then config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order elseif (typeof(config.Doors.Door_Open_Delay_Pattern) == 'table') then config.Doors.Door_Open_Delay_Pattern else {'Outer', 'Inner'}, --// [Inner, Outer] - The order in which each door opens
					['Delay'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Delay) == 'number') then config.Doors.Door_Delay_Sequence_Config.Opening.Delay elseif (typeof(config.Doors.Door_Open_Pattern_Delay) == 'number') then config.Doors.Door_Open_Speed-config.Doors.Door_Open_Pattern_Delay else 1, --// Delay in seconds the door delay lasts
				},
				['Closing'] = {
					['Enable'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Enable) == 'boolean') then config.Doors.Door_Delay_Sequence_Config.Closing.Enable elseif (typeof(config.Doors.Door_Close_Delay_Pattern) == 'table') then config.Doors.Door_Close_Delay_Pattern ~= nil else false, --// Enable or disable the door delay sequence
					['Sequence_Order'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) == 'table') then config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order elseif (typeof(config.Doors.Door_Close_Delay_Pattern) == 'table') then config.Doors.Door_Close_Delay_Pattern else {'Outer', 'Inner'}, --// [Inner, Outer] - The order in which each door opens
					['Delay'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Delay) == 'number') then config.Doors.Door_Delay_Sequence_Config.Closing.Delay elseif (typeof(config.Doors.Door_Close_Pattern_Delay) == 'number') then config.Doors.Door_Close_Speed-config.Doors.Door_Close_Pattern_Delay else 1, --// Delay in seconds the door delay lasts
				},
			},

			['Door_Close_Button_Delay'] = if (typeof(config.Doors.Door_Close_Button_Delay) == 'number') then config.Doors.Door_Close_Button_Delay else 0,

			['Sensor_LED_Data'] = {

				['Opening_Color'] = {
					['Delay'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Delay or .25,
					['Tween_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Tween_Time or .035, --Time in seconds for the sensor LED to change color
					['Flash_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Flash_Time or .15, --Time in seconds for flashing
					['Behavior'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Behavior or 'Solid', --Flash/Solid
					['Active'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Active.Color or Color3.fromRGB(77, 194, 56),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Active.Material or Enum.Material.Neon,
					},
					['Inactive'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color or Color3.fromRGB(50, 50, 50),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material or Enum.Material.SmoothPlastic,
					},
				},
				['Closing_Color'] = {
					['Delay'] = if (typeof(config.Doors.Sensor_LED_Data) == 'table' and typeof(config.Doors.Sensor_LED_Data.Closing_Color.Delay) == 'number') then config.Doors.Sensor_LED_Data.Closing_Color.Delay else .25,
					['Tween_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Tween_Time or .035, --Time in seconds for the sensor LED to change color
					['Flash_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Flash_Time or .15, --Time in seconds for flashing
					['Behavior'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Behavior or 'Flash', --Flash/Solid
					['Active'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Active.Color or Color3.fromRGB(194, 81, 52),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Active.Material or Enum.Material.Neon,
					},
					['Inactive'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Inactive.Color or Color3.fromRGB(50, 50, 50),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Inactive.Material or Enum.Material.SmoothPlastic,
					},
				},

			},
			['Realistic_Doors_Data'] = {
				['Enable_Open'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Enable_Open or false,
				['Enable_Close'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Enable_Close or false,
				['Open_Time'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Time or .5,
				['Close_Time'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Time or .6,
				['Open_Easing_Style'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Easing_Style or 'Linear',
				['Close_Easing_Style'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Easing_Style or 'Linear',
				['Open_Ratio'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Ratio and math.clamp(config.Doors.Realistic_Doors_Data.Open_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Close_Ratio'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Ratio and math.clamp(config.Doors.Realistic_Doors_Data.Close_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Open_Delay'] = {
					['Enable'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Delay and config.Doors.Realistic_Doors_Data.Open_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Delay and config.Doors.Realistic_Doors_Data.Open_Delay.Duration or 0,
				},
				['Close_Delay'] = {
					['Enable'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Delay and config.Doors.Realistic_Doors_Data.Close_Delay.Enable or config.Doors.Door_Close_Delay and config.Doors.Door_Close_Delay > 0 or false,
					['Duration'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Delay and config.Doors.Realistic_Doors_Data.Close_Delay.Duration or config.Doors.Door_Close_Delay and config.Doors.Door_Close_Delay or 0,
				},
			},
			['Realistic_Outer_Doors_Data'] = {
				['Enable_Open'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Enable_Open or false,
				['Enable_Close'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Enable_Close or false,
				['Open_Time'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Time or .5,
				['Close_Time'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Time or .6,
				['Open_Easing_Style'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Easing_Style or 'Linear',
				['Close_Easing_Style'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Easing_Style or 'Linear',
				['Open_Ratio'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Ratio and math.clamp(config.Doors.Realistic_Outer_Doors_Data.Open_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Close_Ratio'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Ratio and math.clamp(config.Doors.Realistic_Outer_Doors_Data.Close_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Open_Delay'] = {
					['Enable'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Delay and config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Delay and config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Duration or 0,
				},
				['Close_Delay'] = {
					['Enable'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Delay and config.Doors.Realistic_Outer_Doors_Data.Close_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Delay and config.Doors.Realistic_Outer_Doors_Data.Close_Delay.Duration or 0,
				},
			},

			['Door_Motor'] = if (typeof(config.Doors.Door_Motor) == 'boolean') then config.Doors.Door_Motor else true,

			['Open_Delay'] = if (typeof(config.Doors.Open_Delay) == 'number') then config.Doors.Open_Delay else 0,
			['Reopen_Delay'] = if (typeof(config.Doors.Reopen_Delay) == 'number') then config.Doors.Reopen_Delay else .5,
			['Close_Delay'] = if (typeof(config.Doors.Close_Delay) == 'number') then config.Doors.Close_Delay else 0,

			['Reopen_When_Nudge_Obstruction'] = config.Doors.Reopen_When_Nudge_Obstruction,
			['Hold_On_Nudge_Obstruction'] = config.Doors.Reopen_When_Nudge_Obstruction,

			['Stay_Open_When_Idle'] = config.Doors.Stay_Open_When_Idle,

			['Close_On_Button_Press'] = {
				['Enable'] = if (typeof(config.Doors.Close_On_Button_Press) == 'table' and typeof(config.Doors.Close_On_Button_Press.Enable) == 'boolean') then config.Doors.Close_On_Button_Press.Enable else false,
				['Delay'] = if (typeof(config.Doors.Close_On_Button_Press) == 'table' and typeof(config.Doors.Close_On_Button_Press.Delay) == 'number') then config.Doors.Close_On_Button_Press.Delay else 0,
			},

			['Disable_Door_Close'] = if (typeof(config.Doors.Disable_Door_Close) == 'boolean') then config.Doors.Disable_Door_Close else false,

			['Manual_Door_Controls'] = config.Doors.Manual_Door_Controls,

			['Custom_Door_Operator_Config'] = {

				['Inner'] = {
					['Opening'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Offset
							else 0,
					},
					['Closing'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Offset
							else 0,
					},
				},
				['Outer'] = {
					['Opening'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Offset
							else 0,
					},
					['Closing'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Offset
							else 0,
					},
				},

			},

			['Door_Open_Sound_Delay'] = if (typeof(config.Doors.Door_Open_Sound_Delay) == 'number') then config.Doors.Door_Open_Sound_Delay elseif (typeof(config.Doors.Open_Delay) == 'number') then config.Doors.Open_Delay else 0,
			['Door_Close_Sound_Delay'] = if (typeof(config.Doors.Door_Close_Sound_Delay) == 'number') then config.Doors.Door_Close_Sound_Delay elseif (typeof(config.Doors.Close_Delay) == 'number') then config.Doors.Close_Delay else 0,

			['New_Attachment_Doors_Config'] = {
				['Enable'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Enable) == 'boolean') then config.Doors.New_Attachment_Doors_Config.Enable else false, -- When enabled, the outer doors will be "attached" to the inner doors instead of running independently
				['Attachment_Threshold'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Attachment_Threshold) == 'number') then config.Doors.New_Attachment_Doors_Config.Attachment_Threshold else .05, -- Offset in studs the outer doors are positioned when moving with the inner doors
				['Closing_Min_Threshold'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold) == 'number') then config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold else 0, -- Minimum distance in studs the doors can be from the closing position before the elevator is able to move
			},

		},
		['Movement'] = {
			['Movement_Type'] = config.Movement.Movement_Type or 1, --[1]: CFrame  [2]: AlignPosition

			['Weld_On_Move'] = config.Movement.Weld_On_Move,
			['Disable_Jumping'] = config.Movement.Disable_Jumping or false,
			--['Use_New_Welding'] = config.Movement.Weld_On_Move and ((config.Movement.Weld_On_Move ~= nil and config.Movement.Weld_On_Move) or (config.Movement.Weld_On_Move == nil and false)) or false,
			['Use_New_Welding'] = config.Movement.Use_New_Welding or false,
			--['Use_New_Welding'] = false,
			['Enable_New_Player_Sticking'] = if (typeof(config.Movement.Enable_New_Player_Sticking) == 'boolean') then config.Movement.Enable_New_Player_Sticking else false,

			['Start_Delay'] = config.Movement.Start_Delay,
			['Down_Start_Delay'] = if (typeof(config.Movement.Down_Start_Delay) == 'number') then config.Movement.Down_Start_Delay else config.Movement.Start_Delay,
			
			['Motor_Start_Delay'] = {
				['Up'] = if (typeof(config.Movement.Motor_Start_Delay) == 'table' and typeof(config.Movement.Motor_Start_Delay.Up) == 'number') then config.Movement.Motor_Start_Delay.Up else 0,
				['Down'] = if (typeof(config.Movement.Motor_Start_Delay) == 'table' and typeof(config.Movement.Motor_Start_Delay.Down) == 'number') then config.Movement.Motor_Start_Delay.Down else 0,
			},

			['Use_Dynamic_Acceleration'] = config.Movement.Use_Dynamic_Acceleration,
			['Dynamic_Acceleration_Time'] = if (typeof(config.Movement.Dynamic_Acceleration_Time) == 'number') then config.Movement.Dynamic_Acceleration_Time else .75,

			['Acceleration'] = config.Movement.Acceleration,
			['Down_Acceleration'] = config.Movement.Down_Acceleration or config.Movement.Acceleration,

			['Travel_Speed'] = config.Movement.Travel_Speed,
			['Level_Speed'] = config.Movement.Level_Speed,
			['Floor_Pass_Chime_On_Stop'] = if (typeof(config.Movement.Floor_Pass_Chime_On_Stop) == 'boolean') then config.Movement.Floor_Pass_Chime_On_Stop else false,

			['Braking_Data'] = {
				['Mode'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Mode) == 'string') then if (config.Movement.Braking_Data.Mode == 'Auto') then 'Default' else config.Movement.Braking_Data.Mode elseif (typeof(config.Movement.Braking_Mode) == 'string') then if (config.Movement.Braking_Mode == 'Auto') then 'Default' else config.Movement.Braking_Mode else 'Linear',
					['Increment'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Increment) == 'number') then config.Movement.Braking_Data.Increment elseif (typeof(config.Movement.Braking_Amount) == 'number') then config.Movement.Braking_Amount else 0,
					['Linear_Mode_Offset_Up'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset_Up) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset_Up elseif (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset else 0,
					['Linear_Mode_Offset_Down'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset_Down) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset_Down elseif (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset else 0,

					['Advanced_Leveling'] = {
						['Stage_1_Min_Speed'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Advanced_Leveling and config.Movement.Braking_Data.Advanced_Leveling.Stage_1_Min_Speed or 1+config.Movement.Level_Speed*2.0,
						['Stage_2_Decel_Offset'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Advanced_Leveling and config.Movement.Braking_Data.Advanced_Leveling.Stage_2_Decel_Offset or 1.6,
					},
					['Smart_Linear_Transition_Dist'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Smart_Linear_Transition_Dist or 1.75,

					['Custom_Leveling_Stages'] = config.Movement.Braking_Data and typeof(config.Movement.Braking_Data.Custom_Leveling_Stages) == 'table' and config.Movement.Braking_Data.Custom_Leveling_Stages or {},

			},

			['Jolt_Start_Data'] =
				{
					['Enable'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Enable,
					['Ratio'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Ratio or 1,
					['Depth'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Depth or -1,
					['Speed'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Speed or .4,
					['Start_Delay'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Start_Delay or 0
				},

			['Bounce_Stop_Config'] = {
				['Enable'] = if (typeof(config.Movement.Bounce_Stop_Config) == 'table' and typeof(config.Movement.Bounce_Stop_Config.Enable) == 'boolean') then config.Movement.Bounce_Stop_Config.Enable elseif (typeof(config.Movement.Bounce_Stop) == 'string') then config.Movement.Bounce_Stop == 'Enable' and true or false else false,
				['Amount'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Amount or .5,
				['Times'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Times or 1,
				['Stop_Sound'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Stop_Sound or {['Enable']=false,['Sound_Id']=0,['Volume']=0,['Pitch']=0},
			},
			['Motor_Stop_On_Open'] = config.Movement.Motor_Stop_On_Open or false,

			['Enable_Smooth_Stop'] = if (typeof(config.Movement.Enable_Smooth_Stop) == 'boolean') then config.Movement.Enable_Smooth_Stop else false,
			['Smooth_Stop_Min_Speed'] = typeof(config.Movement.Smooth_Stop_Min_Speed) ~= 'number' and .0025 or config.Movement.Smooth_Stop_Min_Speed,
			-- ! SMOOTH STOP OVERHAUL - NOW AS A THRESHOLD VALUE ! --
			['Smooth_Stop_Threshold'] = typeof(config.Movement.Smooth_Stop_Threshold) == 'number' and config.Movement.Smooth_Stop_Threshold or .15, -- Distance in studs from the floor that the elevator comes to a gradual stop

			['Smooth_Stop_V2'] = {
				['Enable'] = if (typeof(config.Movement.Smooth_Stop_V2) == 'table' and typeof(config.Movement.Smooth_Stop_V2.Enable) == 'boolean') then config.Movement.Smooth_Stop_V2.Enable else false,
				['Threshold'] = if (typeof(config.Movement.Smooth_Stop_V2) == 'table' and typeof(config.Movement.Smooth_Stop_V2.Threshold) == 'number') then config.Movement.Smooth_Stop_V2.Threshold else .4,
			},

			['Overdrive_Chance_Max'] = config.Movement.Overdrive_Chance_Max or 100000000,
			['Pre_Start_Data'] = config.Movement.Pre_Start_Data or {
				['Enabled'] = false,
				['Floor_Change_Delay'] = .3,
				['Chime_Delay'] = .3,
			},
			['Motor_Sound'] = if (config.Movement.Motor_Sound == nil) then true else config.Movement.Motor_Sound,
			['Depart_Pre_Start'] = {

				['Enable'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Enable or false,
				['Delay'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Delay or .1,
				['Ignore_Start_Delay'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Ignore_Start_Delay or true,
				['Cancel_On_Door_Reopen'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen ~= nil and config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen or (not config.Movement.Depart_Pre_Start) and true or config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen,

			}, --If you enter a call while the doors are closing, the elevator ignores the start delay (like the SchindIer 5500).
			['Relevel_Tolerance'] = config.Movement.Relevel_Tolerance or .1,
			['Inspection_Start_Delay'] = {
				['Up'] = config.Movement.Inspection_Start_Delay and typeof(config.Movement.Inspection_Start_Delay) == 'table' and config.Movement.Inspection_Start_Delay.Up or config.Movement.Inspection_Start_Delay or .5,
				['Down'] = config.Movement.Inspection_Start_Delay and typeof(config.Movement.Inspection_Start_Delay) == 'table' and config.Movement.Inspection_Start_Delay.Down or config.Movement.Inspection_Start_Delay or .5,
			},

			['Inspection_Config'] = {

				['Max_Speed'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Max_Speed or config.Movement.Travel_Speed/2, --The maximum speed the elevator can travel in inspection mode
				['Accceleration_Rate'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Accceleration_Rate or config.Movement.Acceleration, --The rate of acceleration in inspection
				['Deceleration_Rate'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Deceleration_Rate or config.Movement.Acceleration*2, --The rate of deceleration in inspection

			},
			['Level_Offset_Ratio'] = config.Movement.Level_Offset_Ratio or .2,
			['Floor_Pass_Chime_On_Stop_Config'] = {
				['Enable'] = 'UNSET',
				['Delay'] = 'UNSET',
				['Play_On_Arrival_Floor'] = 'UNSET',
			},
			['Parking_Config'] = config.Movement.Parking_Config or {

				['Enable'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Enable or false,
				['Idle_Time'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Idle_Time or 60,
				['Park_Floor'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Park_Floor or 1,

			},
			['Releveling_Speed'] = typeof(config.Movement.Releveling_Speed) == 'number' and config.Movement.Releveling_Speed or config.Movement.Level_Speed,

			['Stop_Delay'] = if (typeof(config.Movement.Stop_Delay) == 'number') then config.Movement.Stop_Delay else 0,

			['Open_Doors_On_Stop'] = config.Movement.Open_Doors_On_Stop,
			['Open_Doors_On_Call'] = config.Movement.Open_Doors_On_Call,
			
			['Accelerated_Floor_Config'] = {
				['Enabled'] = if (typeof(config.Movement.Accelerated_Floor_Config) == 'table' and typeof(config.Movement.Accelerated_Floor_Config.Enabled) == 'boolean') then config.Movement.Accelerated_Floor_Config.Enabled else false,
				['Offset'] = if (typeof(config.Movement.Accelerated_Floor_Config) == 'table' and typeof(config.Movement.Accelerated_Floor_Config.Offset) == 'number') then config.Movement.Accelerated_Floor_Config.Offset else 1,
				['Delay_On_Elevator_Start'] = if (typeof(config.Movement.Accelerated_Floor_Config) == 'table' and typeof(config.Movement.Accelerated_Floor_Config.Delay_On_Elevator_Start) == 'number') then config.Movement.Accelerated_Floor_Config.Delay_On_Elevator_Start else .4,
			},

		},
		['Sensors'] = {

			['Up_Level_Offset'] = config.Sensors.Up_Level_Offset or config.Sensors.Level_Offset,
			['Down_Level_Offset'] = config.Sensors.Down_Level_Offset or config.Sensors.Level_Offset,

			['Stop_Offset'] = config.Sensors.Stop_Offset,
			['Pre_Door_Data'] = {
				['Enable'] = config.Sensors.Pre_Door,
				['Offset'] = config.Sensors.Pre_Door_Offset
			},

			['Floor_Position_Offset'] = config.Sensors.Floor_Position_Offset or 0,
			['Floor_Value_Offset'] = config.Sensors.Floor_Value_Offset or 0,

		},
		['Freight'] = {
			['Same_Floor_Call'] = {
				['With_Doors_Open'] = {
					['Enable'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Enable or false,
					['Bell'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Call_Elevator or false
				},
				['With_Doors_Closed'] = {
					['Enable'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Enable or false,
					['Bell'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Call_Elevator or false
				}
			},
			['Other_Floor_Call'] = {
				['With_Doors_Open'] = {
					['Enable'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Enable or false,
					['Bell'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Call_Elevator or false
				},
				['With_Doors_Closed'] = {
					['Enable'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Enable or false,
					['Bell'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Call_Elevator or false
				}
			}
		},
		['Color_Database'] = {
			['Lanterns'] = {
				['Active_On_Door_Open'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Call_Only else false,
					},
				},
				['Active_After_Door_Open'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_After_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_After_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_After_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_After_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Call_Only else false,
					},
				},
				['Active_On_Arrival'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Call_Only else false,
					},
				},
				['Active_On_Call_Enter'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Call_Only else false,
					},
				},
				['Active_On_Button_Press'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Call_Enter) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Call_Enter else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Call_Enter) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Call_Enter else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Call_Only else false,
					},
				},
				['Active_On_Exterior_Call'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Exterior_Call) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Exterior_Call else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only else 0]],
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Exterior_Call) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Exterior_Call else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only else 0]],
					},
				},
				
				['Active_On_Door_Close'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Close) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Close else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only else 0]],
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Close) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Close else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only else 0]],
					},
				},

				['Door_Distance_Reset_Ratio'] = config.Color_Database.Lanterns.Door_Distance_Reset_Ratio or 0,

				['Exterior'] = {

					['Repeat_Data'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Repeat_Data or config.Color_Database.Lanterns.Repeat_Data or {
						['Enable'] = false,
						['Times'] = 1,
						['Delay'] = .33,
						['Play_Chime_On_Light'] = false,
						['Allowed_Directions'] = {'D'} --List of elevator directions when the repeat feature is supposed to run. Available directions: U, D, N
					},

					['Up'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Up or config.Color_Database.Lanterns.Up,
					['Down'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Down or config.Color_Database.Lanterns.Down,

					['Reset_After_Door_Close'] = if (typeof(config.Color_Database.Lanterns.Exterior) == 'table' and typeof(config.Color_Database.Lanterns.Exterior.Reset_After_Door_Close) == 'boolean') then config.Color_Database.Lanterns.Exterior.Reset_After_Door_Close else true,
					['Transparent_When_Inactive'] = if (typeof(config.Color_Database.Lanterns.Exterior) == 'table' and typeof(config.Color_Database.Lanterns.Exterior.Transparent_When_Inactive) == 'boolean') then config.Color_Database.Lanterns.Exterior.Transparent_When_Inactive else false,
					['Lantern_Reset_Delay'] = if (typeof(config.Color_Database.Lanterns.Exterior) == 'table' and typeof(config.Color_Database.Lanterns.Exterior.Lantern_Reset_Delay) == 'number') then config.Color_Database.Lanterns.Exterior.Lantern_Reset_Delay else 0,

				},
				['Interior'] = {

					['Repeat_Data'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Repeat_Data or config.Color_Database.Lanterns.Repeat_Data or {
						['Enable'] = false,
						['Times'] = 1,
						['Delay'] = .33,
						['Play_Chime_On_Light'] = false,
						['Allowed_Directions'] = {'D'} --List of elevator directions when the repeat feature is supposed to run. Available directions: U, D, N
					},

					['Up'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Up or config.Color_Database.Lanterns.Up,
					['Down'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Down or config.Color_Database.Lanterns.Down,

					['Reset_After_Door_Close'] = if (typeof(config.Color_Database.Lanterns.Interior) == 'table' and typeof(config.Color_Database.Lanterns.Interior.Reset_After_Door_Close) == 'boolean') then config.Color_Database.Lanterns.Interior.Reset_After_Door_Close else true,
					['Transparent_When_Inactive'] = if (typeof(config.Color_Database.Lanterns.Interior) == 'table' and typeof(config.Color_Database.Lanterns.Interior.Transparent_When_Inactive) == 'boolean') then config.Color_Database.Lanterns.Interior.Transparent_When_Inactive else false,
					['Lantern_Reset_Delay'] = if (typeof(config.Color_Database.Lanterns.Interior) == 'table' and typeof(config.Color_Database.Lanterns.Interior.Lantern_Reset_Delay) == 'number') then config.Color_Database.Lanterns.Interior.Lantern_Reset_Delay else 0,
				},
			},
			['Car'] = {

				['Lit_Delay'] = config.Color_Database.Car.Lit_Delay or .1,
				['Floor_Button'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Car.Floor_Button.Lit_State.Color, ['Material'] = config.Color_Database.Car.Floor_Button.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Car.Floor_Button.Neautral_State.Color, ['Material'] = config.Color_Database.Car.Floor_Button.Neautral_State.Material
					},
				},
				['Alarm_Button'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Car.Alarm_Button.Lit_State.Color, ['Material'] = config.Color_Database.Car.Alarm_Button.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Car.Alarm_Button.Neautral_State.Color, ['Material'] = config.Color_Database.Car.Alarm_Button.Neautral_State.Material
					},
				},

				['Doors'] = {

					['Open'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},
					['Close'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},
					['Hold'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},

				},

				['Custom_Color_Data'] = config.Color_Database.Car.Custom_Color_Data or {},

			},
			['Floor'] = {
				['Active_Duration'] = config.Color_Database.Floor.Active_Duration or config.Color_Database.Floor.Lit_Delay or .1,
				['Up'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Floor.Up.Lit_State.Color, ['Material'] = config.Color_Database.Floor.Up.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Floor.Up.Neautral_State.Color, ['Material'] = config.Color_Database.Floor.Up.Neautral_State.Material
					},
				},
				['Down'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Floor.Down.Lit_State.Color, ['Material'] = config.Color_Database.Floor.Down.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Floor.Down.Neautral_State.Color, ['Material'] = config.Color_Database.Floor.Down.Neautral_State.Material
					},
				},
			},

		},
		['Extra_Config'] = config.Extra_Config or
			{
				['Debug'] = false,
				['Enable_Parking'] = false,
				['Parking'] = {
					['Park_Floor'] = 1,
					['Park_Time'] = 1,
				},
			},
		['Locking'] = {
			['Locked_Floors'] = config.Locking and config.Locking.Locked_Floors or {},
			['Locked_Hall_Floors'] = config.Locking and config.Locking.Locked_Hall_Floors or {},
			['Disable_Door_Open_On_Locked_Floor'] = {
				['Car'] = {
					['When_Doors_Closing'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Car and config.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing or false,
					['When_Doors_Closed'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Car and config.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed or false
				},
				['Hall'] = {
					['When_Doors_Closing'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing or false,
					['When_Doors_Closed'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed or false
				}
			},
			['Lock_Opposite_Travel_Direction_Floors'] = config.Locking and config.Locking.Lock_Opposite_Travel_Direction_Floors or false
		},
		['Custom_Floor_Label'] = config.Custom_Floor_Label or {},
		['Camera_Force_Data'] = config.Cam_Force_Data or
			{
				['Enable'] = true, --Whether the effect is enabled or not.
				['Acceleration_Amount'] = 1, --How many times this value is multiplied by the default value.
				['Show_When_Leaving'] = true, --Whether the effect shows when the elevator accelerates (leaves a floor) or not.
				['Show_When_Leveling'] = true, --Whether the effect shows when the elevator is leveling (slowing down to a stop).
			},
		['ClientRefresh_Movement_Config'] = {
			['Enable'] = config.ClientRefresh_Movement_Config and config.ClientRefresh_Movement_Config.Enable,
			['Priority'] = 1, --Unused for now.
		},

		['Call_Limiting'] = {
			['Enable'] = if (typeof(config.Call_Limiting) == 'table' and typeof(config.Call_Limiting.Enable) == 'boolean') then config.Call_Limiting.Enable else false,
			['Max_Calls'] = if (typeof(config.Call_Limiting) == 'table' and typeof(config.Call_Limiting.Max_Calls) == 'number') then config.Call_Limiting.Max_Calls else math.huge,
		},

		['Sound_Database'] = {
			['Chime_On_Door_Open'] = config.Sound_Database.Chime_On_Door_Open,
			['Chime_After_Door_Open'] = config.Sound_Database.Chime_After_Door_Open,
			['Chime_On_Arrival'] = config.Sound_Database.Chime_On_Arrival,
			['Chime_On_Button_Press'] = config.Sound_Database.Chime_On_Button_Press,
			['Chime_On_Call_Enter'] = config.Sound_Database.Chime_On_Call_Enter,
			['Chime_On_Exterior_Call'] = config.Sound_Database.Chime_On_Exterior_Call,

			['Chime_Events'] = {

				['On_Open'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Open.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Open.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Open.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Open.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open.Exterior.Call_Only else
							false,
					},
				},
				['After_Open'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_After_Door_Open.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_After_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_After_Door_Open.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_After_Door_Open.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_After_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_After_Door_Open.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open.Exterior.Call_Only else
							false,
					},
				},
				['On_Arrival'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Arrival.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Arrival) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Arrival.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Arrival.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Arrival) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Arrival.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival.Exterior.Call_Only else
							false,
					},
				},
				['Floor_Button_Pressed'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only else
							false,
					},
				},
				['New_Call_Input'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only else
							false,
					},
				},
				['Exterior_Call_Only'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Exterior_Call.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Exterior_Call.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Exterior_Call.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Exterior_Call.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call.Exterior.Call_Only else
							false,
					},
				},
				
				['On_Door_Close'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Close.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Close) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Close.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Close.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Close) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Close.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close.Exterior.Call_Only else
							false,
					},
				},

			},

			['Chime_Database'] = {
				['Interior_Up_Chime'] = {['Sound_Id'] = config.Sound_Database.Chime_Database.Up_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Chime_Database.Up_Chime.Volume, ['Pitch'] = config.Sound_Database.Chime_Database.Up_Chime.Pitch},
				['Interior_Down_Chime'] = {['Sound_Id'] = config.Sound_Database.Chime_Database.Down_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Chime_Database.Down_Chime.Volume, ['Pitch'] = config.Sound_Database.Chime_Database.Down_Chime.Pitch},
			},
			['Arrival_Chime_Database'] = {
				['Exterior_Up_Chime'] = {['Sound_Id'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Volume, ['Pitch'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Pitch},
				['Exterior_Down_Chime'] = {['Sound_Id'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Volume, ['Pitch'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Pitch},
			},
			['Motors'] =
				{
					['Up'] = {
						['Motor_Start_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Pitch or 1},
						['Motor_Run_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Pitch or 1},
						['Motor_Stop_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Pitch or 1},
					},
					['Down'] = {
						['Motor_Start_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Pitch or 1},
						['Motor_Run_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Pitch or 1},
						['Motor_Stop_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Pitch or 1},
					},
				},
			['Doors'] = {
				['Open_Sound'] = {['Sound_Id'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Sound_Id or 0, ['Volume'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Volume or 0, ['Pitch'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Pitch or 0},
				['Close_Sound'] = {['Sound_Id'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Sound_Id or 0, ['Volume'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Volume or 0, ['Pitch'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Pitch or 0},
				['Floors'] = if (typeof(config.Sound_Database.Doors) == 'table' and typeof(config.Sound_Database.Doors.Floors) == 'table') then config.Sound_Database.Doors.Floors else nil,
			},
			['Others'] = {
				['Floor_Pass_Chime'] = {['Sound_Id'] = config.Sound_Database.Others.Floor_Pass_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Others.Floor_Pass_Chime.Volume, ['Pitch'] = config.Sound_Database.Others.Floor_Pass_Chime.Pitch, ['Append']=config.Sound_Database.Others.Floor_Pass_Chime.Append},
				['Enable_Floor_Pass_Chime'] = if (typeof(config.Sound_Database.Others.Enable_Floor_Pass_Chime) == 'boolean') then config.Sound_Database.Others.Enable_Floor_Pass_Chime else true,
				
				['Nudge_Buzzer'] = {['Sound_Id'] = config.Sound_Database.Others.Nudge_Buzzer.Sound_Id, ['Volume'] = config.Sound_Database.Others.Nudge_Buzzer.Volume, ['Pitch'] = config.Sound_Database.Others.Nudge_Buzzer.Pitch},
				['Alarm'] = {['Sound_Id'] = config.Sound_Database.Others.Alarm.Sound_Id, ['Volume'] = config.Sound_Database.Others.Alarm.Volume, ['Pitch'] = config.Sound_Database.Others.Alarm.Pitch, ['Pause_On_Release'] = config.Sound_Database.Others.Alarm.Pause_On_Release},
				['Alarm_Release'] = {['Sound_Id'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Pitch or 0},
				['Button_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Button_Beep.Sound_Id, ['Volume'] = config.Sound_Database.Others.Button_Beep.Volume, ['Pitch'] = config.Sound_Database.Others.Button_Beep.Pitch},
				['Call_Button_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Sound_Id or config.Sound_Database.Others.Button_Beep.Sound_Id, ['Volume'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Volume or config.Sound_Database.Others.Button_Beep.Volume, ['Pitch'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Pitch or config.Sound_Database.Others.Button_Beep.Pitch},

				['Button_Beep_Sound'] = {
					['Enable'] = config.Sound_Database.Others.Button_Beep_Sound and (config.Sound_Database.Others.Button_Beep_Sound.Enable ~= nil and config.Sound_Database.Others.Button_Beep_Sound.Enable or config.Sound_Database.Others.Button_Beep_Sound == nil and false or config.Sound_Database.Others.Button_Beep_Sound.Enable),
					['Delay'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Delay or 0,

					['Sound_Id'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Sound_Id or 0,
					['Volume'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Volume or 0,
					['Pitch'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Pitch or 0,
				},

				['Call_Recognition_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Pitch or 1, ['Delay'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Delay or .1},
				['Door_Obstruction_Signal'] = {['Sound_Id'] = typeof(config.Sound_Database.Others.Door_Obstruction_Signal) == 'table' and config.Sound_Database.Others.Door_Obstruction_Signal.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Door_Obstruction_Signal and config.Sound_Database.Others.Door_Obstruction_Signal.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Door_Obstruction_Signal and config.Sound_Database.Others.Door_Obstruction_Signal.Pitch or 1},
				['Door_Motor_Sound'] = {},
				['Traveling_Sound'] = {

					['Enable'] = config.Sound_Database.Others.Traveling_Sound and (config.Sound_Database.Others.Traveling_Sound.Enable ~= nil and config.Sound_Database.Others.Traveling_Sound.Enable or config.Sound_Database.Others.Traveling_Sound.Enable == nil and true) or config.Sound_Database.Others.Traveling_Sound == nil and true,
					['Sound_Id'] = config.Sound_Database.Others.Traveling_Sound and config.Sound_Database.Others.Traveling_Sound.Sound_Id or 10419439335,
					['Speed_Factor'] = if (typeof(config.Sound_Database.Others.Traveling_Sound) == 'table' and typeof(config.Sound_Database.Others.Traveling_Sound.Speed_Factor) == 'number') then config.Sound_Database.Others.Traveling_Sound.Speed_Factor else 1,
					['Factor_Type'] = if (typeof(config.Sound_Database.Others.Traveling_Sound) == 'table' and config.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio') then config.Sound_Database.Others.Traveling_Sound.Factor_Type else 'Absolute_Speed',
					['Constraints'] = {
						['Volume'] = {
							['Min'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Min)) and 0 or config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Min,
							['Max'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Max)) and .2 or config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Max,
						},
						['Pitch'] = {
							['Min'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Min)) and 1 or (not config.Sound_Database.Others.Traveling_Sound.Min_Pitch) and 1 or config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Min,
							['Max'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Max)) and 1 or (not config.Sound_Database.Others.Traveling_Sound.Max_Pitch) and 1 or config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Max,
						}
					},

				},
				['Safety_Brake_Sound'] = {
					['Sound_Id'] = if (typeof(config.Sound_Database.Others.Safety_Brake_Sound) == 'table' and typeof(config.Sound_Database.Others.Safety_Brake_Sound.Sound_Id) == 'number') then config.Sound_Database.Others.Safety_Brake_Sound.Sound_Id else 6389151811,
					['Volume'] = if (typeof(config.Sound_Database.Others.Safety_Brake_Sound) == 'table' and typeof(config.Sound_Database.Others.Safety_Brake_Sound.Volume) == 'number') then config.Sound_Database.Others.Safety_Brake_Sound.Volume else .5,
					['Pitch'] = if (typeof(config.Sound_Database.Others.Safety_Brake_Sound) == 'table' and typeof(config.Sound_Database.Others.Safety_Brake_Sound.Pitch) == 'number') then config.Sound_Database.Others.Safety_Brake_Sound.Pitch else 1
				},
				['Fire_Recall_Buzzer_Type'] = config.Sound_Database.Others.Fire_Recall_Buzzer_Type or 'Continuous', --[[
				Continuous - Buzzer plays continuously until the elevator recalls to the designated recall floor
				Repeat - Buzzer plays, then pauses, then plays again (like OTIS recall buzzers)
			]]--
				['Elevator_Stop_Beep'] = {
					['Sound_Id'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Sound_Id or 0,
					['Volume'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Volume or 0,
					['Pitch'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Pitch or 0,
					['Enable'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Enable
				},
			},

			['Voice_Config'] = config.Sound_Database.Voice_Config or require(coreScript.Voice_Module.STOCK_VoiceModule),
			['Floor_Pass_Chime_Delay'] = if (typeof(config.Sound_Database.Floor_Pass_Chime_Delay) == 'number') then config.Sound_Database.Floor_Pass_Chime_Delay else 0,

		}
	}
	return DefaultConfig
end]]></ProtectedString>
								<int64 name="SourceAssetId">13443177628</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="BillboardGui" referent="RBX5B1F011CBF5744CFBB6E151756618F2D">
							<Properties>
								<bool name="Active">true</bool>
								<Ref name="Adornee">null</Ref>
								<bool name="AlwaysOnTop">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<float name="Brightness">1</float>
								<bool name="ClipsDescendants">true</bool>
								<float name="DistanceLowerLimit">0</float>
								<float name="DistanceStep">0</float>
								<float name="DistanceUpperLimit">-1</float>
								<bool name="Enabled">false</bool>
								<Vector3 name="ExtentsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="ExtentsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="LightInfluence">0</float>
								<float name="MaxDistance">INF</float>
								<string name="Name">DOOR_KEY_UI</string>
								<Ref name="PlayerToHideFrom">null</Ref>
								<bool name="ResetOnSpawn">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>350</XO>
									<YS>0</YS>
									<YO>100</YO>
								</UDim2>
								<Vector2 name="SizeOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<int64 name="SourceAssetId">-1</int64>
								<Vector3 name="StudsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="StudsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<BinaryString name="Tags"></BinaryString>
								<token name="ZIndexBehavior">1</token>
							</Properties>
							<Item class="Frame" referent="RBXB41627BEFD7145EEBF1F4CB384FA327E">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.211764723</R>
										<G>0.211764723</G>
										<B>0.211764723</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">BG</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>-50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UICorner" referent="RBX81EF05C6EFE74E0082FE95740D17235C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>10</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX9F1F907C641C48FBB997C0CD7715AAD5">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Slider</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">1</int>
										<UDim2 name="Size">
											<XS>0.649999976</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>3</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
									<Item class="TextButton" referent="RBX49AE673C4BF342A9B18BCC0FBAAFE115">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">false</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">3</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Button</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>35</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Button</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">1</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXD28BE1A3CABC47EEABE8E7E13495A862">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">false</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">3</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Select</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0</XS>
												<XO>12</XO>
												<YS>1</YS>
												<YO>35</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Button</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">1</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UICorner" referent="RBX54DBF09E86DB4D7F8F3524EF47937F2E">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<UDim name="CornerRadius">
													<S>1</S>
													<O>0</O>
												</UDim>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="ImageLabel" referent="RBX6F11690CD69B406298580AE39A443595">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://13746787307</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Closed</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>100</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIAspectRatioConstraint" referent="RBX699AE3CCCDC14521BAC772885614351B">
										<Properties>
											<float name="AspectRatio">1.29999995</float>
											<token name="AspectType">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="DominantAxis">1</token>
											<string name="Name">UIAspectRatioConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ImageLabel" referent="RBX6B077AF8EA7146E7828692F18B032D8C">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://13746787390</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Open</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>100</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIAspectRatioConstraint" referent="RBXF9DE8CD227584E459D1E118146084FB0">
										<Properties>
											<float name="AspectRatio">1.29999995</float>
											<token name="AspectType">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="DominantAxis">1</token>
											<string name="Name">UIAspectRatioConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Frame" referent="RBX50B562FE0B3146C6BF3C6F09E13898D7">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.211764723</R>
											<G>0.211764723</G>
											<B>0.211764723</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Top</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>13</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>50</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UICorner" referent="RBXCD8DBE948B9F4B9488C5111A7F8165F4">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>10</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ImageButton" referent="RBXD4BDCC1198084715B7D06603E3D4A73D">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<Content name="HoverImage"><null></null></Content>
											<Content name="Image"><url>rbxassetid://13745395147</url></Content>
											<Color3 name="ImageColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<Vector2 name="ImageRectOffset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<Vector2 name="ImageRectSize">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="ImageTransparency">0</float>
											<int name="LayoutOrder">0</int>
											<bool name="Modal">false</bool>
											<string name="Name">Button</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<Content name="PressedImage"><null></null></Content>
											<token name="ResampleMode">0</token>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<token name="ScaleType">3</token>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>-15</XO>
												<YS>1</YS>
												<YO>-15</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<Rect2D name="SliceCenter">
												<min>
													<X>0</X>
													<Y>0</Y>
												</min>
												<max>
													<X>0</X>
													<Y>0</Y>
												</max>
											</Rect2D>
											<float name="SliceScale">1</float>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<UDim2 name="TileSize">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="LocalScript" referent="RBX056090A9361740989450530DE2F3DCF3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Disabled">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CLIENT</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{CAFB5620-83A8-40D2-AA45-9C6023C6D97E}</string>
									<ProtectedString name="Source"><![CDATA[local this = script.Parent
local remote = this:WaitForChild('RemoteEvent')
local ratio = this:WaitForChild('RATIO')
local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local draggableUI = require(script:WaitForChild('DraggableUI'))
local uis = game:GetService('UserInputService')
local mouse = player:GetMouse()

local doorSet = this:WaitForChild('DOOR_SET').Value or this:WaitForChild('DOOR_SET'):GetPropertyChangedSignal('Value'):Wait()

local slider,select = this.BG.Slider,this.BG.Slider.Select

local delta = Vector2.zero
local dragInput,startPos,dragStart
select.InputBegan:Connect(function(input)
	if (input.UserInputType == Enum.UserInputType.MouseButton1) then
		player:GetMouse().Icon = 'rbxasset://SystemCursors/PointingHand'
		dragInput = input
		dragStart = uis:GetMouseLocation()
		startPos = select.Position.X.Offset
		input.Changed:Connect(function()
			if (input.UserInputState == Enum.UserInputState.End) then
				dragInput = nil
				player:GetMouse().Icon = [[ ]]
			end
		end)
	end
end)
uis.InputChanged:Connect(function(input: InputObject)
	if (dragInput) then
		if (uis.MouseBehavior ~= Enum.MouseBehavior.Default) then
			delta += uis:GetMouseDelta()*3.5
		else
			delta = uis:GetMouseLocation()-dragStart
		end
		select.Position = UDim2.new(0, math.clamp(startPos+delta.X, 0, slider.AbsoluteSize.X), .5, 0)
	end
end)

this.BG.Top.Button.MouseButton1Down:Connect(function()
	local elevator = (doorSet:FindFirstAncestor('Car') or doorSet:FindFirstAncestor('Floors')).Parent
	if (not elevator) then return end
	elevator.Cortex_Remote:FireServer('exit',doorSet)
end)

local active = false
uis.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
	if (gameProcessed) then return end
	if (input.KeyCode == Enum.KeyCode.LeftControl) then
		local zoom = (camera.CFrame.Position-camera.Focus.Position).Magnitude
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = zoom,zoom
		active = true
	elseif (input.KeyCode == Enum.KeyCode.Q) then
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = game.StarterPlayer.CameraMinZoomDistance,game.StarterPlayer.CameraMaxZoomDistance
		active = false
		local elevator = (doorSet:FindFirstAncestor('Car') or doorSet:FindFirstAncestor('Floors')).Parent
		if (not elevator) then return end
		elevator.Cortex_Remote:FireServer('exit',doorSet)
	end
end)
local lastTick = tick()
uis.InputChanged:Connect(function(input: InputObject)
	if (input.UserInputType == Enum.UserInputType.MouseWheel and active) then
		if (input.Position.Z == 1 or input.Position.Z == -1) then
			local t = math.clamp((tick()-lastTick),0,.2)
			lastTick = tick()
			game:GetService('TweenService'):Create(select,TweenInfo.new(t,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Position=UDim2.fromOffset(math.clamp(select.Position.X.Offset+input.Position.Z*7.5,0,slider.AbsoluteSize.X),0)}):Play()
		end
	end
end)
uis.InputEnded:Connect(function(input: InputObject)
	if (input.KeyCode == Enum.KeyCode.LeftControl) then
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = game.StarterPlayer.CameraMinZoomDistance,game.StarterPlayer.CameraMaxZoomDistance
		active = false
	end
end)

select:GetPropertyChangedSignal('Position'):Connect(function()
	remote:FireServer('UPDATE_RATIO_VALUE',select.Position.X.Offset/slider.AbsoluteSize.X,0,1)
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX5AE93B508B3E482699959CE3240FCCA8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">DraggableUI</string>
										<string name="ScriptGuid">{97F2CF79-74C1-471B-B6CC-8EE805CF88C9}</string>
										<ProtectedString name="Source"><![CDATA[local Signal = require(script.Signal)

local TweenService = game:GetService("TweenService")
local PlayerObject = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")

local Mouse = PlayerObject:GetMouse()
local Camera = workspace.CurrentCamera
local PlayerGui = PlayerObject:WaitForChild("PlayerGui")

local listOfDraggable = {}

local function ValidateParametersValue(UI: GuiObject, byScale: boolean?)
	if not UI then
		error("First argument must not be empty!")
	end

	if not (typeof(UI) == "Instance") then
		error("First argument must be a type of instance!")
	end

	if not (typeof(byScale) == "boolean") then
		error("Second argument must be a type of boolean!")
	end
end

local function IsMouseOrTouch(input: InputObject, isMouseMovement: boolean?): boolean
	return input.UserInputType
		== (if isMouseMovement then Enum.UserInputType.MouseMovement else Enum.UserInputType.MouseButton1)
		or input.UserInputType == Enum.UserInputType.Touch
end

local function GetDominantObject(list: { Instance }): GuiObject
	local dominant = math.huge
	local guiObject: GuiObject

	for _, value in ipairs(listOfDraggable) do
		local index = table.find(list, value._UI)

		if index and index < dominant then
			dominant = index
			guiObject = value._UI
		end
	end

	return guiObject
end

local DraggableUI = {}
DraggableUI.__index = DraggableUI
DraggableUI.__tostring = function()
	return "Draggable"
end

function DraggableUI.new(UI: GuiObject, byScale: true?)
	byScale = byScale or true
	ValidateParametersValue(UI, byScale)

	local self = setmetatable({
		_Released = Signal.new(),
		_Started = Signal.new(),
		_Moved = Signal.new(),

		_Connections = {},
		_Overlapping = {
			Disabled = false,
		},
		_LimitBoundingBox = {
			Enabled = false,
			Type = 0,
		},

		_TweenInfo = false,
		_UI = UI,
	}, DraggableUI)

	self.Released = self._Released.Event
	self.Started = self._Started.Event
	self.Moved = self._Moved.Event

	local success, result = pcall(self._Initialize, self, UI, byScale)

	if not success then
		error(("Something went wrong: %s"):format(result))
	end

	table.insert(listOfDraggable, self)
	return self
end

function DraggableUI:_Initialize(UI: GuiObject, byScale: boolean)
	local startPosition = UI.AbsolutePosition
	local dragStartPosition = UserInputService:GetMouseLocation()

	local mouseOnUI = false
	local button1Down = false

	table.insert(
		self._Connections,
		UI.MouseEnter:Connect(function()
			mouseOnUI = true
		end)
	)

	table.insert(
		self._Connections,
		UI.MouseLeave:Connect(function()
			mouseOnUI = false
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputBegan:Connect(function(input)
			if IsMouseOrTouch(input) and mouseOnUI then
				local list = PlayerGui:GetGuiObjectsAtPosition(Mouse.X, Mouse.Y)

				if #list >= 2 then
					if not (GetDominantObject(list) == UI) then
						return
					end
				end

				for _, value in pairs(self._Overlapping) do
					if value then
						return
					end
				end

				startPosition = UI.AbsolutePosition + (UI.AbsoluteSize * UI.AnchorPoint) - UI.Parent.AbsolutePosition
				dragStartPosition = UserInputService:GetMouseLocation()
				button1Down = true

				self._Started:Fire()
			end
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputEnded:Connect(function(input)
			if IsMouseOrTouch(input) and button1Down then
				button1Down = false
				self._Released:Fire(UserInputService:GetMouseLocation())
			end
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputChanged:Connect(function(input)
			if IsMouseOrTouch(input, true) and button1Down then
				local mousePosition = UserInputService:GetMouseLocation()
				local delta = mousePosition - dragStartPosition
				local parentSize = UI.Parent.AbsoluteSize
				local position = startPosition + delta

				position = self:_LimitPosition(UI, position, parentSize)

				if not byScale then
					position = UDim2.fromOffset(position.X, position.Y)
				else
					position /= parentSize
					position = UDim2.fromScale(position.X, position.Y)
				end

				if self._TweenInfo then
					TweenService:Create(UI, self._TweenInfo, { Position = position }):Play()
				else
					UI.Position = position
				end

				self._Moved:Fire(mousePosition)
			end
		end)
	)
end

function DraggableUI:_LimitPosition(UI: GuiObject, position: Vector2, parentSize: Vector2)
	if self._LimitBoundingBox.Enabled then
		local offset = (UI.AbsoluteSize * UI.AnchorPoint)
		local uiSize = UI.AbsoluteSize

		if self._LimitBoundingBox.Type == 0 then
			local screenSize = Camera.ViewportSize
			local max = (screenSize - uiSize) + offset

			return Vector2.new(math.clamp(position.X, offset.X, max.X), math.clamp(position.Y, offset.Y, max.Y))
		else
			local max = (parentSize - uiSize) + offset

			return Vector2.new(math.clamp(position.X, offset.X, max.X), math.clamp(position.Y, offset.Y, max.Y))
		end
	end

	return position
end

function DraggableUI:_Ignore(UI: GuiObject)
	table.insert(
		self._Connections,
		UI.MouseEnter:Connect(function()
			self._Overlapping[UI] = true
		end)
	)

	table.insert(
		self._Connections,
		UI.MouseLeave:Connect(function()
			self._Overlapping[UI] = nil
		end)
	)
end

function DraggableUI:LimitScreenBoundingBox(byParent: false?, value: boolean?): boolean
	local limitBoundingBox = self._LimitBoundingBox
	byParent = byParent or false

	limitBoundingBox.Type = if byParent then 1 else 0
	limitBoundingBox.Enabled = if typeof(value) == "boolean" then value else not limitBoundingBox.Enabled

	return limitBoundingBox.Enabled
end

function DraggableUI:Toggle(value: boolean?): boolean
	local overlapping = self._Overlapping
	overlapping.Disabled = if typeof(value) == "boolean" then value else not overlapping.Disabled

	return overlapping.Disabled
end

function DraggableUI:SetTweenInfo(tweenInfo: TweenInfo)
	if not (typeof(tweenInfo) == "TweenInfo") then
		error("Argument must be a type of TweenInfo!")
	end

	self._TweenInfo = tweenInfo
end

function DraggableUI:Ignore(list: { Instance }, instanceCheck: false?)
	instanceCheck = instanceCheck or false

	if not (typeof(list) == "table") then
		error("First argument must be a type of table!")
	end

	if not (typeof(instanceCheck) == "boolean") then
		error("Second argument must be a type of boolean!")
	end

	local success = pcall(function()
		if instanceCheck then
			for _, object in ipairs(list) do
				pcall(function()
					self:_Ignore(object)
				end)
			end
		else
			for _, object in ipairs(list) do
				self:_Ignore(object)
			end
		end
	end)

	if not success then
		error("It seems that the array contained a none type of GuiObject")
	end
end

function DraggableUI:IgnoreChildren()
	self:Ignore(self._UI:GetChildren(), true)
end

function DraggableUI:IgnoreDescendants()
	self:Ignore(self._UI:GetDescendants(), true)
end

function DraggableUI:Destroy()
	for _, connection: RBXScriptSignal in ipairs(self._Connections) do
		if typeof(connection) == "RBXScriptSignal" then
			connection:Disconnect()
		end
	end

	for key, _ in pairs(self._IgnoreList) do
		self._IgnoreList[key] = nil
	end

	self._Released:Destroy()
	self._Started:Destroy()
	self._Moved:Destroy()

	table.remove(listOfDraggable, table.find(listOfDraggable, self))
	table.clear(self)
end

setmetatable(DraggableUI, {
	__index = function(_, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,

	__newindex = function(_, key)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

export type Draggable = {
	LimitScreenBoundingBox: (self: { Draggable }, byParent: false?, value: boolean?) -> boolean,
	Ignore: (self: { Draggable }, list: { Frame | Instance }, instanceCheck: false?) -> (),
	SetTweenInfo: (self: { Draggable }, tweenInfo: TweenInfo) -> (),
	Toggle: (self: { Draggable }, value: boolean?) -> boolean,
	IgnoreDescendants: (self: { Draggable }) -> (),
	IgnoreChildren: (self: { Draggable }) -> (),
	Destroy: (self: { Draggable }) -> (),

	Released: Signal.Event,
	Started: Signal.Event,
	Moved: Signal.Event,
}

return DraggableUI :: {
	new: (UI: Instance, byScale: true?) -> Draggable,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">11263101887</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX5057451F517B4A778E3BA7C3E75245B6">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Signal</string>
											<string name="ScriptGuid">{6675C747-9F8C-41A6-9EE7-7C18584F5133}</string>
											<ProtectedString name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal
Signal.__tostring = function()
	return "Signal"
end

Signal.Event = {} :: {
	Connect: (self: { RBXScriptSignal }) -> RBXScriptConnection,
	Once: (self: { RBXScriptSignal }) -> RBXScriptConnection,
	Wait: (self: { RBXScriptSignal }) -> ...any,
}
Signal.Event.__index = Signal.Event
Signal.Event.__tostring = function()
	return "Event"
end

local Connection = {}
Connection.__index = Connection
Connection.__tostring = function()
	return "Connection"
end

local function DisableTableIndex(Table: {})
	setmetatable(Table, {
		__index = function(_, key)
			error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,

		__newindex = function(_, key)
			error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,
	})
end

Connection.__eq = function(self, other)
	return self._Handler == other._Handler
end

function Connection.new(Parent: {}, Handler: any): RBXScriptConnection
	return setmetatable({
		_Handler = Handler,
		_Parent = Parent,
	}, Connection)
end

function Connection:Disconnect()
	local Position = table.find(self._Parent, self)

	if Position then
		table.remove(self._Parent, Position)
	end
end

function Connection:_Fire(...)
	self._Handler(...)
end

function Signal.new()
	return setmetatable({}, Signal)
end

function Signal.Event:Connect(Handler: any): RBXScriptConnection
	local self: RBXScriptConnection = self
	local _Connection = Connection.new(self, Handler)

	table.insert(self, _Connection)

	return _Connection
end

function Signal.Event:Once(Handler: any): RBXScriptConnection
	local self: RBXScriptConnection = self

	local Fired = false
	local Connection

	Connection = self:Connect(function(...)
		if Fired then
			return
		end

		Fired = true
		Connection:Disconnect()
		Handler(...)
	end)

	return Connection
end

function Signal.Event:Wait(): ...any
	local self: RBXScriptConnection = self

	local Result = coroutine.running()
	local Fired = false
	local Connection

	Connection = self:Connect(function(...)
		if Fired then
			return
		end

		Fired = true
		Connection:Disconnect()
		task.spawn(Result, ...)
	end)

	return coroutine.yield()
end

function Signal:DisconnectAll()
	local self: RBXScriptConnection = self

	for _, Handler in ipairs(self.Event) do
		coroutine.wrap(Handler.Disconnect)(Handler)
	end
end

function Signal:Fire(...: any)
	local self: RBXScriptConnection = self
	local args = { ... }

	for _, Handler in ipairs(self.Event) do
		coroutine.wrap(Handler._Fire)(Handler, unpack(args))
	end
end

function Signal:Destroy()
	local self: RBXScriptConnection = self

	self:DisconnectAll()
	table.clear(self)
end

DisableTableIndex(Signal)
DisableTableIndex(Connection)
DisableTableIndex(Signal.Event)

export type Event = {
	Connect: (self: { Event }, func: (...any) -> ()) -> RBXScriptConnection,
	Once: (self: { Event }, func: (...any) -> ()) -> RBXScriptConnection,
	Wait: (self: { Event }) -> ...any,
}

export type Signal = {
	new: (
	) -> {
		Event: Event,
		Destroy: (self: { Signal }) -> (),
		Fire: (self: { Signal }, ...any) -> (),
		DisconnectAll: (self: { Signal }) -> (),
	},
}

return Signal :: Signal
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="RemoteEvent" referent="RBXDA9B44C89F734728AE0E8969BBBAB976">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">RemoteEvent</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Script" referent="RBXAB66F9ECDBA6438099E891BD078A1242">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Disabled">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SERVER</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{6A5581B2-3CFF-4D3B-A93E-6F83A9C41F8D}</string>
									<ProtectedString name="Source"><![CDATA[--local Connection
--Connection = script.Parent.AncestryChanged:Connect(function()
	if not script:IsDescendantOf(game.Players) then
		return--Connection:Disconnect()
	end
	
	local player = script:FindFirstAncestorOfClass('Player')
	script.Parent:WaitForChild("RemoteEvent").OnServerEvent:Connect(function(user, protocol, params)
		if (protocol == 'UPDATE_RATIO_VALUE' and user == player) then
			script.Parent.RATIO.Value = params
		end
	end)
--end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX488C82F98D5445D888A368CCB0B9A40D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">RATIO</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="ObjectValue" referent="RBX577A43E5923747218B5F58A5118DE58F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">DOOR_SET</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Ref name="Value">null</Ref>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX675E1E70FD35416193C09879217B045E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LiveSettings</string>
								<string name="ScriptGuid">{73D903A7-51D0-4090-AA91-8052A5D0BDCE}</string>
								<ProtectedString name="Source">return {}</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX68E1620E898B4AD09C09F26DD4622CE2">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Modules</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXC4F45FC72F4C48AD86086482201357A2">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Door_Engine</string>
								<string name="ScriptGuid">{37BEDBCE-2918-47A2-B152-8D187EDF6E99}</string>
								<ProtectedString name="Source"><![CDATA[local doorEngineClass = {}

local heartbeat =_G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

doorEngineClass.className = 'doorEngineClass'

doorEngineClass.isPluginModule = true

doorEngineClass.config = nil
doorEngineClass.elevator = nil

local core = require(script.Parent.Parent)
local coreFunctions = core.coreFunctions
local coreFunctionsModule = require(script.Parent.Core_Functions)
local signal = require(script.Parent.Signal)
local legacyEasing = require(script.Parent.Legacy_Easing)

function doorEngineClass.new(doorSet, dataTable)
	local self = setmetatable({}, doorEngineClass)
	if (doorSet.Name == 'Doors') then doorSet.Name = 'Front_Doors' end
	self.side = string.split(string.split(doorSet.Name, 'Doors')[1], '_')[1]
	if self.side == '' then self.side = string.split(doorSet.Name, 'Doors')[1] ~= "" and string.split(doorSet.Name, 'Doors')[1] or string.split(doorSet.Name, 'Doors')[2] ~= "" and string.split(doorSet.Name, 'Doors')[2] end
	--self.side = string.split(doorSet.Name, 'Doors')[2] and string.split(doorSet.Name, 'Doors')[1]
	--if (not self.side) then return end
	--self.side = string.split(self.side, '_')[1]
	if (self.side == '') then self.side = 'Front' end
	self.sideJoin = "{self.side == '' and '' or "{self.side}_"}"
	self.state = 'Closed'
	self.isEnabled = true
	self.nudging = false
	self.doorSet = doorSet
	self.velocity = {
		['Inner'] = 0,
		['Outer'] = 0,
	}
	self.alpha = {
		['Inner'] = 0,
		['Outer'] = 0,
	}
	self.currentStage = {
		['Opening'] = {
			['Inner'] = 1,
			['Outer'] = 1,
		},
		['Closing'] = {
			['Inner'] = 1,
			['Outer'] = 1,
		}
	}

	self.sensorLEDs = {}

	self.openingThread,self.closingThread = nil,nil

	self.Opened = signal.new()
	self.Closed = signal.new()
	self.LanternsReset = signal.new()

	self.openingThreads = {}
	self.closingThreads = {}

	self.doorTimestamp = 0
	self.nudgeTimestamp = 0

	self.lanternsReset = false

	local elevator = doorEngineClass.elevator
	local car = elevator.Car
	local carLevel = elevator.Car:FindFirstChild('Level') or elevator.Car:FindFirstChild('Platform')
	local cabRegion = elevator.Car:WaitForChild('Cab_Region')
	self.doorSensorPart = elevator.Car:WaitForChild('Door_Sensor_Parts'):FindFirstChild((self.sideJoin) .. "Sensor")

	for i, v in pairs(doorSet:GetDescendants()) do
		if (not v:IsA('BasePart') or v.Name ~= 'Sensor_LED') then continue end
		table.insert(self.sensorLEDs, v)
		v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color
		v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material
	end

	if (doorEngineClass.config.Sound_Database.Doors.Open_Sound) then
		self.doorOpenSound = coreFunctions.addSound(self.doorSensorPart, 'Door_Open_Sound', doorEngineClass.config.Sound_Database.Doors.Open_Sound, false, 4, 25)
	end
	if (doorEngineClass.config.Sound_Database.Doors.Close_Sound) then
		self.doorCloseSound = coreFunctions.addSound(self.doorSensorPart, 'Door_Close_Sound', doorEngineClass.config.Sound_Database.Doors.Close_Sound, false, 4, 25)
	end

	for i, v in pairs(core.registeredFloors) do
		if (typeof(doorEngineClass.config.Sound_Database.Doors.Floors) ~= 'table') then continue end
		local floorDoorSoundConfig = doorEngineClass.config.Sound_Database.Doors.Floors[tostring(v.floorNumber)]
		if (typeof(doorEngineClass.config.Sound_Database.Doors.Floors) ~= 'table' or (not floorDoorSoundConfig)) then continue end
		self["doorOpenSoundFloor" .. (v.floorNumber)] = coreFunctions.addSound(self.doorSensorPart, "Door_Open_Sound_Floor_" .. (v.floorNumber), floorDoorSoundConfig.Open_Sound, false, 4, 25)
		self["doorCloseSoundFloor" .. (v.floorNumber)] = coreFunctions.addSound(self.doorSensorPart, "Door_Close_Sound_Floor_" .. (v.floorNumber), floorDoorSoundConfig.Close_Sound, false, 4, 25)
	end

	self.obstructionSignal = coreFunctions.addSound(self.doorSensorPart, 'Obstruction_Signal', doorEngineClass.config.Sound_Database.Others.Door_Obstruction_Signal, true, 2, 15)

	function self:Open(floor)

		local startingState = self.state

		local registeredFloor = coreFunctions.findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		local carWelds, floorWelds = car.Door_Engine_Welds:FindFirstChild(self.side), registeredFloor.floorInstance.Door_Engine_Welds:FindFirstChild(self.side)
		if ((not carWelds) or (not floorWelds)) then return end

		for i, v in pairs(self.closingThreads) do
			pcall(task.cancel, v)
			self.closingThreads[i] = nil
		end
		self.Closed:Destroy()
		self.state = 'Opening'
		core.statValues[(self.sideJoin) .. "Door_State"] = self.state
		task.spawn(coreFunctions.updateStatValues)

		local distanceFactor = 0
		for i, v in pairs(carWelds:GetChildren()) do
			local dist = ((v:GetAttribute('openPoint').Position-v.C0.Position).Magnitude/(v:GetAttribute('openPoint').Position-v:GetAttribute('closedPoint').Position).Magnitude)/#carWelds:GetChildren()
			distanceFactor += dist
		end
		local openSound, closeSound = self["doorOpenSoundFloor" .. (floor)] or self.doorOpenSound, self["doorCloseSoundFloor" .. (floor)] or self.doorCloseSound
		closeSound:Stop()
		coroutine.wrap(function()
			if (startingState == 'Closed') then
				local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Open_Sound_Delay, function() return {self.state == 'Opening'} end)
				if (not hasPassed) then return end
			end
			openSound.TimePosition = openSound.TimeLength*(1-distanceFactor)
			task.wait()
			openSound:Play()
		end)()
		if (startingState == 'Closed') then
			local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Open_Delay, function() return {self.state == 'Opening'} end)
			if (not hasPassed) then return end
		end

		local function runDoor(set)
			local velocityConfig = doorEngineClass.config.Doors.Custom_Door_Operator_Config[set].Opening
			if ((set ~= 'Inner' and set ~= 'Outer') or (velocityConfig.Enable and set == 'Outer' and doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable)) then return end
			local doorWelds = set == 'Inner' and car.Door_Engine_Welds:FindFirstChild(self.side) or floorWelds
			if (not doorWelds) then return end

			local landingDoors = registeredFloor.floorInstance:FindFirstChild((self.sideJoin) .. "Doors")
			if (not landingDoors) then return end
			local direction = (select(1, landingDoors:GetBoundingBox()).Position-select(1, doorSet:GetBoundingBox()).Position)

			local duration = doorEngineClass.config.Doors.Door_Open_Speed

			local masterWeld,dist = nil,math.huge
			for _, v in pairs(doorWelds:GetChildren()) do
				local distance = (v:GetAttribute('openPoint').Position-v:GetAttribute('closedPoint').Position).Magnitude
				if (distance < dist and distance > 0) then
					masterWeld = v
					dist = distance
				end
			end

			local function checkWelds(point, threshold, includeFloorDoors)
				for _, v in pairs(carWelds:GetChildren()) do
					if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
				end
				if (includeFloorDoors == true) then
					for _, v in pairs(floorWelds:GetChildren()) do
						if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
					end
				end
				return true
			end

			local reopenStartTime
			local reopenDelayCompleted = false

			if (velocityConfig.Enable) then
				if (startingState == 'Closed') then
					self.velocity[set] = 0
					self.currentStage.Opening[set] = 1
				else
					self.velocity[set] = -self.velocity[set]
				end
				local startVelocity = self.velocity[set]

				local startTime = os.clock()
				local startLerpTime
				local stageAccelTime,initialVelocity,stageSpeed
				local decelerating = false
				local lastVelocity = self.velocity[set]
				local delayTick

				local doorSpeed = dist/duration
				local lastDist

				local distOffset = math.clamp(velocityConfig.Deceleration_Offset, 0, math.huge)
				local minSpeed = math.clamp(velocityConfig.Minimum_Speed or .05, 0, doorSpeed)

				local dtTime = 0

				if (startingState == 'Closed' and doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable) then
					if (floorWelds) then
						local function getEngineWeld(part: BasePart?)
							for _,v in pairs(floorWelds:GetChildren()) do
								if (v.Part0 == part) then return v end
							end
							return nil
						end
						local params = RaycastParams.new()
						params.FilterType = Enum.RaycastFilterType.Whitelist
						local list = {}
						for _,weld in pairs(floorWelds:GetChildren()) do
							table.insert(list, weld.Part0)
						end
						params.FilterDescendantsInstances = list
						for _,weld in pairs(carWelds:GetChildren()) do
							local result = workspace:Blockcast(CFrame.new(weld.Part0.CFrame.Position), Vector3.new(0, weld.Part0.Size.Y, 0), Vector3.new(direction.X, 0, direction.Z).Unit*5, params)
							if ((not result) or (not result.Instance)) then continue end
							local value = weld:FindFirstChild('Door_Weld') or Instance.new('ObjectValue')
							value.Name = 'Door_Weld'
							value.Value = getEngineWeld(result.Instance)
							value.Parent = weld
						end
					end
				end

				local function getFloorWeldFromCarWeld(weld)
					for i, v in pairs(floorWelds:GetChildren()) do
						if (v == weld) then return v end
					end
					return nil
				end

				local parent = self.doorSet:IsDescendantOf(car) and elevator:WaitForChild('Legacy') or self.doorSet.Parent
				local doorSpeedValue = parent:FindFirstChild((self.sideJoin) .. "Door_Speed")

				while (self.alpha[set] < 1 and (self.state == 'Opening' or self.state == 'Open')) do
					local thisConfig = typeof(velocityConfig.Custom_Acceleration_Stages) == 'table' and velocityConfig.Custom_Acceleration_Stages or {}
					local currentStage = thisConfig[self.currentStage.Opening[set]]

					local thisDist = (masterWeld:GetAttribute('openPoint').Position-masterWeld.C0.Position).Magnitude
					local thisDistCheck = thisDist/dist <= velocityConfig.Deceleration_Distance*(math.clamp((self.velocity[set])/doorSpeed, 0, 1))

					for i, v in pairs(self.sensorLEDs) do
						v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Active.Color
						v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Active.Material
					end

					if (startVelocity < 0 and self.velocity[set] >= 0) then
						if (not reopenStartTime) then
							reopenStartTime = os.clock()
						else
							if ((os.clock()-reopenStartTime)/doorEngineClass.config.Doors.Reopen_Delay < 1) then heartbeat:Wait() continue end
							if (not reopenDelayCompleted) then
								reopenDelayCompleted = true
								startLerpTime += (os.clock()-reopenStartTime)
								startLerpTime = nil
							end
						end
					end

					if (not thisDistCheck) then
						if (not decelerating) then
							if (currentStage) then
								if (not startLerpTime) then
									startLerpTime = os.clock()
									initialVelocity = self.velocity[set]
									stageSpeed = math.clamp(currentStage.Speed, 0, doorSpeed)
									stageAccelTime = (startingState == 'Closing' and self.state == 'Opening' and self.velocity[set] < 0) and coreFunctionsModule.getAccelerationTime(initialVelocity, stageSpeed, .2) or coreFunctionsModule.getAccelerationTime(initialVelocity, stageSpeed, if (currentStage.Acceleration == 'USE_ACCELERATION') then velocityConfig.Acceleration else currentStage.Acceleration)
								else
									local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
									self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, stageSpeed, alpha)
									if (alpha >= 1 and thisConfig[self.currentStage.Opening[set]+1]) then
										if (not delayTick) then
											delayTick = os.clock()
										elseif ((os.clock()-delayTick)/currentStage.Delay_Before_Next_Stage >= 1) then
											self.currentStage.Opening[set] = math.min(self.currentStage.Opening[set]+1, #thisConfig)
											startLerpTime = nil
										end
									end
								end
							else
								if (not startLerpTime) then
									startLerpTime = os.clock()
									initialVelocity = self.velocity[set]
									stageAccelTime = coreFunctionsModule.getAccelerationTime(initialVelocity, doorSpeed, velocityConfig.Acceleration)
								else
									local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
									self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, doorSpeed, alpha)
								end
							end
						end
					else
						if (not decelerating) then
							decelerating = true
							lastDist = thisDist
							lastVelocity = self.velocity[set]
						end
						if (velocityConfig.Deceleration_Rate == 'Constant') then
							local distOff = thisDist-distOffset
							local currentSpeed = self.velocity[set]
							local deceleration = currentSpeed^2/(2*math.max(.001, distOff))
							local SPEED = math.max(0, currentSpeed-deceleration*dtTime)
							self.velocity[set] = math.max(minSpeed, SPEED)
						end
					end

					self.alpha[set] = math.clamp(self.alpha[set]+((self.velocity[set]/doorSpeed)/duration)*dtTime, 0, 1)
					doorSpeedValue.Value = math.abs(self.velocity[set])

					if (doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable) then
						for _,weld in pairs(carWelds:GetChildren()) do
							weld.C0 = weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set])
							if (weld:FindFirstChild('Door_Weld')) then
								local data = getFloorWeldFromCarWeld(weld.Door_Weld.Value)
								if (data) then
									local goal = CFrame.new((weld:GetAttribute('closedPoint').Position-weld:GetAttribute('openPoint').Position).Unit*doorEngineClass.config.Doors.New_Attachment_Doors_Config.Attachment_Threshold)*(weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set]))
									weld.Door_Weld.Value.C0 = CFrame.new(
										math.clamp(goal.X,data:GetAttribute('openPoint').X >= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X,data:GetAttribute('openPoint').X <= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X),
										math.clamp(goal.Y,data:GetAttribute('openPoint').Y >= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y,data:GetAttribute('openPoint').Y <= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y),
										math.clamp(goal.Z,data:GetAttribute('openPoint').Z >= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z,data:GetAttribute('openPoint').Z <= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z)
									)
								end
							end
						end
					else
						for i, v in pairs(doorWelds:GetChildren()) do
							v.C0 = v:GetAttribute('closedPoint'):Lerp(v.C1, self.alpha[set])
						end
					end

					if (checkWelds('openPoint', 0, false) and self.state == 'Opening') then
						self.state = 'Open'
						core.statValues[(self.sideJoin) .. "Door_State"] = self.state
						task.spawn(coreFunctions.updateStatValues)
						self.Opened:Fire()
					end

					dtTime = heartbeat:Wait()

				end
				if (self.state ~= 'Opening') then return end
				self.velocity[set] = 0
				doorSpeedValue.Value = 0
				if (checkWelds('openPoint', 0, false) and self.state == 'Opening') then
					self.state = 'Open'
					core.statValues[(self.sideJoin) .. "Door_State"] = self.state
					task.spawn(coreFunctions.updateStatValues)
					self.Opened:Fire()
				end

			else
				for i, v in pairs(doorWelds:GetChildren()) do
					local newThread = task.spawn(function()
						local innerDoorsData, outerDoorsData = doorEngineClass.config.Doors.Realistic_Doors_Data, doorEngineClass.config.Doors.Realistic_Outer_Doors_Data
						local data = doorEngineClass.config.Doors[set == 'Inner' and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data']
						if (startingState == 'Closed' and data.Enable_Open) then
							local hasCompleted = legacyEasing.interpolate(v, v:GetAttribute('interlockOpenPoint'), data.Open_Easing_Style, data.Open_Time, function() return {self.state ~= 'Opening'} end)
							if (not hasCompleted) then return end
						end
						if (startingState == 'Closed') then
							if (set == 'Inner' and outerDoorsData.Enable_Open) then
								local hasCompleted = coreFunctionsModule.conditionalWait(outerDoorsData.Open_Time, function() return {self.state == 'Opening'} end)
								if (not hasCompleted) then return end
							elseif (set == 'Outer' and innerDoorsData.Enable_Open) then
								local hasCompleted = coreFunctionsModule.conditionalWait(innerDoorsData.Open_Time, function() return {self.state == 'Opening'} end)
								if (not hasCompleted) then return end
							end
						end
						legacyEasing.interpolate(v, v:GetAttribute('openPoint'), doorEngineClass.config.Doors.Open_Easing_Style, duration*distanceFactor, function() return {self.state ~= 'Opening'} end)
						if (self.state ~= 'Opening') then return end
						if (checkWelds('openPoint', 0, false) and self.state == 'Opening') then
							self.state = 'Open'
							core.statValues[(self.sideJoin) .. "Door_State"] = self.state
							task.spawn(coreFunctions.updateStatValues)
							self.Opened:Fire()
						end
					end)
					table.insert(self.openingThreads, newThread)
				end
			end
		end

		if (doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Opening.Enable) then
			if (self.state ~= 'Opening') then return end
			task.spawn(function()
				for i, part in ipairs(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) do
					local thread = task.spawn(runDoor, part)
					table.insert(self.openingThreads, thread)
					
					local hasCompleted = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Opening.Delay, function()
						return {self.state == 'Opening'}
					end)
					
					if (not hasCompleted) then return end
				end
			end)
		else
			for _, v in pairs({'Inner', 'Outer'}) do
				local thread = task.spawn(runDoor, v)
				table.insert(self.openingThreads, thread)
			end
		end
	end
	
	function self:Close(floor)

		local startingState = self.state
		if (self.state ~= 'Open' and self.state ~= 'Opening' and self.state ~= 'Stopped') then return end
		self.closingThread = task.spawn(function()
			for _, v in pairs(self.openingThreads) do
				pcall(task.cancel, v)
			end
			self.Opened:Destroy()
			self.state = 'Closing'
			self.lanternsReset = false
			core.statValues[(self.sideJoin) .. "Door_State"] = self.state
			task.spawn(coreFunctions.updateStatValues)

			local registeredFloor = coreFunctions.findRegisteredFloor(floor)
			if (not registeredFloor) then return end
			local carWelds, floorWelds = car.Door_Engine_Welds:FindFirstChild(self.side), registeredFloor.floorInstance.Door_Engine_Welds:FindFirstChild(self.side)
			local distanceFactor = 0
			for i, v in pairs(carWelds:GetChildren()) do
				local dist = ((v:GetAttribute('closedPoint').Position-v.C0.Position).Magnitude/(v:GetAttribute('closedPoint').Position-v:GetAttribute('openPoint').Position).Magnitude)/#carWelds:GetChildren()
				distanceFactor += dist
			end
			local openSound, closeSound = self["doorOpenSoundFloor" .. (floor)] or self.doorOpenSound, self["doorCloseSoundFloor" .. (floor)] or self.doorCloseSound
			openSound:Stop()
			coroutine.wrap(function()
				if (startingState == 'Open') then
					local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Close_Sound_Delay, function() return {self.state == 'Closing'} end)
					if (not hasPassed) then return end
				end
				closeSound.TimePosition = closeSound.TimeLength*(1-distanceFactor)
				task.wait()
				closeSound:Play()
			end)()
			if (startingState == 'Open') then
				local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Close_Delay, function() return {self.state == 'Closing'} end)
				if (not hasPassed) then return end
			end

			local function runDoor(set)
				local velocityConfig = doorEngineClass.config.Doors.Custom_Door_Operator_Config[set].Closing
				if ((set ~= 'Inner' and set ~= 'Outer') or (velocityConfig.Enable and set == 'Outer' and doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable)) then return end
				local doorWelds = set == 'Inner' and car.Door_Engine_Welds:FindFirstChild(self.side) or floorWelds
				if (not doorWelds) then return end

				local direction = (registeredFloor.level.Position-carLevel.Position)

				local duration = self.nudging and doorEngineClass.config.Doors.Nudge_Speed or doorEngineClass.config.Doors.Door_Close_Speed

				local masterWeld,dist = nil,math.huge
				for _, v in pairs(doorWelds:GetChildren()) do
					local distance = (v:GetAttribute('openPoint').Position-v:GetAttribute('closedPoint').Position).Magnitude
					if (distance < dist and distance > 0) then
						masterWeld = v
						dist = distance
					end
				end

				local function checkWelds(point, threshold, includeFloorDoors)
					for _, v in pairs(carWelds:GetChildren()) do
						if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
					end
					if (includeFloorDoors == true) then
						for _, v in pairs(floorWelds:GetChildren()) do
							if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
						end
					end
					return true
				end

				local lastSLEDTick = tick()
				local startSLEDTick = tick()

				for i, v in pairs({'Interior', 'Exterior'}) do
					if (not doorEngineClass.config.Color_Database.Lanterns[v].Reset_After_Door_Close) then
						self.lanternsReset = true
						self.LanternsReset:Fire({v})
					end
				end

				if (velocityConfig.Enable) then
					if (startingState == 'Open') then
						self.velocity[set] = 0
						self.currentStage.Closing[set] = 1
					else
						self.velocity[set] = -self.velocity[set]
					end

					local startTime = os.clock()
					local startLerpTime
					local stageAccelTime,initialVelocity,stageSpeed
					local decelerating = false
					local lastVelocity = self.velocity[set]
					local delayTick

					local doorSpeed = dist/duration
					local lastDist

					local distOffset = math.clamp(velocityConfig.Deceleration_Offset, 0, math.huge)
					local minSpeed = math.clamp(velocityConfig.Minimum_Speed or .05, 0, doorSpeed)

					local dtTime = 0

					local function getFloorWeldFromCarWeld(weld)
						for i, v in pairs(floorWelds:GetChildren()) do
							if (v == weld) then return v end
						end
						return nil
					end
					
					local bounceFactor = 1
					local bounceVel = 0

					local parent = self.doorSet:IsDescendantOf(car) and elevator:WaitForChild('Legacy') or self.doorSet.Parent
					local doorSpeedValue = parent:FindFirstChild((self.sideJoin) .. "Door_Speed")

					while (self.alpha[set] > 0 and (self.state == 'Closing' or self.state == 'Closed')) do
						local thisConfig = typeof(velocityConfig.Custom_Acceleration_Stages) == 'table' and velocityConfig.Custom_Acceleration_Stages or {}
						local currentStage = thisConfig[self.currentStage.Closing[set]]

						local thisDist = (masterWeld:GetAttribute('closedPoint').Position-masterWeld.C0.Position).Magnitude
						local thisDistCheck = thisDist/dist <= velocityConfig.Deceleration_Distance*(math.clamp((self.velocity[set])/doorSpeed, 0, 1))

						local data = doorEngineClass.config.Doors.Sensor_LED_Data.Closing_Color
						if (self.state == 'Closing') then
							if ((tick()-startSLEDTick)/data.Delay > 1) then
								local cfg = (tick()-lastSLEDTick)/data.Flash_Time < 1 and data.Active or data.Inactive
								if ((tick()-lastSLEDTick)/data.Flash_Time/2 > 1) then
									lastSLEDTick = tick()
								end
								for i, v in pairs(self.sensorLEDs) do
									v.Color = cfg.Color
									v.Material = cfg.Material
								end
							else
								lastSLEDTick = tick()
								for i, v in pairs(self.sensorLEDs) do
									v.Color = data.Active.Color
									v.Material = data.Active.Material
								end
							end
						end

						if (not thisDistCheck) then
							if (not decelerating) then
								if (currentStage) then
									if (not startLerpTime) then
										startLerpTime = os.clock()
										initialVelocity = self.velocity[set]
										stageSpeed = math.clamp(currentStage.Speed, 0, doorSpeed)
										stageAccelTime = coreFunctionsModule.getAccelerationTime(initialVelocity, stageSpeed, if (currentStage.Acceleration == 'USE_ACCELERATION') then velocityConfig.Acceleration else currentStage.Acceleration)
									else
										local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
										self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, stageSpeed, alpha)
										if (alpha >= 1 and thisConfig[self.currentStage.Closing[set]+1]) then
											if (not delayTick) then
												delayTick = os.clock()
											elseif ((os.clock()-delayTick)/currentStage.Delay_Before_Next_Stage >= 1) then
												self.currentStage.Closing[set] = math.max(1, self.currentStage.Closing[set]+1)
												startLerpTime = nil
											end
										end
									end
								else
									if (not startLerpTime) then
										startLerpTime = os.clock()
										initialVelocity = self.velocity[set]
										stageAccelTime = coreFunctionsModule.getAccelerationTime(initialVelocity, doorSpeed, velocityConfig.Acceleration)
									else
										local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
										self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, doorSpeed, alpha)
									end
								end
							end
						else
							if (not decelerating) then
								decelerating = true
								lastDist = thisDist
								lastVelocity = self.velocity[set]
							end
							if (velocityConfig.Deceleration_Rate == 'Constant') then
								local distOff = thisDist-distOffset
								local currentSpeed = self.velocity[set]
								local deceleration = currentSpeed^2/(2*math.max(.001, distOff))
								local SPEED = math.max(0, currentSpeed-deceleration*dtTime)
								self.velocity[set] = math.max(minSpeed, SPEED)
							end
						end

						self.alpha[set] = math.clamp(self.alpha[set]-((self.velocity[set]/doorSpeed)/duration)*dtTime, 0, 1)
						
						doorSpeedValue.Value = -math.abs(self.velocity[set])

						if (doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable) then
							for _,weld in pairs(carWelds:GetChildren()) do
								weld.C0 = weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set])
								if (weld:FindFirstChild('Door_Weld')) then
									local data = getFloorWeldFromCarWeld(weld.Door_Weld.Value)
									if (data) then
										local goal = CFrame.new((weld:GetAttribute('closedPoint').Position-weld:GetAttribute('openPoint').Position).Unit*(doorEngineClass.config.Doors.New_Attachment_Doors_Config.Attachment_Threshold))*(weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set]))
										weld.Door_Weld.Value.C0 = CFrame.new(
											math.clamp(goal.X,data:GetAttribute('openPoint').X >= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X,data:GetAttribute('openPoint').X <= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X),
											math.clamp(goal.Y,data:GetAttribute('openPoint').Y >= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y,data:GetAttribute('openPoint').Y <= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y),
											math.clamp(goal.Z,data:GetAttribute('openPoint').Z >= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z,data:GetAttribute('openPoint').Z <= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z)
										)
									end
								end
							end
						else
							for i, v in pairs(doorWelds:GetChildren()) do
								v.C0 = v:GetAttribute('closedPoint'):Lerp(v.C1, self.alpha[set])
							end
						end

						-- // Check distance for lanterns reset ratio // --
						if ((thisDist/dist) <= doorEngineClass.config.Color_Database.Lanterns.Door_Distance_Reset_Ratio and (not self.lanternsReset)) then
							self.lanternsReset = true
							self.LanternsReset:Fire({'Interior', 'Exterior'})
						end

						if (checkWelds('closedPoint', doorEngineClass.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
							self.state = 'Closed'
							core.statValues[(self.sideJoin) .. "Door_State"] = self.state
							task.spawn(coreFunctions.updateStatValues)
							if (not self.lanternsReset) then
								self.lanternsReset = true
								self.LanternsReset:Fire({'Interior', 'Exterior'})
								for i, v in pairs(self.sensorLEDs) do
									v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color
									v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material
								end
							end
							self.Closed:Fire()
						end

						dtTime = heartbeat:Wait()

					end
					if (self.state ~= 'Closing') then return end
					self.velocity[set] = 0
					doorSpeedValue.Value = 0
					if (checkWelds('closedPoint', 0, true) and self.state == 'Closing') then
						self.state = 'Closed'
						core.statValues[(self.sideJoin) .. "Door_State"] = self.state
						task.spawn(coreFunctions.updateStatValues)
						if (not self.lanternsReset) then
							self.lanternsReset = true
							self.LanternsReset:Fire({'Interior', 'Exterior'})
							for i, v in pairs(self.sensorLEDs) do
								v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color
								v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material
							end
						end
						self.Closed:Fire()
					end
				else
					local newThread = task.spawn(function()
						while (self.state == 'Closing') do
							local data = doorEngineClass.config.Doors.Sensor_LED_Data.Closing_Color
							local cfg = (tick()-lastSLEDTick)/data.Flash_Time < 1 and data.Active or data.Inactive
							if ((tick()-lastSLEDTick)/data.Flash_Time/2 > 1) then
								lastSLEDTick = tick()
							end
							for i, v in pairs(self.sensorLEDs) do
								v.Color = cfg.Color
								v.Material = cfg.Material
							end
							heartbeat:Wait()
						end
					end)
					table.insert(self.openingThreads, newThread)
					for i, v in pairs(doorWelds:GetChildren()) do
						local newThread = task.spawn(function()
							local innerDoorsData, outerDoorsData = doorEngineClass.config.Doors.Realistic_Doors_Data, doorEngineClass.config.Doors.Realistic_Outer_Doors_Data
							local data = doorEngineClass.config.Doors[set == 'Inner' and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data']
							local hasCompleted = legacyEasing.interpolate(v, v:GetAttribute(data.Enable_Close and 'interlockClosedPoint' or 'closedPoint'), doorEngineClass.config.Doors.Close_Easing_Style, duration*distanceFactor, function() return {self.state ~= 'Closing'} end)
							if (not hasCompleted) then return end
							if (data.Enable_Close) then
								local hasCompleted = legacyEasing.interpolate(v, v:GetAttribute('closedPoint'), data.Close_Easing_Style, data.Close_Time, function()
									if (checkWelds('closedPoint', doorEngineClass.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
										self.state = 'Closed'
										core.statValues[(self.sideJoin) .. "Door_State"] = self.state
										task.spawn(coreFunctions.updateStatValues)
										if (not self.lanternsReset) then
											self.lanternsReset = true
											self.LanternsReset:Fire({'Interior', 'Exterior'})
										end
										self.Closed:Fire()
									end
									return {} end)
								if (not hasCompleted) then return end
							end
							if (self.state ~= 'Closing') then return end
							if (checkWelds('closedPoint', 0, true) and self.state == 'Closing') then
								if (not self.lanternsReset) then
									self.lanternsReset = true
									self.LanternsReset:Fire({'Interior', 'Exterior'})
								end
								self.state = 'Closed'
								core.statValues[(self.sideJoin) .. "Door_State"] = self.state
								task.spawn(coreFunctions.updateStatValues)
								self.Closed:Fire()
							end
						end)
						table.insert(self.openingThreads, newThread)
					end
				end
			end
			
			if (doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Closing.Enable) then
				if (self.state ~= 'Closing') then return end
				task.spawn(function()
					for i, part in ipairs(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) do
						local thread = task.spawn(runDoor, part)
						table.insert(self.openingThreads, thread)
						self.openingThreads[i] = nil
						local hasCompleted = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Closing.Delay, function()
							return {self.state == 'Closing'}
						end)
						if (not hasCompleted) then return end
					end
				end)
			else
				for i, v in pairs({'Inner', 'Outer'}) do
					local thread = task.spawn(runDoor, v)
					table.insert(self.openingThreads, thread)
					self.openingThreads[i] = nil
				end
			end
		end)
	end
	function self:IsValid(floor)
		local registeredFloor = coreFunctions.findRegisteredFloor(floor)
		if (not registeredFloor) then return false end
		local carWelds, floorWelds = car.Door_Engine_Welds:FindFirstChild(self.side), registeredFloor.floorInstance.Door_Engine_Welds:FindFirstChild(self.side)
		if ((not carWelds) or (not floorWelds)) then return false end
		return true
	end
	return self
end

function doorEngineClass.setUp(doorSet)
	if (doorSet.Name == 'Doors') then doorSet.Name = 'Front_Doors' end
	local side = string.split(doorSet.Name, 'Doors')[2] and string.split(doorSet.Name, 'Doors')[1]
	if (not side) then return end
	side = string.split(side, '_')[1]
	if (side == '') then side = 'Front' end
	local sideJoin = "{side == '' and '' or "{side}_"}"
	local parent = doorSet.Parent
	local elevator = doorEngineClass.elevator
	local car = elevator:FindFirstChild('Car')
	local platform = car:FindFirstChild('Platform')
	local level = parent:FindFirstChild('Level')
	local carLevel = car:FindFirstChild('Level') or platform
	local doorWeldsFolder = coreFunctions.createInstance(parent, (sideJoin) .. "Door_Welds", 'Folder', true)
	local doorEngineWeldsFolder = coreFunctions.createInstance(parent, 'Door_Engine_Welds', 'Folder', true)
	local doorEngineWeldsFolder_Side = coreFunctions.createInstance(doorEngineWeldsFolder, side, 'Folder', true)

	local doorSpeedValue = coreFunctions.createInstance(doorSet:IsDescendantOf(car) and elevator:WaitForChild('Legacy') or parent, (sideJoin) .. "Door_Speed", 'NumberValue', true)

	local dropKeyOpen = doorSet:FindFirstChild('Drop_Key_Open') or Instance.new('BoolValue', doorSet)
	dropKeyOpen.Name = 'Drop_Key_Open'

	if (doorSet:IsDescendantOf(car)) then
		local boundsCf, boundsSize = doorSet:GetBoundingBox()
		local doorSensorPartsFolder = coreFunctions.createInstance(car, 'Door_Sensor_Parts', 'Folder', true)
		local doorSensorPart = coreFunctions.createInstance(doorSensorPartsFolder, (sideJoin) .. "Sensor", 'Part', true, {
			Anchored = false,
			CanCollide = false,
			CanQuery = false,
			Transparency = 1,
			CFrame = boundsCf,
			Size = boundsSize,
		})
		coreFunctions.weldParts(doorSensorPart, doorSensorPart, platform, true, false)
	end

	for _,v in pairs(doorSet:GetChildren()) do
		local scaler = v:FindFirstChild('Scaler')
		if (not scaler) then continue end
		local open = scaler:FindFirstChild('Open')
		if (not open) then
			open = Instance.new('Part')
			open.Name = 'Open'
			open.Size = scaler.Size
			open.CanCollide = false
			open.Color = scaler.Color
			local cf = scaler.CFrame:ToWorldSpace(CFrame.new(0, 0, -((scaler.Parent.Name:sub(2,2) == 'R' and 1 or scaler.Parent.Name:sub(2,2) == 'L' and -1 or 0)*scaler.Size.Magnitude*.9)*scaler.Parent.Name:sub(3)))
			open.CFrame = cf
			open.Transparency = 1
			open.Parent = scaler
		end
		coreFunctions.weldParts(doorWeldsFolder, open, level, true, false)
		local engineWeld = coreFunctions.weldParts(doorEngineWeldsFolder_Side, scaler, open, true, false)
		engineWeld.Name = 'Door_Engine_Weld'
		engineWeld:SetAttribute('closedPoint', engineWeld.C0)
		engineWeld:SetAttribute('openPoint', engineWeld.C1)
		local x, y, z = engineWeld.C1:ToEulerAnglesXYZ()
		local data = doorEngineClass.config.Doors[engineWeld:IsDescendantOf(doorSet) and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data']
		local rotOpen = Vector3.new(x, y, z)/data.Open_Ratio
		local rotClosed = Vector3.new(x, y, z)/data.Close_Ratio
		engineWeld:SetAttribute('interlockOpenPoint', CFrame.new(engineWeld.C1.Position-(engineWeld.C1.Position/data.Open_Ratio))*CFrame.Angles(rotOpen.X, rotOpen.Y, rotOpen.Z))
		engineWeld:SetAttribute('interlockClosedPoint', CFrame.new(engineWeld.C1.Position-(engineWeld.C1.Position/data.Close_Ratio))*CFrame.Angles(rotClosed.X, rotClosed.Y, rotClosed.Z))
		coreFunctions.weldModel(v, scaler, {open}, doorWeldsFolder)
		scaler.Anchored = false
		scaler.CanQuery = true
		open.Anchored = false
	end
end

return doorEngineClass]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXEA8333F24D484FC5872AAA510EF2972E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Core_Functions</string>
								<string name="ScriptGuid">{51DDE65A-3AE5-4ED1-A391-CDFCD64E8B01}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local heartbeat =_G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module.lerp(a, b, t)
	return a+(b-a)*t
end

function module.getAccelerationTime(initialSpeed, finalSpeed, rate)
	return math.abs(finalSpeed-initialSpeed)/math.deg(rate)
end

function module.findAncestor(model, name)
	if (not model or typeof(model) ~= 'Instance') then return end
	local result = model:FindFirstChild(name, true)
	if (result) then
		return result
	else
		return module.findAncestor(model.Parent, name)
	end
end

function module.conditionalWait(duration, conditions)
	if (typeof(duration) ~= 'number') then return false end
	
	local function checkConditions()
		if (typeof(conditions) ~= 'function') then return true end
		for _, v in pairs(conditions()) do
			if (not v) then return false end
		end
		return true
	end
	
	local startTime = os.clock()
	while ((os.clock()-startTime)/duration < 1) do
		heartbeat:Wait()
		if (not checkConditions()) then return false, (os.clock()-startTime) end
	end
	return true, (os.clock()-startTime)
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX9D9C53BDFCD54D6A9280BDC69CADC029">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Signal</string>
								<string name="ScriptGuid">{1B5C5096-18EC-4A16-B139-1D5F3E7990A4}</string>
								<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	"lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	"
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	"lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	"
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	"lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	"
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- "true" if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	"lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	"
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use "Signal:Once" instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	"lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	"
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	"lua
	signal:DisconnectAll()
	"
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	"lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, " .. (Test = "Test") .. ", true)
	"
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as "Fire", but uses "task.defer" internally & doesn't take advantage of thread reuse.
	"lua
	signal:FireDeferred("Hello")
	"
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using "Once" might be a better solution.
	"lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	"
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	"Signal.Wrap". Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling "Destroy"
	on a signal will also disconnect all connections immediately.
	"lua
	signal:Destroy()
	"
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})]]></ProtectedString>
								<int64 name="SourceAssetId">10568398310</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX613598F9D4164EBAA9165DE25F0BE880">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Legacy_Easing</string>
								<string name="ScriptGuid">{12FBAD9B-FBA0-4620-B060-169C3944C23E}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

module.isPluginModule = true

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT


function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

module.easingStyles = {
	['Linear'] = {Enum.EasingStyle.Linear, Enum.EasingDirection.InOut},
	['In_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.In},
	['Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.Out},
	['In_Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.InOut},
	['In_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.In},
	['Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.Out},
	['In_Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.InOut},
	['In_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.In},
	['Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.Out},
	['In_Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.InOut},
	['In_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.In},
	['Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.Out},
	['In_Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.InOut},
	['In_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.In},
	['Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.Out},
	['In_Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.InOut},
	['In_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.In},
	['Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.Out},
	['In_Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.InOut},
	['In_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.In},
	['Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.Out},
	['In_Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.InOut},
	['In_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.In},
	['Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.Out},
	['In_Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut},
	['In_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.In},
	['In_Out_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.Out},
	['In_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.In},
	['Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.Out},
	['In_Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.InOut},
}
module.easingStyles.functions = {
	--Linear
	Linear = function(t, b, c, d)
		return c * t / d + b 
	end,

	--Quad
	In_Quad = function(t, b, c, d) 
		return c * math.pow(t / d, 2) + b 
	end,

	Out_Quad = function(t, b, c, d)
		t = t / d
		return -c * t * (t - 2) + b
	end,

	In_Out_Quad = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 2) + b end
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end,

	Out_In_Quad = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuad(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Cubic
	In_Cubic = function(t, b, c, d) 
		return c * math.pow(t / d, 3) + b 
	end,

	Out_Cubic = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 3) + 1) + b 
	end,

	In_Out_Cubic = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * t * t * t + b end
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end,

	Out_In_Cubic = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCubic(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end,


	--Quart

	On_Quart = function(t, b, c, d) 
		return c * math.pow(t / d, 4) + b 
	end,

	Out_Quart = function(t, b, c, d) 
		return -c * (math.pow(t / d - 1, 4) - 1) + b 
	end,

	In_Out_Quart = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 4) + b end
		return -c / 2 * (math.pow(t - 2, 4) - 2) + b
	end,

	Out_In_Quart = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuart(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Quint

	In_Quint = function(t, b, c, d)
		return c * math.pow(t / d, 5) + b 
	end,

	Out_Quint = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 5) + 1) + b 
	end,

	In_Out_Quint = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 5) + b end
		return c / 2 * (math.pow(t - 2, 5) + 2) + b
	end,

	Out_In_Quint = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuint(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Sine

	In_Sine = function(t, b, c, d) 
		return -c * math.cos(t / d * (math.pi / 2)) + c + b 
	end,

	Out_Sine = function(t, b, c, d) 
		return c * math.sin(t / d * (math.pi / 2)) + b 
	end,

	In_Out_Sine = function(t, b, c, d) 
		return -c / 2 * (math.cos(math.pi * t / d) - 1) + b 
	end,

	Out_In_Sine = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outSine(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inSine((t * 2) -d, b + c / 2, c / 2, d)
	end,

	--Expo

	In_Expo = function(t, b, c, d)
		if t == 0 then return b end
		return c * math.pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end,

	Out_Expo = function(t, b, c, d)
		if t == d then return b + c end
		return c * 1.001 * (-math.pow(2, -10 * t / d) + 1) + b
	end,

	In_Out_Expo = function(t, b, c, d)
		if t == 0 then return b end
		if t == d then return b + c end
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(2, 10 * (t - 1)) + b - c * 0.0005 end
		return c / 2 * 1.0005 * (-math.pow(2, -10 * (t - 1)) + 2) + b
	end,

	Out_In_Expo = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outExpo(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Circ

	In_Circ = function(t, b, c, d) 
		return(-c * (math.sqrt(1 - math.pow(t / d, 2)) - 1) + b) 
	end,

	Out_Circ = function(t, b, c, d)  
		return(c * math.sqrt(1 - math.pow(t / d - 1, 2)) + b) 
	end,

	In_Out_Circ = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return -c / 2 * (math.sqrt(1 - t * t) - 1) + b end
		t = t - 2
		return c / 2 * (math.sqrt(1 - t * t) + 1) + b
	end,

	Out_In_Circ = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCirc(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end,



	--Back
	Out_Back = function(t, b, c, d, s)
		s = s or 1.2
		t = t / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	end,

	In_Back = function(t, b, c, d, s)
		s = s or 1.70158
		t = t / d
		return c * t * t * ((s + 1) * t - s) + b
	end,

	In_Out_Back = function(t, b, c, d, s)
		s = (s or 1.70158) * 1.525
		t = t / d * 2
		if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end,

	Out_In_Back = function(t, b, c, d, s)
		if t < d / 2 then return module.easingStyles.types.outBack(t * 2, b, c / 2, d, s) end
		return module.easingStyles.types.inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end,

	--bounce

	Out_Bounce = function(t, b, c, d)
		t = t / d
		if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end
		if t < 2 / 2.75 then
			t = t - (1.5 / 2.75)
			return c * (7.5625 * t * t + 0.75) + b
		elseif t < 2.5 / 2.75 then
			t = t - (2.25 / 2.75)
			return c * (7.5625 * t * t + 0.9375) + b
		end
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end,

	In_Bounce = function(t, b, c, d) 
		return c - module.easingStyles.types.outBounce(d - t, 0, c, d) + b 
	end,

	In_Out_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.inBounce(t * 2, 0, c, d) * 0.5 + b end
		return module.easingStyles.types.outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end,

	Out_In_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outBounce(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end,
}

local function checkBreakStatements(statements)
	for i,v in pairs((statements and typeof(statements) == 'function') and statements() or {}) do
		if (v) then return true end
	end
	return false
end

local codeName = 'InterpolationCode'

local runningThreads = {}

local signal = require(script.Parent.Signal)

function module.interpolate(weld: Weld, c0: CFrame, easingStyle: any, duration: number, breakStatements: any)
	easingStyle = easingStyle or 'Linear'
	easingStyle = module.easingStyles.functions[easingStyle] or module.easingStyles.functions.Linear
	if (not runningThreads[weld]) then runningThreads[weld] = {} end
	for i, v in pairs(runningThreads[weld]) do
		v.event:Fire(false)
		v.event:Destroy()
		pcall(task.cancel, v.thread)
		runningThreads[weld][i] = nil
	end
	local event = signal.new()
	local thread = task.spawn(function()
		local startTime = os.clock()
		local startC0 = weld.C0
		local alpha = 0
		while (alpha < 1) do
			alpha = math.clamp(((os.clock()-startTime)/duration), 0, 1)
			weld.C0 = startC0:Lerp(c0, easingStyle(alpha, 0, 1, 1))
			if (checkBreakStatements(breakStatements)) then event:Fire(false) return end
			HEARTBEAT:Wait()
		end
		event:Fire(alpha >= 1)
	end)
	if (runningThreads[weld]) then
		table.insert(runningThreads[weld], { ['thread'] = thread, ['event'] = event})
	end
	return event:Wait()
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX82E7D402CDE6461C86E227680AE95BED">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Core_Modules_INTERNAL</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0ECBEC9163B043F5B0C2EEAC238D0D96">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Storage</string>
								<string name="ScriptGuid">{731BCE7D-DA48-4C80-B9C9-756088F16409}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX6B28C0F18BCC49C38B9F9D337C20CB28">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Legacy_Easing</string>
								<string name="ScriptGuid">{48388990-74ED-4A12-8214-7FE18ACFDD9C}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

module.easingStyles = {
	['Linear'] = {Enum.EasingStyle.Linear, Enum.EasingDirection.InOut},
	['In_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.In},
	['Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.Out},
	['In_Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.InOut},
	['In_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.In},
	['Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.Out},
	['In_Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.InOut},
	['In_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.In},
	['Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.Out},
	['In_Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.InOut},
	['In_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.In},
	['Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.Out},
	['In_Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.InOut},
	['In_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.In},
	['Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.Out},
	['In_Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.InOut},
	['In_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.In},
	['Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.Out},
	['In_Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.InOut},
	['In_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.In},
	['Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.Out},
	['In_Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.InOut},
	['In_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.In},
	['Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.Out},
	['In_Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut},
	['In_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.In},
	['In_Out_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.Out},
	['In_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.In},
	['Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.Out},
	['In_Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.InOut},
}
module.easingStyles.functions = {
	--Linear
	Linear = function(t, b, c, d)
		return c * t / d + b 
	end,

	--Quad
	In_Quad = function(t, b, c, d) 
		return c * math.pow(t / d, 2) + b 
	end,

	Out_Quad = function(t, b, c, d)
		t = t / d
		return -c * t * (t - 2) + b
	end,

	In_Out_Quad = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 2) + b end
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end,

	Out_In_Quad = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuad(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Cubic
	In_Cubic = function(t, b, c, d) 
		return c * math.pow(t / d, 3) + b 
	end,

	Out_Cubic = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 3) + 1) + b 
	end,

	In_Out_Cubic = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * t * t * t + b end
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end,

	Out_In_Cubic = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCubic(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end,


	--Quart

	On_Quart = function(t, b, c, d) 
		return c * math.pow(t / d, 4) + b 
	end,

	Out_Quart = function(t, b, c, d) 
		return -c * (math.pow(t / d - 1, 4) - 1) + b 
	end,

	In_Out_Quart = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 4) + b end
		return -c / 2 * (math.pow(t - 2, 4) - 2) + b
	end,

	Out_In_Quart = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuart(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Quint

	In_Quint = function(t, b, c, d)
		return c * math.pow(t / d, 5) + b 
	end,

	Out_Quint = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 5) + 1) + b 
	end,

	In_Out_Quint = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 5) + b end
		return c / 2 * (math.pow(t - 2, 5) + 2) + b
	end,

	Out_In_Quint = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuint(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Sine

	In_Sine = function(t, b, c, d) 
		return -c * math.cos(t / d * (math.pi / 2)) + c + b 
	end,

	Out_Sine = function(t, b, c, d) 
		return c * math.sin(t / d * (math.pi / 2)) + b 
	end,

	In_Out_Sine = function(t, b, c, d) 
		return -c / 2 * (math.cos(math.pi * t / d) - 1) + b 
	end,

	Out_In_Sine = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outSine(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inSine((t * 2) -d, b + c / 2, c / 2, d)
	end,

	--Expo

	In_Expo = function(t, b, c, d)
		if t == 0 then return b end
		return c * math.pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end,

	Out_Expo = function(t, b, c, d)
		if t == d then return b + c end
		return c * 1.001 * (-math.pow(2, -10 * t / d) + 1) + b
	end,

	In_Out_Expo = function(t, b, c, d)
		if t == 0 then return b end
		if t == d then return b + c end
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(2, 10 * (t - 1)) + b - c * 0.0005 end
		return c / 2 * 1.0005 * (-math.pow(2, -10 * (t - 1)) + 2) + b
	end,

	Out_In_Expo = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outExpo(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Circ

	In_Circ = function(t, b, c, d) 
		return(-c * (math.sqrt(1 - math.pow(t / d, 2)) - 1) + b) 
	end,

	Out_Circ = function(t, b, c, d)  
		return(c * math.sqrt(1 - math.pow(t / d - 1, 2)) + b) 
	end,

	In_Out_Circ = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return -c / 2 * (math.sqrt(1 - t * t) - 1) + b end
		t = t - 2
		return c / 2 * (math.sqrt(1 - t * t) + 1) + b
	end,

	Out_In_Circ = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCirc(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end,



	--Back
	Out_Back = function(t, b, c, d, s)
		s = s or 1.2
		t = t / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	end,

	In_Back = function(t, b, c, d, s)
		s = s or 1.70158
		t = t / d
		return c * t * t * ((s + 1) * t - s) + b
	end,

	In_Out_Back = function(t, b, c, d, s)
		s = (s or 1.70158) * 1.525
		t = t / d * 2
		if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end,

	Out_In_Back = function(t, b, c, d, s)
		if t < d / 2 then return module.easingStyles.types.outBack(t * 2, b, c / 2, d, s) end
		return module.easingStyles.types.inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end,

	--bounce

	Out_Bounce = function(t, b, c, d)
		t = t / d
		if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end
		if t < 2 / 2.75 then
			t = t - (1.5 / 2.75)
			return c * (7.5625 * t * t + 0.75) + b
		elseif t < 2.5 / 2.75 then
			t = t - (2.25 / 2.75)
			return c * (7.5625 * t * t + 0.9375) + b
		end
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end,

	In_Bounce = function(t, b, c, d) 
		return c - module.easingStyles.types.outBounce(d - t, 0, c, d) + b 
	end,

	In_Out_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.inBounce(t * 2, 0, c, d) * 0.5 + b end
		return module.easingStyles.types.outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end,

	Out_In_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outBounce(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end,
}

local function checkBreakStatements(statements)
	for i,v in pairs((statements and typeof(statements) == 'function') and statements() or {}) do
		if (v) then return true end
	end
	return false
end

local codeName = 'InterpolationCode'

function module:interpolate(weld: Weld, c0: CFrame, c1: CFrame, easingStyle: any, duration: number, breakStatements: any)
	easingStyle = easingStyle or 'Linear'
	easingStyle = module.easingStyles.functions[easingStyle] or module.easingStyles.functions.Linear
	local newCode = tostring(math.random(0,1e5))
	weld:SetAttribute(codeName, newCode)
	local startTime = os.clock()
	local startC0 = weld.C0
	local startC1 = weld.C1
	local oldCode = weld:GetAttribute(codeName)
	local alpha = 0
	while (alpha <= 1 and weld.C0 ~= c0) do
		alpha = math.clamp(((os.clock()-startTime)/duration), 0, 1)
		weld.C0 = startC0:Lerp(c0, easingStyle(alpha, 0, 1, 1))
		weld.C1 = startC1:Lerp(c1, easingStyle(alpha, 0, 1, 1))
		oldCode = weld:GetAttribute(codeName)
		if (oldCode ~= newCode or checkBreakStatements(breakStatements)) then return false end
		HEARTBEAT:Wait()
	end
	return true
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBXB0982E55E40146F7AFA0E314EE1FC50C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Voice_Module</string>
							<string name="ScriptGuid">{B137F03C-2D02-428C-8781-B209B77B3C67}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local voiceModule = {}
voiceModule.__index = voiceModule

local modules = script.Parent:WaitForChild("Modules")
local coreFunctions = require(modules.Core_Functions)

function voiceModule.new(voiceSettings)
	local self = setmetatable(voiceModule, {})
	
	self.voiceSettings = voiceSettings
	
	return self
end

function voiceModule:PlayClip(voiceAudio, clip, pauseThread)
	if (not voiceAudio) then return warn('Cortex Voice Module - No sound instance supplied!') end
	if (not clip) then return warn('Cortex Voice Module - No voice clip supplied!') end
	
	local function run()
		voiceAudio.SoundId = clip.SoundId and "rbxassetid://" .. (clip.SoundId) or "rbxassetid://" .. (self.voiceSettings.SoundId)
		
		if not voiceAudio.IsLoaded then
			coreFunctions.conditionalWait(4, function() return {not voiceAudio.IsLoaded} end)
			if not voiceAudio.IsLoaded then
				return warn("Cortex Voice Module - Sound ID: " .. (voiceAudio.SoundId) .. " has failed to load within 4 seconds, please check if you have access to this audio.")
			end
		end
		
		voiceAudio.Volume = clip.Volume and clip.Volume or self.voiceSettings.Volume
		voiceAudio.Pitch = clip.Pitch and clip.Pitch or self.voiceSettings.Pitch
		voiceAudio.TimePosition = clip.Start or 0
		voiceAudio:Play()
		local clipEnd = clip.End or voiceAudio.TimeLength
		while (voiceAudio.IsPlaying and voiceAudio.TimePosition < clipEnd) do RunService.Heartbeat:Wait() end
		voiceAudio:Stop()
	end
	
	if (pauseThread) then
		run()
	else
		task.spawn(run)
	end
end

return voiceModule]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX5F2C8D1C102D4F7B8CE0549BB3705625">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">STOCK_VoiceModule</string>
								<string name="ScriptGuid">{F6C8E2AD-3B76-4F4F-8E38-DFB5FC4A17A5}</string>
								<ProtectedString name="Source"><![CDATA[return {
	['SoundId'] = 8492151402,
	['Volume'] = 2,
	['Pitch'] = 1,

	['Voice_Clips'] = {
		--[[ Options
			['SoundId'] = Id - Optional
			['Start'] = number -- If not provided it will default to 0
			['End'] = number -- If not provided it will default to clip time length
			['Volume'] = number - Optional
			['Pitch'] = number - Optional
			
			Optional options fallback to the main values at the top of the script if not present
		]]

		--//Floors\\--
		['1st'] = {['Start']=36.709, ['End']=37.334},
		['2nd'] = {['Start']=37.505, ['End']=38.086},
		['3rd'] = {['Start']=38.364, ['End']=38.903},
		['4th'] = {['Start']=39.142, ['End']=39.771},
		['5th'] = {['Start']=39.892, ['End']=40.430},

		--//Labels\\--
		['Floor'] = {['Start']=12.788, ['End']=13.360},
		['Level'] = {['Start']=14.657, ['End']=15.129},
		['Level_Suffix'] = {['Start']=67.700, ['End']=68.209},

		['Lobby'] = {['Start']=66.186, ['End']=66.749},
		['Parking'] = {['Start']=168.366, ['End']=168.992},

		--//Door Announcements\\--
		['Doors_Opening'] = {['Start']=165.380, ['End']=166.381},
		['Doors_Closing'] = {['Start']=166.678, ['End']=167.763},
		['Please_Remove_Obstruction'] = {['Start']=162.309, ['End']=164.397},

		--//Directional Announcements\\--
		['Going_Up'] = {['Start']=159.886, ['End']=160.686},
		['Going_Down'] = {['Start']=160.903, ['End']=161.741},

		--//Other Destination Dispatch Messages\\--
		['Select_Destination'] = {['Start']=0.022, ['End']=1.672},
		['Take_Car'] = {['Start']=1.800, ['End']=2.652},
		['Please_Scan_Access_Card'] = {['Start']=2.986, ['End']=4.469},
		['Handicap_Message'] = {['Start']=5.259, ['End']=10.653},
		['Fire_Recall'] = {['Start']=11.302, ['End']=12.227},
		['Through'] = {['Start']=15.645, ['End']=16.340},
		['And'] = {['Start']=16.456, ['End']=16.968},
		['Going_To'] = {['Start']=13.545, ['End']=14.371},

		--//DESTINATION DISPATCH LETTERING\\--
		['A'] = {['Start']=18.888, ['End']=19.326},
		['B'] = {['Start']=19.524, ['End']=19.889},
		['C'] = {['Start']=20.050, ['End']=20.543},
		['D'] = {['Start']=20.860, ['End']=21.293},
		['E'] = {['Start']=21.585, ['End']=22.033},
		['F'] = {['Start']=22.253, ['End']=22.651},
		['G'] = {['Start']=22.928, ['End']=23.366},
		['H'] = {['Start']=23.391, ['End']=24.578},

		--//FLOOR NUMBERS\\--
		['1'] = {['Start']=111.744, ['End']=112.268},
		['2'] = {['Start']=112.517, ['End']=113.019},
		['3'] = {['Start']=113.325, ['End']=113.942},
	},

	['Floor_Announcements'] = { --To add a voice segment for a floor, add: {{'Segment', ['Delay'] = .1}}
		['1'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'1', ['Delay'] = 0}},
		['2'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'2', ['Delay'] = 0}},
		['3'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'3', ['Delay'] = 0}},
	},

	['Settings'] = {
		['Floor_Announcements'] = {
			['Announce_Floor_On_Arrival'] = true, --Announces the floor the elevators arriving on
			['Announce_Floor_On_Stop'] = false, --Announces the floor the elevators on when the car comes to a full stop
		},
		['Directional_Announcements'] = {
			['Announce_After_Floor_Announcement'] = false, --Announces the direction after the floor announcement
			['Announce_After_Door_Open'] = true, --Announces the direction after the doors have fully opened
			['Up_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Going_Up', ['Delay'] = 0}}},
			['Down_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Going_Down', ['Delay'] = 0}}},
		},
		['Door_Announcements'] = {
			['Open_Announcement'] = {['Enabled'] = false, ['Sequence'] = {{'Doors_Opening', ['Delay'] = 0}}},
			['Close_Announcement'] = {['Enabled'] = false, ['Sequence'] = {{'Doors_Closing', ['Delay'] = 0}}},
			['Nudge_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Please_Remove_Obstruction', ['Delay'] = 0}}},
		},
		['Other_Announcements'] = {
			['Independent_Service_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Fire_Recall_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Safety_Brake_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Inspection_Service_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Out_Of_Service_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
		},
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX4374DD632C774332879A2AB1AA0CE462">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DefaultVoiceModule</string>
								<string name="ScriptGuid">{A5594268-EA50-468E-8BD2-798F3C9355ED}</string>
								<ProtectedString name="Source"><![CDATA[return function (config, source)
	if config.Voice_Config or config.Options then
		warn("-----------------------------------------------")
		warn("CORTEX VOICE CONFIG: Old config detected!")
		if config.Voice_Config then
			warn("Please rename 'Voice_Config' to 'Floor_Announcements'")
		end
		if config.Options then
			warn("Please rename 'Options' to 'Settings'")
		end
		warn("Or replace the whole file with the updated version")
		warn("Elevator location: " .. (source:GetFullName()))
		warn("-----------------------------------------------")
	end
	return {
		['SoundId'] = config.SoundId and config.SoundId or config.Voice_ID and config.Voice_ID or 0,
		['Volume'] = config.Volume and config.Volume or 1,
		['Pitch'] = config.Pitch and config.Pitch or 1,

		['Voice_Clips'] = config.Voice_Clips and config.Voice_Clips or {},
		['Floor_Announcements'] = config.Floor_Announcements and config.Floor_Announcements or config.Voice_Config and config.Voice_Config or {},

		['Settings'] = {
			['Floor_Announcements'] = {
				['Announce_Floor_On_Arrival'] = config.Settings and config.Settings.Floor_Announcements and config.Settings.Floor_Announcements.Announce_Floor_On_Arrival or false, --Announces the floor the elevators arriving on
				['Announce_Floor_On_Stop'] = config.Settings and config.Settings.Floor_Announcements and config.Settings.Floor_Announcements.Announce_Floor_On_Stop or false, --Announces the floor the elevators on when the car comes to a full stop
			},

			['Directional_Announcements'] = {
				['Announce_After_Floor_Announcement'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Announce_After_Floor_Announcement or false, --Announces the direction after the floor announcement
				['Announce_After_Door_Open'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Announce_After_Door_Open or false, --Announces the direction after the doors have fully opened
				['Up_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Up_Announcement and config.Settings.Directional_Announcements.Up_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Up_Announcement and config.Settings.Directional_Announcements.Up_Announcement.Sequence or {},
				},
				['Down_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Down_Announcement and config.Settings.Directional_Announcements.Down_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Down_Announcement and config.Settings.Directional_Announcements.Down_Announcement.Sequence or {},
				},
			},

			['Door_Announcements'] = {
				['Open_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Open_Announcement and config.Settings.Door_Announcements.Open_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Open_Announcement and config.Settings.Door_Announcements.Open_Announcement.Sequence or {},
				},
				['Close_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Close_Announcement and config.Settings.Door_Announcements.Close_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Close_Announcement and config.Settings.Door_Announcements.Close_Announcement.Sequence or {},
				},
				['Nudge_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Nudge_Announcement and config.Settings.Door_Announcements.Nudge_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Nudge_Announcement and config.Settings.Door_Announcements.Nudge_Announcement.Sequence or {},
				},
			},

			['Other_Announcements'] = {
				['Independent_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Independent_Service_Announcement and config.Settings.Other_Announcements.Independent_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Independent_Service_Announcement and config.Settings.Other_Announcements.Independent_Service_Announcement.Sequence or {},
				},
				['Fire_Recall_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Fire_Recall_Announcement and config.Settings.Other_Announcements.Fire_Recall_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Fire_Recall_Announcement and config.Settings.Other_Announcements.Fire_Recall_Announcement.Sequence or {},
				},
				['Safety_Brake_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Safety_Brake_Announcement and config.Settings.Other_Announcements.Safety_Brake_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Safety_Brake_Announcement and config.Settings.Other_Announcements.Safety_Brake_Announcement.Sequence or {},
				},
				['Inspection_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Inspection_Service_Announcement and config.Settings.Other_Announcements.Inspection_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Inspection_Service_Announcement and config.Settings.Other_Announcements.Inspection_Service_Announcement.Sequence or {},
				},
				['Out_Of_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Out_Of_Service_Announcement and config.Settings.Other_Announcements.Out_Of_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Out_Of_Service_Announcement and config.Settings.Other_Announcements.Out_Of_Service_Announcement.Sequence or {},
				}
			}
		},
	}
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX3E3A4A1E6C3642708B67BB891B1E6667">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">BETA_MAR_2024</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX2C427D551F0C4232B41A87AB29F339D4">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Multi_Bay</string>
						<string name="ScriptGuid">{BEEA8BC5-05ED-4CBB-9EF5-8CC136270EB9}</string>
						<ProtectedString name="Source"><![CDATA[--[[

CORTEX MULTIBAY - VER. 4
10/03/23

WRITTEN BY aaxtatious (540781721)

]]--

local module = {}
module.callFloorData = {}

return function(source)

	local collectionService = game:GetService('CollectionService')
	local replicatedStorage = game:GetService('ReplicatedStorage')

	local this = source.Parent
	local callButtons = this:FindFirstChild('Call_Buttons')
	if (not callButtons) then return warn("Cortex Multibay // GroupCalling :: " .. (this:GetFullName()) .. " :: Missing required instance Call_Buttons") end
	local elevators = this:FindFirstChild('Elevators')
	if (not callButtons) then return warn("Cortex Multibay // GroupCalling :: " .. (this:GetFullName()) .. " :: Missing required instance Elevators") end

	local allocator = require(script:WaitForChild('Allocator'))

	local configAvailable = source:FindFirstChild('Settings') ~= nil
	local config = configAvailable and require(source.Settings)

	local function setButton(button: Model, config: any, state: string, includeAllButtonsInFloorGroup: boolean?)
		if (typeof(config) ~= 'table') then return end
		local cfg = config[state]
		if (not cfg) then return end
		for _,v in pairs((includeAllButtonsInFloorGroup == true and button.Parent or button):GetDescendants()) do
			if ((includeAllButtonsInFloorGroup and v.Name == button.Name) or (not includeAllButtonsInFloorGroup)) then
				for _,light in pairs(v:GetDescendants()) do
					if ((not light:IsA('BasePart')) or light.Name ~= 'Light') then continue end
					light.Color = cfg.Color
					light.Material = cfg.Material
				end
			end
		end
	end

	for _,v in pairs(callButtons:GetChildren()) do
		local floorName = tonumber(string.split(v.Name, 'Floor_')[2]) or tonumber(string.split(v.Name, 'Floor')[2]) or tonumber(v.Name)
		if (not floorName) then continue end
		if (not module.callFloorData[tostring(floorName)]) then
			module.callFloorData[tostring(floorName)] = {}
		end
		for _,btnModel in pairs(v:GetDescendants()) do
			local buttonDirection = string.split(btnModel.Name, '_')[1]
			if (buttonDirection ~= 'Up' and buttonDirection ~= 'Down') then continue end
			local buttonPart: Part
			for _,v in pairs(btnModel:GetChildren()) do
				if ((not v:IsA('BasePart')) or v.Name ~= 'Button') then continue end
				buttonPart = v
				break
			end
			if (not buttonPart) then continue end
			buttonPart:SetAttribute('isACortexElevButton', true)
			--buttonPart.CollisionGroup = 'elevatorCollisionGroup'
			if (not module.callFloorData[tostring(floorName)][btnModel.Name]) then
				module.callFloorData[tostring(floorName)][btnModel.Name] = {
					elevator = nil,
					arrivalConnection = nil,
					otherConnections = {}
				}
			end
			if (config) then
				setButton(btnModel, config.Color_Config[btnModel.Name], 'Neutral_State', false)
			else
				local function getElevatorSettings(index)
					local elev = elevators:GetChildren()[index]
					if (((not elev) or (not elev:FindFirstChild('Settings'))) and elevators:GetChildren()[index+1]) then return getElevatorSettings(index+1) end
					return require(elev.Settings)
				end
				local newConfig = getElevatorSettings(1)
				if (not newConfig) then continue end
				setButton(btnModel, newConfig.Color_Database.Floor[btnModel.Name], 'Neautral_State', false)
			end
		end
	end

	local function addSound(append: Instance, name: string, soundId: number, volume: number, pitch: number, looped: boolean?, minDistance: number?, maxDistance: number?, playOnRemove: boolean?)
		if (typeof(append) ~= 'Instance') then return end
		local result = append:FindFirstChild(name)
		if (not result) then
			result = Instance.new('Sound')
			result.Name = name
			result.SoundId = "rbxassetid://" .. (soundId)
			result.Volume = volume
			result.PlaybackSpeed = pitch
			result.Looped = looped
			result.RollOffMinDistance = minDistance
			result.RollOffMaxDistance = maxDistance
			result.Parent = append
			if (playOnRemove == true) then
				result.PlayOnRemove = true
				result:Destroy()
			end
		end
		return result
	end

	local function handleButtonInput(user: Player? | any?, protocol: string, params: any)
		if (protocol ~= 'onButtonPressed' and protocol ~= 'onButtonReleased') then return end
		local button = params.button
		if (not button) then return end
		local buttonPart = button:FindFirstChild('Button')
		if (not buttonPart) then return end
		local buttonDirection = string.split(button.Name, '_')[1]
		local buttonSide = string.split(button.Name, '_')[2]
		local callFloor = tonumber(string.split(button.Parent.Name, 'Floor_')[2]) or tonumber(string.split(button.Parent.Name, 'Floor')[2]) or tonumber(button.Parent.Name)
		if (not callFloor) then return end
		local callFloorData = module.callFloorData[tostring(callFloor)][buttonDirection]
		if (not callFloorData) then return end
		local callDirection = buttonDirection == 'Up' and 1 or buttonDirection == 'Down' and -1 or nil
		if (not callDirection) then return end

		if (protocol == 'onButtonPressed') then
			if (config) then
				setButton(button, config.Color_Config[buttonDirection], 'Active_State', true)
				addSound(buttonPart, 'Button_Click', config.Sound_Config.Click.Sound_Id, config.Sound_Config.Click.Volume, config.Sound_Config.Click.Pitch, false, config.Sound_Config.Click.Roll_Off.Min, config.Sound_Config.Click.Roll_Off.Max, true)
			end

			local elevator = params.elevator or allocator.findElevator(elevators:GetChildren(), callFloor, callDirection)
			if ((not config) and (elevator or callFloorData.elevator)) then
				-- // No config located in the script? Use the elevator's config // --
				local elevator = callFloorData.elevator or elevator
				local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
				local soundConfig = require(elevator.Settings).Sound_Database.Others.Call_Button_Beep or require(elevator.Settings).Sound_Database.Others.Button_Beep
				addSound(buttonPart, 'Button_Click', soundConfig.Sound_Id, soundConfig.Volume, soundConfig.Pitch, false, 2, 50, true)
				setButton(button, newConfig, 'Lit_State', true)
			end
			--print(elevator, callFloorData.elevator)
			--print(callFloorData.elevator == elevator)
			--print(callFloorData.elevator and callFloorData.elevator:GetFullName(), elevator:GetFullName())
			if ((not elevator) or callFloorData.elevator) then return end
			if (not config) then
				-- // No config located in the script? Use the elevator's config // --
				local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
				local soundConfig = require(elevator.Settings).Sound_Database.Others.Call_Button_Beep or require(elevator.Settings).Sound_Database.Others.Button_Beep
				addSound(buttonPart, 'Button_Click', soundConfig.Sound_Id, soundConfig.Volume, soundConfig.Pitch, false, 2, 50, true)
				setButton(button, newConfig, 'Lit_State', true)
			end
			callFloorData.elevator = elevator
			--print("added call")
			elevator.Cortex_API:Fire('Add_Call', { ['call'] = callFloor, ['direction'] = callDirection, ['side'] = (buttonSide ~= '' and buttonSide ~= nil) and buttonSide or nil})
			if (callFloorData.arrivalConnection) then return end
			local isIdle = (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value) and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Queue_Direction.Value == string.sub(button.Name, 1, 1) or elevator.Legacy.Queue_Direction.Value == 'N')
			if (not isIdle) then
				callFloorData.arrivalConnection = elevator.Cortex_API.Event:Connect(function(protocol, params)
					if (protocol ~= 'onCallRespond') then return end
					--print(params)
					if (params.floor == callFloor and params.direction == string.sub(button.Name, 1, 1)) then
						for i, v in pairs(callFloorData.otherConnections) do
							callFloorData.otherConnections[i]:Disconnect()
							callFloorData.otherConnections[i] = nil
						end
						callFloorData.arrivalConnection:Disconnect()
						callFloorData.arrivalConnection = nil
						callFloorData.elevator = nil
						if (not config) then
							-- // No config located in the script? Use the elevator's config // --
							local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
							setButton(button, newConfig, 'Neautral_State', true)
						else
							setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
						end
					end
				end)
			end

			for _, v in pairs(elevator.Legacy:GetChildren()) do
				if v.Name == 'Independent_Service' or v.Name == 'Fire_Service' or v.Name == 'Stop' or v.Name == 'Inspection' or v.Name == 'Out_Of_Service' then
					table.insert(callFloorData.otherConnections, v:GetPropertyChangedSignal('Value'):Connect(function()
						if v.Value then
							for i, v in pairs(callFloorData.otherConnections) do
								callFloorData.otherConnections[i]:Disconnect()
								callFloorData.otherConnections[i] = nil
							end
							callFloorData.arrivalConnection:Disconnect()
							callFloorData.arrivalConnection = nil
							callFloorData.elevator = nil
							if (not config) then
								-- // No config located in the script? Use the elevator's config // --
								local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
								setButton(button, newConfig, 'Neautral_State', true)
							else
								setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
							end
						end
					end))
				end
			end
			--print("added call")
			--elevator.Cortex_API:Fire('Add_Call', { ['call'] = callFloor, ['direction'] = callDirection, ['side'] = (buttonSide ~= '' and buttonSide ~= nil) and buttonSide or nil})
		else
			local elevator = callFloorData.elevator
			if (not elevator) then
				local function getElevatorSettings(index)
					local elev = elevators:GetChildren()[index]
					if (((not elev) or (not elev:FindFirstChild('Settings'))) and elevators:GetChildren()[index+1]) then return getElevatorSettings(index+1) end
					return require(elev.Settings)
				end
				if config then
					setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
				else
					local newConfig = getElevatorSettings(1)
					if (not newConfig) then return end
					setButton(button, newConfig.Color_Database.Floor[buttonDirection], 'Neautral_State', false)
				end
				return
			end
			-- // Let's do an idle check, only reset the button and its values if this check passes // --
			local isIdle = (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value) and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Queue_Direction.Value == string.sub(button.Name, 1, 1) or elevator.Legacy.Queue_Direction.Value == 'N')
			if (isIdle) then
				for i, v in pairs(callFloorData.otherConnections) do
					callFloorData.otherConnections[i]:Disconnect()
					callFloorData.otherConnections[i] = nil
				end
				if (callFloorData.arrivalConnection) then
					callFloorData.arrivalConnection:Disconnect()
					callFloorData.arrivalConnection = nil
				end
				callFloorData.elevator = nil
				if (config) then
					setButton(button, config.Color_Config[buttonDirection], 'Neutral_State', true)
				else
					-- // No config located in the script? Use the elevator's config // --
					local newConfig = require(elevator.Settings).Color_Database.Floor[buttonDirection]
					setButton(button, newConfig, 'Neautral_State', true)
				end
			end
		end
	end

	local buttonAPI,buttonRemote,allocatorAPI = this:FindFirstChild('Button_API'),this:FindFirstChild('Button_Remote'),this:FindFirstChild('Cortex_Allocator_API')
	if (not buttonAPI) then
		buttonAPI = Instance.new('BindableEvent')
		buttonAPI.Name = 'Button_API'
		buttonAPI.Parent = this
	end
	if (not buttonRemote) then
		buttonRemote = Instance.new('RemoteEvent')
		buttonRemote.Name = 'Button_Remote'
		buttonRemote.Parent = this
	end
	if (not allocatorAPI) then
		allocatorAPI = Instance.new('BindableFunction')
		allocatorAPI.Name = 'Cortex_Allocator_API'
		allocatorAPI.Parent = this
		function allocatorAPI.OnInvoke(params)
			local elevator = allocator.findElevator(params.elevators, params.floor, params.direction)
			handleButtonInput(nil, 'onButtonPressed', {button = params.callButton, elevator = elevator})
			task.delay(.35, function()
				handleButtonInput(nil, 'onButtonReleased', {button = params.callButton})
			end)
			return elevator
		end
	end

	buttonAPI.Event:Connect(function(protocol, params)
		handleButtonInput(nil, protocol, params)
	end)
	buttonRemote.OnServerEvent:Connect(handleButtonInput)

end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX308957FCF0D84903A2244770CAF47005">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Allocator</string>
							<string name="ScriptGuid">{40952E41-FE39-4D5E-82A8-07DDE90B0583}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

local function absoluteDifference(a, b)
	return math.abs(a-b)
end

local function checkElevatorStatValue(elevator, name)
	if (not elevator) then return nil end
	if ((not elevator:FindFirstChild('Legacy'))) then return nil end
	if (elevator.Legacy:FindFirstChild(name)) then return elevator.Legacy:FindFirstChild(name).Value end
	return nil
end

local function isElevatorOutOfService(elevator)
	return (checkElevatorStatValue(elevator, 'Independent_Service')
		or checkElevatorStatValue(elevator, 'Fire_Service')
		or checkElevatorStatValue(elevator, 'Stop')
		or checkElevatorStatValue(elevator, 'Inspection')
		or checkElevatorStatValue(elevator, 'Out_Of_Service')
	)
end

function module.findElevator(elevators: {}, callFloor: number, callDirection: number)
	local CALL_DIRECTION = callDirection
	local availableElevators = {}
	for i,v in pairs(elevators) do
		if isElevatorOutOfService(v) then continue end
		local floor,destination,moveDirection,queueDirection = checkElevatorStatValue(v,'Floor'),checkElevatorStatValue(v,'Destination'),checkElevatorStatValue(v,'Move_Value'),checkElevatorStatValue(v,'Queue_Direction')
		if ((not floor) or (not destination) or (not moveDirection) or (not queueDirection)) then continue end
		table.insert(availableElevators, v)
	end
	--table.sort(availableElevators, function(a,b)
	--	return a.Name < b.Name
	--end)
	local sortedElevators = {}
	for _, elevator in availableElevators do
		if (((elevator.Legacy.Queue_Direction.Value == 'U' and callDirection == 1) or (elevator.Legacy.Queue_Direction.Value == 'D' and callDirection == -1) or elevator.Legacy.Queue_Direction.Value == 'N') and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value))
			or (elevator.Legacy.Move_Value.Value ~= -1 and elevator.Legacy.Queue_Direction.Value ~= 'D' and callDirection == 1 and elevator.Legacy.Raw_Floor.Value <= callFloor)
			or (elevator.Legacy.Move_Value.Value ~= 1 and elevator.Legacy.Queue_Direction.Value ~= 'U' and callDirection == -1 and elevator.Legacy.Raw_Floor.Value >= callFloor)
			or (elevator.Legacy.Queue_Direction.Value == 'N' and elevator.Legacy.Move_Value.Value == 0)
		then
			--print(elevator.Legacy.Move_Value.Value, elevator.Legacy.Queue_Direction.Value, callDirection, callFloor)
			--print(1, ((elevator.Legacy.Queue_Direction.Value == 'U' and callDirection == 1) or (elevator.Legacy.Queue_Direction.Value == 'D' and callDirection == -1) or elevator.Legacy.Queue_Direction.Value == 'N') and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value))
			--print(2, elevator.Legacy.Move_Value.Value == 1 and elevator.Legacy.Queue_Direction.Value == 'U' and callDirection == 1 and elevator.Legacy.Raw_Floor.Value <= callFloor)
			--print(3, elevator.Legacy.Move_Value.Value == -1 and elevator.Legacy.Queue_Direction.Value == 'D' and callDirection == -1 and elevator.Legacy.Raw_Floor.Value >= callFloor)
			--print(4, elevator.Legacy.Queue_Direction.Value == 'N' and elevator.Legacy.Move_Value.Value == 0)
			table.insert(sortedElevators, elevator)
		end
		
		--if (elevator.Legacy.Queue_Direction.Value == 'N'
		--	or ((elevator.Legacy.Queue_Direction.Value == 'U' and elevator.Legacy.Move_Value.Value ~= 1 and elevator.Legacy.Raw_Floor.Value <= callFloor and destinationCall > callFloor)
		--	or (elevator.Legacy.Queue_Direction.Value == 'D' and elevator.Legacy.Move_Value.Value ~= -1 and elevator.Legacy.Raw_Floor.Value >= callFloor --[[and destinationCall < callFloor]]))) then
		--	table.insert(sortedElevators, elevator)
		--end
	end

	if (#sortedElevators == 0) then
		--print("fallback")
		table.insert(sortedElevators, availableElevators[1])
	end

	table.sort(sortedElevators, function(a, b)
		if (absoluteDifference(a.Legacy.Raw_Floor.Value, callFloor) == absoluteDifference(b.Legacy.Raw_Floor.Value, callFloor)) then
			return a.Name < b.Name
		else
			return absoluteDifference(a.Legacy.Raw_Floor.Value, callFloor) < absoluteDifference(b.Legacy.Raw_Floor.Value, callFloor)
		end
	end)

	return sortedElevators[1]
	
	--local sortedElevators = {}
	--local nearestElevator
	--local minDistance = math.huge
	--for _, elevator in ipairs(availableElevators) do
	--	if isElevatorOutOfService(elevator) then continue end
	--	local statValues = elevator.Legacy
	--	local floor,direction,queueDirection = statValues.Floor.Value,statValues.Move_Value.Value,statValues.Queue_Direction.Value
	--	queueDirection = queueDirection == 'U' and 1 or queueDirection == 'D' and -1 or 0 --// Correct queue direction
	--	local distance = math.abs(floor-callFloor)
	--	if (distance < minDistance) then
	--		-- // If elevator is idle on call floor
	--		if ((floor == callFloor and direction == 0) and (queueDirection == callDirection or queueDirection == 0)) then
	--			nearestElevator = elevator
	--			minDistance = distance
	--			--// Check for elevators in direction & check for their queue direction
	--		elseif ((callDirection == 1 and floor <= callFloor and (direction == -1 or direction == 0) and (queueDirection == 1 or queueDirection == 0)) or (callDirection == -1 and floor >= callFloor and (direction == 1 or direction == 0) and ((queueDirection == -1 or queueDirection == 0)))) then
	--			nearestElevator = elevator
	--			minDistance = distance
	--			-- // Check for any elevator that is idle on any floor
	--		elseif (direction == 0 and (queueDirection == callDirection or queueDirection == 0)) then
	--			nearestElevator = elevator
	--			minDistance = distance
	--		end
	--	end
	--end
	--if (not nearestElevator) then
	--	return availableElevators[1]
	--end
	
	--return nearestElevator
end

return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBX651C72F789FF4D1F9001411F7472A0B6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Legacy</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="StringValue" referent="RBX75A3DA0FE2B54489A0FCB8C472025789">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Queue</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">[]</string>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX8F78E35799CD498C93F679709334CB61">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX4B14B776A2734839917878B90A740C67">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Raw_Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX23002FCCBA2C4086AFB8272593B9BDB9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Move_Value</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX19C44A6D0BD84CF59D4FD7F410E394F6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Arrow_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBXB265B65984A14F6ABF3D779A4BD392E6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Queue_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX83F981B04A6346FBB96439B0FE63F512">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Destination</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXA575E62BE97E465AAEEE9DD831FE04B8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Remote_Call</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXD14ED5121C06438889CCAFEB6855A9C4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Fire_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX00C6348F0A974E27B0247FA9455A06BC">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Phase_1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXE5FB6AF18B57443B90EFA38CBD4B5C93">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Phase_2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX5DAD360B05B94FA29AE000E438A630A6">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Inspection</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXC933640ACB804F3FA35C997DFC7F74F0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Out_Of_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX828EDA911536422EA62873ECA8A33E1A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Independent_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX330A138B68DD4F658BE8C640838853A0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Current_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX48063421DC3846D18E101FB28C8F5B52">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Velocity</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX66ED0FA26B284DED8DBE1B07EE51F067">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Arrive_Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">-100000</double>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX29C3AC42829746EDB7149C94E8F85912">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Leveling</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX65011A7F351A438285421D311C06396F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Nudge</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXC28AF37963BC4F1F80F4F96FEE830535">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Stop</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX1C5C1DADB1DD41DEAF35683A3C94EBA2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Move_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX41188164007743D993D336B78EACDE32">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Pre_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX3E65BD2CA2664B3A89240CFFBBC2DFE0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_State</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">Closed</string>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX5E79AF37EB8449C282C001494758B6E5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Hold</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXAE4685FA26924D1DBD54EF3D2B485063">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Nudging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX6D697AA13EFB4A52A0ACCC0E0886CB73">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX14A33440B79D46119755B36385D3EFD2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_State</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">Closed</string>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX21DEA0EFABFB481A9DD09A835B56A80C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Hold</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXF2C82117CC394213A299D058AE9CDD37">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Nudging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX70911F2584294D3697B79FBE49D14B43">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX4E09052C33904FB9BB3CC535932A125F">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core</string>
						<string name="ScriptGuid">{C533B2EB-552A-4565-AF99-18A2E55CEB6F}</string>
						<ProtectedString name="Source"><![CDATA[--[[

	CORTEX CLASSIC V10 // OCTOBER 2023 REWRITE
	START DATE: 10/09/2023
	
	WRITTEN BY: aaxtatious (540781721) & ImFirstPlace (79641334)
	
	Â© 2024 Cortex Elevator Company.

]]--

local module = {
	['doorData'] = {},
	['statValues'] = {
		['Floor'] = 1,
		['Raw_Floor'] = 1,
		['Arrive_Floor'] = 1,
		['Move_Value'] = 0,
		['Move_Direction'] = 'N',
		['Direction'] = 'N',
		['Leveling'] = false,
		['Arriving'] = false,
		['Destination'] = 1,
		['Queue_Direction'] = 'N',
		['Arrow_Direction'] = 'N',
		['Stop'] = false,
		['Inspection'] = false,
		['Independent_Service'] = false,
		['Out_Of_Service'] = false,
		['Fire_Service'] = false,
		['Fire_Recall'] = false,
		['Phase_1'] = false,
		['Phase_2'] = false,
		['Parking'] = false,
		['Current_Speed'] = 0,
		['Velocity'] = 0,
		['Nudge'] = false,
	},
	['coreFunctions'] = {},
	['statFolderValues'] = {},
	['queue'] = {},
	['pluginModules'] = {},
	['sounds'] = {},
	['lockedCalls'] = {
		['car'] = {},
		['hall'] = {
			['up'] = {},
			['down'] = {}
		}
	},
	['safetyEnaged'] = true,
	['dropKeyCheckValues'] = {},
	['dropKeyHandlers'] = {}
}

local dependencies = script:WaitForChild('Dependencies')
local modules = script:WaitForChild('Modules')

local elevatorID = math.random(0, 1e5)

local heartbeat = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

local function checkIndependentService()
	return (not module.statValues.Fire_Service and module.statValues.Independent_Service)
end

local function checkFireServicePhase2()
	return (not module.statValues.Fire_Recall and module.statValues.Fire_Service and module.statValues.Phase_2)
end

local function weldModel(model, weldPart, ignoreList, append)
	if (typeof(model) ~= 'Instance') then return end
	local welds = {}
	for _,v in pairs(model:GetDescendants()) do
		if (not v:IsA('BasePart')) then continue end
		if (not weldPart) then weldPart = v end
		if (weldPart ~= v and (typeof(ignoreList) ~= 'table' or (not table.find(ignoreList, v)))) then
			local weld = Instance.new('Weld')
			weld.Name = (v.Name) .. "_To_" .. (weldPart.Name) .. "_Weld"
			weld.Part0, weld.Part1 = v, weldPart
			weld.C0, weld.C1 = CFrame.new(), weldPart.CFrame:ToObjectSpace(v.CFrame)
			weld.Parent = if (typeof(append) == 'Instance') then append else weldPart
			table.insert(welds, weld)
			v.Anchored = false
		end
	end
	return welds
end

local function weldParts(append, part0, part1, joinInPlace, animatable)
	if (typeof(append) ~= 'Instance') then append = part0 end
	local weld = Instance.new('Weld')
	weld.Name = (part0.Name) .. "_To_" .. (part1.Name) .. "_Weld"
	weld.Part0, weld.Part1 = part0, part1
	weld.C0, weld.C1 = CFrame.new(), part1.CFrame:ToObjectSpace(part0.CFrame)
	weld.Parent = if (typeof(append) == 'Instance') then append else part1
	return weld
end

module.coreFunctions.weldModel = weldModel
module.coreFunctions.weldParts = weldParts

local function createInstance(append, name, type, replaceByName, properties)
	if (typeof(append) ~= 'Instance') then return end
	if (typeof(name) ~= 'string') then return end
	local result = replaceByName == true and append:FindFirstChild(name)
	if (not result) then
		result = Instance.new(type)
		result.Name = name
		for property, value in if (typeof(properties) == 'table') then properties else {} do
			pcall(function()
				--if ((not result[property]) or typeof(result[property] ~= typeof(value))) then return end
				result[property] = value
			end)
		end
	end

	result.Parent = append
	return result
end

local function addSound(append, name, config, looped, minDistance, maxDistance)
	if (typeof(append) ~= 'Instance' or typeof(name) ~= 'string') then return end
	local newSound = append:FindFirstChild(name)
	if (not newSound) then
		newSound = createInstance(append, name, 'Sound', false, {
			SoundId = if (typeof(config.Sound_Id) == 'number' and config.Sound_Id ~= 0) then "rbxassetid://" .. (config.Sound_Id) else '',
			Volume = config.Volume,
			PlaybackSpeed = config.Pitch,
			Looped = if (typeof(config.Looped) == 'boolean') then config.Looped elseif (typeof(looped) == 'boolean') then looped else false,
			RollOffMinDistance = minDistance,
			RollOffMaxDistance = maxDistance
		})
	end
	return newSound
end

local function addPlayingSound(append, sound, pitchOffset)
	if (typeof(sound) ~= 'Instance' or (not sound:IsA('Sound'))) then return end
	local newSound = sound:Clone()
	newSound.Playing = true
	newSound.PlaybackSpeed = typeof(pitchOffset) == 'number' and newSound.PlaybackSpeed+pitchOffset or newSound.PlaybackSpeed
	newSound.Parent = append
	game:GetService('Debris'):AddItem(newSound, newSound.TimeLength + 0.1)
end

local function recursiveTable(t, callback)
	if (typeof(t) ~= 'table') then return end
	for i, v in pairs(t) do
		if (typeof(callback) == 'function') then callback(i, v) end
		if (typeof(v) == 'table') then recursiveTable(v, callback) end
	end
end

module.coreFunctions.recursiveTable = recursiveTable
module.coreFunctions.addSound = addSound
module.coreFunctions.addPlayingSound = addPlayingSound

module.coreFunctions.createInstance = createInstance

module.registeredFloors = {}

local function findRegisteredFloor(floor)
	floor = tostring(floor)
	return module.registeredFloors[floor]
end
module.coreFunctions.findRegisteredFloor = findRegisteredFloor

local coreFunctions = require(modules.Core_Functions)
local signal = require(modules.Signal)

local httpService = game:GetService('HttpService')
local runService = game:GetService('RunService')
local tweenService = game:GetService('TweenService')
local collectionService = game:GetService('CollectionService')
local players = game:GetService('Players')

function module.Start(source, config, buildData, moduleDependencies)

	local _VERSION = "Cortex Classic v" .. (buildData.VERSION)

	assert(typeof(source) == 'Instance', (_VERSION) .. " :: Source not valid for initiation")

	local ran, config = pcall(require, config)
	assert(ran, (_VERSION) .. " :: " .. (source.Parent:GetFullName()) .. " :: Config not valid for initiation: " .. (config))

	local elevator = source.Parent
	local configFile = require(dependencies.ConfigFile)(config, script)

	local newConfigFileClone = script.Dependencies.LiveSettings:Clone()
	local newConfigFile = require(newConfigFileClone)
	newConfigFile.Settings = configFile
	newConfigFileClone.Parent = elevator
	configFile = newConfigFile.Settings

	--assert(ran == true, (_VERSION) .. " :: " .. (source.Parent:GetFullName()) .. " :: ConfigFile not found | " .. (configFile))

	if (configFile.Sound_Database.Voice_Config.Voice_Clips == 'STOCK') then
		configFile.Sound_Database.Voice_Config.Voice_Clips = require(script.Voice_Module.DefaultVoiceModule)(require(script.Voice_Module.STOCK_VoiceModule), source)
	elseif typeof(configFile.Sound_Database.Voice_Config.Voice_Clips) == 'table' then
		configFile.Sound_Database.Voice_Config.Voice_Clips = require(script.Voice_Module.DefaultVoiceModule)(configFile.Sound_Database.Voice_Config.Voice_Clips, source)
	end



	local voiceConfig = configFile.Sound_Database.Voice_Config.Voice_Clips
	local voiceModule = require(script.Voice_Module).new(voiceConfig)

	local car = elevator:FindFirstChild('Car')
	local floors = elevator:FindFirstChild('Floors')
	local platform = car:FindFirstChild('Platform')
	local level = car:FindFirstChild('Level') or platform

	local counterweight = elevator:FindFirstChild('Counterweight')

	local fireServiceRecallFloor = -99999

	local elevatorPosition = platform.CFrame

	local elevatorMovementThread
	local elevatorRelevelThread

	--newConfigFile.Doors = configFile.Doors
	--liveModule.Parent = source.Parent

	dependencies.ConfigFile.Parent = elevator

	_G.Elevator_Output_Storage_GLOBAL[elevator.Name] = {}

	local pluginModuleData = {}
	for i, v in pairs(modules:GetChildren()) do
		task.spawn(function()
			local ran, res = pcall(require, v)
			if (not ran) then return end
			if (not res.isPluginModule) then return end
			res.config = configFile
			res.elevator = elevator
			pluginModuleData[v.Name] = { content=res, instance=v }
		end)
	end

	for i, v in pairs(source:FindFirstChild('Plugins_INTERNAL') and source.Plugins_INTERNAL:GetChildren() or {}) do
		local ran, res = pcall(require, v)
		if (not ran) then return print("INTERNAL PLUGIN MODULE '" .. (v.Name) .. "' SETUP FAILED :: " .. (res)) end
		local ran, res2 = pcall(function()
			return task.spawn(function() return res:INITIATE_PLUGIN_INTERNAL(script, source) end)
		end)
		if (not ran) then print("INTERNAL PLUGIN MODULE '" .. (v.Name) .. "' INITIATION FAILED :: " .. (res))
		else
			module.pluginModules[v.Name] = { content = res, module = v }
		end
	end

	-- // Check for any floors being added/removed // --
	floors.ChildAdded:Connect(function(child)
		task.wait()
		local floorName = tonumber(string.split(child.Name, 'Floor_')[2])
		if (not floorName) then return end
		if (findRegisteredFloor(floorName)) then return end
		local level = child:FindFirstChild('Level')
		if (not level) then return end
		module.registeredFloors[floorName] = nil
	end)
	floors.ChildRemoved:Connect(function(child)
		task.wait()
		local floorName = tonumber(string.split(child.Name, 'Floor_')[2])
		if (not floorName) then return end
		if (not findRegisteredFloor(floorName)) then return end
		local level = child:FindFirstChild('Level')
		if (not level) then return end
		module.registeredFloors[floorName] = { floorNumber = floorName, floorInstance = child, level = level }
	end)

	elevator:SetAttribute('elevatorID', elevatorID)
	collectionService:AddTag(elevator, 'CortexElevatorInstance')

	-- // Internal variables // --
	local doorEngine = pluginModuleData.Door_Engine.content
	local moveLock = false
	local preDooring = false
	local inspectionEnabled = false
	local inspectionLocked = false
	local releveling = false

	local inspectionMoving = false
	local inspectionStopping = false

	local inspectionMoveThread
	local inspectionStopThread

	local statValuesFolder = createInstance(elevator, 'Legacy', 'Folder', true)
	local valueTypes = {
		['boolean'] = 'Bool',
		['number'] = 'Number',
		['CFrame'] = 'CFrame',
		['string'] = 'String',
		['Vector3'] = 'Vector3',
	}

	local remoteCallValue = createInstance(statValuesFolder, 'Remote_Call', 'NumberValue', true)

	local api = createInstance(elevator, 'Cortex_API', 'BindableEvent', true)
	local remote = createInstance(elevator, 'Cortex_Remote', 'RemoteEvent', true)
	local elevatorSignal = createInstance(elevator, 'Cortex_Signal', 'BindableFunction', true)

	local carWeldsFolder = createInstance(car, 'Car_Welds', 'Folder', true)

	local playerWeldsFolder = createInstance(platform, 'Player_Welds', 'Folder', true)

	for i, v in pairs(floors:GetChildren()) do
		local floorNumber, level = tonumber(string.split(v.Name, 'Floor_')[2]), v:FindFirstChild('Level')
		if ((not floorNumber) or (not level)) then continue end
		module.registeredFloors[tostring(floorNumber)] = { floorNumber = floorNumber, floorInstance = v, level = level }
	end

	local startLoadTime = os.clock()

	-- // Cab region part // --
	local size = platform.Size+Vector3.new(0, 15, 0)
	local cabRegion = createInstance(car, 'Cab_Region', 'Part', true, {
		Anchored = false,
		CanCollide = false,
		CanTouch = false,
		CanQuery = false,
		Transparency = 1,
		CFrame = CFrame.new(platform.Position.X, platform.Position.Y+size.Y/2, platform.Position.Z)*CFrame.Angles(platform.CFrame:ToEulerAnglesXYZ()),
		Size = size,
	})

	cabRegion.Anchored = false
	cabRegion.CanCollide = false
	cabRegion.CanQuery = false

	for i,v in pairs(floors:GetChildren()) do
		if v:FindFirstChild('Level') then
			createInstance(v.Level, 'Drop_Key_Sound', 'Sound', true, {
				SoundId = 'rbxassetid://4496280365',
				Volume = 1,
				RollOffMaxDistance = 200,
				RollOffMinDistance = 5,
				Pitch = 2.55/config.Doors.Door_Open_Speed
			})
		end
	end

	local dropKeySound = createInstance(level, 'Drop_Key_Sound', 'Sound', true, {
		SoundId = 'rbxassetid://4496280365',
		Volume = 1,
		RollOffMaxDistance = 200,
		RollOffMinDistance = 5,
		Pitch = 2.55/config.Doors.Door_Open_Speed
	})

	weldParts(cabRegion, cabRegion, platform, true, false)
	local soundGroup = cabRegion:FindFirstChildOfClass('SoundGroup') or Instance.new('SoundGroup')
	soundGroup.Parent = cabRegion
	local equalizer = soundGroup:FindFirstChildOfClass('EqualizerSoundEffect') or Instance.new('EqualizerSoundEffect')
	equalizer.Name = 'Muffler'
	equalizer.Parent = soundGroup
	equalizer.HighGain = 0
	equalizer.LowGain = 0
	equalizer.MidGain = 0

	-- // Get bottom & top floor // --
	local bottomFloor, topFloor
	local bottomPoint, topPoint = math.huge, -math.huge
	for i, v in pairs(module.registeredFloors) do
		if (v.level.Position.Y > topPoint) then
			topPoint = v.level.Position.Y
			topFloor = v
		end
		if (v.level.Position.Y < bottomPoint) then
			bottomPoint = v.level.Position.Y
			bottomFloor = v
		end
	end

	local doorsIgnoreList = {}
	for i, v in pairs(car:GetChildren()) do
		local side = string.split(v.Name, 'Doors')[2] and string.split(v.Name, 'Doors')[1]
		if (not side) then continue end
		side = string.split(side, '_')[1]
		if (not side) then continue end
		if (side == '') then side = 'Front' end
		for i, v in pairs(v:GetDescendants()) do
			if (not v:IsA('BasePart')) then continue end
			table.insert(doorsIgnoreList, v)
		end
		doorEngine.setUp(v)
		local data = doorEngine.new(v)
		module.doorData[side] = data
	end

	for i, f in pairs(module.registeredFloors) do
		for i, v in pairs(f.floorInstance:GetChildren()) do
			local side = string.split(v.Name, 'Doors')[2] and string.split(v.Name, 'Doors')[1]
			if (not side) then continue end
			doorEngine.setUp(v)
		end
	end

	recursiveTable(configFile, function(i, v)
		if (typeof(v) == 'table' and v.Voice_ID) then v.Sound_Id = v.Voice_ID i = 'Voice_Audio' end
		if (typeof(v) == 'table' and v.Sound_Id and i ~= 'Door_Obstruction_Signal') then
			local newSound = addSound(cabRegion, i, v, i == 'Alarm' or i == 'Nudge_Buzzer' or (string.match(i, 'Motor_Run') ~= nil) or i == 'Traveling_Sound', 3, 25)
			newSound:SetAttribute('originalPitch', newSound.PlaybackSpeed)
			module.sounds[i] = newSound
		end
	end)

	module.sounds.Voice_Audio = addSound(cabRegion, 'Voice_Audio', {['Sound_Id'] = voiceConfig.SoundId, ['Volume'] = voiceConfig.Volume, ['Pitch'] = voiceConfig.Pitch}, false, 3, 25)

	for side, data in pairs(module.doorData) do
		local valueName = side == '' and '' or side.."_".."Door_State"
		module.statValues[valueName] = data.state
		module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
	end

	for i, v in pairs(module.statValues) do
		if (i == 'Queue_Direction' or i == 'Move_Direction' or i == 'Arrow_Direction' or i == 'Direction') then
			module.statValues[i] = 0
		end
		local val = createInstance(statValuesFolder, i, (valueTypes[typeof(v)]) .. "Value", true, { Value = v })
		module.statFolderValues[i] = { value = val, update = function()
			if (i == 'Current_Speed') then
				val.Value = math.rad(module.statValues[i])
			elseif (i == 'Queue_Direction' or i == 'Move_Direction' or i == 'Arrow_Direction' or i == 'Direction') then
				val.Value = module.statValues[i] == 1 and 'U' or module.statValues[i] == -1 and 'D' or 'N'
			else
				val.Value = module.statValues[i]
			end
		end}
	end
	local queueValue = createInstance(statValuesFolder, 'Queue', 'StringValue', true, {Value = httpService:JSONEncode(module.queue)})

	remoteCallValue:GetPropertyChangedSignal('Value'):Connect(function()
		if (not findRegisteredFloor(remoteCallValue.Value)) then return end
		task.spawn(addCall, {call = remoteCallValue.Value})
		remoteCallValue.Value = -math.huge
	end)

	local voiceSequenceQueue = {}
	local voiceSequenceIndex = 0

	local function playVoiceSequenceProtocolWithQueue(clipSequence, pauseThread, playCondition)
		if (not configFile.Sound_Database.Voice_Config.Enabled or not playCondition) then return end
		task.spawn(function()
			local length = #voiceSequenceQueue
			if (not table.find(voiceSequenceQueue, clipSequence)) then table.insert(voiceSequenceQueue, clipSequence) end
			if (length <= 0) then
				local function run()
					while (#voiceSequenceQueue > 0) do
						voiceSequenceIndex += 1
						local sequence = voiceSequenceQueue[voiceSequenceIndex]
						for index,item in pairs(sequence) do
							voiceModule:PlayClip(module.sounds.Voice_Audio, voiceConfig.Voice_Clips[item[1]], true)
							task.wait(item.Delay)
						end
						local tindex = table.find(voiceSequenceQueue, sequence)
						if (tindex) then table.remove(voiceSequenceQueue, tindex) voiceSequenceIndex -= 1 end
					end
					voiceSequenceIndex = 0
				end
				if (pauseThread) then
					run()
				else
					task.spawn(run)
				end
			end
		end)
	end

	function resetButtons(floor)
		for i, v in pairs(car:GetChildren()) do
			if (v.Name == 'Buttons') then
				for i, button in pairs(v:GetChildren()) do
					local buttonFloor = tonumber(string.split(button.Name, '_')[2]) or tonumber(string.split(button.Name, 'Floor')[2])
					if (buttonFloor and buttonFloor == floor) then
						setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
					end
				end
			end
		end
		local registeredFloor = findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		local direction = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down' or 'Neutral'
		for i, v in pairs(registeredFloor.floorInstance:GetChildren()) do
			if (v.Name == 'Call_Buttons') then
				for i, button in pairs(v:GetChildren()) do
					if (string.sub(button.Name, 1, 1) == (module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 0)) then
						setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
						updateButton(button, configFile.Color_Database.Floor[direction], 'Neautral_State')
					end
				end
			end
		end
	end

	function removeAllCalls()
		for i, floor in pairs(module.registeredFloors) do
			removeCall(floor.floorNumber)
			pcall(function()
				resetLanterns(floor.floorNumber, 'all')
				resetButtons(floor.floorNumber)
			end)
		end
	end

	local function updateStatValues()
		module.statValues.Arrow_Direction = module.statValues.Queue_Direction
		for i, v in pairs(module.statFolderValues) do
			v.update()
		end
	end

	local function updateFloor()
		local nearFloor, nearRawFloor, dist = nil, nil, math.huge
		for i, floor in pairs(module.registeredFloors) do
			local distance = math.abs(floor.level.Position.Y-level.Position.Y)
			if (distance < dist) then
				dist = distance
				local min = (module.statValues.Move_Value == 1 or module.statValues.Move_Value == 0) and module.statValues.Raw_Floor or module.statValues.Destination
				local max = (module.statValues.Move_Value == 1 or module.statValues.Move_Value == 0) and module.statValues.Destination or module.statValues.Raw_Floor
				nearFloor = (configFile.Movement.Accelerated_Floor_Config.Enabled and not module.statValues.Inspection) and math.clamp(floor.floorNumber+(configFile.Movement.Accelerated_Floor_Config.Offset*module.statValues.Move_Value), min, max) or floor.floorNumber
				nearRawFloor = floor.floorNumber
			end
		end

		module.statValues.Raw_Floor = nearRawFloor

		if (nearFloor ~= module.statValues.Floor) then
			module.statValues.Floor = nearFloor
			if (configFile.Sound_Database.Others.Enable_Floor_Pass_Chime) then
				task.delay(configFile.Sound_Database.Others.Floor_Pass_Chime_Delay, function()
					module.sounds.Floor_Pass_Chime:Play()
				end)
			end
			task.spawn(updateStatValues)
		end
	end
	updateFloor()

	function findAncestor(model, name)
		if (not model or typeof(model) ~= 'Instance') then return end
		local result = model:FindFirstChild(name)
		if (result) then
			return result
		else
			return findAncestor(model.Parent, name)
		end
	end

	module.coreFunctions.updateStatValues = updateStatValues

	weldModel(car, platform, doorsIgnoreList, carWeldsFolder)

	local cwStart,cwOffset
	if (counterweight and counterweight:FindFirstChild('Main')) then
		for i,v in pairs(counterweight:GetDescendants()) do
			if (string.match(v.ClassName, 'Weld') or v:IsA('Sound') or (string.match(v.ClassName, 'Script') and v.Parent == counterweight)) then
				v:Destroy()
			end
		end
		weldModel(counterweight, counterweight.Main, {})
		local travelingSound = addSound(counterweight.Main, 'Traveling_Sound', {Sound_Id=6003695467,Volume=0,Pitch=1.15}, true, false, 50, .2)
		local equalizer: EqualizerSoundEffect = travelingSound:FindFirstChildOfClass('EqualizerSoundEffect') or Instance.new('EqualizerSoundEffect')
		equalizer.HighGain = -8
		equalizer.LowGain = 7
		equalizer.MidGain = -2
		equalizer.Parent = travelingSound
		travelingSound:Play()
		counterweight.Main.Anchored = true

		local cwPos = counterweight.Main.CFrame.Y+(topFloor.level.Position.Y-level.Position.Y)
		local oriX,oriY,oriZ = counterweight.Main.CFrame:ToOrientation()
		--counterweight.Main.CFrame = CFrame.new(counterweight.Main.CFrame.X, cwPos, counterweight.Main.CFrame.Z)*CFrame.Angles(oriX, oriY, oriZ)
		cwStart = counterweight.Main.CFrame
		cwOffset = counterweight.Main.Position
	end
	local elevatorHeight = math.abs(topFloor.level.Position.Y-bottomFloor.level.Position.Y)

	local endLoadTime = os.clock()
	print((_VERSION) .. " :: " .. (elevator:GetFullName()) .. " :: Initiated in build " .. (buildData.BUILD) .. ", load time: " .. (math.round((endLoadTime-startLoadTime)*1000)/1000) .. "s")

	local prevIndependentServiceValue = module.statValues.Independent_Service
	local function setIndependentService(bool)
		module.statValues.Independent_Service = bool
		--outputElevMessage("Elevator has been placed " .. (bool and 'into' or 'out of') .. " independent service", 'warning')
		if (prevIndependentServiceValue ~= module.statValues.Independent_Service) then
			prevIndependentServiceValue = module.statValues.Independent_Service
			removeAllCalls()
			task.spawn(updateStatValues)
			if (bool) then
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Independent_Service_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Independent_Service_Announcement.Enabled)
				--If the elevator is already on the recall floor, open the doors (if closed or closing)
				for i, doorData in pairs(module.doorData) do
					if (doorData.state == 'Closed' or doorData.state == 'Closing' or doorData.state == 'Stopped') then
						task.spawn(runDoorOpen, module.statValues.Raw_Floor, doorData.side, true)
						if doorData.nudging and not module.statValues.Fire_Recall then
							module.sounds.Nudge_Buzzer.Playing = false
						end
					end
				end
			end
		end
	end

	-- // Safety core check // --
	function isElevatorSafe()
		if (module.statValues.Out_Of_Service or module.statValues.Stop or module.statValues.Inspection or (not checkDropKeyState())) then return false end
		return true
	end

	-- // Door handling // --
	local function checkAllNudge() -- // false - At least one set of doors are nudging, do not return true. true - No doors are nudging, all clear!
		for i, v in pairs(module.doorData) do
			if (v.nudging) then return false end
		end
		return true
	end

	function getFloorDistance(floor: number, absolute: boolean?)
		absolute = if (absolute == nil) then true else absolute
		if (not findRegisteredFloor(floor)) then return 0 end
		local dist = level.Position.Y-findRegisteredFloor(floor).floorInstance.Level.Position.Y
		return absolute and math.abs(dist) or dist
	end

	local sensorParams = OverlapParams.new()
	sensorParams.FilterType = Enum.RaycastFilterType.Whitelist
	function runDoorOpen(floor, side, doorTimer, bypassNudge)
		local registeredFloor = findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		local function runDoor(data)
			if (not data:IsValid(floor)) then return end
			--if bypassNudge then
			--	data.nudging = false
			--end
			if ((data.nudging and (not bypassNudge)) or (data.state ~= 'Closed' and data.state ~= 'Closing' and data.state ~= 'Stopped')) then return end
			playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Open_Announcement.Sequence, false, voiceConfig.Settings.Door_Announcements.Open_Announcement.Enabled)
			data.obstructionSignal.Playing = false
			local isObstructed = false
			local startingState = data.state
			api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
			api:Fire('onDoorOpening', { ['side'] = data.side, ['state'] = data.state })
			api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = 'Opening' })

			data.Opened:Once(function()
				data.doorTimestamp = os.clock()
				if (startingState == 'Closed') then
					data.nudgeTimestamp = os.clock()
					task.spawn(runChime, module.statValues.Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.After_Open)
					task.spawn(doLanterns, module.statValues.Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_After_Door_Open)

					if module.statValues.Queue_Direction ~= 0 then
						local dir = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down'
						local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
						if clip then
							playVoiceSequenceProtocolWithQueue(clip.Sequence, false, clip.Enabled)
						end
					end
				end

				api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = data.state })
				api:Fire('onDoorOpened', { ['side'] = data.side, ['state'] = data.state, ['floor'] = module.statValues.Raw_Floor })
				api:Fire('onDoorOpen', { ['side'] = data.side, ['state'] = data.state, ['floor'] = module.statValues.Raw_Floor }) -- Depricated API

				if (data.nudging) then return task.spawn(runDoorClose, module.statValues.Raw_Floor, side) end

				while ((os.clock()-data.doorTimestamp)/(configFile.Doors.Door_Timers[doorTimer] or configFile.Doors.Door_Timers.Open_On_Stop) < 1 and data.state == 'Open') do
					sensorParams.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
					local obstructed = #workspace:GetPartBoundsInBox(data.doorSensorPart.CFrame, data.doorSensorPart.Size, sensorParams) > 0
					if (obstructed ~= isObstructed) then
						isObstructed = obstructed
						data.obstructionSignal.Playing = not module.statValues.Fire_Service and obstructed
						api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
					end
					if (data.buttonHold or obstructed or checkIndependentService() or module.statValues.Fire_Service) then
						data.doorTimestamp = os.clock()
						if (checkIndependentService() or module.statValues.Fire_Service) then
							data.nudgeTimestamp = os.clock()
						end
					end
					if ((os.clock()-data.nudgeTimestamp)/configFile.Doors.Nudge_Timer > 1 and (not data.nudging) and (not checkIndependentService())) then
						module.statValues.Nudge = true
						data.nudging = true
						module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
						module.sounds.Nudge_Buzzer.Playing = true
						task.spawn(updateStatValues)
						task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
					end
					heartbeat:Wait()
				end
				if (data.state ~= 'Open') then return end
				task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
			end)
			data:Open(floor)
		end
		if ((moveLock and (not preDooring)) or (not isElevatorSafe()) or getFloorDistance(module.statValues.rawFloor) > .35) then return end
		if (string.upper(side) == 'ALL') then
			for _, v in pairs(module.doorData) do
				task.spawn(runDoor, v)
			end
		else
			local data = module.doorData[side]
			if (not data) then return end
			task.spawn(runDoor, data)
		end
	end

	function runDoorClose(floor, side, nudge)
		local function runDoor(data)
			if (not data:IsValid(floor)) then return end
			if (data.state ~= 'Open' and data.state ~= 'Stopped' and not module.statValues.Fire_Recall and (not (data.state == 'Opening' and (checkIndependentService() or checkFireServicePhase2())))) then return end
			if nudge then
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Nudge_Announcement.Sequence, false, voiceConfig.Settings.Door_Announcements.Nudge_Announcement.Enabled)
			else
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Close_Announcement.Sequence, false, voiceConfig.Settings.Door_Announcements.Close_Announcement.Enabled)
			end

			local startingState = data.state
			if nudge and data.state ~= 'Closed' then
				module.statValues.Nudge = true
				data.nudging = true
				module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
				module.sounds.Nudge_Buzzer.Playing = true
				task.spawn(updateStatValues)
			end
			local runTask
			data.obstructionSignal.Playing = false
			data.buttonHold = false
			local isObstructed = false
			local startingState = data.state

			api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
			api:Fire('onDoorClosing', { ['side'] = data.side, ['nudge'] = nudge, ['state'] = data.state })
			api:Fire('onDoorClose', { ['side'] = data.side, ['nudge'] = nudge, ['floor'] = module.statValues.Raw_Floor })
			api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = 'Closing' })

			task.spawn(runChime, module.statValues.Arrive_Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Door_Close, false)
			task.spawn(doLanterns, module.statValues.Arrive_Floor, { side }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Door_Close, true)
			data.Closed:Once(function()
				api:Fire('onDoorClosed', { ['side'] = data.side, ['state'] = data.state })
				api:Fire('doorStateChange', { ['floor'] = module.statValues.Raw_Floor, ['side'] = data.side, ['state'] = data.state })
				data.nudging = false
				if ((not checkDoorStates('Closed')) or moveLock) then return end
				pcall(task.cancel, runTask)
				module.statValues.Nudge = (not checkAllNudge())
				if (not module.statValues.Fire_Recall) then
					module.sounds.Nudge_Buzzer.Playing = module.statValues.Nudge
				end
				module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
				data.obstructionSignal.Playing = false
				task.spawn(updateStatValues)
				local nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))

				-- // No call in current direction? Check in the opposite direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, -module.statValues.Queue_Direction)) end

				-- // Still no call? Check in any direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end

				-- // Yet still no call? Let's look for any calls on the current floor // --
				local thisCall = select(2, findCallInQueue(module.statValues.Raw_Floor, -module.statValues.Queue_Direction))

				if ((not select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))) and thisCall) then
					module.statValues.Queue_Direction = 0
					task.spawn(updateStatValues)
					local hasCompleted = coreFunctions.conditionalWait(1, function() return {not moveLock} end)
					if (not hasCompleted) then return end
					module.statValues.Queue_Direction = thisCall.directions[1]
					api:Fire('onCallRespond', { floor = module.statValues.Raw_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })

					local lanternSides = {}
					for _, side in thisCall and thisCall.sides or {} do
						if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
							table.insert(lanternSides, string.split(side, '_')[2])
						end
					end
					task.spawn(updateStatValues)
					task.spawn(runChime, module.statValues.Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.Exterior_Call_Only)
					task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Exterior_Call, true)


					if (getTotalDirectionSides(thisCall.sides, thisCall and thisCall.directions[1] or 0) == 0) then
						task.spawn(runDoorOpen, floor, 'all', thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
					else
						local callSidesCopy = table.clone(thisCall.sides)
						for _, side in pairs(callSidesCopy) do
							local dir = #thisCall.directions > 0 and thisCall.directions[1] or 0
							if dir then
								if tonumber(string.split(side, '_')[1]) == dir or tonumber(string.split(side, '_')[1]) == 0 then
									table.remove(module.queue[select(1, findCallInQueue(thisCall.call))].sides, table.find(module.queue[select(1, findCallInQueue(thisCall.call))].sides, side))
									task.spawn(runDoorOpen, floor, string.split(side, '_')[2], thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
								end
							end
						end
					end

					removeCall(module.statValues.Raw_Floor, module.statValues.Queue_Direction)
					return
				end
				if (not nextQueue) then
					module.statValues.Queue_Direction = 0
					parkTimer()
					task.spawn(updateStatValues)
					return
				end
				task.spawn(goToFloor, nextQueue.call)
			end)
			data.LanternsReset:Once(function(types)
				task.spawn(resetLanterns, module.statValues.Raw_Floor, data.side, module.statValues.Queue_Direction, types)
				local nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))
				-- // No call in current direction? Check in the opposite direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, -module.statValues.Queue_Direction)) end
				-- // Still no call? Check in any direction
				if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end
				if (not nextQueue and checkDoorStates('Closed')) then
					--module.statValues.Queue_Direction = 0
					task.spawn(updateStatValues)
					return
				end
			end)
			data:Close(floor)
			runTask = task.spawn(function()
				while (data.state == 'Closing') do
					sensorParams.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
					local obstructed = #workspace:GetPartBoundsInBox(data.doorSensorPart.CFrame, data.doorSensorPart.Size, sensorParams) > 0
					if (obstructed ~= isObstructed) then
						isObstructed = obstructed
						api:Fire('doorObstructionStateChanged', { ['side'] = data.side, ['isObstructed'] = isObstructed })
						data.obstructionSignal.Playing = obstructed
						task.spawn(runDoorOpen, module.statValues.Raw_Floor, data.side, 'Open_No_Call')
					end
					if ((os.clock()-data.nudgeTimestamp)/configFile.Doors.Nudge_Timer > 1 and (not data.nudging) and data.state == 'Closing' and (not checkIndependentService()) and (not module.statValues.Fire_Service)) then
						module.statValues.Nudge = true
						data.nudging = true
						module.statValues[(data.sideJoin) .. "Door_Nudging"] = data.nudging
						module.sounds.Nudge_Buzzer.Playing = true
						task.spawn(updateStatValues)
					end
					heartbeat:Wait()
				end
			end)
		end
		if (module.statValues.Out_Of_Service or module.statValues.Stop) then return end
		if (string.upper(side) == 'ALL') then
			for _, v in pairs(module.doorData) do
				task.spawn(runDoor, v)
			end
		else
			local data = module.doorData[side]
			if (not data) then return end
			task.spawn(runDoor, data)
		end
	end

	function checkDoorStates(state, params)
		local thisFloor = findRegisteredFloor(module.statValues.Raw_Floor)
		if (not thisFloor) then return end
		local dontRequireAll = params and params.dontRequireAll or false
		local onlyPresentDoors = params and params.onlyPresentDoors or false
		local isAllStates = true

		for i, v in pairs(module.doorData) do
			if (not dontRequireAll) and v.state ~= state and ((not onlyPresentDoors) and true or thisFloor.floorInstance:FindFirstChild((v.side == '' and '' or v.side.."_").."Doors")) then
				isAllStates = false
				break
			elseif dontRequireAll and v.state == state then
				return true
			end
		end
		if (dontRequireAll) then
			return false
		elseif (not dontRequireAll) then
			return isAllStates
		end

		--for i, v in pairs(module.doorData) do
		--	if (v.state ~= state) then return false end
		--end
		--return true
	end

	-- // Queue handling // --

	function findCallInQueue(call, direction)
		for i, v in pairs(module.queue) do
			if (v.call == call and (typeof(direction) ~= 'number' or direction == 0 or table.find(v.directions, direction) or #v.directions == 0)) then return i, v end
		end

		return nil
	end
	function checkNearestCallInDirection(call, direction, requireDirectionInCall)
		local function checkForDirection(call, direction)
			for i, v in pairs(call.directions) do
				if (v == direction) then return true end
			end
			if (requireDirectionInCall == false) then return true end
			return false
		end

		local highestDownCall, lowestUpCall = -math.huge, math.huge
		local lowestDownCall, highestUpCall = math.huge, -math.huge
		for _, v in module.queue do
			-- Highest down call
			if table.find(v.directions, -1) and v.call >= highestDownCall then
				highestDownCall = v.call
			end

			-- Lowest up call
			if table.find(v.directions, 1) and v.call <= lowestUpCall then
				lowestUpCall = v.call
			end

			-- Lowest down call
			if #v.directions == 0 or table.find(v.directions, -1) and v.call <= lowestDownCall then
				lowestDownCall = v.call
			end

			-- Highest up call
			if #v.directions == 0 or table.find(v.directions, 1) and v.call >= highestUpCall then
				highestUpCall = v.call
			end
		end

		local nearResult, nearDist = {}, math.huge
		for i, v in next, module.queue do
			if (math.abs(v.call-call) <= nearDist
				and (((v.call > call and direction == 1 and (checkForDirection(v, direction) or #module.queue <= 1 or #v.directions == 0 or (v.call > highestUpCall and v.call == highestDownCall) or v.isCarCall))
					or (v.call < call and direction == -1 and (checkForDirection(v, direction) or #module.queue <= 1 or #v.directions == 0 or (v.call < lowestDownCall and v.call == lowestUpCall) or v.isCarCall)))
					or (direction == 0 and v.call ~= call)))
			then
				nearResult = {i, v}
				nearDist = math.abs(v.call-call)
			end
		end
		return table.unpack(nearResult)
	end

	function getTotalDirectionSides(sides, direction)
		local count = 0
		for _, side in sides do
			local sideDirection = tonumber(string.split(side, '_')[1])
			if sideDirection == direction or sideDirection == 0 then
				count += 1
			end
		end

		return count
	end

	function addCall(callParams)
		local regFloor = findRegisteredFloor(callParams.call)
		if ((not regFloor) or (module.statValues.Fire_Recall and not callParams.bypassFireRecall)) then return end
		local callIndex, callExists = findCallInQueue(callParams.call)
		local direction = if (typeof(callParams.direction) == 'string') then callParams.direction == 'U' and 1 or callParams.direction == 'D' and -1 elseif (typeof(callParams.direction) == 'number') then callParams.direction else nil
		local newTemplate = {
			['call'] = callParams.call,
			['directions'] = {},
			['sides'] = {},
			['isCarCall'] = if (typeof(callParams.isCarCall) == 'boolean') then callParams.isCarCall else false
		}
		if (callExists) then
			if (callExists.isCarCall == nil or callExists.isCarCall == false) then
				callExists.isCarCall = if (typeof(callParams.isCarCall) == 'boolean') then callParams.isCarCall else false
			end

			if callParams.side and not table.find(callExists.sides, (callParams.direction or 0) .. "_" .. (callParams.side)) then
				table.insert(callExists.sides, (callParams.direction or 0) .. "_" .. (callParams.side))
			end

			if not (table.find(callExists.directions, direction)) then
				table.insert(callExists.directions, direction)
			end

		else
			if callParams.side and not table.find(newTemplate.sides, (callParams.direction or 0) .. "_" .. (callParams.side)) then
				table.insert(newTemplate.sides, (callParams.direction or 0) .. "_" .. (callParams.side))
			end
			if (not table.find(newTemplate.directions, direction)) then 
				table.insert(newTemplate.directions, direction)
			end
			table.insert(module.queue, newTemplate)
		end

		-- // Set queue direction if idle // --
		if (module.statValues.Queue_Direction == 0) then
			module.statValues.Queue_Direction = callParams.call > module.statValues.Raw_Floor and 1 or callParams.call < module.statValues.Raw_Floor and -1 or 0
			task.spawn(updateStatValues)
		end

		local nextCall = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))
		if not nextCall then nextCall = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end
		if not nextCall then nextCall = select(2, findCallInQueue(module.statValues.Arrive_Floor)) end

		-- // Set the destination to call if within range // --
		if ((not module.statValues.Destination) or (
			(module.statValues.Queue_Direction == 'U' or module.statValues.Move_Value == 1) and
				nextCall.call > module.statValues.Raw_Floor and
				nextCall.call <= module.statValues.Destination
			) or
				(
					(module.statValues.Queue_Direction == 'D' or module.statValues.Move_Value == -1) and
					nextCall.call < module.statValues.Raw_Floor and
					nextCall.call >= module.statValues.Destination
				)
			) then
			module.statValues.Destination = nextCall.call
		end
		--module.statValues.Destination = nextCall.call
		task.spawn(updateStatValues)

		if (not moveLock) then
			task.spawn(goToFloor, callParams.call)
		end

		if (not callExists) then
			api:Fire('onCallAdded', { call = callParams.call, direction = callParams.direction })
		end
		queueValue.Value = httpService:JSONEncode(module.queue)
		return true
	end

	function removeCall(call, direction)
		local removed = false
		local q = module.queue

		for i, v in q do
			if (v.call == call and ((direction == 0 or typeof(direction) ~= 'number') or table.find(v.directions, direction) or #v.directions == 0 or v.isCarCall)) then
				local dirs = v.directions
				v.isCarCall = false

				for i, d in dirs do
					if (d ~= direction) then continue end
					table.remove(v.directions, i)
					removed = true
				end

				if (#v.directions == 0 or direction == 0 or typeof(direction) ~= 'number') then
					table.remove(module.queue, i)
					removed = true
					api:Fire('onCallRemoved', { call = call, direction = direction })
				end

				for i, b in car:GetDescendants() do
					local buttonFloor = tonumber(string.split(b.Name, '_')[2]) or tonumber(string.split(b.Name, 'Floor')[2])
					if ((not buttonFloor) or buttonFloor ~= call) then continue end

					setButton(b, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
				end

				local regFloor = findRegisteredFloor(call)
				if (not regFloor) then continue end

				for i, c in regFloor.floorInstance:GetChildren() do
					if (c.Name ~= 'Call_Buttons') then continue end
					for _, b in pairs(c:GetDescendants()) do
						local buttonName = string.split(b.Name, '_')[1]
						if (buttonName ~= 'Up' and buttonName ~= 'Down') then continue end

						local buttonDirection = buttonName == 'Up' and 1 or buttonName == 'Down' and -1 or 0
						if (buttonDirection ~= direction) then continue end

						setButton(b, configFile.Color_Database.Floor[buttonName], 'Neautral_State', b.Parent)
					end
				end
			end
		end

		queueValue.Value = httpService:JSONEncode(module.queue)
		return removed
	end

	-- // Motor sound handling // --
	function doMotorSound()
		local dirIndex = module.statValues.Move_Value == 1 and 'Up' or module.statValues.Move_Value == -1 and 'Down' or nil
		if (not dirIndex) then return end
		for i, v in pairs(module.sounds) do
			if (string.match(v.Name, 'Motor_Start_')) then
				v.Playing = i == "Motor_Start_" .. (dirIndex)
			end
		end
		statValuesFolder.Leveling:GetPropertyChangedSignal('Value'):Once(function()
			if (not statValuesFolder.Leveling.Value) then return end
			module.sounds["Motor_Start_" .. (dirIndex)]:Stop()
			module.sounds["Motor_Run_" .. (dirIndex)]:Stop()
			module.sounds["Motor_Stop_" .. (dirIndex)]:Play()
		end)
		local connection: RBXScriptConnection
		connection = api.Event:Connect(function(protocol)
			if (protocol ~= 'On_Safety_Brake') then return end
			connection:Disconnect()
			for i, v in pairs(module.sounds) do
				if (string.match(v.Name, 'Motor_')) then
					v:Stop()
				end
			end
		end)
		module.sounds["Motor_Start_" .. (dirIndex)].Ended:Wait()
		if (statValuesFolder.Leveling.Value) then return end
		module.sounds["Motor_Run_" .. (dirIndex)]:Play()
	end

	-- // Player welding // --
	local params = OverlapParams.new()
	params.FilterType = Enum.RaycastFilterType.Whitelist
	local elevatorPlayerWelds = {}
	local elevatorPlayerRidingValues = {}
	function playerWeld(weld)
		if (weld) then
			params.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
			local parts = workspace:GetPartBoundsInBox(cabRegion.CFrame, cabRegion.Size, params)
			for _, v in parts do
				local humanoid, root = v.Parent:FindFirstChildOfClass('Humanoid'), v.Parent:FindFirstChild('HumanoidRootPart')
				if (not (humanoid and root)) then continue end

				if (configFile.Movement.Weld_On_Move and not root:FindFirstChild('Cortex_Elevator_Weld')) then
					local weld = Instance.new('Weld')
					weld.Name = humanoid.Parent.Name
					--weld.Part0, weld.Part1 = (not configFile.Movement.Enable_New_Player_Sticking) and root or nil, platform
					weld.Part0, weld.Part1 = root, platform
					weld.C0, weld.C1 = CFrame.new(), weld.Part0 and weld.Part1.CFrame:ToObjectSpace(weld.Part0.CFrame) or CFrame.new()
					humanoid.PlatformStand = not configFile.Movement.Enable_New_Player_Sticking
					weld.Parent = playerWeldsFolder
					local yOffset = math.abs(root.CFrame.Position.Y-platform.CFrame.Position.Y)
					--local att0, att1 = Instance.new('Attachment'), Instance.new('Attachment')
					--att0.Parent, att1.Parent = root, platform
					--att1.WorldPosition += Vector3.new(0, yOffset, 0)
					--local ap = Instance.new('AlignPosition')
					--ap.Attachment0, ap.Attachment1 = att0, att1
					--ap.Responsiveness = math.huge
					--ap.ForceLimitMode = Enum.ForceLimitMode.PerAxis
					--ap.MaxAxesForce = Vector3.new(0, 1, 0)*math.huge
					--ap.Parent = players:GetPlayerFromCharacter(root.Parent) and root or nil
					table.insert(elevatorPlayerWelds, { weld = weld, humanoid = humanoid, root = root, yOffset = yOffset, extras = { ap, att0, att1 }, jumpPower = humanoid.JumpPower, jumpHeight = humanoid.JumpHeight })
					--humanoid.JumpPower = 0
					--humanoid.JumpHeight = 0
				end

				if not root:FindFirstChild('Cortex_Elevator_Riding') then
					local elevatorRidingValue = Instance.new("ObjectValue")
					elevatorRidingValue.Name = 'Cortex_Elevator_Riding'
					elevatorRidingValue.Value = elevator
					elevatorRidingValue.Parent = humanoid.Parent

					table.insert(elevatorPlayerRidingValues, { value = elevatorRidingValue })
				end
			end
		else
			for i, v in elevatorPlayerWelds do
				for _, s in v.extras do
					s:Destroy()
				end
				v.humanoid.PlatformStand = false
				v.weld:Destroy()
				--v.humanoid.JumpPower = v.jumpPower
				--v.humanoid.JumpHeight = v.jumpHeight
				elevatorPlayerWelds[i] = nil
			end

			for i, v in elevatorPlayerRidingValues do
				v.value:Destroy()
				elevatorPlayerRidingValues[i] = nil
			end
		end
	end

	local targetPointVal: CFrameValue = platform:FindFirstChild('TARGET_POSITION_FRAME') or Instance.new('CFrameValue')
	targetPointVal.Name = 'TARGET_POSITION_FRAME'
	targetPointVal.Parent = platform
	targetPointVal:GetPropertyChangedSignal('Value'):Connect(function()
		platform.CFrame = targetPointVal.Value
	end)

	local lastPlatformPosition = platform.CFrame.Position
	function moveElevator(dtTime)
		elevatorPosition *= CFrame.new(0, module.statValues.Move_Value*module.statValues.Current_Speed*dtTime, 0)
		platform.CFrame = elevatorPosition
		targetPointVal.Value = elevatorPosition
		module.statValues.Velocity = module.statValues.Current_Speed

		local carSpeed = (platform.CFrame.Position-lastPlatformPosition)
		lastPlatformPosition = platform.CFrame.Position
		if (counterweight and cwStart) then
			cwOffset -= carSpeed
			local oriX,oriY,oriZ = cwStart:ToOrientation()
			counterweight.Main.CFrame = CFrame.new(cwOffset)*CFrame.Angles(oriX, oriY, oriZ)
			counterweight.Main.Traveling_Sound.Volume = math.clamp(math.abs(module.statValues.Current_Speed)/15, 0, 2)
		end

		if configFile.Sound_Database.Others.Traveling_Sound.Enable then
			local tSpeedFactor = configFile.Sound_Database.Others.Traveling_Sound.Speed_Factor*(module.statValues.Current_Speed/configFile.Movement.Travel_Speed)
			local volumeConstraint = configFile.Sound_Database.Others.Traveling_Sound.Constraints.Volume
			local pitchConstraint = configFile.Sound_Database.Others.Traveling_Sound.Constraints.Pitch
			if (not module.sounds.Traveling_Sound.Playing) then
				module.sounds.Traveling_Sound.Playing = true
			end
			module.sounds.Traveling_Sound.Volume = configFile.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio' and ((volumeConstraint.Max-volumeConstraint.Min)*tSpeedFactor)+volumeConstraint.Min or math.abs(module.statValues.Current_Speed)/30
			module.sounds.Traveling_Sound.PlaybackSpeed = configFile.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio' and ((pitchConstraint.Max-pitchConstraint.Min)*tSpeedFactor)+pitchConstraint.Min or math.clamp(.5+math.abs(module.statValues.Current_Speed)/30, pitchConstraint.Min, pitchConstraint.Max)
		end
		task.spawn(updateStatValues)
		task.spawn(updateFloor)
		return dtTime, carSpeed.Y > 0 and 1 or carSpeed.Y < 0 and -1 or 0
	end

	-- // Safety brake // --
	local safetyBraking = false

	function safetyBrake()
		if (safetyBraking) then return end
		safetyBraking = true
		preDooring = false
		local initialSpeed = module.statValues.Current_Speed
		local rate = 1.35
		local dtTime = 0
		pcall(task.cancel, elevatorMovementThread)
		pcall(task.cancel, elevatorRelevelThread)
		if (module.statValues.Current_Speed > 0) then
			module.sounds.Safety_Brake_Sound:Play()
		end

		while (module.statValues.Current_Speed > 0 and safetyBraking) do
			module.statValues.Current_Speed = math.max(0, module.statValues.Current_Speed-rate*math.deg(dtTime))
			moveElevator(dtTime)
			dtTime = heartbeat:Wait()
		end

		api:Fire('On_Safety_Brake')
		playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Safety_Brake_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Safety_Brake_Announcement.Enabled)

		if (initialSpeed > 0) then
			local threshold = (initialSpeed/2)/rate^2
			local bounceThreshold = 1
			local dtTime = 0
			while (bounceThreshold > 0) do
				module.statValues.Current_Speed = math.sin(tick()*20)*bounceThreshold*threshold
				moveElevator(dtTime)
				bounceThreshold = math.max(0, bounceThreshold-.035*math.deg(dtTime))
				dtTime = heartbeat:Wait()
			end
		end
		module.statValues.Current_Speed = 0
		module.statValues.Move_Value = 0
		moveLock = false
		safetyBraking = false
		task.spawn(updateStatValues)
		releveling = false
	end

	local parkTimerRunning = false
	function parkTimer()
		if parkTimerRunning then return end
		task.spawn(function()
			if (configFile.Movement.Parking_Config.Enable and module.statValues.Raw_Floor ~= configFile.Movement.Parking_Config.Park_Floor) then
				parkTimerRunning = true
				local startTime = os.clock()
				while (os.clock()-startTime <= configFile.Movement.Parking_Config.Idle_Time) do
					task.wait(.5)
					if (module.statValues.Move_Value ~= 0 or (not checkDoorStates('Closed')) or (module.statValues.Fire_Service or checkIndependentService() or module.statValues.Inspection or module.statValues.Out_Of_Service)) then
						parkTimerRunning = false
						return
					end
				end
				parkTimerRunning = false

				if checkDoorStates('Closed') then
					goToFloor(configFile.Movement.Parking_Config.Park_Floor, true)
				else
					local connections = {}
					for i, v in module.doorData do
						connections[v] = v.Closed:Once(function()
							if (not checkDoorStates('Closed')) then return end
							for i, v in pairs(connections) do
								v:Disconnect()
							end
							goToFloor(configFile.Movement.Parking_Config.Park_Floor, true)
						end)
					end
				end
			end
		end)
	end

	local dropKeyUpdaters = {}

	-- // Drop key system // --
	function isDropKeyOnElevator()
		for i,v in pairs(module.dropKeyCheckValues) do
			if (v.Value) then return false end
		end
		return true
	end

	local function doDropKey(params)
		--local doorSide = string.split(params.Name, 'Doors')[2] and string.split(params.Name, 'Doors')[1] or string.split(params.Name, '_')

		local doorSide = string.split(string.split(params.Name, 'Doors')[1], '_')[1]
		if doorSide == '' then doorSide = string.split(params.Name, 'Doors')[1] ~= '' and string.split(params.Name, 'Doors')[1] or string.split(params.Name, 'Doors')[2] ~= '' and string.split(params.Name, 'Doors')[2] end

		local foundFloorNumber, floorNumberPosition = string.gsub(params.Parent.Name, '%D', '')
		local floorNumber = tonumber(foundFloorNumber)

		local function getWelds()
			local welds = {}

			for i, v in next, module.doorData do
				for i, w in params:IsDescendantOf(car) and car.Door_Engine_Welds:FindFirstChild(doorSide):GetChildren() or findRegisteredFloor(floorNumber) and findRegisteredFloor(floorNumber).floorInstance:FindFirstChild('Door_Engine_Welds'):FindFirstChild(doorSide):GetChildren() or {} do
					table.insert(welds, w)
				end
			end

			return welds
		end

		local landingLevel = findAncestor(params, 'Level')
		if (not landingLevel) then return end

		if ((landingLevel.Parent == car and module.doorData[doorSide].state == 'Closed') or (landingLevel.Parent ~= car and (((module.doorData[doorSide].state == 'Closed' and tonumber(landingLevel.Parent.Name:sub(7)) == module.statValues.Raw_Floor) or tonumber(landingLevel.Parent.Name:sub(7)) ~= module.statValues.Raw_Floor)))) then
			local closedOnce = false
			for i,weld in pairs(getWelds()) do
				if (weld.C0 == weld:GetAttribute('closedPoint')) then
					landingLevel.Drop_Key_Sound:Play()
					task.spawn(function()
						pluginModuleData.Legacy_Easing.content.interpolate(weld, weld:GetAttribute('openPoint'), 'Out_Bounce', configFile.Doors.Door_Open_Speed * 1.3)
					end)
					if module.statValues.Move_Value ~= 0 and checkDropKeyState() then
						module.sounds.Safety_Brake_Sound.PlaybackSpeed = module.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
						task.spawn(safetyBrake)
						playerWeld(false)
					end
					module.statValues.Out_Of_Service = true
					params:SetAttribute('Drop_Key_Open', true)
					params.Drop_Key_Open.Value = true
					module.doorData[doorSide].isEnabled = false
					task.spawn(updateStatValues)
				elseif (weld.C0 == weld:GetAttribute('openPoint')) then
					landingLevel.Drop_Key_Sound:Play()
					task.spawn(function()
						pluginModuleData.Legacy_Easing.content.interpolate(weld, weld:GetAttribute('closedPoint'), 'Out_Sine', configFile.Doors.Door_Open_Speed * 1.3)
						params:SetAttribute('Drop_Key_Open', false)
						params.Drop_Key_Open.Value = false
						module.doorData[doorSide].isEnabled = true
						module.statValues.Out_Of_Service = not checkDropKeyState()
						task.spawn(updateStatValues)

						if checkDropKeyState() and not closedOnce then
							closedOnce = true
							task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
						end
					end)
				end
			end
		end
	end

	local dropKeyHandlers = {}
	function checkDropKeyState()
		for i, v in module.doorData do
			if (not v.isEnabled) then return false end
		end

		for _, v in car:GetDescendants() do
			if v:GetAttribute('Drop_Key_Open') then return false end
		end

		for _, v in floors:GetDescendants() do
			if v:GetAttribute('Drop_Key_Open') then return false end
		end

		return true
	end

	local function dismountDropKeyClient(user,params)
		local doorSet = params
		if (not collectionService:HasTag(doorSet, 'IsInUse')) then return end
		local thisFloorName = doorSet:IsDescendantOf(floors) and string.split(doorSet.Parent.Name, 'Floor_')[2]
		local landingLevel = doorSet.Parent.Level
		local sideIndex = doorSet.Name:split('Doors')[1]:split('_')[1]
		local fullSideName = (sideIndex == '' and 'Front' or sideIndex)

		for i,v in pairs(dropKeyHandlers[doorSet] or {}) do
			v:Disconnect()
		end
		local index = table.find(dropKeyHandlers,user)
		if (index) then
			table.remove(dropKeyHandlers,index)
		end
		local doorBounds = doorSet:FindFirstChild('Door_Bounds')
		if (doorBounds) then doorBounds:Destroy() end
		dropKeyHandlers[doorSet] = nil

		local welds = {}
		local data = module.doorData[sideIndex]
		local welds = {}
		for i,v in next,data and (doorSet:IsDescendantOf(car) and car.Door_Engine_Welds:FindFirstChild(sideIndex):GetChildren() or findRegisteredFloor(thisFloorName).floorInstance:FindFirstChild('Door_Engine_Welds'):FindFirstChild(sideIndex):GetChildren()) or {} do
			table.insert(welds, { ['weld'] = v })
		end
		local function checkIfDoorIsClosed()
			for i,v in pairs(welds) do
				if (v.weld.C0 ~= v.weld:GetAttribute('closedPoint')) then return false end
			end
			return true
		end

		local isClosed = checkIfDoorIsClosed()

		local function check()
			module.statValues.Out_Of_Service = not checkDropKeyState()
			preDooring = false
			api:Fire('onElevDoorKey',{doorSet=doorSet,status='release'})
			task.spawn(updateStatValues)
			task.spawn(function()
				local isCompleted = coreFunctions.conditionalWait(1, function() return {not module.statValues.Out_Of_Service} end)
				if (not isCompleted) then return end
				task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
			end)
		end
		addPlayingSound(landingLevel, addSound(landingLevel, 'Interlock_Click', {
			Sound_Id = 9116323848,
			Volume = 1,
			Pitch = 1.35
		}, false, 40, 3))
		if (isClosed) then
			check()
		elseif (not isClosed) then
			local hasCompleted = coreFunctions.conditionalWait(2, function() return {collectionService:HasTag(doorSet, 'IsInUse')} end)
			if (not hasCompleted) then return end
			local connection: RBXScriptConnection

			local i = 0
			for _,v in pairs(welds) do
				v.startPosition = v.weld.C0
				v.alpha = 0
			end

			connection = heartbeat:Connect(function(dtTime)
				i += .025*dtTime
				for _,v in pairs(welds) do
					v.alpha += i
					v.weld.C0 = v.startPosition:Lerp(v.weld:GetAttribute('closedPoint'), math.min(v.alpha,1))
				end
				if (dropKeyHandlers[doorSet]) then return connection:Disconnect() end

				if checkIfDoorIsClosed() then
					local doorSide = string.split(doorSet.Name, '_')[1]
					module.doorData[doorSide].isEnabled = true
				end

				if (checkIfDoorIsClosed()) then connection:Disconnect() return check() end
			end)
		end

		collectionService:RemoveTag(doorSet, 'IsInUse')
	end

	function stopAtFloor(floor, park)
		local regFloor = findRegisteredFloor(floor)
		if (not regFloor) then return end
		local direction = module.statValues.Move_Value
		local floorQueue

		local distanceToFloor = module.statValues.Move_Value*(regFloor.level.Position.Y-level.Position.Y)
		local offsetDistanceToFloor = module.statValues.Move_Value*((regFloor.level.Position.Y+direction*(configFile.Sensors.Stop_Offset+configFile.Movement.Braking_Data["Linear_Mode_Offset_" .. (direction == 1 and 'Up' or direction == -1 and 'Down')]))-level.Position.Y)
		local stopped = false
		local weldsRemoved = false
		local levelingStage = 0
		local customLevelingStage = 1
		local minSpeed = configFile.Movement.Level_Speed

		local landingLevel = regFloor.floorInstance.Level

		local INITIAL_SPEED, DISTANCE_TO_DECELERATE = module.statValues.Current_Speed, offsetDistanceToFloor

		local dtTime = 0

		while (not stopped) do
			distanceToFloor = module.statValues.Move_Value*(regFloor.level.Position.Y-level.Position.Y)
			offsetDistanceToFloor = module.statValues.Move_Value*((regFloor.level.Position.Y+direction*(configFile.Sensors.Stop_Offset+configFile.Movement.Braking_Data["Linear_Mode_Offset_" .. (direction == 1 and 'Up' or direction == -1 and 'Down')]))-level.Position.Y)
			if (not module.statValues.Leveling) then
				module.statValues.Leveling = true
				module.statValues.Arrive_Floor = floor

				-- // Get nearest call in direction
				local nextCall = select(2, checkNearestCallInDirection(module.statValues.Arrive_Floor, module.statValues.Queue_Direction))

				--// No calls? Check in the opposite direction
				if (not nextCall) then nextCall = select(2, checkNearestCallInDirection(module.statValues.Arrive_Floor, -module.statValues.Queue_Direction)) end

				-- // Still no calls? Check in any direction
				if (not nextCall) then nextCall = select(2, checkNearestCallInDirection(module.statValues.Arrive_Floor, 0)) end

				-- // Yet still no calls? Let's look for any directional calls on current floor
				local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))

				local callDirection
				for _, v in pairs(thisCall and thisCall.directions or {}) do
					if (v == module.statValues.Queue_Direction or (module.statValues.Arrive_Floor == topFloor.floorNumber or module.statValues.Arrive_Floor == bottomFloor.floorNumber) or #module.queue <= 1) then
						callDirection = v
						break
					end
				end

				module.statValues.Queue_Direction = callDirection or (nextCall and (nextCall.call > module.statValues.Arrive_Floor and 1 or nextCall.call < module.statValues.Arrive_Floor and -1)) or 0

				local lanternSides = {}
				for _, side in thisCall and thisCall.sides or {} do
					if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
						table.insert(lanternSides, string.split(side, '_')[2])
					end
				end

				api:Fire('onCallRespond', { floor = module.statValues.Arrive_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })
				api:Fire('onElevatorArrive', { floor = module.statValues.Arrive_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })

				if (not park or module.statValues.Queue_Direction ~= 0) and (not checkIndependentService()) and (not module.statValues.Fire_Service) then
					task.spawn(runChime, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Arrival, true)
					task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Arrival, true)

					playVoiceSequenceProtocolWithQueue(voiceConfig.Floor_Announcements[tostring(floor)] or {}, true, voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Arrival)

					if (voiceConfig.Settings.Directional_Announcements.Announce_After_Floor_Announcement and module.statValues.Queue_Direction ~= 0) then
						local dir = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down'
						local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
						if clip then
							playVoiceSequenceProtocolWithQueue(clip.Sequence, false, clip.Enabled)
						end
					end
				end
				--removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
			end
			if (module.statValues.Current_Speed > configFile.Movement.Level_Speed) then
				if (configFile.Movement.Braking_Data.Mode == 'Linear') then
					local currentSpeed = module.statValues.Current_Speed
					local gradualDecelRatio = math.min(1, math.max(.1, ((offsetDistanceToFloor/(DISTANCE_TO_DECELERATE*configFile.Movement.Smooth_Stop_V2.Threshold)))/(currentSpeed/INITIAL_SPEED)))
					local rate = currentSpeed^2/(2*offsetDistanceToFloor*(configFile.Movement.Smooth_Stop_V2.Enable and gradualDecelRatio or 1))
					local newSpeed = math.max(0, currentSpeed-rate*dtTime)
					
					module.statValues.Current_Speed = math.max(newSpeed, configFile.Movement.Level_Speed)
				elseif (configFile.Movement.Braking_Data.Mode == 'SmartLinear') then
					if (offsetDistanceToFloor > configFile.Movement.Braking_Data.Smart_Linear_Transition_Dist*(INITIAL_SPEED/(configFile.Movement.Travel_Speed/3)) and levelingStage ~= 2) then
						levelingStage = 1
						local currentSpeed = module.statValues.Current_Speed
						local gradualDecelRatio = math.min(1, math.max(.1, ((offsetDistanceToFloor/(DISTANCE_TO_DECELERATE*configFile.Movement.Smooth_Stop_V2.Threshold)))/(currentSpeed/INITIAL_SPEED)))
						local rate = currentSpeed^2/(2*offsetDistanceToFloor*(configFile.Movement.Smooth_Stop_V2.Enable and gradualDecelRatio or 1))
						local newSpeed = math.max(0, currentSpeed-rate*dtTime)
						
						module.statValues.Current_Speed = math.max(newSpeed, configFile.Movement.Level_Speed)
					elseif (levelingStage == 1) then
						levelingStage = 2
						INITIAL_SPEED,DISTANCE_TO_DECELERATE = module.statValues.Current_Speed,offsetDistanceToFloor
						
						api:Fire('levelingStageChange', { brakingMode = configFile.Movement.Braking_Data.Mode, stage=levelingStage })
					elseif (levelingStage == 2) then
						module.statValues.Current_Speed = math.clamp((INITIAL_SPEED/DISTANCE_TO_DECELERATE)*offsetDistanceToFloor, configFile.Movement.Level_Speed, if (INITIAL_SPEED) < configFile.Movement.Level_Speed then INITIAL_SPEED+configFile.Movement.Level_Speed else INITIAL_SPEED)
					end
				elseif (configFile.Movement.Braking_Data.Mode == 'Default') then
					module.statValues.Current_Speed = math.max(configFile.Movement.Level_Speed, (INITIAL_SPEED/DISTANCE_TO_DECELERATE)*distanceToFloor)
				elseif (configFile.Movement.Braking_Data.Mode == 'Manual') then
					module.statValues.Current_Speed = math.max(configFile.Movement.Level_Speed, module.statValues.Current_Speed-configFile.Movement.Braking_Data.Increment*math.deg(dtTime))
					--elseif (configFile.Movement.Braking_Data.Mode == 'Custom') then
					--	local currentLevelingStage = configFile.Movement.Braking_Data.Custom_Leveling_Stages[customLevelingStage]
					--	local nextLevelingStage = configFile.Movement.Braking_Data.Custom_Leveling_Stages[customLevelingStage+1]
					--	if (currentLevelingStage) then
					--		if (nextLevelingStage and nextLevelingStage.Transition_Distance >= getFloorDistance(module.statValues.Arrive_Floor)) then
					--			customLevelingStage += 1
					--			INITIAL_SPEED = module.statValues.Current_Speed
					--			distanceToFloor = (math.abs((landingLevel.Position.Y + (module.statValues.Move_Value * currentLevelingStage.Offset)) - level.Position.Y))
					--		end
					--		print(currentLevelingStage.Rate)
					--		if (currentLevelingStage.Rate == 'Constant') then
					--			local currentSpeed = module.statValues.Current_Speed
					--			local deceleration = currentSpeed^2/(2*math.max(distanceToFloor, .001))
					--			local SPEED = math.max(0, currentSpeed-deceleration*dtTime)
					--			module.statValues.Current_Speed = math.max(SPEED, .015)
					--		else
					--			module.statValues.Current_Speed = math.clamp((INITIAL_SPEED/distanceToFloor) * getFloorDistance(module.statValues.Arrive_Floor), minSpeed, if (INITIAL_SPEED) < minSpeed then INITIAL_SPEED+minSpeed else INITIAL_SPEED)
					--		end
					--	end
				end
			elseif (not weldsRemoved) then
				weldsRemoved = true
				playerWeld(false)
			end

			if (distanceToFloor <= configFile.Sensors.Pre_Door_Data.Offset and configFile.Sensors.Pre_Door_Data.Enable and (not preDooring)) then
				local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))

				local lanternSides = {}
				for _, side in thisCall and thisCall.sides or {} do
					if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
						table.insert(lanternSides, string.split(side, '_')[2])
					end
				end

				api:Fire('onElevatorOpen', {floor = module.statValues.Arrive_Floor})
				if (not park or module.statValues.Queue_Direction ~= 0) then
					task.spawn(runChime, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Open, true)
					task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Door_Open, true)
				end
				local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))
				if ((((not module.statValues.Fire_Service) or (module.statValues.Fire_Recall and fireServiceRecallFloor == module.statValues.Raw_Floor))) and (not preDooring)) then
					preDooring = true
					if (getTotalDirectionSides(thisCall and thisCall.sides or {}, thisCall and thisCall.directions[1] or 0) == 0) then
						task.spawn(runDoorOpen, floor, 'all', thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
					else
						local callSidesCopy = table.clone(thisCall.sides)
						for _, side in pairs(callSidesCopy) do
							local dir = #thisCall.directions > 0 and thisCall.directions[1] or 0
							if dir then
								if tonumber(string.split(side, '_')[1]) == dir or tonumber(string.split(side, '_')[1]) == 0 then
									table.remove(module.queue[select(1, findCallInQueue(thisCall.call))].sides, table.find(module.queue[select(1, findCallInQueue(thisCall.call))].sides, side))
									task.spawn(runDoorOpen, floor, string.split(side, '_')[2], thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
								end
							end
						end
					end
				end

				removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
			end
			if (distanceToFloor <= 0) then
				stopped = true
				api:Fire('onCallRespond', {floor = floor, direction = module.statValues.Queue_Direction, parking = module.statValues.Parking})
				api:Fire('onElevatorStop', {floor = module.statValues.Arrive_Floor})
				break
			end
			moveElevator(dtTime)
			dtTime = heartbeat:Wait()
		end

		module.statValues.Move_Value = 0
		module.statValues.Move_Direction = 0
		module.statValues.Velocity = 0
		module.statValues.Current_Speed = 0
		module.statValues.Leveling = false
		module.statValues.Arrow_Direction = 0
		module.statValues.Parking = false
		parkTimer()
		task.spawn(updateStatValues)
		task.spawn(updateFloor)

		if voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Stop and (not park or module.statValues.Queue_Direction ~= 0) and (not checkIndependentService()) and (module.statValues.Fire_Service) then
			playVoiceSequenceProtocolWithQueue(voiceConfig.Floor_Announcements[tostring(floor)] or {}, true, voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Stop)

			if (voiceConfig.Settings.Directional_Announcements.Announce_After_Floor_Announcement and module.statValues.Queue_Direction ~= 0) then
				local dir = module.statValues.Queue_Direction == 1 and 'Up' or module.statValues.Queue_Direction == -1 and 'Down'
				local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
				if clip then
					playVoiceSequenceProtocolWithQueue(clip.Sequence, false, clip.Enabled)
				end
			end
		end

		local thisCall = select(2, findCallInQueue(module.statValues.Arrive_Floor))
		local hasPassed = coreFunctions.conditionalWait(configFile.Movement.Stop_Delay, function() return {module.statValues.Move_Value == 0} end)
		if (not hasPassed) then return end
		releveling = false
		moveLock = false

		if ((((not module.statValues.Fire_Service) or (module.statValues.Fire_Recall and fireServiceRecallFloor == module.statValues.Raw_Floor))) and (not preDooring)) then
			api:Fire('onElevatorOpen', {floor = module.statValues.Arrive_Floor})

			local lanternSides = {}
			for _, side in thisCall and thisCall.sides or {} do
				if string.split(side, '_')[1] == tostring(module.statValues.Queue_Direction) then
					table.insert(lanternSides, string.split(side, '_')[2])
				end
			end

			task.spawn(runChime, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.On_Open, true)
			task.spawn(doLanterns, module.statValues.Arrive_Floor, lanternSides, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Door_Open, true)

			if (getTotalDirectionSides(thisCall and thisCall.sides or {}, thisCall and thisCall.directions[1] or 0) == 0) then
				task.spawn(runDoorOpen, floor, 'all', thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
			else
				local callSidesCopy = table.clone(thisCall and thisCall.sides or {})
				for _, side in pairs(callSidesCopy) do
					local dir = #thisCall.directions > 0 and thisCall.directions[1] or 0
					if dir then
						if tonumber(string.split(side, '_')[1]) == dir or tonumber(string.split(side, '_')[1]) == 0 then
							table.remove(module.queue[select(1, findCallInQueue(thisCall.call))].sides, table.find(module.queue[select(1, findCallInQueue(thisCall.call))].sides, side))
							task.spawn(runDoorOpen, floor, string.split(side, '_')[2], thisCall and thisCall.directions[1] and 'Open_By_Call' or 'Open_On_Stop')
						end
					end
				end
			end

			removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
		elseif (module.statValues.Fire_Recall and not preDooring or module.statValues.Phase_2) then
			removeCall(module.statValues.Arrive_Floor, module.statValues.Queue_Direction)
		end
		preDooring = false

		local hasPassed = coreFunctions.conditionalWait(2, function() return {module.statValues.Move_Value == 0 and checkDoorStates('Closed')} end)
		if (not hasPassed) then return end

		local nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))

		-- // No call in current direction? Check in the opposite direction
		if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, -module.statValues.Queue_Direction)) end

		-- // Still no call? Check in any direction
		if (not nextQueue) then nextQueue = select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, 0)) end

		-- // Yet still no call? Let's look for any calls on the current floor // --
		local thisCall = select(2, findCallInQueue(module.statValues.Raw_Floor, -module.statValues.Queue_Direction))
		if ((not select(2, checkNearestCallInDirection(module.statValues.Raw_Floor, module.statValues.Queue_Direction))) and thisCall) then
			module.statValues.Queue_Direction = 0
			task.spawn(updateStatValues)
			local hasCompleted = coreFunctions.conditionalWait(1, function() return {not moveLock} end)
			if (not hasCompleted) then return end
			module.statValues.Queue_Direction = thisCall.directions[1]
			api:Fire('onCallRespond', { floor = module.statValues.Raw_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })
			task.spawn(updateStatValues)
			task.spawn(runDoorOpen, floor, 'all', 'Open_By_Call')
			removeCall(module.statValues.Raw_Floor, module.statValues.Queue_Direction)
			return
		end


		if (not nextQueue) then
			module.statValues.Queue_Direction = 0
			task.spawn(updateStatValues)
			return
		end
		task.spawn(goToFloor, nextQueue.call)
	end

	function goToFloor(floor, park)
		local ran,res = pcall(function()
			if (not isElevatorSafe()) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'MOVE_NOT_SAFE' } end
			local regFloor = findRegisteredFloor(floor)
			if (not regFloor) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'INVALID_FLOOR' } end
			if (floor == module.statValues.Raw_Floor or moveLock or (not checkDoorStates('Closed')) or module.statValues.Out_Of_Service or module.statValues.Stop) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'NOT_MOVE_SAFE' } end

			module.statValues.Parking = park
			elevatorMovementThread = task.spawn(function()
				local direction = floor > module.statValues.Raw_Floor and 1 or floor < module.statValues.Raw_Floor and -1 or nil
				if (not direction) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'UNKNOWN_DIRECTION' } end
				module.statValues.Move_Value = direction
				module.statValues.Queue_Direction = direction
				module.statValues.Move_Direction = direction
				module.statValues.Current_Speed = 0
				module.statValues.Destination = floor
				module.statValues.Leveling = false
				preDooring = false
				moveLock = true
				playerWeld(true)
				task.spawn(updateStatValues)

				api:Fire('onElevatorMoveBegin', { directionString = direction == 1 and 'U' or direction == -1 and 'D' or nil, directionValue = direction })

				task.spawn(function()
					local hasPassed = coreFunctions.conditionalWait(configFile.Movement.Motor_Start_Delay[direction == 1 and 'Up' or direction == -1 and 'Down'], function() return {module.statValues.Move_Value == direction} end)
					if (not hasPassed) then return end
					doMotorSound()
				end)
				local hasCompleted = coreFunctions.conditionalWait(configFile.Movement[direction == 1 and 'Start_Delay' or direction == -1 and 'Down_Start_Delay'], function() return {module.statValues.Move_Value == direction} end)
				if (not hasCompleted) then return task.cancel(elevatorMovementThread) end

				api:Fire('onDepartStart', { directionString = direction == 1 and 'U' or direction == -1 and 'D' or nil, directionValue = direction })
				if (configFile.Movement.Jolt_Start_Data.Enable) then
					local hasPassed = coreFunctions.conditionalWait(configFile.Movement.Jolt_Start_Data.Start_Delay, function() return {module.statValues.Move_Value == direction} end)
					if (not hasPassed) then return end

					local done = false
					local checked = false
					local lastSpeed = module.statValues.Current_Speed
					local startTime = os.clock()
					local dtTime = 0
					while (not checked) do
						module.statValues.Current_Speed = -(math.sin(math.abs(os.clock()-startTime)*math.pi*configFile.Movement.Jolt_Start_Data.Speed)*configFile.Movement.Jolt_Start_Data.Ratio)/math.pi
						--module.statValues.Current_Speed = -(math.sin(math.abs(os.clock()-startTime)*configFile.Movement.Jolt_Start_Data.Speed)*configFile.Movement.Jolt_Start_Data.Ratio)
						local spd = module.statValues.Current_Speed
						if ((lastSpeed-spd) > 0) then
							lastSpeed = spd
						elseif (spd >= 0) then
							checked = true
						end
						elevatorPosition *= CFrame.new(0, module.statValues.Move_Value*module.statValues.Current_Speed*dtTime, 0)
						platform.CFrame = elevatorPosition
						module.statValues.Velocity = module.statValues.Current_Speed
						task.spawn(updateStatValues)
						dtTime = heartbeat:Wait()
					end
				end

				local topSpeed = configFile.Movement.Travel_Speed
				local initialSpeed = module.statValues.Current_Speed
				local accelerationRate = configFile.Movement[direction == 1 and 'Acceleration' or direction == -1 and 'Down_Acceleration'] or configFile.Movement.Acceleration
				local accelTime = coreFunctions.getAccelerationTime(initialSpeed, configFile.Movement.Travel_Speed, accelerationRate)
				local startTime = os.clock()

				local dtTime = 0
				local lvlOffset = configFile.Sensors[module.statValues.Move_Value == 1 and 'Up_Level_Offset' or module.statValues.Move_Value == -1 and 'Down_Level_Offset']

				local dynamicAccelRate = 1/math.deg(configFile.Movement.Dynamic_Acceleration_Time)
				local dynamicAccelValue = 0

				while true do
					regFloor = findRegisteredFloor(module.statValues.Destination)
					if (not regFloor) then continue end
					local distanceToFloor = module.statValues.Move_Value*(regFloor.level.Position.Y-level.Position.Y)
					local offsetDistanceToFloor = module.statValues.Move_Value*((regFloor.level.Position.Y+direction*(configFile.Sensors.Stop_Offset+configFile.Movement.Braking_Data["Linear_Mode_Offset_" .. (direction == 1 and 'Up' or direction == -1 and 'Down')]))-level.Position.Y)
					if (not module.statValues.Leveling) then
						dynamicAccelValue = math.clamp(dynamicAccelValue+dynamicAccelRate*math.deg(dtTime), 0, 1)
						--module.statValues.Current_Speed = coreFunctions.lerp(initialSpeed, configFile.Movement.Travel_Speed*dynamicAccelValue, math.min((os.clock()-startTime)/accelTime, 1))
						module.statValues.Current_Speed = math.clamp(module.statValues.Current_Speed+accelerationRate*dynamicAccelValue*math.deg(dtTime), 0, topSpeed)
					end

					if (distanceToFloor <= lvlOffset*(module.statValues.Current_Speed*configFile.Movement.Level_Offset_Ratio)) then
						return stopAtFloor(module.statValues.Destination, park)
					end

					local carMovementDirection = select(2, moveElevator(dtTime))
					if ((carMovementDirection == 1 and level.Position.Y >= topFloor.level.Position.Y+1.5) or (carMovementDirection == -1 and level.Position.Y <= bottomFloor.level.Position.Y-1.5)) then
						safetyBraking = false
						safetyBrake()
					end
					dtTime = heartbeat:Wait()
				end
			end)
		end)
		if (not ran) then return { ['RUN_STATUS'] = false, ['RUN_CODE'] = 'RUNTIME_ERROR', ['MESSAGE'] = res } end
		return { ['RUN_STATUS'] = true, ['RUN_CODE'] = 'RUNTIME_SUCCESS' }
	end

	-- // Relevel // --
	function relevel(floor, tolerance, openDoorsIfLeveled)
		if (not isElevatorSafe()) then return end

		if (typeof(tolerance) ~= 'number') then tolerance = 0 end
		local registeredFloor = findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		if (releveling) then return end

		elevatorRelevelThread = task.spawn(function()
			local levelOffset = (registeredFloor.level.Position.Y-level.Position.Y)
			local directionToTravelTo = levelOffset < 0 and -1 or levelOffset > 0 and 1 or 0
			if (math.abs(levelOffset) <= tolerance) then
				if not openDoorsIfLeveled then return end

				for i, v in pairs(module.doorData) do
					task.spawn(runDoorOpen, module.statValues.Raw_Floor, v.side, 'Open_No_Call')
				end

				return
			end

			releveling = true
			module.statValues.Leveling = true
			task.spawn(updateStatValues)

			module.statValues.Move_Value = directionToTravelTo
			module.statValues.Move_Direction = directionToTravelTo
			moveLock = true
			task.spawn(updateStatValues)

			local dtTime = 0

			local lvlOffset = configFile.Sensors[directionToTravelTo == 1 and 'Up_Level_Offset' or directionToTravelTo == -1 and 'Down_Level_Offset']

			while true do
				local thisLevelOffset = (registeredFloor.level.Position.Y-level.Position.Y)
				local currentDirTravel = thisLevelOffset < 0 and -1 or thisLevelOffset > 0 and 1 or 0
				module.statValues.Current_Speed = math.min(configFile.Movement.Travel_Speed, module.statValues.Current_Speed+configFile.Movement[currentDirTravel == 1 and 'Acceleration' or 'Down_Acceleration'])
				local distanceToFloor = module.statValues.Move_Value*thisLevelOffset
				if (distanceToFloor <= lvlOffset*(module.statValues.Current_Speed*configFile.Movement.Level_Offset_Ratio)) then
					return stopAtFloor(floor, false)
				end
				moveElevator(dtTime)
				dtTime = heartbeat:Wait()
			end
		end)
	end

	-- // Fire Recall // --
	local allFireRecallEventListeners = {}

	function fireRecall(bool, recallFloor)
		local regFloor = findRegisteredFloor(recallFloor)

		module.statValues.Phase_1 = bool
		task.spawn(updateStatValues)

		--outputElevMessage("Elevator has been placed " .. (bool and 'into' or 'out of') .. " fire service to floor " .. (floor), 'warning')

		if (bool) then
			if (not regFloor) then return end
			fireServiceRecallFloor = recallFloor
			module.statValues.Fire_Recall = true
			module.statValues.Fire_Service = true

			playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Fire_Recall_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Fire_Recall_Announcement.Enabled)

			local function handleDoors()
				if (checkDoorStates('Open', {dontRequireAll = true, onlyPresentDoors = false})) then
					module.sounds.Nudge_Buzzer.Playing = false
					module.statValues.Fire_Recall = false
					task.spawn(updateStatValues)
					return
				end

				for i, doorData in pairs(module.doorData) do
					if (not regFloor.floorInstance:FindFirstChild((doorData.side == '' and '' or doorData.side.."_").."Doors")) then continue end
					if (doorData.state ~= 'Open') then
						local connection: RBXScriptConnection
						connection = doorData.Opened:Connect(function()
							connection:Disconnect()
							if (not checkDoorStates('Open', {dontRequireAll = true, onlyPresentDoors = false})) then return end
							module.sounds.Nudge_Buzzer.Playing = false
							module.statValues.Fire_Recall = false
							task.spawn(updateStatValues)
						end)
						table.insert(allFireRecallEventListeners, connection)
					end
				end
			end

			removeAllCalls()
			module.statValues.Queue_Direction = 0
			module.sounds.Nudge_Buzzer.Playing = true
			task.spawn(updateStatValues)


			local isOnFloor = module.statValues.Raw_Floor == recallFloor and (module.statValues.Move_Value == 0 or module.statValues.Leveling)
			if (isOnFloor) then
				task.spawn(runDoorOpen, recallFloor, 'all', 'Open_No_Call', true)
				handleDoors()
			else
				local direction = module.statValues.Move_Value
				local nearFloor, nearDist = nil, math.huge
				for _, floor in pairs(module.registeredFloors) do
					local thisDist = math.abs(floor.floorInstance.Level.Position.Y - level.Position.Y)
					if (thisDist < nearDist and ((direction == 1 and floor.floorNumber > module.statValues.Raw_Floor) or (direction == -1 and floor.floorNumber < module.statValues.Raw_Floor))) then
						nearDist = thisDist
						nearFloor = floor
					end
				end

				--if (nearFloor and module.statValues.Move_Value ~= 0) then
				--	addCall({call = nearFloor.floorNumber, direction = nil, bypassFireRecall = true})
				--end

				if ((module.statValues.Move_Value == -1 and module.statValues.Raw_Floor >= fireServiceRecallFloor) or (module.statValues.Move_Value == 1 and module.statValues.Raw_Floor <= fireServiceRecallFloor)) then
					addCall({call = recallFloor, direction = nil, bypassFireRecall = true})
				elseif module.statValues.Move_Value == 0 or module.statValues.Leveling then
					task.spawn(runDoorClose, module.statValues.Raw_Floor, 'all', true)
					addCall({call = recallFloor, direction = nil, bypassFireRecall = true})
				elseif (nearFloor) then
					addCall({call = nearFloor.floorNumber, direction = nil, bypassFireRecall = true})
				end

				local connection: RBXScriptConnection
				connection = api.Event:Connect(function(protocol, params)
					if (protocol == 'onElevatorStop') then
						if (module.statValues.Raw_Floor ~= recallFloor) then
							addCall({call = recallFloor, direction = nil, bypassFireRecall = true})
						else
							connection:Disconnect()
							handleDoors()
						end
					end
				end)
				table.insert(allFireRecallEventListeners, connection)
			end
		elseif (not bool and module.statValues.Fire_Service) then
			if module.statValues.Fire_Recall then
				module.sounds.Nudge_Buzzer.Playing = false
			end
			module.statValues.Fire_Recall = false
			module.statValues.Fire_Service = false
			task.spawn(updateStatValues)
			for i, v in allFireRecallEventListeners do
				v:Disconnect()
			end
			allFireRecallEventListeners = {}
		end
	end

	-- // Chime & Lantern Handling // --
	function runChime(floor, sides, direction, indexes, cfg, requireCallOnlyParam)
		local regFloor = findRegisteredFloor(floor)
		if #sides == 0 then sides = { "all" } end
		if ((not regFloor) or (direction ~= 1 and direction ~= -1)) then return end
		for index, value in pairs(indexes) do
			local thisData = cfg[value]
			local thisCall = select(2, findCallInQueue(floor, direction))
			local callOnlyMet = (requireCallOnlyParam and thisData.Call_Only and (thisCall and table.find(thisCall.directions, direction))) or (not thisData.Call_Only) or (not requireCallOnlyParam)
			if ((not thisData) or (not thisData.Enable) or (not callOnlyMet)) then continue end
			local directionStr = direction == 1 and 'Up' or direction == -1 and 'Down' or nil

			for i, v in pairs((value == 'Exterior' and regFloor.floorInstance or car):GetChildren()) do
				local sideData = sides[1] == 'all' and module.doorData or sides
				for i, rawSide in (sideData) do
					local side = typeof(i) == "string" and i or rawSide
					--if (v.Name ~= 'Lanterns') then continue end
					local lanternPart
					if (v.Name == 'Lanterns') or (v.Name == "Lanterns_" .. (side) and floors["Floor_" .. (floor)]:FindFirstChild((side) .. "_Doors")) then
						for _, l in pairs(v:GetChildren()) do
							if (l.Name ~= directionStr and l.Name ~= 'Both') then continue end
							for _, v in pairs(l:GetDescendants()) do
								if ((not v:IsA('BasePart')) or v.Name ~= 'Light') then continue end
								lanternPart = v
								break
							end
						end
						if ((not lanternPart) or lanternPart:GetAttribute('Is_Chiming')) then continue end
						lanternPart:SetAttribute('Is_Chiming', true)
						task.delay(thisData.Delay, addPlayingSound, lanternPart, module.sounds[(value) .. "_" .. (directionStr) .. "_Chime"], math.random(-10,10)/6000)
					end
				end
			end

		end
	end

	-- // Lantern handling // --
	function doLanterns(floor, sides, direction, indexes, cfg, requireCallOnlyParam)
		local regFloor = findRegisteredFloor(floor)
		if #sides == 0 then sides = { "all" } end
		if ((not regFloor) or (direction ~= 1 and direction ~= -1)) then return end
		for index, value in pairs(indexes) do
			local thisData = cfg[value]
			local thisCall = select(2, findCallInQueue(floor, direction))
			local callOnlyMet = (requireCallOnlyParam and thisData.Call_Only and (thisCall and table.find(thisCall.directions, direction))) or (not thisData.Call_Only) or (not requireCallOnlyParam)
			if ((not thisData) or (not thisData.Enable) or (not callOnlyMet)) then continue end
			local directionStr = direction == 1 and 'Up' or direction == -1 and 'Down' or nil
			local lanternCfgOut = configFile.Color_Database.Lanterns[value]
			local lanternCfg = lanternCfgOut[directionStr]

			task.delay(thisData.Delay, function()
				api:Fire('onElevatorLanternApi', {
					['state'] = 'active',
					['floor'] = floor,
					['sides'] = sides,
					['direction'] = string.sub(directionStr, 1, 1),
					['type'] = string.lower(value),
					['eventData'] = thisData,
					['conditionMet'] = callOnlyMet
				})
				for i, v in pairs((value == 'Exterior' and regFloor.floorInstance or car):GetChildren()) do
					local sideData = sides[1] == 'all' and module.doorData or sides
					for i, rawSide in (sideData) do
						local side = typeof(i) == "string" and i or rawSide
						if (v.Name == 'Lanterns') or (v.Name == "Lanterns_" .. (side) and floors["Floor_" .. (floor)]:FindFirstChild((side) .. "_Doors")) then
							for _, l in pairs(v:GetChildren()) do
								if (l.Name ~= directionStr and l.Name ~= 'Both') then continue end
								for _, v in pairs(l:GetDescendants()) do
									if ((not v:IsA('BasePart')) or v.Name ~= 'Light') then continue end
									v.Color = lanternCfg.Lit_State.Color
									v.Material = lanternCfg.Lit_State.Material
									for i, l in pairs(v:GetDescendants()) do
										if (not string.match(l.ClassName, 'Light')) then continue end
										l.Enabled = true
									end

									if ((not lanternCfgOut.Repeat_Data.Enable) or (not table.find(lanternCfgOut.Repeat_Data.Allowed_Directions, string.sub(directionStr, 1, 1))) or v:GetAttribute('Active')) then continue end

									v:SetAttribute('Active', true)
									task.spawn(function()
										for i = 1, lanternCfgOut.Repeat_Data.Times do
											task.wait(lanternCfgOut.Repeat_Data.Delay)
											v.Color = lanternCfg.Neautral_State.Color
											v.Material = lanternCfg.Neautral_State.Material
											for i, l in pairs(v:GetDescendants()) do
												if (not string.match(l.ClassName, 'Light')) then continue end
												l.Enabled = false
											end

											task.wait(lanternCfgOut.Repeat_Data.Delay)
											if not v:GetAttribute('Active') then break end

											v.Color = lanternCfg.Lit_State.Color
											v.Material = lanternCfg.Lit_State.Material
											for i, l in pairs(v:GetDescendants()) do
												if (not string.match(l.ClassName, 'Light')) then continue end
												l.Enabled = true
											end
										end
									end)
								end
							end
						end
					end
				end
			end)

		end
	end

	function resetLanterns(floor, side, direction, indexes)
		local regFloor = findRegisteredFloor(floor)
		if ((not regFloor) or (direction ~= 1 and direction ~= -1)) then return end
		if not side then side = 'all' end

		for index, value in pairs(indexes) do
			local directionStr = direction == 1 and 'Up' or direction == -1 and 'Down' or nil
			local lanternCfgOut = configFile.Color_Database.Lanterns[value]
			local lanternCfg = lanternCfgOut[directionStr]

			task.delay(configFile.Color_Database.Lanterns[value].Lantern_Reset_Delay, function()
				api:Fire('onElevatorLanternApi', {
					['state'] = 'neutral',
					['floor'] = floor,
					['direction'] = string.sub(directionStr, 1, 1),
					['type'] = string.lower(value)
				})

				for i, v in pairs((value == 'Exterior' and regFloor.floorInstance or car):GetChildren()) do
					local sideData = side == 'all' and module.doorData or {side}
					for i, rawSide in (sideData) do
						local side = typeof(i) == "string" and i or rawSide
						if (v.Name == 'Lanterns') or (v.Name == "Lanterns_" .. (side) and floors["Floor_" .. (floor)]:FindFirstChild((side) .. "_Doors")) then
							for _, l in pairs(v:GetChildren()) do
								if (l.Name ~= directionStr and l.Name ~= 'Both') then continue end
								for _, v in pairs(l:GetDescendants()) do
									if ((not v:IsA('BasePart')) or v.Name ~= 'Light') then continue end
									v.Color = lanternCfg.Neautral_State.Color
									v.Material = lanternCfg.Neautral_State.Material
									for i, l in pairs(v:GetDescendants()) do
										if (not string.match(l.ClassName, 'Light')) then continue end
										l.Enabled = false
									end
									v:SetAttribute('Active', false)
									v:SetAttribute('Is_Chiming', false)
								end
							end
						end
					end
				end
			end)

		end
	end

	for i, v in pairs(module.registeredFloors) do
		resetLanterns(v.floorNumber, 'all', 1, {'Exterior'})
		resetLanterns(v.floorNumber, 'all', -1, {'Exterior'})
	end
	resetLanterns(module.statValues.Raw_Floor, 'all', 1, {'Interior'})
	resetLanterns(module.statValues.Raw_Floor, 'all', -1, {'Interior'})

	-- // Button handling // --
	function setButton(button, config, state, from)
		local config = config[state]
		if (not config) then return end

		local buttonFloor = tonumber(string.split(button.Name, 'Floor')[2]) or tonumber(string.split(button.Name, 'Floor_')[2])
		local colorConfig = buttonFloor and configFile.Color_Database.Car.Custom_Color_Data[buttonFloor] or configFile.Color_Database.Car.Custom_Color_Data[tostring(buttonFloor)]
		if (colorConfig) then
			config = { Color = colorConfig[state].Color, Material = colorConfig[state].Material }
		end

		for i, v in pairs(from:GetDescendants()) do
			if (v.Name ~= button.Name) then continue end
			for _, led in pairs(v:GetDescendants()) do
				if ((not led:IsA('BasePart')) or led.Name ~= 'Light') then continue end
				led.Color = config.Color
				led.Material = config.Material
			end
		end
	end

	for _, button in pairs(elevator:GetDescendants()) do
		if (not button:FindFirstChild('Button')) then continue end
		button.Button:SetAttribute('isACortexElevButton', true)
		local buttonFloor = tonumber(string.split(button.Name, '_')[2]) or tonumber(string.split(button.Name, 'Floor')[2])
		if (buttonFloor) then
			setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
		elseif (string.match(button.Name, 'DoorOpen') or string.match(button.Name, 'Door_Open')) then
			setButton(button, configFile.Color_Database.Car.Doors.Open, 'Neutral', car)
		elseif (string.match(button.Name, 'DoorClose') or string.match(button.Name, 'Door_Close')) then
			setButton(button, configFile.Color_Database.Car.Doors.Close, 'Neutral', car)
		elseif (button.Name == 'DoorHold' or button.Name == 'Door_Hold') then
			setButton(button, configFile.Color_Database.Car.Doors.Hold, 'Neautral_State', car)
		elseif (button.Name == 'Alarm') then
			setButton(button, configFile.Color_Database.Car.Alarm_Button, 'Neautral_State', car)
		elseif (button.Name == 'CallCancel' or button.Name == 'Call_Cancel') then
			setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car)
		end
	end

	for i,v in pairs(module.registeredFloors) do
		for _, f in pairs(v.floorInstance:GetChildren()) do
			if (f.Name ~= 'Call_Buttons') then continue end
			for _, b in pairs(f:GetDescendants()) do
				local buttonName = string.split(b.Name, '_')[1]
				if (buttonName ~= 'Up' and buttonName ~= 'Down') then continue end
				setButton(b, configFile.Color_Database.Floor[buttonName], 'Neautral_State', b.Parent)
			end
		end
	end

	-- // Welding inspection control buttons // --
	for i,v in pairs(elevator:GetDescendants()) do
		if (v.Name ~= 'Inspection_Controls') then continue end
		for i, button in pairs(v:GetDescendants()) do
			if (button.Name ~= 'Up' and button.Name ~= 'Down' and button.Name ~= 'Stop' and button.Name ~= 'Inspection_Switch' and button.Name ~= 'Common' and button.Name ~= 'Enable' and button.Name ~= 'Alarm') then continue end
			if (button:IsA('BasePart')) then
				local model = Instance.new('Model')
				model.Name = button.Name
				model.Parent = button.Parent
				button.Name = 'Button'
				button.Parent = model
				button = model
			end
			local buttonPart
			for i, v in pairs(button:GetDescendants()) do
				if ((not v:IsA('BasePart')) or v.Name ~= 'Button') then continue end
				buttonPart = v
			end
			if (not buttonPart) then continue end

			buttonPart:SetAttribute('isACortexElevButton', true)
			for i, weld in pairs(carWeldsFolder:GetChildren()) do
				if (weld.Part0:IsDescendantOf(button)) then
					weld:Destroy()
				end
			end
			local buttonAttachment = buttonPart:FindFirstChild('Pressed_Point')
			if (not buttonAttachment) then
				buttonAttachment = Instance.new('Part')
				buttonAttachment.Name = 'Pressed_Point'
				buttonAttachment.CFrame, buttonAttachment.Size = if (button.Name == 'Inspection_Switch') then buttonPart.CFrame*CFrame.Angles(0, 0, math.rad(90)) else if (button.Name == 'Stop') then buttonPart.CFrame*CFrame.new(0, -.02, 0) else buttonPart.CFrame*CFrame.new(-.02, 0, 0), buttonPart.Size
				buttonAttachment.Transparency = 1
				buttonAttachment.CanCollide = false
				buttonAttachment.CanTouch = false
				buttonAttachment.CanQuery = false
				buttonAttachment.Parent = buttonPart

				local animWeld = weldParts(buttonAttachment, buttonAttachment, buttonPart, false, false)
				animWeld.Name = 'Button_Weld'
				animWeld:SetAttribute('down', animWeld.C1)
				animWeld:SetAttribute('up', animWeld.C0)
				weldModel(button, buttonPart, {buttonAttachment})
				weldParts(buttonAttachment, buttonAttachment, platform, true, false)
			end
		end
	end

	local function isButtonALockedFloor(tablePath, buttonFloor, buttonSide)
		for i, v in pairs(tablePath) do
			if (buttonSide and ((i == (buttonFloor) .. "_" .. (buttonSide) or i == buttonFloor) and v == true) or (not buttonSide and (string.split(i, '_')[1] == buttonFloor and v == true))) then
				return true
			end
		end

		return false
	end

	--local function isAllLockedFloorCallsInQueue(tablePath, floor, queue) -- WIP do not use
	--	for i, v in pairs(tablePath) do
	--		if string.split(i, "_")[1] == floor and not table.find(queue.sides, "0_" .. (string.split(i, "_")[2])) then
	--			print("not all in queue")
	--			return false
	--		end
	--	end
	--end

	local lastButtonPressedtick = tick()

	local function btnDelay(button: any, duration: number, callback: any, bypassCheckInRecurse: boolean?)
		if (button:GetAttribute('litDelayCooldown') and bypassCheckInRecurse == false) then return end
		button:SetAttribute('litDelayCooldown', true) -- Prevents multiple loops from running per button
		task.delay(duration, function()
			if ((tick()-lastButtonPressedtick)/duration < 1) then return btnDelay(button, duration, callback, true) end
			if (typeof(callback) == 'function') then callback() end
			button:SetAttribute('litDelayCooldown', false)
		end)
	end

	local function handleButtonInput(user, protocol, params)
		if (protocol ~= 'onButtonPressed' and protocol ~= 'onButtonReleased') then return end

		local button = params.button
		if (not button) then return end

		local buttonPart = button:FindFirstChild('Button')
		if (not buttonPart) then return end

		if (protocol == 'onButtonPressed') then
			addPlayingSound(buttonPart, buttonPart:IsDescendantOf(car) and module.sounds.Button_Beep or module.sounds.Call_Button_Beep)
		end

		local buttonFloor = tonumber(string.split(button.Name, '_')[1] == 'Floor' and string.split(button.Name, '_')[2]) or tonumber(string.split(button.Name, 'Floor')[2])
		local buttonSide = string.split(button.Name, '_')[3]

		if (buttonFloor) then -- Car Floor buttons
			local isOnFloor = (buttonFloor == module.statValues.Raw_Floor and (module.statValues.Move_Value == 0 or module.statValues.Leveling))
			local callQueue = findCallInQueue(buttonFloor) and select(2, findCallInQueue(buttonFloor))
			local callFound = callQueue and (buttonSide and table.find(callQueue.sides, "0_" .. (buttonSide)) or (not buttonSide and callQueue)) -- This works but non floor side buttons will light up but wont open all doors due to the way the queue system is scripted, this will be improved soon.
			local lockResetStatement = (isButtonALockedFloor(module.lockedCalls.car, tostring(buttonFloor), buttonSide) and not checkFireServicePhase2() and (callFound and not callQueue.isCarCall or not callFound) --[[findCallInQueue(buttonFloor)]])
			local resetStatement = (lockResetStatement or (not findRegisteredFloor(buttonFloor)) or (module.statValues.Fire_Service and not module.statValues.Phase_2) or module.statValues.Fire_Recall or module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service)

			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Floor_Button, 'Lit_State', car)
				if (resetStatement) then return end

				if (isOnFloor) then
					if moveLock then return end
					task.spawn(runDoorOpen, module.statValues.Raw_Floor, buttonSide or 'all', 'Open_No_Call')
				else
					if not findCallInQueue(buttonFloor) then
						task.delay(configFile.Sound_Database.Others.Call_Recognition_Beep.Delay, function()
							addPlayingSound(cabRegion, module.sounds.Call_Recognition_Beep)
						end)
					end
					
					local newCallAdded = addCall({call = buttonFloor, side = buttonSide, isCarCall = true})
					if ((not newCallAdded) or moveLock) then return end
					task.spawn(runChime, module.statValues.Raw_Floor, { buttonSide }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.New_Call_Input)
					task.spawn(doLanterns, module.statValues.Raw_Floor, { buttonSide }, module.statValues.Queue_Direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Call_Enter)
				end
			elseif (resetStatement or isOnFloor) then
				btnDelay(button, configFile.Color_Database.Car.Lit_Delay, function() setButton(button, configFile.Color_Database.Car.Floor_Button, 'Neautral_State', car) end, false)
			end
		elseif (string.match(button.Name, 'DoorOpen') or string.match(button.Name, 'Door_Open')) then -- Door Open buttons
			local side = (string.split(button.Name, 'DoorOpen')[2] and string.split(button.Name, 'DoorOpen')[1]) or (string.split(button.Name, '_Door_Open')[2] and string.split(button.Name, '_Door_Open')[1])
			if button.Name == 'Door_Open' then side = '' end
			if (not side) then return end
			side = string.split(side, '_')[1]
			if (not side) then return end
			local rawSide = side
			if (side == '') then side = 'Front' end

			local doorData = module.doorData[side]

			local Disable_Door_Open_On_Locked_Floor = configFile.Locking.Disable_Door_Open_On_Locked_Floor

			local function checkLockedStatement(doorSide)
				local doorSideData = module.doorData[doorSide]
				return (Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and not checkFireServicePhase2() and doorSideData.state == 'Closing')
					or (Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and not checkFireServicePhase2() and doorSideData.state == 'Closed')
					or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (doorSide)])) and doorSideData.state == 'Closing')
					or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (doorSide)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (doorSide)])) and doorSideData.state == 'Closed')
			end

			--local lockResetStatement = (
			--	(Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (side)]) and not checkFireServicePhase2() and doorData.state == 'Closing')
			--		or (Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed and button:IsDescendantOf(car) and (module.lockedCalls.car[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.car[(module.statValues.Raw_Floor) .. "_" .. (side)]) and not checkFireServicePhase2() and doorData.state == 'Closed')
			--		or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (side)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (side)])) and doorData.state == 'Closing')
			--		or (Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed and button:IsDescendantOf(floors) and ((module.lockedCalls.hall.up[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.up[(module.statValues.Raw_Floor) .. "_" .. (side)]) and (module.lockedCalls.hall.down[tostring(module.statValues.Raw_Floor)] or module.lockedCalls.hall.down[(module.statValues.Raw_Floor) .. "_" .. (side)])) and doorData.state == 'Closed')
			--)
			local resetStatement = (module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service)

			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Doors.Open, 'Active', car)
				if resetStatement then return end

				doorData.buttonHold = true
				if rawSide == '' then
					for _, v in pairs(module.doorData) do
						if checkLockedStatement(v.side) then continue end
						task.spawn(runDoorOpen, module.statValues.Raw_Floor, v.side, 'Open_No_Call')
					end
				else
					if checkLockedStatement(side) then return end
					task.spawn(runDoorOpen, module.statValues.Raw_Floor, side, 'Open_No_Call')
				end
			else
				doorData.buttonHold = false
				btnDelay(button, configFile.Color_Database.Car.Lit_Delay, function() setButton(button, configFile.Color_Database.Car.Doors.Open, 'Neutral', car) end, false)
				if (checkFireServicePhase2() and doorData.state == 'Opening') then
					task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
				end
			end
		elseif (string.match(button.Name, 'DoorClose') or string.match(button.Name, 'Door_Close')) then -- Door Close buttons
			local side = (string.split(button.Name, 'DoorClose')[2] and string.split(button.Name, 'DoorClose')[1]) or (string.split(button.Name, '_Door_Close')[2] and string.split(button.Name, '_Door_Close')[1])
			if button.Name == 'Door_Close' then side = '' end
			if (not side) then return end
			side = string.split(side, '_')[1]
			if (not side) then return end
			local rawSide = side
			if (side == '') then side = 'Front' end
			local doorData = module.doorData[side]

			local resetStatement = (module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service or (module.statValues.Fire_Service and not checkFireServicePhase2()))
			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Doors.Close, 'Active', car)
				if resetStatement then return end
				if rawSide == '' then
					for _, v in pairs(module.doorData) do
						task.spawn(runDoorClose, module.statValues.Raw_Floor, v.side)
					end
				else
					task.spawn(runDoorClose, module.statValues.Raw_Floor, side)
				end
			else
				btnDelay(button, configFile.Color_Database.Car.Lit_Delay, function() setButton(button, configFile.Color_Database.Car.Doors.Close, 'Neutral', car) end, false)
				if ((checkIndependentService() or checkFireServicePhase2())) then
					if side == '' then
						for _, v in pairs(module.doorData) do
							if v.state == 'Closing' then
								task.spawn(runDoorOpen, module.statValues.Raw_Floor, side, 'Open_No_Call')
							end
						end
					else
						if doorData.state == 'Closing' then
							task.spawn(runDoorOpen, module.statValues.Raw_Floor, side, 'Open_No_Call')
						end
					end
				end
			end
		elseif (button.Name == 'Alarm') then
			if (protocol == 'onButtonPressed') then
				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Car.Alarm_Button, 'Lit_State', car)
				module.sounds.Alarm.Playing = true
			else
				setButton(button, configFile.Color_Database.Car.Alarm_Button, 'Neautral_State', car)
				module.sounds.Alarm.Playing = false
				module.sounds.Alarm_Release:Play()
			end
		elseif (button.Name == 'CallCancel' or button.Name == 'Call_Cancel') then
			if (checkIndependentService() or checkFireServicePhase2()) then
				removeAllCalls()
				if (module.statValues.Move_Value ~= 0) then
					removeCall(module.statValues.Raw_Floor)
				end
			end
		end

		if (button:IsDescendantOf(floors)) then -- Hall Call buttons
			local buttonFloor = tonumber(string.split(button.Parent.Parent.Name, '_')[2]) or tonumber(string.split(button.Parent.Parent.Name, 'Floor')[2])
			local buttonName = string.split(button.Name, '_')[1]
			local buttonDirection = string.sub(buttonName, 1, 1)
			local buttonSide = string.split(button.Name, '_')[2]

			if (not buttonFloor or (buttonDirection ~= 'U' and buttonDirection ~= 'D')) then return end

			buttonDirection = buttonDirection == 'U' and 1 or buttonDirection == 'D' and -1 or nil
			local isOnFloor = (buttonFloor == module.statValues.Raw_Floor and (module.statValues.Move_Value == 0 or module.statValues.Leveling) and (module.statValues.Queue_Direction == buttonDirection or module.statValues.Queue_Direction == 0))
			local lockResetStatement = isButtonALockedFloor(module.lockedCalls.hall[string.lower(buttonName)], tostring(buttonFloor), buttonSide) --[[module.lockedCalls.hall[string.lower(buttonName)][tostring(buttonFloor)]] and (not findCallInQueue(buttonFloor, buttonDirection))
			local resetStatement = (lockResetStatement or module.statValues.Fire_Service or module.statValues.Independent_Service or module.statValues.Inspection or module.statValues.Stop or module.statValues.Out_Of_Service)

			if (protocol == 'onButtonPressed') then

				lastButtonPressedtick = tick()
				setButton(button, configFile.Color_Database.Floor[buttonName], 'Lit_State', button.Parent)
				if (resetStatement) then return end

				if (isOnFloor) then
					task.spawn(runChime, buttonFloor, { buttonSide }, buttonDirection, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.Exterior_Call_Only)
					task.spawn(doLanterns, buttonFloor, { buttonSide }, buttonDirection, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Exterior_Call)
					for _, v in pairs(module.doorData) do
						if (not v:IsValid(module.statValues.Raw_Floor)) then continue end
						if buttonSide and buttonSide ~= v.side then continue end

						v.buttonHold = true
						if (module.statValues.Queue_Direction == 0) then
							module.statValues.Queue_Direction = buttonDirection
							task.spawn(updateStatValues)
						end

						task.spawn(runDoorOpen, module.statValues.Raw_Floor, v.side, 'Open_By_Call')
					end
				else
					local newCallAdded = addCall({call = buttonFloor, side = buttonSide, direction = buttonDirection})
				end
			elseif (resetStatement or isOnFloor) then
				for _, v in pairs(module.doorData) do
					if (not v:IsValid(module.statValues.Raw_Floor)) then continue end
					v.buttonHold = false
				end
				btnDelay(button, configFile.Color_Database.Floor.Active_Duration, function()
					setButton(button, configFile.Color_Database.Floor[buttonName], 'Neautral_State', button.Parent)
				end, false)
			end
		elseif (button:FindFirstAncestor('Inspection_Controls')) then
			if (inspectionLocked) then return end
			if (button.Name == 'Stop') then
				if (protocol == 'onButtonPressed') then
					local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
					if (not animWeld) then return end
					tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = module.statValues.Stop and animWeld:GetAttribute('up') or animWeld:GetAttribute('down')}):Play()
					api:Fire('Stop', not module.statValues.Stop)
				end
			elseif (button.Name == 'Inspection_Switch') then
				if (protocol == 'onButtonPressed') then
					local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
					if (not animWeld) then return end
					tweenService:Create(animWeld, TweenInfo.new(.15, Enum.EasingStyle.Linear), {C0 = module.statValues.Inspection and animWeld:GetAttribute('up') or animWeld:GetAttribute('down')}):Play()
					api:Fire('Inspection_Service', not module.statValues.Inspection)
				end
			elseif (button.Name == 'Alarm') then
				local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
				if (not animWeld) then return end
				tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = protocol == 'onButtonPressed' and animWeld:GetAttribute('down') or animWeld:GetAttribute('up')}):Play()
				module.sounds.Alarm.Playing = protocol == 'onButtonPressed'
				if protocol == 'onButtonReleased' then
					module.sounds.Alarm_Release:Play()
				end
			elseif (button.Name == 'Enable' or button.Name == 'Common') then
				if (protocol == 'onButtonPressed') then
					local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
					if (not animWeld) then return end
					inspectionEnabled = not inspectionEnabled
					tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = inspectionEnabled and animWeld:GetAttribute('down') or animWeld:GetAttribute('up')}):Play()
				end
			elseif (button.Name == 'Up' or button.Name == 'Down') then
				local animWeld = buttonPart:FindFirstChild('Button_Weld', true)
				if (not animWeld) then return end
				tweenService:Create(animWeld, TweenInfo.new(.05, Enum.EasingStyle.Linear), {C0 = protocol == 'onButtonPressed' and animWeld:GetAttribute('down') or animWeld:GetAttribute('up')}):Play()
				if (protocol == 'onButtonPressed') then
					if inspectionEnabled then
						api:Fire('Inspection_Service_Move', { ['direction'] = string.sub(button.Name, 1, 1), ['maxSpeed'] = configFile.Movement.Inspection_Config.Max_Speed})
					end
				else
					if inspectionEnabled then
						api:Fire('Inspection_Service_Stop', true)
					end
				end
			end
		end
	end

	local inspectionStopped = signal.new()

	api.Event:Connect(function(protocol, params, ...)
		handleButtonInput(nil, protocol, params)

		if (protocol == 'Add_Call' or protocol == 'Request_Call_F' or protocol == 'Add_Hall_Call' or protocol == 'addHallCall') then
			local call = typeof(params) == 'table' and (tonumber(params.call) or tonumber(params.floor)) or (typeof(params) == 'number') and params or nil
			if (not call) then return end
			if ((typeof(params) == 'table' and not params.bypassFireRecall or true) and (module.statValues.Fire_Recall or module.statValues.Phase_1)) then return end

			--if params.floor and not params.call then params.call = params.floor end -- Legacy API support
			local direction = typeof(params) == 'table' and (if (typeof(params.direction) == 'string') then params.direction == 'U' and 1 or params.direction == 'D' and -1 or 0 else params.direction) or if (typeof(... and select(1, ...)) == 'number') then ... and select(1, ...) else nil

			local isOnFloor = (call == module.statValues.Raw_Floor and (module.statValues.Move_Value == 0 or module.statValues.Leveling) and (module.statValues.Queue_Direction == direction or module.statValues.Queue_Direction == 0 or (not direction)))
			if (isOnFloor) then
				task.spawn(runChime, call, { typeof(params) == 'table' and params.side or 'all' }, direction, {'Exterior', 'Interior'}, configFile.Sound_Database.Chime_Events.Exterior_Call_Only)
				task.spawn(doLanterns, call, { typeof(params) == 'table' and params.side or 'all' }, direction, {'Exterior', 'Interior'}, configFile.Color_Database.Lanterns.Active_On_Exterior_Call)

				task.spawn(runDoorOpen, module.statValues.Raw_Floor, typeof(params) == 'table' and params.side or 'all', 'Open_By_Call')
				module.statValues.Queue_Direction = direction or call > module.statValues.Raw_Floor and 1 or call < module.statValues.Raw_Floor and -1 or 0
				task.spawn(updateStatValues)
				api:Fire('onCallRespond', { floor = module.statValues.Raw_Floor, direction = module.statValues.Queue_Direction == 1 and 'U' or module.statValues.Queue_Direction == -1 and 'D' or 'N' })
			else
				addCall({call = call, direction = direction, side = typeof(params) == 'table' and params.side, isCarCall = typeof(params) == 'table' and params.isCarCall or (not direction), bypassFireRecall = typeof(params) == 'table' and params.bypassFireRecall or false})
				if (typeof(params) == 'table' and params.activateCarButtons == true) then
					local carButton = car:FindFirstChild('Buttons') and (car.Buttons:FindFirstChild("Floor" .. (call)) or car.Buttons:FindFirstChild("Floor_" .. (call)))
					if (not carButton) then return end
					setButton(carButton, configFile.Color_Database.Car.Floor_Button, 'Lit_State', car)
				end
			end
		elseif (protocol == 'Independent_Service' or protocol == 'invokeIndependentService' or protocol == 'invokeIS') then
			setIndependentService(params)
		elseif (protocol == 'Fire_Recall' or protocol == 'Fire_Service_Phase_1') then
			if (typeof(params) ~= 'table') then
				params = {
					floor = ... and select(1, ...),
					enable = params
				}
			end

			fireRecall(params.enable, params.floor)
		elseif (protocol == 'Phase_2' or protocol == 'Fire_Service_Phase_2') then
			--outputElevMessage((module.MODULE_STORAGE.statValues.phase1) .. ", " .. (module.MODULE_STORAGE.statValues.phase2), 'debug')
			module.statValues.Phase_2 = params
			task.spawn(updateStatValues)
			if (module.statValues.Fire_Service and not module.statValues.Phase_2) then
				fireRecall(false, fireServiceRecallFloor)
				fireRecall(true, fireServiceRecallFloor)
			end
		elseif (protocol == 'Stop') then
			if (params) then
				removeAllCalls()
				module.statValues.Stop = true
				safetyBraking = false
				for i, v in pairs(module.doorData) do
					if (v.state == 'Opening' or v.state == 'Closing') then
						for _, vl in pairs(v.velocity) do
							v.velocity[_] = 0
						end
						v.state = 'Stopped'
						module.statValues[(v.sideJoin) .. "Door_State"] = v.state
					end
				end
				task.spawn(updateStatValues)
				safetyBrake()
				playerWeld(false)
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Out_Of_Service_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Out_Of_Service_Announcement.Enabled)
			else
				if (not module.statValues.Stop) then return end
				moveLock = false
				module.statValues.Stop = false
				while (safetyBraking) do task.wait() end
				task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
				task.spawn(updateStatValues)
			end
		elseif (protocol == 'Inspection_Service' or protocol == 'setInspection') then
			if (params) then
				task.spawn(safetyBrake)
				playerWeld(false)
				module.statValues.Inspection = true

				if (not checkDoorStates('Closed', {dontRequireAll = false, onlyPresentDoors = true})) then
					module.statValues.Nudge = true
				end

				for i, v in pairs(module.doorData) do
					if (v.state == 'Closed') then continue end
					v.nudging = true
				end
				playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Other_Announcements.Inspection_Service_Announcement.Sequence, false, voiceConfig.Settings.Other_Announcements.Inspection_Service_Announcement.Enabled)
			else
				if (not module.statValues.Inspection) then return end
				module.statValues.Inspection = false
				moveLock = false
				while (safetyBraking) do task.wait() end
				task.spawn(relevel, module.statValues.Raw_Floor, .015, false)
			end
			task.spawn(updateStatValues)
		elseif (protocol == 'Inspection_Service_Lock' or protocol == 'inspectionLock') then
			inspectionLocked = params
		elseif (protocol == 'Inspection_Service_Common') then
			inspectionEnabled = params
		elseif (protocol == 'Inspection_Service_Move' or protocol == 'inspectionMove') then
			if ((not module.statValues.Inspection)) then return end -- // Inspection is not enabled! Do not run inspection

			if not params.direction then
				params.direction = params[1] == 'Up' and 'U' or params[1] == 'Down' and 'D'
			end
			if not params.maxSpeed then
				params.maxSpeed = params[2]
			end

			local moveDir = params.direction == 'U' and 1 or params.direction == 'D' and -1 or nil

			pcall(task.cancel, inspectionStopThread)
			inspectionMoveThread = task.spawn(function()
				if (inspectionMoving and module.statValues.Move_Value ~= moveDir or inspectionStopping) then
					api:Fire('Inspection_Service_Stop')
					inspectionStopped:Wait()
				end
				if ((moveDir == 1 and level.Position.Y >= topFloor.level.Position.Y+1.5) or (moveDir == -1 and level.Position.Y <= bottomFloor.level.Position.Y-1.5)) then return end

				module.statValues.Move_Value = moveDir
				module.statValues.Move_Direction = moveDir
				updateStatValues()

				inspectionMoving = true

				local initialSpeed = module.statValues.Current_Speed
				local finalSpeed = params.maxSpeed or configFile.Movement.Inspection_Config.Max_Speed
				local duration = coreFunctions.getAccelerationTime(initialSpeed, finalSpeed, configFile.Movement.Inspection_Config.Accceleration_Rate)
				local startTime = os.clock()
				while (inspectionMoving) do
					module.statValues.Current_Speed = coreFunctions.lerp(initialSpeed, finalSpeed, math.min((os.clock()-startTime)/duration, 1))
					updateStatValues()
					local dtTime, carMovementDirection = moveElevator(heartbeat:Wait())
					if ((carMovementDirection == 1 and level.Position.Y >= topFloor.level.Position.Y+1.5) or (carMovementDirection == -1 and level.Position.Y <= bottomFloor.level.Position.Y-1.5)) then
						safetyBraking = false
						safetyBrake()
						playerWeld(false)
					end
				end
			end)

		elseif (protocol == 'Inspection_Service_Stop' or protocol == 'inspectionStop') then
			if ((not module.statValues.Inspection)) then return end -- // Inspection is not enabled! Do not run inspection
			pcall(task.cancel, inspectionMoveThread)
			inspectionStopThread = task.spawn(function()
				local initialSpeed = module.statValues.Current_Speed
				local duration = coreFunctions.getAccelerationTime(initialSpeed, 0, configFile.Movement.Inspection_Config.Deceleration_Rate)
				local startTime = os.clock()
				inspectionMoving = false
				inspectionStopping = true
				while ((os.clock()-startTime)/duration < 1) do
					module.statValues.Current_Speed = coreFunctions.lerp(initialSpeed, 0, math.min((os.clock()-startTime)/duration, 1))
					updateStatValues()
					moveElevator(heartbeat:Wait())
				end
				module.statValues.Move_Value = 0
				module.statValues.Current_Speed = 0
				updateStatValues()
				inspectionStopping = false
				inspectionStopped:Fire()
			end)

		elseif (protocol == 'Lock_Floors') then
			if (typeof(params) ~= 'table') then return --[[debugWarn((event) .. " API :: Paramrters is not of type table")]] end
			--outputElevMessage("Elevator floors locked with calls " .. (table.concat(params, ', ')), 'debug')
			for _, v in pairs(params) do
				module.lockedCalls.car[tostring(v)] = true
			end
		elseif (protocol == 'Unlock_Floors') then
			if (typeof(params) ~= 'table') then return --[[debugWarn((event) .. " API :: Paramrters is not of type table")]] end
			--outputElevMessage("Elevator floors unlocked with calls " .. (table.concat(params, ', ')), 'debug')
			for _, v in pairs(params) do
				module.lockedCalls.car[tostring(v)] = false
			end
		elseif (protocol == 'Lock_Hall_Floors') then
			--if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
			--outputElevMessage("Elevator floors hall locked with calls " .. (table.concat(params, ', ')), 'debug')
			if params['up'] then
				for _, v in pairs(params.up) do
					module.lockedCalls.hall.up[tostring(v)] = true
				end
			end

			if params['down'] then
				for _, v in pairs(params.down) do
					module.lockedCalls.hall.down[tostring(v)] = true
				end
			end

			if not params['up'] and not params['down'] then
				for _, v in pairs(params) do
					if tonumber(v) then
						module.lockedCalls.hall.up[tostring(v)] = true
						module.lockedCalls.hall.down[tostring(v)] = true
					end
				end
			end
		elseif (protocol == 'Unlock_Hall_Floors') then
			--if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
			--outputElevMessage("Elevator floors hall locked with calls " .. (table.concat(params, ', ')), 'debug')
			if (params['up']) then
				for _, v in pairs(params.up) do
					module.lockedCalls.hall.up[tostring(v)] = false
				end
			end
			if (params['down']) then
				for _, v in pairs(params.down) do
					module.lockedCalls.hall.down[tostring(v)] = false
				end
			end
			if ((not params['up']) and (not params['down'])) then
				for _, v in pairs(params) do
					if tonumber(v) then
						module.lockedCalls.hall.up[tostring(v)] = false
						module.lockedCalls.hall.down[tostring(v)] = false
					end
				end
			end
		elseif (protocol == 'Door_Open') then
			runDoorOpen(module.statValues.Raw_Floor, typeof(params) == 'table' and params or 'ALL')
		elseif (protocol == 'Door_Close') then
			runDoorClose(module.statValues.Raw_Floor, typeof(params) == 'table' and params or 'ALL')
		elseif (protocol == 'Door_Nudge') then
			runDoorClose(module.statValues.Raw_Floor, typeof(params) == 'table' and params or 'ALL', true)
		elseif (protocol == 'Fire_Button_Event') then
			handleButtonInput(nil, params.protocol, { ['button'] = params.button })
		elseif (protocol == 'Drop_Key_Toggle' or protocol == 'dropKeyToggle') then
			doDropKey(params)
		end
	end)

	remote.OnServerEvent:Connect(function(user, protocol, params)
		handleButtonInput(user, protocol, params)
		if (protocol == 'dropKeyToggle') then
			local isHoldingKey = user.Character and user.Character:FindFirstChild('Drop Key')
			if (not isHoldingKey) then return end
			doDropKey(params)
		elseif (protocol == 'addDropKeyGuiToPlayer') then
			local containsDropKey
			for i,v in pairs(user.Character:GetChildren()) do
				if (v.Name == 'Drop Key' or v:FindFirstChild('Cortex_Drop_Key')) then
					containsDropKey = v
					break
				end
			end
			local isHoldingKey = user.Character and containsDropKey
			if (not isHoldingKey) then return end
			if (user.PlayerGui:FindFirstChild('DOOR_KEY_UI')) then return end
			local doorSet = params
			local thisFloorName = doorSet:IsDescendantOf(floors) and string.split(doorSet.Parent.Name, 'Floor_')[2]
			local landingLevel = doorSet.Parent.Level
			local sideIndex = doorSet.Name:split('Doors')[1]:split('_')[1]
			local fullSideName = (sideIndex == '' and 'Front' or sideIndex)
			local data = module.doorData[sideIndex]
			if (collectionService:HasTag(doorSet, 'IsInUse') or table.find(dropKeyHandlers,user) or (not ((landingLevel:IsDescendantOf(car) and data.state == 'Closed') or ((not landingLevel:IsDescendantOf(car)) and ((data.state == 'Closed' and tonumber(landingLevel.Parent.Name:sub(7)) == module.statValues.Raw_Floor) or tonumber(landingLevel.Parent.Name:sub(7)) ~= module.statValues.Raw_Floor))))) then return end
			table.insert(dropKeyHandlers,user)
			collectionService:AddTag(doorSet, 'IsInUse')
			local boundsCFrame,boundsSize = doorSet:GetBoundingBox()
			local doorBounds = doorSet:FindFirstChild('Door_Bounds')
			if (not doorBounds) then
				doorBounds = Instance.new('Part')
				doorBounds.Name = 'Door_Bounds'
				doorBounds.CFrame,doorBounds.Size = boundsCFrame,boundsSize
				doorBounds.CanCollide = false
				doorBounds.CanTouch = false
				doorBounds.CanQuery = false
				doorBounds.Transparency = 1
				weldParts(doorBounds, doorBounds, landingLevel, true, false)
				doorBounds.Anchored = false
				doorBounds.Parent = doorSet
			end
			local gui = dependencies.DOOR_KEY_UI:Clone()
			gui.DOOR_SET.Value = doorSet
			gui.Adornee = doorBounds
			gui.Enabled = true
			gui.Parent = user.PlayerGui:WaitForChild('DOOR_KEY_UIS')
			collectionService:AddTag(gui,'ACTIVE')
			local function getOrientation(cf)
				return cf:ToOrientation()
			end
			local welds = {}
			for i,v in next,data and (doorSet:IsDescendantOf(car) and car.Door_Engine_Welds:FindFirstChild(sideIndex):GetChildren() or findRegisteredFloor(thisFloorName).floorInstance:FindFirstChild('Door_Engine_Welds'):FindFirstChild(sideIndex):GetChildren()) or {} do
				table.insert(welds, v)
			end
			local function checkIfDoorIsClosed()
				for i,v in pairs(welds) do
					if (v.C0 ~= v:GetAttribute('closedPoint')) then return false end
				end
				return true
			end
			addPlayingSound(landingLevel, addSound(landingLevel, 'Interlock_Click', {
				Sound_Id = 9116323848,
				Volume = 1,
				Pitch = 1.35
			}, false, 40, 3))
			for i,v in pairs(module.doorData) do
				v.nudging = false
			end
			module.statValues.Nudge = false
			task.spawn(updateStatValues)
			local val = gui:WaitForChild('RATIO')
			local hasStopped = false
			local lastChecked = checkIfDoorIsClosed()
			api:Fire('onElevDoorKey',{doorSet=doorSet,status='insert'})

			local update: RBXScriptConnection
			update = heartbeat:Connect(function(dtTime)
				local value = val.Value
				for i,weld in pairs(welds) do
					weld.C0 = weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'),value)
				end
				local checked = checkIfDoorIsClosed()
				if (lastChecked ~= checked) then
					lastChecked = checked
					data.isEnabled = checked
					if (not checked) then
						if (not hasStopped) then
							hasStopped = true
							module.statValues.Out_Of_Service = true
							module.sounds.Safety_Brake_Sound.PlaybackSpeed = module.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
							task.spawn(safetyBrake)
							playerWeld(false)
						end
					else
						hasStopped = false
						module.statValues.Out_Of_Service = not checkDropKeyState()
						if (not module.statValues.Out_Of_Service) then
							task.spawn(function()
								local isCompleted = coreFunctions.conditionalWait(1, function() return {module.statValues.Out_Of_Service} end)
								if (not isCompleted) then return end
								--task.spawn(safeCheckRelevel)
							end)
						end
						task.spawn(updateStatValues)
					end
				end
			end)
			if (not dropKeyHandlers[doorSet]) then dropKeyHandlers[doorSet] = {} end
			table.insert(dropKeyHandlers[doorSet], update)
		elseif (protocol == 'exit') then
			for i,v in pairs(user.PlayerGui:WaitForChild('DOOR_KEY_UIS'):GetChildren()) do
				if (collectionService:HasTag(v,'ACTIVE')) then
					v:Destroy()
				end
			end
			dismountDropKeyClient(user, params)
		end
	end)

	function elevatorSignal.OnInvoke(protocol, params)
		if (protocol == 'GET_ELEVATOR_WELDS') then
			return elevatorPlayerWelds
		end
	end

	players.PlayerRemoving:Connect(function(plr: Player)
		if (not table.find(dropKeyHandlers,plr)) then return end
		for i,v in pairs(collectionService:GetTagged('IsInUse')) do
			if (v:IsDescendantOf(elevator)) then
				dismountDropKeyClient(plr,v)
			end
		end
	end)

	api:Fire('Lock_Floors', (configFile.Locking.Locked_Floors) or {})
	api:Fire('Lock_Hall_Floors', (configFile.Locking.Locked_Hall_Floors) or {})

	task.spawn(updateFloor)
	task.spawn(updateStatValues)
	parkTimer()
end

return module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBX89F79E81A42C4D4E87C71CD2B5B2E095">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Dependencies</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX7D1BF382D8D64B39925AB160D5F4FE7F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ConfigFile</string>
								<string name="ScriptGuid">{EAB435CC-653F-4D20-B4A3-66BE3FA1A209}</string>
								<ProtectedString name="Source"><![CDATA[return function(config, coreScript)
	local DefaultConfig = {
		['Doors'] = {
			['Door_Open_Speed'] = config.Doors.Door_Open_Speed, -- Doors take 1.68 seconds to open fully.
			['Door_Close_Speed'] = config.Doors.Door_Close_Speed, -- Doors take 2.48 seconds to close fully.
			['Door_Close_Delay'] = config.Doors.Door_Close_Delay or 0,
			['Nudge_Speed'] = config.Doors.Nudge_Speed or config.Doors.Door_Close_Speed,

			['Door_Timers'] = {
				['Open_No_Call'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Open_No_Call) == 'number') then config.Doors.Door_Timers.Open_No_Call else config.Doors.Door_Timer,
				['Open_On_Stop'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Open_On_Stop) == 'number') then config.Doors.Door_Timers.Open_On_Stop else config.Doors.Door_Timer,
				['Open_By_Call'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Open_By_Call) == 'number') then config.Doors.Door_Timers.Open_By_Call else config.Doors.Door_Timer,
				['Handicap_Call'] = if (typeof(config.Doors.Door_Timers) == 'table' and typeof(config.Doors.Door_Timers.Handicap_Call) == 'number') then config.Doors.Door_Timers.Handicap_Call else config.Doors.Door_Timer,
			},
			['Nudge_Timer'] = config.Doors.Nudge_Timer,

			['Use_Old_Door_Sensors'] = config.Doors.Use_Old_Door_Sensors,

			['Open_Easing_Style'] = config.Doors.Open_Easing_Style or 'In_Out_Quad',
			['Close_Easing_Style'] = config.Doors.Close_Easing_Style or 'In_Out_Sine',

			['Door_Sensors'] = config.Doors.Door_Sensors,

			['Door_Open_Delay_Pattern'] = config.Doors.Door_Open_Delay_Pattern, -- Example: ['Door_Open_Delay_Pattern'] = {'Outer', 'Inner'} - Outer doors open, then the inner doors
			['Door_Close_Delay_Pattern'] = config.Doors.Door_Close_Delay_Pattern, -- Example: ['Door_Close_Delay_Pattern'] = {'Inner', 'Outer'} - Inner doors close, then the outer doors

			['Door_Open_Pattern_Delay'] = config.Doors.Door_Open_Pattern_Delay,
			['Door_Close_Pattern_Delay'] = config.Doors.Door_Close_Pattern_Delay,

			['Door_Delay_Sequence_Config'] = {
				['Opening'] = {
					['Enable'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Enable) == 'boolean') then config.Doors.Door_Delay_Sequence_Config.Opening.Enable elseif (typeof(config.Doors.Door_Open_Delay_Pattern) == 'table') then config.Doors.Door_Open_Delay_Pattern ~= nil else false, --// Enable or disable the door delay sequence
					['Sequence_Order'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) == 'table') then config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order elseif (typeof(config.Doors.Door_Open_Delay_Pattern) == 'table') then config.Doors.Door_Open_Delay_Pattern else {'Outer', 'Inner'}, --// [Inner, Outer] - The order in which each door opens
					['Delay'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Delay) == 'number') then config.Doors.Door_Delay_Sequence_Config.Opening.Delay elseif (typeof(config.Doors.Door_Open_Pattern_Delay) == 'number') then config.Doors.Door_Open_Speed-config.Doors.Door_Open_Pattern_Delay else 1, --// Delay in seconds the door delay lasts
				},
				['Closing'] = {
					['Enable'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Enable) == 'boolean') then config.Doors.Door_Delay_Sequence_Config.Closing.Enable elseif (typeof(config.Doors.Door_Close_Delay_Pattern) == 'table') then config.Doors.Door_Close_Delay_Pattern ~= nil else false, --// Enable or disable the door delay sequence
					['Sequence_Order'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) == 'table') then config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order elseif (typeof(config.Doors.Door_Close_Delay_Pattern) == 'table') then config.Doors.Door_Close_Delay_Pattern else {'Outer', 'Inner'}, --// [Inner, Outer] - The order in which each door opens
					['Delay'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Delay) == 'number') then config.Doors.Door_Delay_Sequence_Config.Closing.Delay elseif (typeof(config.Doors.Door_Close_Pattern_Delay) == 'number') then config.Doors.Door_Close_Speed-config.Doors.Door_Close_Pattern_Delay else 1, --// Delay in seconds the door delay lasts
				},
			},

			['Door_Close_Button_Delay'] = if (typeof(config.Doors.Door_Close_Button_Delay) == 'number') then config.Doors.Door_Close_Button_Delay else 0,

			['Sensor_LED_Data'] = {

				['Opening_Color'] = {
					['Delay'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Delay or .25,
					['Tween_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Tween_Time or .035, --Time in seconds for the sensor LED to change color
					['Flash_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Flash_Time or .15, --Time in seconds for flashing
					['Behavior'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Behavior or 'Solid', --Flash/Solid
					['Active'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Active.Color or Color3.fromRGB(77, 194, 56),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Active.Material or Enum.Material.Neon,
					},
					['Inactive'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color or Color3.fromRGB(50, 50, 50),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material or Enum.Material.SmoothPlastic,
					},
				},
				['Closing_Color'] = {
					['Delay'] = if (typeof(config.Doors.Sensor_LED_Data) == 'table' and typeof(config.Doors.Sensor_LED_Data.Closing_Color.Delay) == 'number') then config.Doors.Sensor_LED_Data.Closing_Color.Delay else .25,
					['Tween_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Tween_Time or .035, --Time in seconds for the sensor LED to change color
					['Flash_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Flash_Time or .15, --Time in seconds for flashing
					['Behavior'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Behavior or 'Flash', --Flash/Solid
					['Active'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Active.Color or Color3.fromRGB(194, 81, 52),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Active.Material or Enum.Material.Neon,
					},
					['Inactive'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Inactive.Color or Color3.fromRGB(50, 50, 50),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Inactive.Material or Enum.Material.SmoothPlastic,
					},
				},

			},
			['Realistic_Doors_Data'] = {
				['Enable_Open'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Enable_Open or false,
				['Enable_Close'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Enable_Close or false,
				['Open_Time'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Time or .5,
				['Close_Time'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Time or .6,
				['Open_Easing_Style'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Easing_Style or 'Linear',
				['Close_Easing_Style'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Easing_Style or 'Linear',
				['Open_Ratio'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Ratio and math.clamp(config.Doors.Realistic_Doors_Data.Open_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Close_Ratio'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Ratio and math.clamp(config.Doors.Realistic_Doors_Data.Close_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Open_Delay'] = {
					['Enable'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Delay and config.Doors.Realistic_Doors_Data.Open_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Delay and config.Doors.Realistic_Doors_Data.Open_Delay.Duration or 0,
				},
				['Close_Delay'] = {
					['Enable'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Delay and config.Doors.Realistic_Doors_Data.Close_Delay.Enable or config.Doors.Door_Close_Delay and config.Doors.Door_Close_Delay > 0 or false,
					['Duration'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Delay and config.Doors.Realistic_Doors_Data.Close_Delay.Duration or config.Doors.Door_Close_Delay and config.Doors.Door_Close_Delay or 0,
				},
			},
			['Realistic_Outer_Doors_Data'] = {
				['Enable_Open'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Enable_Open or false,
				['Enable_Close'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Enable_Close or false,
				['Open_Time'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Time or .5,
				['Close_Time'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Time or .6,
				['Open_Easing_Style'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Easing_Style or 'Linear',
				['Close_Easing_Style'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Easing_Style or 'Linear',
				['Open_Ratio'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Ratio and math.clamp(config.Doors.Realistic_Outer_Doors_Data.Open_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Close_Ratio'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Ratio and math.clamp(config.Doors.Realistic_Outer_Doors_Data.Close_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Open_Delay'] = {
					['Enable'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Delay and config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Delay and config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Duration or 0,
				},
				['Close_Delay'] = {
					['Enable'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Delay and config.Doors.Realistic_Outer_Doors_Data.Close_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Delay and config.Doors.Realistic_Outer_Doors_Data.Close_Delay.Duration or 0,
				},
			},

			['Door_Motor'] = if (typeof(config.Doors.Door_Motor) == 'boolean') then config.Doors.Door_Motor else true,

			['Open_Delay'] = if (typeof(config.Doors.Open_Delay) == 'number') then config.Doors.Open_Delay else 0,
			['Reopen_Delay'] = if (typeof(config.Doors.Reopen_Delay) == 'number') then config.Doors.Reopen_Delay else .5,
			['Close_Delay'] = if (typeof(config.Doors.Close_Delay) == 'number') then config.Doors.Close_Delay else 0,

			['Reopen_When_Nudge_Obstruction'] = config.Doors.Reopen_When_Nudge_Obstruction,
			['Hold_On_Nudge_Obstruction'] = config.Doors.Reopen_When_Nudge_Obstruction,

			['Stay_Open_When_Idle'] = config.Doors.Stay_Open_When_Idle,

			['Close_On_Button_Press'] = {
				['Enable'] = if (typeof(config.Doors.Close_On_Button_Press) == 'table' and typeof(config.Doors.Close_On_Button_Press.Enable) == 'boolean') then config.Doors.Close_On_Button_Press.Enable else false,
				['Delay'] = if (typeof(config.Doors.Close_On_Button_Press) == 'table' and typeof(config.Doors.Close_On_Button_Press.Delay) == 'number') then config.Doors.Close_On_Button_Press.Delay else 0,
			},

			['Disable_Door_Close'] = if (typeof(config.Doors.Disable_Door_Close) == 'boolean') then config.Doors.Disable_Door_Close else false,

			['Manual_Door_Controls'] = config.Doors.Manual_Door_Controls,

			['Custom_Door_Operator_Config'] = {

				['Inner'] = {
					['Opening'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Offset
							else 0,
					},
					['Closing'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Offset
							else 0,
					},
				},
				['Outer'] = {
					['Opening'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Offset
							else 0,
					},
					['Closing'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Offset
							else 0,
					},
				},

			},

			['Door_Open_Sound_Delay'] = if (typeof(config.Doors.Door_Open_Sound_Delay) == 'number') then config.Doors.Door_Open_Sound_Delay elseif (typeof(config.Doors.Open_Delay) == 'number') then config.Doors.Open_Delay else 0,
			['Door_Close_Sound_Delay'] = if (typeof(config.Doors.Door_Close_Sound_Delay) == 'number') then config.Doors.Door_Close_Sound_Delay elseif (typeof(config.Doors.Close_Delay) == 'number') then config.Doors.Close_Delay else 0,

			['New_Attachment_Doors_Config'] = {
				['Enable'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Enable) == 'boolean') then config.Doors.New_Attachment_Doors_Config.Enable else false, -- When enabled, the outer doors will be "attached" to the inner doors instead of running independently
				['Attachment_Threshold'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Attachment_Threshold) == 'number') then config.Doors.New_Attachment_Doors_Config.Attachment_Threshold else .05, -- Offset in studs the outer doors are positioned when moving with the inner doors
				['Closing_Min_Threshold'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold) == 'number') then config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold else 0, -- Minimum distance in studs the doors can be from the closing position before the elevator is able to move
			},

		},
		['Movement'] = {
			['Movement_Type'] = config.Movement.Movement_Type or 1, --[1]: CFrame  [2]: AlignPosition

			['Weld_On_Move'] = config.Movement.Weld_On_Move,
			['Disable_Jumping'] = config.Movement.Disable_Jumping or false,
			--['Use_New_Welding'] = config.Movement.Weld_On_Move and ((config.Movement.Weld_On_Move ~= nil and config.Movement.Weld_On_Move) or (config.Movement.Weld_On_Move == nil and false)) or false,
			['Use_New_Welding'] = config.Movement.Use_New_Welding or false,
			--['Use_New_Welding'] = false,
			['Enable_New_Player_Sticking'] = if (typeof(config.Movement.Enable_New_Player_Sticking) == 'boolean') then config.Movement.Enable_New_Player_Sticking else false,

			['Start_Delay'] = config.Movement.Start_Delay,
			['Down_Start_Delay'] = if (typeof(config.Movement.Down_Start_Delay) == 'number') then config.Movement.Down_Start_Delay else config.Movement.Start_Delay,
			
			['Motor_Start_Delay'] = {
				['Up'] = if (typeof(config.Movement.Motor_Start_Delay) == 'table' and typeof(config.Movement.Motor_Start_Delay.Up) == 'number') then config.Movement.Motor_Start_Delay.Up else 0,
				['Down'] = if (typeof(config.Movement.Motor_Start_Delay) == 'table' and typeof(config.Movement.Motor_Start_Delay.Down) == 'number') then config.Movement.Motor_Start_Delay.Down else 0,
			},

			['Use_Dynamic_Acceleration'] = config.Movement.Use_Dynamic_Acceleration,
			['Dynamic_Acceleration_Time'] = if (typeof(config.Movement.Dynamic_Acceleration_Time) == 'number') then config.Movement.Dynamic_Acceleration_Time else .75,

			['Acceleration'] = config.Movement.Acceleration,
			['Down_Acceleration'] = config.Movement.Down_Acceleration or config.Movement.Acceleration,

			['Travel_Speed'] = config.Movement.Travel_Speed,
			['Level_Speed'] = config.Movement.Level_Speed,
			['Floor_Pass_Chime_On_Stop'] = if (typeof(config.Movement.Floor_Pass_Chime_On_Stop) == 'boolean') then config.Movement.Floor_Pass_Chime_On_Stop else false,

			['Braking_Data'] = {
				['Mode'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Mode) == 'string') then if (config.Movement.Braking_Data.Mode == 'Auto') then 'Default' else config.Movement.Braking_Data.Mode elseif (typeof(config.Movement.Braking_Mode) == 'string') then if (config.Movement.Braking_Mode == 'Auto') then 'Default' else config.Movement.Braking_Mode else 'Linear',
					['Increment'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Increment) == 'number') then config.Movement.Braking_Data.Increment elseif (typeof(config.Movement.Braking_Amount) == 'number') then config.Movement.Braking_Amount else 0,
					['Linear_Mode_Offset_Up'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset_Up) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset_Up elseif (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset else 0,
					['Linear_Mode_Offset_Down'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset_Down) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset_Down elseif (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset else 0,

					['Advanced_Leveling'] = {
						['Stage_1_Min_Speed'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Advanced_Leveling and config.Movement.Braking_Data.Advanced_Leveling.Stage_1_Min_Speed or 1+config.Movement.Level_Speed*2.0,
						['Stage_2_Decel_Offset'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Advanced_Leveling and config.Movement.Braking_Data.Advanced_Leveling.Stage_2_Decel_Offset or 1.6,
					},
					['Smart_Linear_Transition_Dist'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Smart_Linear_Transition_Dist or 1.75,

					['Custom_Leveling_Stages'] = config.Movement.Braking_Data and typeof(config.Movement.Braking_Data.Custom_Leveling_Stages) == 'table' and config.Movement.Braking_Data.Custom_Leveling_Stages or {},

			},

			['Jolt_Start_Data'] =
				{
					['Enable'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Enable,
					['Ratio'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Ratio or 1,
					['Depth'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Depth or -1,
					['Speed'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Speed or .4,
					['Start_Delay'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Start_Delay or 0
				},

			['Bounce_Stop_Config'] = {
				['Enable'] = if (typeof(config.Movement.Bounce_Stop_Config) == 'table' and typeof(config.Movement.Bounce_Stop_Config.Enable) == 'boolean') then config.Movement.Bounce_Stop_Config.Enable elseif (typeof(config.Movement.Bounce_Stop) == 'string') then config.Movement.Bounce_Stop == 'Enable' and true or false else false,
				['Amount'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Amount or .5,
				['Times'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Times or 1,
				['Stop_Sound'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Stop_Sound or {['Enable']=false,['Sound_Id']=0,['Volume']=0,['Pitch']=0},
			},
			['Motor_Stop_On_Open'] = config.Movement.Motor_Stop_On_Open or false,

			['Enable_Smooth_Stop'] = if (typeof(config.Movement.Enable_Smooth_Stop) == 'boolean') then config.Movement.Enable_Smooth_Stop else false,
			['Smooth_Stop_Min_Speed'] = typeof(config.Movement.Smooth_Stop_Min_Speed) ~= 'number' and .0025 or config.Movement.Smooth_Stop_Min_Speed,
			-- ! SMOOTH STOP OVERHAUL - NOW AS A THRESHOLD VALUE ! --
			['Smooth_Stop_Threshold'] = typeof(config.Movement.Smooth_Stop_Threshold) == 'number' and config.Movement.Smooth_Stop_Threshold or .15, -- Distance in studs from the floor that the elevator comes to a gradual stop

			['Smooth_Stop_V2'] = {
				['Enable'] = if (typeof(config.Movement.Smooth_Stop_V2) == 'table' and typeof(config.Movement.Smooth_Stop_V2.Enable) == 'boolean') then config.Movement.Smooth_Stop_V2.Enable else false,
				['Threshold'] = if (typeof(config.Movement.Smooth_Stop_V2) == 'table' and typeof(config.Movement.Smooth_Stop_V2.Threshold) == 'number') then config.Movement.Smooth_Stop_V2.Threshold else .4,
			},

			['Overdrive_Chance_Max'] = config.Movement.Overdrive_Chance_Max or 100000000,
			['Pre_Start_Data'] = config.Movement.Pre_Start_Data or {
				['Enabled'] = false,
				['Floor_Change_Delay'] = .3,
				['Chime_Delay'] = .3,
			},
			['Motor_Sound'] = if (config.Movement.Motor_Sound == nil) then true else config.Movement.Motor_Sound,
			['Depart_Pre_Start'] = {

				['Enable'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Enable or false,
				['Delay'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Delay or .1,
				['Ignore_Start_Delay'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Ignore_Start_Delay or true,
				['Cancel_On_Door_Reopen'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen ~= nil and config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen or (not config.Movement.Depart_Pre_Start) and true or config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen,

			}, --If you enter a call while the doors are closing, the elevator ignores the start delay (like the SchindIer 5500).
			['Relevel_Tolerance'] = config.Movement.Relevel_Tolerance or .1,
			['Inspection_Start_Delay'] = {
				['Up'] = config.Movement.Inspection_Start_Delay and typeof(config.Movement.Inspection_Start_Delay) == 'table' and config.Movement.Inspection_Start_Delay.Up or config.Movement.Inspection_Start_Delay or .5,
				['Down'] = config.Movement.Inspection_Start_Delay and typeof(config.Movement.Inspection_Start_Delay) == 'table' and config.Movement.Inspection_Start_Delay.Down or config.Movement.Inspection_Start_Delay or .5,
			},

			['Inspection_Config'] = {

				['Max_Speed'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Max_Speed or config.Movement.Travel_Speed/2, --The maximum speed the elevator can travel in inspection mode
				['Accceleration_Rate'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Accceleration_Rate or config.Movement.Acceleration, --The rate of acceleration in inspection
				['Deceleration_Rate'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Deceleration_Rate or config.Movement.Acceleration*2, --The rate of deceleration in inspection

			},
			['Level_Offset_Ratio'] = config.Movement.Level_Offset_Ratio or .2,
			['Floor_Pass_Chime_On_Stop_Config'] = {
				['Enable'] = 'UNSET',
				['Delay'] = 'UNSET',
				['Play_On_Arrival_Floor'] = 'UNSET',
			},
			['Parking_Config'] = config.Movement.Parking_Config or {

				['Enable'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Enable or false,
				['Idle_Time'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Idle_Time or 60,
				['Park_Floor'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Park_Floor or 1,

			},
			['Releveling_Speed'] = typeof(config.Movement.Releveling_Speed) == 'number' and config.Movement.Releveling_Speed or config.Movement.Level_Speed,

			['Stop_Delay'] = if (typeof(config.Movement.Stop_Delay) == 'number') then config.Movement.Stop_Delay else 0,

			['Open_Doors_On_Stop'] = config.Movement.Open_Doors_On_Stop,
			['Open_Doors_On_Call'] = config.Movement.Open_Doors_On_Call,
			
			['Accelerated_Floor_Config'] = {
				['Enabled'] = if (typeof(config.Movement.Accelerated_Floor_Config) == 'table' and typeof(config.Movement.Accelerated_Floor_Config.Enabled) == 'boolean') then config.Movement.Accelerated_Floor_Config.Enabled else false,
				['Offset'] = if (typeof(config.Movement.Accelerated_Floor_Config) == 'table' and typeof(config.Movement.Accelerated_Floor_Config.Offset) == 'number') then config.Movement.Accelerated_Floor_Config.Offset else 1,
				['Delay_On_Elevator_Start'] = if (typeof(config.Movement.Accelerated_Floor_Config) == 'table' and typeof(config.Movement.Accelerated_Floor_Config.Delay_On_Elevator_Start) == 'number') then config.Movement.Accelerated_Floor_Config.Delay_On_Elevator_Start else .4,
			},

		},
		['Sensors'] = {

			['Up_Level_Offset'] = config.Sensors.Up_Level_Offset or config.Sensors.Level_Offset,
			['Down_Level_Offset'] = config.Sensors.Down_Level_Offset or config.Sensors.Level_Offset,

			['Stop_Offset'] = config.Sensors.Stop_Offset,
			['Pre_Door_Data'] = {
				['Enable'] = config.Sensors.Pre_Door,
				['Offset'] = config.Sensors.Pre_Door_Offset
			},

			['Floor_Position_Offset'] = config.Sensors.Floor_Position_Offset or 0,
			['Floor_Value_Offset'] = config.Sensors.Floor_Value_Offset or 0,

		},
		['Freight'] = {
			['Same_Floor_Call'] = {
				['With_Doors_Open'] = {
					['Enable'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Enable or false,
					['Bell'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Call_Elevator or false
				},
				['With_Doors_Closed'] = {
					['Enable'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Enable or false,
					['Bell'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Call_Elevator or false
				}
			},
			['Other_Floor_Call'] = {
				['With_Doors_Open'] = {
					['Enable'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Enable or false,
					['Bell'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Call_Elevator or false
				},
				['With_Doors_Closed'] = {
					['Enable'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Enable or false,
					['Bell'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Call_Elevator or false
				}
			}
		},
		['Color_Database'] = {
			['Lanterns'] = {
				['Active_On_Door_Open'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Call_Only else false,
					},
				},
				['Active_After_Door_Open'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_After_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_After_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_After_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_After_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Call_Only else false,
					},
				},
				['Active_On_Arrival'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Call_Only else false,
					},
				},
				['Active_On_Call_Enter'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Call_Only else false,
					},
				},
				['Active_On_Button_Press'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Call_Enter) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Call_Enter else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Call_Enter) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Call_Enter else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Call_Only else false,
					},
				},
				['Active_On_Exterior_Call'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Exterior_Call) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Exterior_Call else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only else 0]],
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Exterior_Call) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Exterior_Call else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only else 0]],
					},
				},
				
				['Active_On_Door_Close'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Close) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Close else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Close.Interior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only else 0]],
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Close) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Close else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Close and config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Close.Exterior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only else 0]],
					},
				},

				['Door_Distance_Reset_Ratio'] = config.Color_Database.Lanterns.Door_Distance_Reset_Ratio or 0,

				['Exterior'] = {

					['Repeat_Data'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Repeat_Data or config.Color_Database.Lanterns.Repeat_Data or {
						['Enable'] = false,
						['Times'] = 1,
						['Delay'] = .33,
						['Play_Chime_On_Light'] = false,
						['Allowed_Directions'] = {'D'} --List of elevator directions when the repeat feature is supposed to run. Available directions: U, D, N
					},

					['Up'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Up or config.Color_Database.Lanterns.Up,
					['Down'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Down or config.Color_Database.Lanterns.Down,

					['Reset_After_Door_Close'] = if (typeof(config.Color_Database.Lanterns.Exterior) == 'table' and typeof(config.Color_Database.Lanterns.Exterior.Reset_After_Door_Close) == 'boolean') then config.Color_Database.Lanterns.Exterior.Reset_After_Door_Close else true,
					['Transparent_When_Inactive'] = if (typeof(config.Color_Database.Lanterns.Exterior) == 'table' and typeof(config.Color_Database.Lanterns.Exterior.Transparent_When_Inactive) == 'boolean') then config.Color_Database.Lanterns.Exterior.Transparent_When_Inactive else false,
					['Lantern_Reset_Delay'] = if (typeof(config.Color_Database.Lanterns.Exterior) == 'table' and typeof(config.Color_Database.Lanterns.Exterior.Lantern_Reset_Delay) == 'number') then config.Color_Database.Lanterns.Exterior.Lantern_Reset_Delay else 0,

				},
				['Interior'] = {

					['Repeat_Data'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Repeat_Data or config.Color_Database.Lanterns.Repeat_Data or {
						['Enable'] = false,
						['Times'] = 1,
						['Delay'] = .33,
						['Play_Chime_On_Light'] = false,
						['Allowed_Directions'] = {'D'} --List of elevator directions when the repeat feature is supposed to run. Available directions: U, D, N
					},

					['Up'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Up or config.Color_Database.Lanterns.Up,
					['Down'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Down or config.Color_Database.Lanterns.Down,

					['Reset_After_Door_Close'] = if (typeof(config.Color_Database.Lanterns.Interior) == 'table' and typeof(config.Color_Database.Lanterns.Interior.Reset_After_Door_Close) == 'boolean') then config.Color_Database.Lanterns.Interior.Reset_After_Door_Close else true,
					['Transparent_When_Inactive'] = if (typeof(config.Color_Database.Lanterns.Interior) == 'table' and typeof(config.Color_Database.Lanterns.Interior.Transparent_When_Inactive) == 'boolean') then config.Color_Database.Lanterns.Interior.Transparent_When_Inactive else false,
					['Lantern_Reset_Delay'] = if (typeof(config.Color_Database.Lanterns.Interior) == 'table' and typeof(config.Color_Database.Lanterns.Interior.Lantern_Reset_Delay) == 'number') then config.Color_Database.Lanterns.Interior.Lantern_Reset_Delay else 0,
				},
			},
			['Car'] = {

				['Lit_Delay'] = config.Color_Database.Car.Lit_Delay or .1,
				['Floor_Button'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Car.Floor_Button.Lit_State.Color, ['Material'] = config.Color_Database.Car.Floor_Button.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Car.Floor_Button.Neautral_State.Color, ['Material'] = config.Color_Database.Car.Floor_Button.Neautral_State.Material
					},
				},
				['Alarm_Button'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Car.Alarm_Button.Lit_State.Color, ['Material'] = config.Color_Database.Car.Alarm_Button.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Car.Alarm_Button.Neautral_State.Color, ['Material'] = config.Color_Database.Car.Alarm_Button.Neautral_State.Material
					},
				},

				['Doors'] = {

					['Open'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},
					['Close'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},
					['Hold'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},

				},

				['Custom_Color_Data'] = config.Color_Database.Car.Custom_Color_Data or {},

			},
			['Floor'] = {
				['Active_Duration'] = config.Color_Database.Floor.Active_Duration or config.Color_Database.Floor.Lit_Delay or .1,
				['Up'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Floor.Up.Lit_State.Color, ['Material'] = config.Color_Database.Floor.Up.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Floor.Up.Neautral_State.Color, ['Material'] = config.Color_Database.Floor.Up.Neautral_State.Material
					},
				},
				['Down'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Floor.Down.Lit_State.Color, ['Material'] = config.Color_Database.Floor.Down.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Floor.Down.Neautral_State.Color, ['Material'] = config.Color_Database.Floor.Down.Neautral_State.Material
					},
				},
			},

		},
		['Extra_Config'] = config.Extra_Config or
			{
				['Debug'] = false,
				['Enable_Parking'] = false,
				['Parking'] = {
					['Park_Floor'] = 1,
					['Park_Time'] = 1,
				},
			},
		['Locking'] = {
			['Locked_Floors'] = config.Locking and config.Locking.Locked_Floors or {},
			['Locked_Hall_Floors'] = config.Locking and config.Locking.Locked_Hall_Floors or {},
			['Disable_Door_Open_On_Locked_Floor'] = {
				['Car'] = {
					['When_Doors_Closing'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Car and config.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing or false,
					['When_Doors_Closed'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Car and config.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed or false
				},
				['Hall'] = {
					['When_Doors_Closing'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing or false,
					['When_Doors_Closed'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed or false
				}
			},
			['Lock_Opposite_Travel_Direction_Floors'] = config.Locking and config.Locking.Lock_Opposite_Travel_Direction_Floors or false
		},
		['Custom_Floor_Label'] = config.Custom_Floor_Label or {},
		['Camera_Force_Data'] = config.Cam_Force_Data or
			{
				['Enable'] = true, --Whether the effect is enabled or not.
				['Acceleration_Amount'] = 1, --How many times this value is multiplied by the default value.
				['Show_When_Leaving'] = true, --Whether the effect shows when the elevator accelerates (leaves a floor) or not.
				['Show_When_Leveling'] = true, --Whether the effect shows when the elevator is leveling (slowing down to a stop).
			},
		['ClientRefresh_Movement_Config'] = {
			['Enable'] = config.ClientRefresh_Movement_Config and config.ClientRefresh_Movement_Config.Enable,
			['Priority'] = 1, --Unused for now.
		},

		['Call_Limiting'] = {
			['Enable'] = if (typeof(config.Call_Limiting) == 'table' and typeof(config.Call_Limiting.Enable) == 'boolean') then config.Call_Limiting.Enable else false,
			['Max_Calls'] = if (typeof(config.Call_Limiting) == 'table' and typeof(config.Call_Limiting.Max_Calls) == 'number') then config.Call_Limiting.Max_Calls else math.huge,
		},

		['Sound_Database'] = {
			['Chime_On_Door_Open'] = config.Sound_Database.Chime_On_Door_Open,
			['Chime_After_Door_Open'] = config.Sound_Database.Chime_After_Door_Open,
			['Chime_On_Arrival'] = config.Sound_Database.Chime_On_Arrival,
			['Chime_On_Button_Press'] = config.Sound_Database.Chime_On_Button_Press,
			['Chime_On_Call_Enter'] = config.Sound_Database.Chime_On_Call_Enter,
			['Chime_On_Exterior_Call'] = config.Sound_Database.Chime_On_Exterior_Call,

			['Chime_Events'] = {

				['On_Open'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Open.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Open.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Open.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Open.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open.Exterior.Call_Only else
							false,
					},
				},
				['After_Open'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_After_Door_Open.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_After_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_After_Door_Open.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_After_Door_Open.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_After_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_After_Door_Open.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open.Exterior.Call_Only else
							false,
					},
				},
				['On_Arrival'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Arrival.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Arrival) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Arrival.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Arrival.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Arrival) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Arrival.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival.Exterior.Call_Only else
							false,
					},
				},
				['Floor_Button_Pressed'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only else
							false,
					},
				},
				['New_Call_Input'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only else
							false,
					},
				},
				['Exterior_Call_Only'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Exterior_Call.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Exterior_Call.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Exterior_Call.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Exterior_Call.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call.Exterior.Call_Only else
							false,
					},
				},
				
				['On_Door_Close'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Close.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Close) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Close.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Close.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Close) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Close.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Close) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Close.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Close.Exterior.Call_Only else
							false,
					},
				},

			},

			['Chime_Database'] = {
				['Interior_Up_Chime'] = {['Sound_Id'] = config.Sound_Database.Chime_Database.Up_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Chime_Database.Up_Chime.Volume, ['Pitch'] = config.Sound_Database.Chime_Database.Up_Chime.Pitch},
				['Interior_Down_Chime'] = {['Sound_Id'] = config.Sound_Database.Chime_Database.Down_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Chime_Database.Down_Chime.Volume, ['Pitch'] = config.Sound_Database.Chime_Database.Down_Chime.Pitch},
			},
			['Arrival_Chime_Database'] = {
				['Exterior_Up_Chime'] = {['Sound_Id'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Volume, ['Pitch'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Pitch},
				['Exterior_Down_Chime'] = {['Sound_Id'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Volume, ['Pitch'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Pitch},
			},
			['Motors'] =
				{
					['Up'] = {
						['Motor_Start_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Pitch or 1},
						['Motor_Run_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Pitch or 1},
						['Motor_Stop_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Pitch or 1},
					},
					['Down'] = {
						['Motor_Start_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Pitch or 1},
						['Motor_Run_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Pitch or 1},
						['Motor_Stop_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Pitch or 1},
					},
				},
			['Doors'] = {
				['Open_Sound'] = {['Sound_Id'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Sound_Id or 0, ['Volume'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Volume or 0, ['Pitch'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Pitch or 0},
				['Close_Sound'] = {['Sound_Id'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Sound_Id or 0, ['Volume'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Volume or 0, ['Pitch'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Pitch or 0},
				['Floors'] = if (typeof(config.Sound_Database.Doors) == 'table' and typeof(config.Sound_Database.Doors.Floors) == 'table') then config.Sound_Database.Doors.Floors else nil,
			},
			['Others'] = {
				['Floor_Pass_Chime'] = {['Sound_Id'] = config.Sound_Database.Others.Floor_Pass_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Others.Floor_Pass_Chime.Volume, ['Pitch'] = config.Sound_Database.Others.Floor_Pass_Chime.Pitch, ['Append']=config.Sound_Database.Others.Floor_Pass_Chime.Append},
				['Enable_Floor_Pass_Chime'] = if (typeof(config.Sound_Database.Others.Enable_Floor_Pass_Chime) == 'boolean') then config.Sound_Database.Others.Enable_Floor_Pass_Chime else true,
				
				['Nudge_Buzzer'] = {['Sound_Id'] = config.Sound_Database.Others.Nudge_Buzzer.Sound_Id, ['Volume'] = config.Sound_Database.Others.Nudge_Buzzer.Volume, ['Pitch'] = config.Sound_Database.Others.Nudge_Buzzer.Pitch},
				['Alarm'] = {['Sound_Id'] = config.Sound_Database.Others.Alarm.Sound_Id, ['Volume'] = config.Sound_Database.Others.Alarm.Volume, ['Pitch'] = config.Sound_Database.Others.Alarm.Pitch, ['Pause_On_Release'] = config.Sound_Database.Others.Alarm.Pause_On_Release},
				['Alarm_Release'] = {['Sound_Id'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Pitch or 0},
				['Button_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Button_Beep.Sound_Id, ['Volume'] = config.Sound_Database.Others.Button_Beep.Volume, ['Pitch'] = config.Sound_Database.Others.Button_Beep.Pitch},
				['Call_Button_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Sound_Id or config.Sound_Database.Others.Button_Beep.Sound_Id, ['Volume'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Volume or config.Sound_Database.Others.Button_Beep.Volume, ['Pitch'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Pitch or config.Sound_Database.Others.Button_Beep.Pitch},

				['Button_Beep_Sound'] = {
					['Enable'] = config.Sound_Database.Others.Button_Beep_Sound and (config.Sound_Database.Others.Button_Beep_Sound.Enable ~= nil and config.Sound_Database.Others.Button_Beep_Sound.Enable or config.Sound_Database.Others.Button_Beep_Sound == nil and false or config.Sound_Database.Others.Button_Beep_Sound.Enable),
					['Delay'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Delay or 0,

					['Sound_Id'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Sound_Id or 0,
					['Volume'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Volume or 0,
					['Pitch'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Pitch or 0,
				},

				['Call_Recognition_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Pitch or 1, ['Delay'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Delay or .1},
				['Door_Obstruction_Signal'] = {['Sound_Id'] = typeof(config.Sound_Database.Others.Door_Obstruction_Signal) == 'table' and config.Sound_Database.Others.Door_Obstruction_Signal.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Door_Obstruction_Signal and config.Sound_Database.Others.Door_Obstruction_Signal.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Door_Obstruction_Signal and config.Sound_Database.Others.Door_Obstruction_Signal.Pitch or 1},
				['Door_Motor_Sound'] = {},
				['Traveling_Sound'] = {

					['Enable'] = config.Sound_Database.Others.Traveling_Sound and (config.Sound_Database.Others.Traveling_Sound.Enable ~= nil and config.Sound_Database.Others.Traveling_Sound.Enable or config.Sound_Database.Others.Traveling_Sound.Enable == nil and true) or config.Sound_Database.Others.Traveling_Sound == nil and true,
					['Sound_Id'] = config.Sound_Database.Others.Traveling_Sound and config.Sound_Database.Others.Traveling_Sound.Sound_Id or 10419439335,
					['Speed_Factor'] = if (typeof(config.Sound_Database.Others.Traveling_Sound) == 'table' and typeof(config.Sound_Database.Others.Traveling_Sound.Speed_Factor) == 'number') then config.Sound_Database.Others.Traveling_Sound.Speed_Factor else 1,
					['Factor_Type'] = if (typeof(config.Sound_Database.Others.Traveling_Sound) == 'table' and config.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio') then config.Sound_Database.Others.Traveling_Sound.Factor_Type else 'Absolute_Speed',
					['Constraints'] = {
						['Volume'] = {
							['Min'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Min)) and 0 or config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Min,
							['Max'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Max)) and .2 or config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Max,
						},
						['Pitch'] = {
							['Min'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Min)) and 1 or (not config.Sound_Database.Others.Traveling_Sound.Min_Pitch) and 1 or config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Min,
							['Max'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Max)) and 1 or (not config.Sound_Database.Others.Traveling_Sound.Max_Pitch) and 1 or config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Max,
						}
					},

				},
				['Safety_Brake_Sound'] = {
					['Sound_Id'] = if (typeof(config.Sound_Database.Others.Safety_Brake_Sound) == 'table' and typeof(config.Sound_Database.Others.Safety_Brake_Sound.Sound_Id) == 'number') then config.Sound_Database.Others.Safety_Brake_Sound.Sound_Id else 6389151811,
					['Volume'] = if (typeof(config.Sound_Database.Others.Safety_Brake_Sound) == 'table' and typeof(config.Sound_Database.Others.Safety_Brake_Sound.Volume) == 'number') then config.Sound_Database.Others.Safety_Brake_Sound.Volume else .5,
					['Pitch'] = if (typeof(config.Sound_Database.Others.Safety_Brake_Sound) == 'table' and typeof(config.Sound_Database.Others.Safety_Brake_Sound.Pitch) == 'number') then config.Sound_Database.Others.Safety_Brake_Sound.Pitch else 1
				},
				['Fire_Recall_Buzzer_Type'] = config.Sound_Database.Others.Fire_Recall_Buzzer_Type or 'Continuous', --[[
				Continuous - Buzzer plays continuously until the elevator recalls to the designated recall floor
				Repeat - Buzzer plays, then pauses, then plays again (like OTIS recall buzzers)
			]]--
				['Elevator_Stop_Beep'] = {
					['Sound_Id'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Sound_Id or 0,
					['Volume'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Volume or 0,
					['Pitch'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Pitch or 0,
					['Enable'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Enable
				},
			},

			['Voice_Config'] = config.Sound_Database.Voice_Config or require(coreScript.Voice_Module.STOCK_VoiceModule),
			['Floor_Pass_Chime_Delay'] = if (typeof(config.Sound_Database.Floor_Pass_Chime_Delay) == 'number') then config.Sound_Database.Floor_Pass_Chime_Delay else 0,

		}
	}
	return DefaultConfig
end]]></ProtectedString>
								<int64 name="SourceAssetId">13443177628</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="BillboardGui" referent="RBXDA4641DDDB444ABC8CB064771B26B33D">
							<Properties>
								<bool name="Active">true</bool>
								<Ref name="Adornee">null</Ref>
								<bool name="AlwaysOnTop">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<float name="Brightness">1</float>
								<bool name="ClipsDescendants">true</bool>
								<float name="DistanceLowerLimit">0</float>
								<float name="DistanceStep">0</float>
								<float name="DistanceUpperLimit">-1</float>
								<bool name="Enabled">false</bool>
								<Vector3 name="ExtentsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="ExtentsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="LightInfluence">0</float>
								<float name="MaxDistance">INF</float>
								<string name="Name">DOOR_KEY_UI</string>
								<Ref name="PlayerToHideFrom">null</Ref>
								<bool name="ResetOnSpawn">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>350</XO>
									<YS>0</YS>
									<YO>100</YO>
								</UDim2>
								<Vector2 name="SizeOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<int64 name="SourceAssetId">-1</int64>
								<Vector3 name="StudsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="StudsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<BinaryString name="Tags"></BinaryString>
								<token name="ZIndexBehavior">1</token>
							</Properties>
							<Item class="Frame" referent="RBX657C80430139401CA843C819965539E5">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.211764723</R>
										<G>0.211764723</G>
										<B>0.211764723</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">BG</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>-50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UICorner" referent="RBX60F8A26554BA4ABFAB1CDC5F4092D70C">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>10</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX8A1CF8ED395B4CFF9E027CBBA7012720">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Slider</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">1</int>
										<UDim2 name="Size">
											<XS>0.649999976</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>3</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
									<Item class="TextButton" referent="RBXC4C6CC7D072C41529A008D3B6266CB62">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">false</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">3</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Button</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>35</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Button</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">1</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXD005B023405B4014B97326C9730DB916">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">false</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">3</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Select</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0</XS>
												<XO>12</XO>
												<YS>1</YS>
												<YO>35</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Button</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">1</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UICorner" referent="RBX40AED80518C946E3AA83E351776DAE6B">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<UDim name="CornerRadius">
													<S>1</S>
													<O>0</O>
												</UDim>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="ImageLabel" referent="RBX2EE487EF8AB74614B1A537F4E0DB0099">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://13746787307</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Closed</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>100</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIAspectRatioConstraint" referent="RBX181CC1938FB54181B1E2591F6D6F28DF">
										<Properties>
											<float name="AspectRatio">1.29999995</float>
											<token name="AspectType">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="DominantAxis">1</token>
											<string name="Name">UIAspectRatioConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ImageLabel" referent="RBX6692FD61ED1E4E758665818DA0A959B6">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://13746787390</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Open</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>100</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIAspectRatioConstraint" referent="RBXCA47710218A04B65839860CC1EAC5ADB">
										<Properties>
											<float name="AspectRatio">1.29999995</float>
											<token name="AspectType">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="DominantAxis">1</token>
											<string name="Name">UIAspectRatioConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Frame" referent="RBX857EFD08F94B49E3953A428958C43D88">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.211764723</R>
											<G>0.211764723</G>
											<B>0.211764723</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Top</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>13</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>50</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UICorner" referent="RBX89C17EAA484C4A409C17E2FBBA62637D">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>10</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ImageButton" referent="RBX17F9DE61735245648696D76B1095301E">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<Content name="HoverImage"><null></null></Content>
											<Content name="Image"><url>rbxassetid://13745395147</url></Content>
											<Color3 name="ImageColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<Vector2 name="ImageRectOffset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<Vector2 name="ImageRectSize">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="ImageTransparency">0</float>
											<int name="LayoutOrder">0</int>
											<bool name="Modal">false</bool>
											<string name="Name">Button</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<Content name="PressedImage"><null></null></Content>
											<token name="ResampleMode">0</token>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<token name="ScaleType">3</token>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>-15</XO>
												<YS>1</YS>
												<YO>-15</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<Rect2D name="SliceCenter">
												<min>
													<X>0</X>
													<Y>0</Y>
												</min>
												<max>
													<X>0</X>
													<Y>0</Y>
												</max>
											</Rect2D>
											<float name="SliceScale">1</float>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<UDim2 name="TileSize">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="LocalScript" referent="RBX71A6A35355C04FB3BB9255B47D51CD45">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Disabled">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CLIENT</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{4A8B03BE-2B7E-434F-875E-73BA4BCF475A}</string>
									<ProtectedString name="Source"><![CDATA[local this = script.Parent
local remote = this:WaitForChild('RemoteEvent')
local ratio = this:WaitForChild('RATIO')
local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local draggableUI = require(script:WaitForChild('DraggableUI'))
local uis = game:GetService('UserInputService')
local mouse = player:GetMouse()

local doorSet = this:WaitForChild('DOOR_SET').Value or this:WaitForChild('DOOR_SET'):GetPropertyChangedSignal('Value'):Wait()

local slider,select = this.BG.Slider,this.BG.Slider.Select

local delta = Vector2.zero
local dragInput,startPos,dragStart
select.InputBegan:Connect(function(input)
	if (input.UserInputType == Enum.UserInputType.MouseButton1) then
		player:GetMouse().Icon = 'rbxasset://SystemCursors/PointingHand'
		dragInput = input
		dragStart = uis:GetMouseLocation()
		startPos = select.Position.X.Offset
		input.Changed:Connect(function()
			if (input.UserInputState == Enum.UserInputState.End) then
				dragInput = nil
				player:GetMouse().Icon = [[ ]]
			end
		end)
	end
end)
uis.InputChanged:Connect(function(input: InputObject)
	if (dragInput) then
		if (uis.MouseBehavior ~= Enum.MouseBehavior.Default) then
			delta += uis:GetMouseDelta()*3.5
		else
			delta = uis:GetMouseLocation()-dragStart
		end
		select.Position = UDim2.new(0, math.clamp(startPos+delta.X, 0, slider.AbsoluteSize.X), .5, 0)
	end
end)

this.BG.Top.Button.MouseButton1Down:Connect(function()
	local elevator = (doorSet:FindFirstAncestor('Car') or doorSet:FindFirstAncestor('Floors')).Parent
	if (not elevator) then return end
	elevator.Cortex_Remote:FireServer('exit',doorSet)
end)

local active = false
uis.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
	if (gameProcessed) then return end
	if (input.KeyCode == Enum.KeyCode.LeftControl) then
		local zoom = (camera.CFrame.Position-camera.Focus.Position).Magnitude
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = zoom,zoom
		active = true
	elseif (input.KeyCode == Enum.KeyCode.Q) then
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = game.StarterPlayer.CameraMinZoomDistance,game.StarterPlayer.CameraMaxZoomDistance
		active = false
		local elevator = (doorSet:FindFirstAncestor('Car') or doorSet:FindFirstAncestor('Floors')).Parent
		if (not elevator) then return end
		elevator.Cortex_Remote:FireServer('exit',doorSet)
	end
end)
local lastTick = tick()
uis.InputChanged:Connect(function(input: InputObject)
	if (input.UserInputType == Enum.UserInputType.MouseWheel and active) then
		if (input.Position.Z == 1 or input.Position.Z == -1) then
			local t = math.clamp((tick()-lastTick),0,.2)
			lastTick = tick()
			game:GetService('TweenService'):Create(select,TweenInfo.new(t,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Position=UDim2.fromOffset(math.clamp(select.Position.X.Offset+input.Position.Z*7.5,0,slider.AbsoluteSize.X),0)}):Play()
		end
	end
end)
uis.InputEnded:Connect(function(input: InputObject)
	if (input.KeyCode == Enum.KeyCode.LeftControl) then
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = game.StarterPlayer.CameraMinZoomDistance,game.StarterPlayer.CameraMaxZoomDistance
		active = false
	end
end)

select:GetPropertyChangedSignal('Position'):Connect(function()
	remote:FireServer('UPDATE_RATIO_VALUE',select.Position.X.Offset/slider.AbsoluteSize.X,0,1)
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXE8F5D5CDE3924EC28BEE977F0B3B242F">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">DraggableUI</string>
										<string name="ScriptGuid">{E722F60E-21D5-472F-BCCE-646FAAE519F6}</string>
										<ProtectedString name="Source"><![CDATA[local Signal = require(script.Signal)

local TweenService = game:GetService("TweenService")
local PlayerObject = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")

local Mouse = PlayerObject:GetMouse()
local Camera = workspace.CurrentCamera
local PlayerGui = PlayerObject:WaitForChild("PlayerGui")

local listOfDraggable = {}

local function ValidateParametersValue(UI: GuiObject, byScale: boolean?)
	if not UI then
		error("First argument must not be empty!")
	end

	if not (typeof(UI) == "Instance") then
		error("First argument must be a type of instance!")
	end

	if not (typeof(byScale) == "boolean") then
		error("Second argument must be a type of boolean!")
	end
end

local function IsMouseOrTouch(input: InputObject, isMouseMovement: boolean?): boolean
	return input.UserInputType
		== (if isMouseMovement then Enum.UserInputType.MouseMovement else Enum.UserInputType.MouseButton1)
		or input.UserInputType == Enum.UserInputType.Touch
end

local function GetDominantObject(list: { Instance }): GuiObject
	local dominant = math.huge
	local guiObject: GuiObject

	for _, value in ipairs(listOfDraggable) do
		local index = table.find(list, value._UI)

		if index and index < dominant then
			dominant = index
			guiObject = value._UI
		end
	end

	return guiObject
end

local DraggableUI = {}
DraggableUI.__index = DraggableUI
DraggableUI.__tostring = function()
	return "Draggable"
end

function DraggableUI.new(UI: GuiObject, byScale: true?)
	byScale = byScale or true
	ValidateParametersValue(UI, byScale)

	local self = setmetatable({
		_Released = Signal.new(),
		_Started = Signal.new(),
		_Moved = Signal.new(),

		_Connections = {},
		_Overlapping = {
			Disabled = false,
		},
		_LimitBoundingBox = {
			Enabled = false,
			Type = 0,
		},

		_TweenInfo = false,
		_UI = UI,
	}, DraggableUI)

	self.Released = self._Released.Event
	self.Started = self._Started.Event
	self.Moved = self._Moved.Event

	local success, result = pcall(self._Initialize, self, UI, byScale)

	if not success then
		error(("Something went wrong: %s"):format(result))
	end

	table.insert(listOfDraggable, self)
	return self
end

function DraggableUI:_Initialize(UI: GuiObject, byScale: boolean)
	local startPosition = UI.AbsolutePosition
	local dragStartPosition = UserInputService:GetMouseLocation()

	local mouseOnUI = false
	local button1Down = false

	table.insert(
		self._Connections,
		UI.MouseEnter:Connect(function()
			mouseOnUI = true
		end)
	)

	table.insert(
		self._Connections,
		UI.MouseLeave:Connect(function()
			mouseOnUI = false
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputBegan:Connect(function(input)
			if IsMouseOrTouch(input) and mouseOnUI then
				local list = PlayerGui:GetGuiObjectsAtPosition(Mouse.X, Mouse.Y)

				if #list >= 2 then
					if not (GetDominantObject(list) == UI) then
						return
					end
				end

				for _, value in pairs(self._Overlapping) do
					if value then
						return
					end
				end

				startPosition = UI.AbsolutePosition + (UI.AbsoluteSize * UI.AnchorPoint) - UI.Parent.AbsolutePosition
				dragStartPosition = UserInputService:GetMouseLocation()
				button1Down = true

				self._Started:Fire()
			end
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputEnded:Connect(function(input)
			if IsMouseOrTouch(input) and button1Down then
				button1Down = false
				self._Released:Fire(UserInputService:GetMouseLocation())
			end
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputChanged:Connect(function(input)
			if IsMouseOrTouch(input, true) and button1Down then
				local mousePosition = UserInputService:GetMouseLocation()
				local delta = mousePosition - dragStartPosition
				local parentSize = UI.Parent.AbsoluteSize
				local position = startPosition + delta

				position = self:_LimitPosition(UI, position, parentSize)

				if not byScale then
					position = UDim2.fromOffset(position.X, position.Y)
				else
					position /= parentSize
					position = UDim2.fromScale(position.X, position.Y)
				end

				if self._TweenInfo then
					TweenService:Create(UI, self._TweenInfo, { Position = position }):Play()
				else
					UI.Position = position
				end

				self._Moved:Fire(mousePosition)
			end
		end)
	)
end

function DraggableUI:_LimitPosition(UI: GuiObject, position: Vector2, parentSize: Vector2)
	if self._LimitBoundingBox.Enabled then
		local offset = (UI.AbsoluteSize * UI.AnchorPoint)
		local uiSize = UI.AbsoluteSize

		if self._LimitBoundingBox.Type == 0 then
			local screenSize = Camera.ViewportSize
			local max = (screenSize - uiSize) + offset

			return Vector2.new(math.clamp(position.X, offset.X, max.X), math.clamp(position.Y, offset.Y, max.Y))
		else
			local max = (parentSize - uiSize) + offset

			return Vector2.new(math.clamp(position.X, offset.X, max.X), math.clamp(position.Y, offset.Y, max.Y))
		end
	end

	return position
end

function DraggableUI:_Ignore(UI: GuiObject)
	table.insert(
		self._Connections,
		UI.MouseEnter:Connect(function()
			self._Overlapping[UI] = true
		end)
	)

	table.insert(
		self._Connections,
		UI.MouseLeave:Connect(function()
			self._Overlapping[UI] = nil
		end)
	)
end

function DraggableUI:LimitScreenBoundingBox(byParent: false?, value: boolean?): boolean
	local limitBoundingBox = self._LimitBoundingBox
	byParent = byParent or false

	limitBoundingBox.Type = if byParent then 1 else 0
	limitBoundingBox.Enabled = if typeof(value) == "boolean" then value else not limitBoundingBox.Enabled

	return limitBoundingBox.Enabled
end

function DraggableUI:Toggle(value: boolean?): boolean
	local overlapping = self._Overlapping
	overlapping.Disabled = if typeof(value) == "boolean" then value else not overlapping.Disabled

	return overlapping.Disabled
end

function DraggableUI:SetTweenInfo(tweenInfo: TweenInfo)
	if not (typeof(tweenInfo) == "TweenInfo") then
		error("Argument must be a type of TweenInfo!")
	end

	self._TweenInfo = tweenInfo
end

function DraggableUI:Ignore(list: { Instance }, instanceCheck: false?)
	instanceCheck = instanceCheck or false

	if not (typeof(list) == "table") then
		error("First argument must be a type of table!")
	end

	if not (typeof(instanceCheck) == "boolean") then
		error("Second argument must be a type of boolean!")
	end

	local success = pcall(function()
		if instanceCheck then
			for _, object in ipairs(list) do
				pcall(function()
					self:_Ignore(object)
				end)
			end
		else
			for _, object in ipairs(list) do
				self:_Ignore(object)
			end
		end
	end)

	if not success then
		error("It seems that the array contained a none type of GuiObject")
	end
end

function DraggableUI:IgnoreChildren()
	self:Ignore(self._UI:GetChildren(), true)
end

function DraggableUI:IgnoreDescendants()
	self:Ignore(self._UI:GetDescendants(), true)
end

function DraggableUI:Destroy()
	for _, connection: RBXScriptSignal in ipairs(self._Connections) do
		if typeof(connection) == "RBXScriptSignal" then
			connection:Disconnect()
		end
	end

	for key, _ in pairs(self._IgnoreList) do
		self._IgnoreList[key] = nil
	end

	self._Released:Destroy()
	self._Started:Destroy()
	self._Moved:Destroy()

	table.remove(listOfDraggable, table.find(listOfDraggable, self))
	table.clear(self)
end

setmetatable(DraggableUI, {
	__index = function(_, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,

	__newindex = function(_, key)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

export type Draggable = {
	LimitScreenBoundingBox: (self: { Draggable }, byParent: false?, value: boolean?) -> boolean,
	Ignore: (self: { Draggable }, list: { Frame | Instance }, instanceCheck: false?) -> (),
	SetTweenInfo: (self: { Draggable }, tweenInfo: TweenInfo) -> (),
	Toggle: (self: { Draggable }, value: boolean?) -> boolean,
	IgnoreDescendants: (self: { Draggable }) -> (),
	IgnoreChildren: (self: { Draggable }) -> (),
	Destroy: (self: { Draggable }) -> (),

	Released: Signal.Event,
	Started: Signal.Event,
	Moved: Signal.Event,
}

return DraggableUI :: {
	new: (UI: Instance, byScale: true?) -> Draggable,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">11263101887</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBXCA18963372E2430386DEDC1E282F743E">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Signal</string>
											<string name="ScriptGuid">{E3CC77C8-2EF8-464B-B002-C81F03492360}</string>
											<ProtectedString name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal
Signal.__tostring = function()
	return "Signal"
end

Signal.Event = {} :: {
	Connect: (self: { RBXScriptSignal }) -> RBXScriptConnection,
	Once: (self: { RBXScriptSignal }) -> RBXScriptConnection,
	Wait: (self: { RBXScriptSignal }) -> ...any,
}
Signal.Event.__index = Signal.Event
Signal.Event.__tostring = function()
	return "Event"
end

local Connection = {}
Connection.__index = Connection
Connection.__tostring = function()
	return "Connection"
end

local function DisableTableIndex(Table: {})
	setmetatable(Table, {
		__index = function(_, key)
			error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,

		__newindex = function(_, key)
			error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,
	})
end

Connection.__eq = function(self, other)
	return self._Handler == other._Handler
end

function Connection.new(Parent: {}, Handler: any): RBXScriptConnection
	return setmetatable({
		_Handler = Handler,
		_Parent = Parent,
	}, Connection)
end

function Connection:Disconnect()
	local Position = table.find(self._Parent, self)

	if Position then
		table.remove(self._Parent, Position)
	end
end

function Connection:_Fire(...)
	self._Handler(...)
end

function Signal.new()
	return setmetatable({}, Signal)
end

function Signal.Event:Connect(Handler: any): RBXScriptConnection
	local self: RBXScriptConnection = self
	local _Connection = Connection.new(self, Handler)

	table.insert(self, _Connection)

	return _Connection
end

function Signal.Event:Once(Handler: any): RBXScriptConnection
	local self: RBXScriptConnection = self

	local Fired = false
	local Connection

	Connection = self:Connect(function(...)
		if Fired then
			return
		end

		Fired = true
		Connection:Disconnect()
		Handler(...)
	end)

	return Connection
end

function Signal.Event:Wait(): ...any
	local self: RBXScriptConnection = self

	local Result = coroutine.running()
	local Fired = false
	local Connection

	Connection = self:Connect(function(...)
		if Fired then
			return
		end

		Fired = true
		Connection:Disconnect()
		task.spawn(Result, ...)
	end)

	return coroutine.yield()
end

function Signal:DisconnectAll()
	local self: RBXScriptConnection = self

	for _, Handler in ipairs(self.Event) do
		coroutine.wrap(Handler.Disconnect)(Handler)
	end
end

function Signal:Fire(...: any)
	local self: RBXScriptConnection = self
	local args = { ... }

	for _, Handler in ipairs(self.Event) do
		coroutine.wrap(Handler._Fire)(Handler, unpack(args))
	end
end

function Signal:Destroy()
	local self: RBXScriptConnection = self

	self:DisconnectAll()
	table.clear(self)
end

DisableTableIndex(Signal)
DisableTableIndex(Connection)
DisableTableIndex(Signal.Event)

export type Event = {
	Connect: (self: { Event }, func: (...any) -> ()) -> RBXScriptConnection,
	Once: (self: { Event }, func: (...any) -> ()) -> RBXScriptConnection,
	Wait: (self: { Event }) -> ...any,
}

export type Signal = {
	new: (
	) -> {
		Event: Event,
		Destroy: (self: { Signal }) -> (),
		Fire: (self: { Signal }, ...any) -> (),
		DisconnectAll: (self: { Signal }) -> (),
	},
}

return Signal :: Signal
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="RemoteEvent" referent="RBX7F76CDA21DB94BB9AF033CCE60FE7257">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">RemoteEvent</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Script" referent="RBX115FA3ACA200474882F19C06EC5907C5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Disabled">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SERVER</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{363B8958-131D-4A43-BD7F-11EB67F291EA}</string>
									<ProtectedString name="Source"><![CDATA[--local Connection
--Connection = script.Parent.AncestryChanged:Connect(function()
	if not script:IsDescendantOf(game.Players) then
		return--Connection:Disconnect()
	end
	
	local player = script:FindFirstAncestorOfClass('Player')
	script.Parent:WaitForChild("RemoteEvent").OnServerEvent:Connect(function(user, protocol, params)
		if (protocol == 'UPDATE_RATIO_VALUE' and user == player) then
			script.Parent.RATIO.Value = params
		end
	end)
--end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXB57B2833819046C4BDC096258406B0F3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">RATIO</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="ObjectValue" referent="RBX89446542A1C1436A9C85F7F302C2731B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">DOOR_SET</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Ref name="Value">null</Ref>
								</Properties>
							</Item>
						</Item>
						<Item class="ModuleScript" referent="RBX544C14C9E8764BD0985791ADCC9C31FC">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">LiveSettings</string>
								<string name="ScriptGuid">{A271D092-2871-4F16-8E0B-6A88BDFCEA32}</string>
								<ProtectedString name="Source">return {}</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBXFDFB656B30594751A5BABB8648D244D1">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Modules</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBXEC66D02C5ED64B6F9D30DCD9C9EE8C6C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Door_Engine</string>
								<string name="ScriptGuid">{B291293F-B7F8-4569-8CF2-3D85E2FB1F8F}</string>
								<ProtectedString name="Source"><![CDATA[local doorEngineClass = {}

local heartbeat =_G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

doorEngineClass.className = 'doorEngineClass'

doorEngineClass.isPluginModule = true

doorEngineClass.config = nil
doorEngineClass.elevator = nil

local core = require(script.Parent.Parent)
local coreFunctions = core.coreFunctions
local coreFunctionsModule = require(script.Parent.Core_Functions)
local signal = require(script.Parent.Signal)
local legacyEasing = require(script.Parent.Legacy_Easing)

function doorEngineClass.new(doorSet, dataTable)
	local self = setmetatable({}, doorEngineClass)
	if (doorSet.Name == 'Doors') then doorSet.Name = 'Front_Doors' end
	self.side = string.split(string.split(doorSet.Name, 'Doors')[1], '_')[1]
	if self.side == '' then self.side = string.split(doorSet.Name, 'Doors')[1] ~= "" and string.split(doorSet.Name, 'Doors')[1] or string.split(doorSet.Name, 'Doors')[2] ~= "" and string.split(doorSet.Name, 'Doors')[2] end
	--self.side = string.split(doorSet.Name, 'Doors')[2] and string.split(doorSet.Name, 'Doors')[1]
	--if (not self.side) then return end
	--self.side = string.split(self.side, '_')[1]
	if (self.side == '') then self.side = 'Front' end
	self.sideJoin = self.side == '' and '' or self.side.."_"
	self.state = 'Closed'
	self.isEnabled = true
	self.nudging = false
	self.doorSet = doorSet
	self.velocity = {
		['Inner'] = 0,
		['Outer'] = 0,
	}
	self.alpha = {
		['Inner'] = 0,
		['Outer'] = 0,
	}
	self.currentStage = {
		['Opening'] = {
			['Inner'] = 1,
			['Outer'] = 1,
		},
		['Closing'] = {
			['Inner'] = 1,
			['Outer'] = 1,
		}
	}

	self.sensorLEDs = {}

	self.openingThread,self.closingThread = nil,nil

	self.Opened = signal.new()
	self.Closed = signal.new()
	self.LanternsReset = signal.new()

	self.openingThreads = {}
	self.closingThreads = {}

	self.doorTimestamp = 0
	self.nudgeTimestamp = 0

	self.lanternsReset = false

	local elevator = doorEngineClass.elevator
	local car = elevator.Car
	local carLevel = elevator.Car:FindFirstChild('Level') or elevator.Car:FindFirstChild('Platform')
	local cabRegion = elevator.Car:WaitForChild('Cab_Region')
	self.doorSensorPart = elevator.Car:WaitForChild('Door_Sensor_Parts'):FindFirstChild((self.sideJoin) .. "Sensor")

	for i, v in pairs(doorSet:GetDescendants()) do
		if (not v:IsA('BasePart') or v.Name ~= 'Sensor_LED') then continue end
		table.insert(self.sensorLEDs, v)
		v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color
		v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material
	end

	if (doorEngineClass.config.Sound_Database.Doors.Open_Sound) then
		self.doorOpenSound = coreFunctions.addSound(self.doorSensorPart, 'Door_Open_Sound', doorEngineClass.config.Sound_Database.Doors.Open_Sound, false, 4, 25)
	end
	if (doorEngineClass.config.Sound_Database.Doors.Close_Sound) then
		self.doorCloseSound = coreFunctions.addSound(self.doorSensorPart, 'Door_Close_Sound', doorEngineClass.config.Sound_Database.Doors.Close_Sound, false, 4, 25)
	end

	for i, v in pairs(core.registeredFloors) do
		if (typeof(doorEngineClass.config.Sound_Database.Doors.Floors) ~= 'table') then continue end
		local floorDoorSoundConfig = doorEngineClass.config.Sound_Database.Doors.Floors[tostring(v.floorNumber)]
		if (typeof(doorEngineClass.config.Sound_Database.Doors.Floors) ~= 'table' or (not floorDoorSoundConfig)) then continue end
		self["doorOpenSoundFloor" .. (v.floorNumber)] = coreFunctions.addSound(self.doorSensorPart, "Door_Open_Sound_Floor_" .. (v.floorNumber), floorDoorSoundConfig.Open_Sound, false, 4, 25)
		self["doorCloseSoundFloor" .. (v.floorNumber)] = coreFunctions.addSound(self.doorSensorPart, "Door_Close_Sound_Floor_" .. (v.floorNumber), floorDoorSoundConfig.Close_Sound, false, 4, 25)
	end

	self.obstructionSignal = coreFunctions.addSound(self.doorSensorPart, 'Obstruction_Signal', doorEngineClass.config.Sound_Database.Others.Door_Obstruction_Signal, true, 2, 15)

	function self:Open(floor)

		local startingState = self.state

		local registeredFloor = coreFunctions.findRegisteredFloor(floor)
		if (not registeredFloor) then return end
		local carWelds, floorWelds = car.Door_Engine_Welds:FindFirstChild(self.side), registeredFloor.floorInstance.Door_Engine_Welds:FindFirstChild(self.side)
		if ((not carWelds) or (not floorWelds)) then return end

		for i, v in pairs(self.closingThreads) do
			pcall(task.cancel, v)
			self.closingThreads[i] = nil
		end
		self.Closed:Destroy()
		self.state = 'Opening'
		core.statValues[(self.sideJoin) .. "Door_State"] = self.state
		task.spawn(coreFunctions.updateStatValues)

		local distanceFactor = 0
		for i, v in pairs(carWelds:GetChildren()) do
			local dist = ((v:GetAttribute('openPoint').Position-v.C0.Position).Magnitude/(v:GetAttribute('openPoint').Position-v:GetAttribute('closedPoint').Position).Magnitude)/#carWelds:GetChildren()
			distanceFactor += dist
		end
		local openSound, closeSound = self["doorOpenSoundFloor" .. (floor)] or self.doorOpenSound, self["doorCloseSoundFloor" .. (floor)] or self.doorCloseSound
		closeSound:Stop()
		coroutine.wrap(function()
			if (startingState == 'Closed') then
				local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Open_Sound_Delay, function() return {self.state == 'Opening'} end)
				if (not hasPassed) then return end
			end
			openSound.TimePosition = openSound.TimeLength*(1-distanceFactor)
			task.wait()
			openSound:Play()
		end)()
		if (startingState == 'Closed') then
			local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Open_Delay, function() return {self.state == 'Opening'} end)
			if (not hasPassed) then return end
		end

		local function runDoor(set)
			local velocityConfig = doorEngineClass.config.Doors.Custom_Door_Operator_Config[set].Opening
			if ((set ~= 'Inner' and set ~= 'Outer') or (velocityConfig.Enable and set == 'Outer' and doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable)) then return end
			local doorWelds = set == 'Inner' and car.Door_Engine_Welds:FindFirstChild(self.side) or floorWelds
			if (not doorWelds) then return end

			local landingDoors = registeredFloor.floorInstance:FindFirstChild((self.sideJoin) .. "Doors")
			if (not landingDoors) then return end
			local direction = (select(1, landingDoors:GetBoundingBox()).Position-select(1, doorSet:GetBoundingBox()).Position)

			local duration = doorEngineClass.config.Doors.Door_Open_Speed

			local masterWeld,dist = nil,math.huge
			for _, v in pairs(doorWelds:GetChildren()) do
				local distance = (v:GetAttribute('openPoint').Position-v:GetAttribute('closedPoint').Position).Magnitude
				if (distance < dist and distance > 0) then
					masterWeld = v
					dist = distance
				end
			end

			local function checkWelds(point, threshold, includeFloorDoors)
				for _, v in pairs(carWelds:GetChildren()) do
					if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
				end
				if (includeFloorDoors == true) then
					for _, v in pairs(floorWelds:GetChildren()) do
						if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
					end
				end
				return true
			end

			local reopenStartTime
			local reopenDelayCompleted = false

			if (velocityConfig.Enable) then
				if (startingState == 'Closed') then
					self.velocity[set] = 0
					self.currentStage.Opening[set] = 1
				else
					self.velocity[set] = -self.velocity[set]
				end
				local startVelocity = self.velocity[set]

				local startTime = os.clock()
				local startLerpTime
				local stageAccelTime,initialVelocity,stageSpeed
				local decelerating = false
				local lastVelocity = self.velocity[set]
				local delayTick

				local doorSpeed = dist/duration
				local lastDist

				local distOffset = math.clamp(velocityConfig.Deceleration_Offset, 0, math.huge)
				local minSpeed = math.clamp(velocityConfig.Minimum_Speed or .05, 0, doorSpeed)

				local dtTime = 0

				if (startingState == 'Closed' and doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable) then
					if (floorWelds) then
						local function getEngineWeld(part: BasePart?)
							for _,v in pairs(floorWelds:GetChildren()) do
								if (v.Part0 == part) then return v end
							end
							return nil
						end
						local params = RaycastParams.new()
						params.FilterType = Enum.RaycastFilterType.Whitelist
						local list = {}
						for _,weld in pairs(floorWelds:GetChildren()) do
							table.insert(list, weld.Part0)
						end
						params.FilterDescendantsInstances = list
						for _,weld in pairs(carWelds:GetChildren()) do
							local result = workspace:Blockcast(CFrame.new(weld.Part0.CFrame.Position), Vector3.new(0, weld.Part0.Size.Y, 0), Vector3.new(direction.X, 0, direction.Z).Unit*5, params)
							if ((not result) or (not result.Instance)) then continue end
							local value = weld:FindFirstChild('Door_Weld') or Instance.new('ObjectValue')
							value.Name = 'Door_Weld'
							value.Value = getEngineWeld(result.Instance)
							value.Parent = weld
						end
					end
				end

				local function getFloorWeldFromCarWeld(weld)
					for i, v in pairs(floorWelds:GetChildren()) do
						if (v == weld) then return v end
					end
					return nil
				end

				local parent = self.doorSet:IsDescendantOf(car) and elevator:WaitForChild('Legacy') or self.doorSet.Parent
				local doorSpeedValue = parent:FindFirstChild((self.sideJoin) .. "Door_Speed")

				while (self.alpha[set] < 1 and (self.state == 'Opening' or self.state == 'Open')) do
					local thisConfig = typeof(velocityConfig.Custom_Acceleration_Stages) == 'table' and velocityConfig.Custom_Acceleration_Stages or {}
					local currentStage = thisConfig[self.currentStage.Opening[set]]

					local thisDist = (masterWeld:GetAttribute('openPoint').Position-masterWeld.C0.Position).Magnitude
					local thisDistCheck = thisDist/dist <= velocityConfig.Deceleration_Distance*(math.clamp((self.velocity[set])/doorSpeed, 0, 1))

					for i, v in pairs(self.sensorLEDs) do
						v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Active.Color
						v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Active.Material
					end

					if (startVelocity < 0 and self.velocity[set] >= 0) then
						if (not reopenStartTime) then
							reopenStartTime = os.clock()
						else
							if ((os.clock()-reopenStartTime)/doorEngineClass.config.Doors.Reopen_Delay < 1) then heartbeat:Wait() continue end
							if (not reopenDelayCompleted) then
								reopenDelayCompleted = true
								startLerpTime += (os.clock()-reopenStartTime)
								startLerpTime = nil
							end
						end
					end

					if (not thisDistCheck) then
						if (not decelerating) then
							if (currentStage) then
								if (not startLerpTime) then
									startLerpTime = os.clock()
									initialVelocity = self.velocity[set]
									stageSpeed = math.clamp(currentStage.Speed, 0, doorSpeed)
									stageAccelTime = (startingState == 'Closing' and self.state == 'Opening' and self.velocity[set] < 0) and coreFunctionsModule.getAccelerationTime(initialVelocity, stageSpeed, .2) or coreFunctionsModule.getAccelerationTime(initialVelocity, stageSpeed, if (currentStage.Acceleration == 'USE_ACCELERATION') then velocityConfig.Acceleration else currentStage.Acceleration)
								else
									local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
									self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, stageSpeed, alpha)
									if (alpha >= 1 and thisConfig[self.currentStage.Opening[set]+1]) then
										if (not delayTick) then
											delayTick = os.clock()
										elseif ((os.clock()-delayTick)/currentStage.Delay_Before_Next_Stage >= 1) then
											self.currentStage.Opening[set] = math.min(self.currentStage.Opening[set]+1, #thisConfig)
											startLerpTime = nil
										end
									end
								end
							else
								if (not startLerpTime) then
									startLerpTime = os.clock()
									initialVelocity = self.velocity[set]
									stageAccelTime = coreFunctionsModule.getAccelerationTime(initialVelocity, doorSpeed, velocityConfig.Acceleration)
								else
									local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
									self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, doorSpeed, alpha)
								end
							end
						end
					else
						if (not decelerating) then
							decelerating = true
							lastDist = thisDist
							lastVelocity = self.velocity[set]
						end
						if (velocityConfig.Deceleration_Rate == 'Constant') then
							local distOff = thisDist-distOffset
							local currentSpeed = self.velocity[set]
							local deceleration = currentSpeed^2/(2*math.max(.001, distOff))
							local SPEED = math.max(0, currentSpeed-deceleration*dtTime)
							self.velocity[set] = math.max(minSpeed, SPEED)
						end
					end

					self.alpha[set] = math.clamp(self.alpha[set]+((self.velocity[set]/doorSpeed)/duration)*dtTime, 0, 1)
					doorSpeedValue.Value = math.abs(self.velocity[set])

					if (doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable) then
						for _,weld in pairs(carWelds:GetChildren()) do
							weld.C0 = weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set])
							if (weld:FindFirstChild('Door_Weld')) then
								local data = getFloorWeldFromCarWeld(weld.Door_Weld.Value)
								if (data) then
									local goal = CFrame.new((weld:GetAttribute('closedPoint').Position-weld:GetAttribute('openPoint').Position).Unit*doorEngineClass.config.Doors.New_Attachment_Doors_Config.Attachment_Threshold)*(weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set]))
									weld.Door_Weld.Value.C0 = CFrame.new(
										math.clamp(goal.X,data:GetAttribute('openPoint').X >= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X,data:GetAttribute('openPoint').X <= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X),
										math.clamp(goal.Y,data:GetAttribute('openPoint').Y >= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y,data:GetAttribute('openPoint').Y <= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y),
										math.clamp(goal.Z,data:GetAttribute('openPoint').Z >= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z,data:GetAttribute('openPoint').Z <= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z)
									)
								end
							end
						end
					else
						for i, v in pairs(doorWelds:GetChildren()) do
							v.C0 = v:GetAttribute('closedPoint'):Lerp(v.C1, self.alpha[set])
						end
					end

					if (checkWelds('openPoint', 0, false) and self.state == 'Opening') then
						self.state = 'Open'
						core.statValues[(self.sideJoin) .. "Door_State"] = self.state
						task.spawn(coreFunctions.updateStatValues)
						self.Opened:Fire()
					end

					dtTime = heartbeat:Wait()

				end
				if (self.state ~= 'Opening') then return end
				self.velocity[set] = 0
				doorSpeedValue.Value = 0
				if (checkWelds('openPoint', 0, false) and self.state == 'Opening') then
					self.state = 'Open'
					core.statValues[(self.sideJoin) .. "Door_State"] = self.state
					task.spawn(coreFunctions.updateStatValues)
					self.Opened:Fire()
				end

			else
				for i, v in pairs(doorWelds:GetChildren()) do
					local newThread = task.spawn(function()
						local innerDoorsData, outerDoorsData = doorEngineClass.config.Doors.Realistic_Doors_Data, doorEngineClass.config.Doors.Realistic_Outer_Doors_Data
						local data = doorEngineClass.config.Doors[set == 'Inner' and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data']
						if (startingState == 'Closed' and data.Enable_Open) then
							local hasCompleted = legacyEasing.interpolate(v, v:GetAttribute('interlockOpenPoint'), data.Open_Easing_Style, data.Open_Time, function() return {self.state ~= 'Opening'} end)
							if (not hasCompleted) then return end
						end
						if (startingState == 'Closed') then
							if (set == 'Inner' and outerDoorsData.Enable_Open) then
								local hasCompleted = coreFunctionsModule.conditionalWait(outerDoorsData.Open_Time, function() return {self.state == 'Opening'} end)
								if (not hasCompleted) then return end
							elseif (set == 'Outer' and innerDoorsData.Enable_Open) then
								local hasCompleted = coreFunctionsModule.conditionalWait(innerDoorsData.Open_Time, function() return {self.state == 'Opening'} end)
								if (not hasCompleted) then return end
							end
						end
						legacyEasing.interpolate(v, v:GetAttribute('openPoint'), doorEngineClass.config.Doors.Open_Easing_Style, duration*distanceFactor, function() return {self.state ~= 'Opening'} end)
						if (self.state ~= 'Opening') then return end
						if (checkWelds('openPoint', 0, false) and self.state == 'Opening') then
							self.state = 'Open'
							core.statValues[(self.sideJoin) .. "Door_State"] = self.state
							task.spawn(coreFunctions.updateStatValues)
							self.Opened:Fire()
						end
					end)
					table.insert(self.openingThreads, newThread)
				end
			end
		end

		if (doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Opening.Enable) then
			if (self.state ~= 'Opening') then return end
			task.spawn(function()
				for i, part in ipairs(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) do
					local thread = task.spawn(runDoor, part)
					table.insert(self.openingThreads, thread)
					
					local hasCompleted = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Opening.Delay, function()
						return {self.state == 'Opening'}
					end)
					
					if (not hasCompleted) then return end
				end
			end)
		else
			for _, v in pairs({'Inner', 'Outer'}) do
				local thread = task.spawn(runDoor, v)
				table.insert(self.openingThreads, thread)
			end
		end
	end
	
	function self:Close(floor)

		local startingState = self.state
		if (self.state ~= 'Open' and self.state ~= 'Opening' and self.state ~= 'Stopped') then return end
		self.closingThread = task.spawn(function()
			for _, v in pairs(self.openingThreads) do
				pcall(task.cancel, v)
			end
			self.Opened:Destroy()
			self.state = 'Closing'
			self.lanternsReset = false
			core.statValues[(self.sideJoin) .. "Door_State"] = self.state
			task.spawn(coreFunctions.updateStatValues)

			local registeredFloor = coreFunctions.findRegisteredFloor(floor)
			if (not registeredFloor) then return end
			local carWelds, floorWelds = car.Door_Engine_Welds:FindFirstChild(self.side), registeredFloor.floorInstance.Door_Engine_Welds:FindFirstChild(self.side)
			local distanceFactor = 0
			for i, v in pairs(carWelds:GetChildren()) do
				local dist = ((v:GetAttribute('closedPoint').Position-v.C0.Position).Magnitude/(v:GetAttribute('closedPoint').Position-v:GetAttribute('openPoint').Position).Magnitude)/#carWelds:GetChildren()
				distanceFactor += dist
			end
			local openSound, closeSound = self["doorOpenSoundFloor" .. (floor)] or self.doorOpenSound, self["doorCloseSoundFloor" .. (floor)] or self.doorCloseSound
			openSound:Stop()
			coroutine.wrap(function()
				if (startingState == 'Open') then
					local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Close_Sound_Delay, function() return {self.state == 'Closing'} end)
					if (not hasPassed) then return end
				end
				closeSound.TimePosition = closeSound.TimeLength*(1-distanceFactor)
				task.wait()
				closeSound:Play()
			end)()
			if (startingState == 'Open') then
				local hasPassed = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Close_Delay, function() return {self.state == 'Closing'} end)
				if (not hasPassed) then return end
			end

			local function runDoor(set)
				local velocityConfig = doorEngineClass.config.Doors.Custom_Door_Operator_Config[set].Closing
				if ((set ~= 'Inner' and set ~= 'Outer') or (velocityConfig.Enable and set == 'Outer' and doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable)) then return end
				local doorWelds = set == 'Inner' and car.Door_Engine_Welds:FindFirstChild(self.side) or floorWelds
				if (not doorWelds) then return end

				local direction = (registeredFloor.level.Position-carLevel.Position)

				local duration = self.nudging and doorEngineClass.config.Doors.Nudge_Speed or doorEngineClass.config.Doors.Door_Close_Speed

				local masterWeld,dist = nil,math.huge
				for _, v in pairs(doorWelds:GetChildren()) do
					local distance = (v:GetAttribute('openPoint').Position-v:GetAttribute('closedPoint').Position).Magnitude
					if (distance < dist and distance > 0) then
						masterWeld = v
						dist = distance
					end
				end

				local function checkWelds(point, threshold, includeFloorDoors)
					for _, v in pairs(carWelds:GetChildren()) do
						if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
					end
					if (includeFloorDoors == true) then
						for _, v in pairs(floorWelds:GetChildren()) do
							if ((v:GetAttribute(point).Position-v.C0.Position).Magnitude > threshold) then return false end
						end
					end
					return true
				end

				local lastSLEDTick = tick()
				local startSLEDTick = tick()

				for i, v in pairs({'Interior', 'Exterior'}) do
					if (not doorEngineClass.config.Color_Database.Lanterns[v].Reset_After_Door_Close) then
						self.lanternsReset = true
						self.LanternsReset:Fire({v})
					end
				end

				if (velocityConfig.Enable) then
					if (startingState == 'Open') then
						self.velocity[set] = 0
						self.currentStage.Closing[set] = 1
					else
						self.velocity[set] = -self.velocity[set]
					end

					local startTime = os.clock()
					local startLerpTime
					local stageAccelTime,initialVelocity,stageSpeed
					local decelerating = false
					local lastVelocity = self.velocity[set]
					local delayTick

					local doorSpeed = dist/duration
					local lastDist

					local distOffset = math.clamp(velocityConfig.Deceleration_Offset, 0, math.huge)
					local minSpeed = math.clamp(velocityConfig.Minimum_Speed or .05, 0, doorSpeed)

					local dtTime = 0

					local function getFloorWeldFromCarWeld(weld)
						for i, v in pairs(floorWelds:GetChildren()) do
							if (v == weld) then return v end
						end
						return nil
					end
					
					local bounceFactor = 1
					local bounceVel = 0

					local parent = self.doorSet:IsDescendantOf(car) and elevator:WaitForChild('Legacy') or self.doorSet.Parent
					local doorSpeedValue = parent:FindFirstChild((self.sideJoin) .. "Door_Speed")

					while (self.alpha[set] > 0 and (self.state == 'Closing' or self.state == 'Closed')) do
						local thisConfig = typeof(velocityConfig.Custom_Acceleration_Stages) == 'table' and velocityConfig.Custom_Acceleration_Stages or {}
						local currentStage = thisConfig[self.currentStage.Closing[set]]

						local thisDist = (masterWeld:GetAttribute('closedPoint').Position-masterWeld.C0.Position).Magnitude
						local thisDistCheck = thisDist/dist <= velocityConfig.Deceleration_Distance*(math.clamp((self.velocity[set])/doorSpeed, 0, 1))

						local data = doorEngineClass.config.Doors.Sensor_LED_Data.Closing_Color
						if (self.state == 'Closing') then
							if ((tick()-startSLEDTick)/data.Delay > 1) then
								local cfg = (tick()-lastSLEDTick)/data.Flash_Time < 1 and data.Active or data.Inactive
								if ((tick()-lastSLEDTick)/data.Flash_Time/2 > 1) then
									lastSLEDTick = tick()
								end
								for i, v in pairs(self.sensorLEDs) do
									v.Color = cfg.Color
									v.Material = cfg.Material
								end
							else
								lastSLEDTick = tick()
								for i, v in pairs(self.sensorLEDs) do
									v.Color = data.Active.Color
									v.Material = data.Active.Material
								end
							end
						end

						if (not thisDistCheck) then
							if (not decelerating) then
								if (currentStage) then
									if (not startLerpTime) then
										startLerpTime = os.clock()
										initialVelocity = self.velocity[set]
										stageSpeed = math.clamp(currentStage.Speed, 0, doorSpeed)
										stageAccelTime = coreFunctionsModule.getAccelerationTime(initialVelocity, stageSpeed, if (currentStage.Acceleration == 'USE_ACCELERATION') then velocityConfig.Acceleration else currentStage.Acceleration)
									else
										local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
										self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, stageSpeed, alpha)
										if (alpha >= 1 and thisConfig[self.currentStage.Closing[set]+1]) then
											if (not delayTick) then
												delayTick = os.clock()
											elseif ((os.clock()-delayTick)/currentStage.Delay_Before_Next_Stage >= 1) then
												self.currentStage.Closing[set] = math.max(1, self.currentStage.Closing[set]+1)
												startLerpTime = nil
											end
										end
									end
								else
									if (not startLerpTime) then
										startLerpTime = os.clock()
										initialVelocity = self.velocity[set]
										stageAccelTime = coreFunctionsModule.getAccelerationTime(initialVelocity, doorSpeed, velocityConfig.Acceleration)
									else
										local alpha = math.min((os.clock()-startLerpTime)/stageAccelTime, 1)
										self.velocity[set] = coreFunctionsModule.lerp(initialVelocity, doorSpeed, alpha)
									end
								end
							end
						else
							if (not decelerating) then
								decelerating = true
								lastDist = thisDist
								lastVelocity = self.velocity[set]
							end
							if (velocityConfig.Deceleration_Rate == 'Constant') then
								local distOff = thisDist-distOffset
								local currentSpeed = self.velocity[set]
								local deceleration = currentSpeed^2/(2*math.max(.001, distOff))
								local SPEED = math.max(0, currentSpeed-deceleration*dtTime)
								self.velocity[set] = math.max(minSpeed, SPEED)
							end
						end

						self.alpha[set] = math.clamp(self.alpha[set]-((self.velocity[set]/doorSpeed)/duration)*dtTime, 0, 1)
						
						doorSpeedValue.Value = -math.abs(self.velocity[set])

						if (doorEngineClass.config.Doors.New_Attachment_Doors_Config.Enable) then
							for _,weld in pairs(carWelds:GetChildren()) do
								weld.C0 = weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set])
								if (weld:FindFirstChild('Door_Weld')) then
									local data = getFloorWeldFromCarWeld(weld.Door_Weld.Value)
									if (data) then
										local goal = CFrame.new((weld:GetAttribute('closedPoint').Position-weld:GetAttribute('openPoint').Position).Unit*(doorEngineClass.config.Doors.New_Attachment_Doors_Config.Attachment_Threshold))*(weld:GetAttribute('closedPoint'):Lerp(weld:GetAttribute('openPoint'), self.alpha[set]))
										weld.Door_Weld.Value.C0 = CFrame.new(
											math.clamp(goal.X,data:GetAttribute('openPoint').X >= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X,data:GetAttribute('openPoint').X <= data:GetAttribute('closedPoint').X and data:GetAttribute('closedPoint').X or data:GetAttribute('openPoint').X),
											math.clamp(goal.Y,data:GetAttribute('openPoint').Y >= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y,data:GetAttribute('openPoint').Y <= data:GetAttribute('closedPoint').Y and data:GetAttribute('closedPoint').Y or data:GetAttribute('openPoint').Y),
											math.clamp(goal.Z,data:GetAttribute('openPoint').Z >= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z,data:GetAttribute('openPoint').Z <= data:GetAttribute('closedPoint').Z and data:GetAttribute('closedPoint').Z or data:GetAttribute('openPoint').Z)
										)
									end
								end
							end
						else
							for i, v in pairs(doorWelds:GetChildren()) do
								v.C0 = v:GetAttribute('closedPoint'):Lerp(v.C1, self.alpha[set])
							end
						end

						-- // Check distance for lanterns reset ratio // --
						if ((thisDist/dist) <= doorEngineClass.config.Color_Database.Lanterns.Door_Distance_Reset_Ratio and (not self.lanternsReset)) then
							self.lanternsReset = true
							self.LanternsReset:Fire({'Interior', 'Exterior'})
						end

						if (checkWelds('closedPoint', doorEngineClass.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
							self.state = 'Closed'
							core.statValues[(self.sideJoin) .. "Door_State"] = self.state
							task.spawn(coreFunctions.updateStatValues)
							if (not self.lanternsReset) then
								self.lanternsReset = true
								self.LanternsReset:Fire({'Interior', 'Exterior'})
								for i, v in pairs(self.sensorLEDs) do
									v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color
									v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material
								end
							end
							self.Closed:Fire()
						end

						dtTime = heartbeat:Wait()

					end
					if (self.state ~= 'Closing') then return end
					self.velocity[set] = 0
					doorSpeedValue.Value = 0
					if (checkWelds('closedPoint', 0, true) and self.state == 'Closing') then
						self.state = 'Closed'
						core.statValues[(self.sideJoin) .. "Door_State"] = self.state
						task.spawn(coreFunctions.updateStatValues)
						if (not self.lanternsReset) then
							self.lanternsReset = true
							self.LanternsReset:Fire({'Interior', 'Exterior'})
							for i, v in pairs(self.sensorLEDs) do
								v.Color = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color
								v.Material = doorEngineClass.config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material
							end
						end
						self.Closed:Fire()
					end
				else
					local newThread = task.spawn(function()
						while (self.state == 'Closing') do
							local data = doorEngineClass.config.Doors.Sensor_LED_Data.Closing_Color
							local cfg = (tick()-lastSLEDTick)/data.Flash_Time < 1 and data.Active or data.Inactive
							if ((tick()-lastSLEDTick)/data.Flash_Time/2 > 1) then
								lastSLEDTick = tick()
							end
							for i, v in pairs(self.sensorLEDs) do
								v.Color = cfg.Color
								v.Material = cfg.Material
							end
							heartbeat:Wait()
						end
					end)
					table.insert(self.openingThreads, newThread)
					for i, v in pairs(doorWelds:GetChildren()) do
						local newThread = task.spawn(function()
							local innerDoorsData, outerDoorsData = doorEngineClass.config.Doors.Realistic_Doors_Data, doorEngineClass.config.Doors.Realistic_Outer_Doors_Data
							local data = doorEngineClass.config.Doors[set == 'Inner' and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data']
							local hasCompleted = legacyEasing.interpolate(v, v:GetAttribute(data.Enable_Close and 'interlockClosedPoint' or 'closedPoint'), doorEngineClass.config.Doors.Close_Easing_Style, duration*distanceFactor, function() return {self.state ~= 'Closing'} end)
							if (not hasCompleted) then return end
							if (data.Enable_Close) then
								local hasCompleted = legacyEasing.interpolate(v, v:GetAttribute('closedPoint'), data.Close_Easing_Style, data.Close_Time, function()
									if (checkWelds('closedPoint', doorEngineClass.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
										self.state = 'Closed'
										core.statValues[(self.sideJoin) .. "Door_State"] = self.state
										task.spawn(coreFunctions.updateStatValues)
										if (not self.lanternsReset) then
											self.lanternsReset = true
											self.LanternsReset:Fire({'Interior', 'Exterior'})
										end
										self.Closed:Fire()
									end
									return {} end)
								if (not hasCompleted) then return end
							end
							if (self.state ~= 'Closing') then return end
							if (checkWelds('closedPoint', 0, true) and self.state == 'Closing') then
								if (not self.lanternsReset) then
									self.lanternsReset = true
									self.LanternsReset:Fire({'Interior', 'Exterior'})
								end
								self.state = 'Closed'
								core.statValues[(self.sideJoin) .. "Door_State"] = self.state
								task.spawn(coreFunctions.updateStatValues)
								self.Closed:Fire()
							end
						end)
						table.insert(self.openingThreads, newThread)
					end
				end
			end
			
			if (doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Closing.Enable) then
				if (self.state ~= 'Closing') then return end
				task.spawn(function()
					for i, part in ipairs(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) do
						local thread = task.spawn(runDoor, part)
						table.insert(self.openingThreads, thread)
						self.openingThreads[i] = nil
						local hasCompleted = coreFunctionsModule.conditionalWait(doorEngineClass.config.Doors.Door_Delay_Sequence_Config.Closing.Delay, function()
							return {self.state == 'Closing'}
						end)
						if (not hasCompleted) then return end
					end
				end)
			else
				for i, v in pairs({'Inner', 'Outer'}) do
					local thread = task.spawn(runDoor, v)
					table.insert(self.openingThreads, thread)
					self.openingThreads[i] = nil
				end
			end
		end)
	end
	function self:IsValid(floor)
		local registeredFloor = coreFunctions.findRegisteredFloor(floor)
		if (not registeredFloor) then return false end
		local carWelds, floorWelds = car.Door_Engine_Welds:FindFirstChild(self.side), registeredFloor.floorInstance.Door_Engine_Welds:FindFirstChild(self.side)
		if ((not carWelds) or (not floorWelds)) then return false end
		return true
	end
	return self
end

function doorEngineClass.setUp(doorSet)
	if (doorSet.Name == 'Doors') then doorSet.Name = 'Front_Doors' end
	local side = string.split(doorSet.Name, 'Doors')[2] and string.split(doorSet.Name, 'Doors')[1]
	if (not side) then return end
	side = string.split(side, '_')[1]
	if (side == '') then side = 'Front' end
	local sideJoin = side == '' and '' or side.."_"
	local parent = doorSet.Parent
	local elevator = doorEngineClass.elevator
	local car = elevator:FindFirstChild('Car')
	local platform = car:FindFirstChild('Platform')
	local level = parent:FindFirstChild('Level')
	local carLevel = car:FindFirstChild('Level') or platform
	local doorWeldsFolder = coreFunctions.createInstance(parent, (sideJoin) .. "Door_Welds", 'Folder', true)
	local doorEngineWeldsFolder = coreFunctions.createInstance(parent, 'Door_Engine_Welds', 'Folder', true)
	local doorEngineWeldsFolder_Side = coreFunctions.createInstance(doorEngineWeldsFolder, side, 'Folder', true)

	local doorSpeedValue = coreFunctions.createInstance(doorSet:IsDescendantOf(car) and elevator:WaitForChild('Legacy') or parent, (sideJoin) .. "Door_Speed", 'NumberValue', true)

	local dropKeyOpen = doorSet:FindFirstChild('Drop_Key_Open') or Instance.new('BoolValue', doorSet)
	dropKeyOpen.Name = 'Drop_Key_Open'

	if (doorSet:IsDescendantOf(car)) then
		local boundsCf, boundsSize = doorSet:GetBoundingBox()
		local doorSensorPartsFolder = coreFunctions.createInstance(car, 'Door_Sensor_Parts', 'Folder', true)
		local doorSensorPart = coreFunctions.createInstance(doorSensorPartsFolder, (sideJoin) .. "Sensor", 'Part', true, {
			Anchored = false,
			CanCollide = false,
			CanQuery = false,
			Transparency = 1,
			CFrame = boundsCf,
			Size = boundsSize,
		})
		coreFunctions.weldParts(doorSensorPart, doorSensorPart, platform, true, false)
	end

	for _,v in pairs(doorSet:GetChildren()) do
		local scaler = v:FindFirstChild('Scaler')
		if (not scaler) then continue end
		local open = scaler:FindFirstChild('Open')
		if (not open) then
			open = Instance.new('Part')
			open.Name = 'Open'
			open.Size = scaler.Size
			open.CanCollide = false
			open.Color = scaler.Color
			local cf = scaler.CFrame:ToWorldSpace(CFrame.new(0, 0, -((scaler.Parent.Name:sub(2,2) == 'R' and 1 or scaler.Parent.Name:sub(2,2) == 'L' and -1 or 0)*scaler.Size.Magnitude*.9)*scaler.Parent.Name:sub(3)))
			open.CFrame = cf
			open.Transparency = 1
			open.Parent = scaler
		end
		coreFunctions.weldParts(doorWeldsFolder, open, level, true, false)
		local engineWeld = coreFunctions.weldParts(doorEngineWeldsFolder_Side, scaler, open, true, false)
		engineWeld.Name = 'Door_Engine_Weld'
		engineWeld:SetAttribute('closedPoint', engineWeld.C0)
		engineWeld:SetAttribute('openPoint', engineWeld.C1)
		local x, y, z = engineWeld.C1:ToEulerAnglesXYZ()
		local data = doorEngineClass.config.Doors[engineWeld:IsDescendantOf(doorSet) and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data']
		local rotOpen = Vector3.new(x, y, z)/data.Open_Ratio
		local rotClosed = Vector3.new(x, y, z)/data.Close_Ratio
		engineWeld:SetAttribute('interlockOpenPoint', CFrame.new(engineWeld.C1.Position-(engineWeld.C1.Position/data.Open_Ratio))*CFrame.Angles(rotOpen.X, rotOpen.Y, rotOpen.Z))
		engineWeld:SetAttribute('interlockClosedPoint', CFrame.new(engineWeld.C1.Position-(engineWeld.C1.Position/data.Close_Ratio))*CFrame.Angles(rotClosed.X, rotClosed.Y, rotClosed.Z))
		coreFunctions.weldModel(v, scaler, {open}, doorWeldsFolder)
		scaler.Anchored = false
		scaler.CanQuery = true
		open.Anchored = false
	end
end

return doorEngineClass]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXB3CDA38104BA435681559141483FBC6E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Core_Functions</string>
								<string name="ScriptGuid">{2B8253A1-2EE2-465C-95AE-FD5AC7E777B3}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local heartbeat =_G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module.lerp(a, b, t)
	return a+(b-a)*t
end

function module.getAccelerationTime(initialSpeed, finalSpeed, rate)
	return math.abs(finalSpeed-initialSpeed)/math.deg(rate)
end

function module.findAncestor(model, name)
	if (not model or typeof(model) ~= 'Instance') then return end
	local result = model:FindFirstChild(name, true)
	if (result) then
		return result
	else
		return module.findAncestor(model.Parent, name)
	end
end

function module.conditionalWait(duration, conditions)
	if (typeof(duration) ~= 'number') then return false end
	
	local function checkConditions()
		if (typeof(conditions) ~= 'function') then return true end
		for _, v in pairs(conditions()) do
			if (not v) then return false end
		end
		return true
	end
	
	local startTime = os.clock()
	while ((os.clock()-startTime)/duration < 1) do
		heartbeat:Wait()
		if (not checkConditions()) then return false, (os.clock()-startTime) end
	end
	return true, (os.clock()-startTime)
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX70DF93EA1FCE4FAEA4FEFB945253A9AB">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Signal</string>
								<string name="ScriptGuid">{92716B16-1DED-4E30-8612-3E1AA8245AFC}</string>
								<ProtectedString name="Source"><![CDATA[-- -----------------------------------------------------------------------------
--               Batched Yield-Safe Signal Implementation                     --
-- This is a Signal class which has effectively identical behavior to a       --
-- normal RBXScriptSignal, with the only difference being a couple extra      --
-- stack frames at the bottom of the stack trace when an error is thrown.     --
-- This implementation caches runner coroutines, so the ability to yield in   --
-- the signal handlers comes at minimal extra cost over a naive signal        --
-- implementation that either always or never spawns a thread.                --
--                                                                            --
-- License:                                                                   --
--   Licensed under the MIT license.                                          --
--                                                                            --
-- Authors:                                                                   --
--   stravant - July 31st, 2021 - Created the file.                           --
--   sleitnick - August 3rd, 2021 - Modified for Knit.                        --
-- -----------------------------------------------------------------------------

-- Signal types
export type Connection = {
	Disconnect: (self: Connection) -> (),
	Destroy: (self: Connection) -> (),
	Connected: boolean,
}

export type Signal<T...> = {
	Fire: (self: Signal<T...>, T...) -> (),
	FireDeferred: (self: Signal<T...>, T...) -> (),
	Connect: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	Once: (self: Signal<T...>, fn: (T...) -> ()) -> Connection,
	DisconnectAll: (self: Signal<T...>) -> (),
	GetConnections: (self: Signal<T...>) -> { Connection },
	Destroy: (self: Signal<T...>) -> (),
	Wait: (self: Signal<T...>) -> T...,
}

-- The currently idle thread to run the next handler on
local freeRunnerThread = nil

-- Function which acquires the currently idle handler runner thread, runs the
-- function fn on it, and then releases the thread, returning it to being the
-- currently idle one.
-- If there was a currently idle runner thread already, that's okay, that old
-- one will just get thrown and eventually GCed.
local function acquireRunnerThreadAndCallEventHandler(fn, ...)
	local acquiredRunnerThread = freeRunnerThread
	freeRunnerThread = nil
	fn(...)
	-- The handler finished running, this runner thread is free again.
	freeRunnerThread = acquiredRunnerThread
end

-- Coroutine runner that we create coroutines of. The coroutine can be
-- repeatedly resumed with functions to run followed by the argument to run
-- them with.
local function runEventHandlerInFreeThread(...)
	acquireRunnerThreadAndCallEventHandler(...)
	while true do
		acquireRunnerThreadAndCallEventHandler(coroutine.yield())
	end
end

--[=[
	@within Signal
	@interface SignalConnection
	.Connected boolean
	.Disconnect (SignalConnection) -> ()

	Represents a connection to a signal.
	"lua
	local connection = signal:Connect(function() end)
	print(connection.Connected) --> true
	connection:Disconnect()
	print(connection.Connected) --> false
	"
]=]

-- Connection class
local Connection = {}
Connection.__index = Connection

function Connection:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

function Connection:Disconnect()
	if not self.Connected then
		return
	end
	self.Connected = false

	-- Unhook the node, but DON'T clear it. That way any fire calls that are
	-- currently sitting on this node will be able to iterate forwards off of
	-- it, but any subsequent fire calls will not hit it, and it will be GCed
	-- when no more fire calls are sitting on it.
	if self._signal._handlerListHead == self then
		self._signal._handlerListHead = self._next
	else
		local prev = self._signal._handlerListHead
		while prev and prev._next ~= self do
			prev = prev._next
		end
		if prev then
			prev._next = self._next
		end
	end
end

Connection.Destroy = Connection.Disconnect

-- Make Connection strict
setmetatable(Connection, {
	__index = function(_tb, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

--[=[
	@within Signal
	@type ConnectionFn (...any) -> ()

	A function connected to a signal.
]=]

--[=[
	@class Signal

	A Signal is a data structure that allows events to be dispatched
	and observed.

	This implementation is a direct copy of the de facto standard, [GoodSignal](https://devforum.roblox.com/t/lua-signal-class-comparison-optimal-goodsignal-class/1387063),
	with some added methods and typings.

	For example:
	"lua
	local signal = Signal.new()

	-- Subscribe to a signal:
	signal:Connect(function(msg)
		print("Got message:", msg)
	end)

	-- Dispatch an event:
	signal:Fire("Hello world!")
	"
]=]
local Signal = {}
Signal.__index = Signal

--[=[
	Constructs a new Signal

	@return Signal
]=]
function Signal.new<T...>(): Signal<T...>
	local self = setmetatable({
		_handlerListHead = false,
		_proxyHandler = nil,
		_yieldedThreads = nil,
	}, Signal)

	return self
end

--[=[
	Constructs a new Signal that wraps around an RBXScriptSignal.

	@param rbxScriptSignal RBXScriptSignal -- Existing RBXScriptSignal to wrap
	@return Signal

	For example:
	"lua
	local signal = Signal.Wrap(workspace.ChildAdded)
	signal:Connect(function(part) print(part.Name .. " added") end)
	Instance.new("Part").Parent = workspace
	"
]=]
function Signal.Wrap<T...>(rbxScriptSignal: RBXScriptSignal): Signal<T...>
	assert(
		typeof(rbxScriptSignal) == "RBXScriptSignal",
		"Argument #1 to Signal.Wrap must be a RBXScriptSignal; got " .. typeof(rbxScriptSignal)
	)

	local signal = Signal.new()
	signal._proxyHandler = rbxScriptSignal:Connect(function(...)
		signal:Fire(...)
	end)

	return signal
end

--[=[
	Checks if the given object is a Signal.

	@param obj any -- Object to check
	@return boolean -- "true" if the object is a Signal.
]=]
function Signal.Is(obj: any): boolean
	return type(obj) == "table" and getmetatable(obj) == Signal
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called anytime the signal is fired.
	"lua
	signal:Connect(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	"
]=]
function Signal:Connect(fn)
	local connection = setmetatable({
		Connected = true,
		_signal = self,
		_fn = fn,
		_next = false,
	}, Connection)

	if self._handlerListHead then
		connection._next = self._handlerListHead
		self._handlerListHead = connection
	else
		self._handlerListHead = connection
	end

	return connection
end

--[=[
	@deprecated v1.3.0 -- Use "Signal:Once" instead.
	@param fn ConnectionFn
	@return SignalConnection
]=]
function Signal:ConnectOnce(fn)
	return self:Once(fn)
end

--[=[
	@param fn ConnectionFn
	@return SignalConnection

	Connects a function to the signal, which will be called the next time the signal fires. Once
	the connection is triggered, it will disconnect itself.
	"lua
	signal:Once(function(msg, num)
		print(msg, num)
	end)

	signal:Fire("Hello", 25)
	signal:Fire("This message will not go through", 10)
	"
]=]
function Signal:Once(fn)
	local connection
	local done = false

	connection = self:Connect(function(...)
		if done then
			return
		end

		done = true
		connection:Disconnect()
		fn(...)
	end)

	return connection
end

function Signal:GetConnections()
	local items = {}

	local item = self._handlerListHead
	while item do
		table.insert(items, item)
		item = item._next
	end

	return items
end

-- Disconnect all handlers. Since we use a linked list it suffices to clear the
-- reference to the head handler.
--[=[
	Disconnects all connections from the signal.
	"lua
	signal:DisconnectAll()
	"
]=]
function Signal:DisconnectAll()
	local item = self._handlerListHead
	while item do
		item.Connected = false
		item = item._next
	end
	self._handlerListHead = false

	local yieldedThreads = rawget(self, "_yieldedThreads")
	if yieldedThreads then
		for thread in yieldedThreads do
			if coroutine.status(thread) == "suspended" then
				warn(debug.traceback(thread, "signal disconnected; yielded thread cancelled", 2))
				task.cancel(thread)
			end
		end
		table.clear(self._yieldedThreads)
	end
end

-- Signal:Fire(...) implemented by running the handler functions on the
-- coRunnerThread, and any time the resulting thread yielded without returning
-- to us, that means that it yielded to the Roblox scheduler and has been taken
-- over by Roblox scheduling, meaning we have to make a new coroutine runner.
--[=[
	@param ... any

	Fire the signal, which will call all of the connected functions with the given arguments.
	"lua
	signal:Fire("Hello")

	-- Any number of arguments can be fired:
	signal:Fire("Hello", 32, " .. (Test = "Test") .. ", true)
	"
]=]
function Signal:Fire(...)
	local item = self._handlerListHead
	while item do
		if item.Connected then
			if not freeRunnerThread then
				freeRunnerThread = coroutine.create(runEventHandlerInFreeThread)
			end
			task.spawn(freeRunnerThread, item._fn, ...)
		end
		item = item._next
	end
end

--[=[
	@param ... any

	Same as "Fire", but uses "task.defer" internally & doesn't take advantage of thread reuse.
	"lua
	signal:FireDeferred("Hello")
	"
]=]
function Signal:FireDeferred(...)
	local item = self._handlerListHead
	while item do
		local conn = item
		task.defer(function(...)
			if conn.Connected then
				conn._fn(...)
			end
		end, ...)
		item = item._next
	end
end

--[=[
	@return ... any
	@yields

	Yields the current thread until the signal is fired, and returns the arguments fired from the signal.
	Yielding the current thread is not always desirable. If the desire is to only capture the next event
	fired, using "Once" might be a better solution.
	"lua
	task.spawn(function()
		local msg, num = signal:Wait()
		print(msg, num) --> "Hello", 32
	end)
	signal:Fire("Hello", 32)
	"
]=]
function Signal:Wait()
	local yieldedThreads = rawget(self, "_yieldedThreads")
	if not yieldedThreads then
		yieldedThreads = {}
		rawset(self, "_yieldedThreads", yieldedThreads)
	end

	local thread = coroutine.running()
	yieldedThreads[thread] = true

	self:Once(function(...)
		yieldedThreads[thread] = nil
		task.spawn(thread, ...)
	end)

	return coroutine.yield()
end

--[=[
	Cleans up the signal.

	Technically, this is only necessary if the signal is created using
	"Signal.Wrap". Connections should be properly GC'd once the signal
	is no longer referenced anywhere. However, it is still good practice
	to include ways to strictly clean up resources. Calling "Destroy"
	on a signal will also disconnect all connections immediately.
	"lua
	signal:Destroy()
	"
]=]
function Signal:Destroy()
	self:DisconnectAll()

	local proxyHandler = rawget(self, "_proxyHandler")
	if proxyHandler then
		proxyHandler:Disconnect()
	end
end

-- Make signal strict
setmetatable(Signal, {
	__index = function(_tb, key)
		error(("Attempt to get Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
	__newindex = function(_tb, key, _value)
		error(("Attempt to set Signal::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

return table.freeze({
	new = Signal.new,
	Wrap = Signal.Wrap,
	Is = Signal.Is,
})]]></ProtectedString>
								<int64 name="SourceAssetId">10568398310</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX986F9AB846AF43DCA00D787AF1DD12E5">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Legacy_Easing</string>
								<string name="ScriptGuid">{3EEE46C9-0FC9-42DA-8CD0-A2027416DD0A}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

module.isPluginModule = true

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT


function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

module.easingStyles = {
	['Linear'] = {Enum.EasingStyle.Linear, Enum.EasingDirection.InOut},
	['In_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.In},
	['Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.Out},
	['In_Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.InOut},
	['In_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.In},
	['Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.Out},
	['In_Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.InOut},
	['In_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.In},
	['Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.Out},
	['In_Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.InOut},
	['In_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.In},
	['Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.Out},
	['In_Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.InOut},
	['In_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.In},
	['Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.Out},
	['In_Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.InOut},
	['In_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.In},
	['Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.Out},
	['In_Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.InOut},
	['In_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.In},
	['Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.Out},
	['In_Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.InOut},
	['In_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.In},
	['Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.Out},
	['In_Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut},
	['In_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.In},
	['In_Out_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.Out},
	['In_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.In},
	['Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.Out},
	['In_Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.InOut},
}
module.easingStyles.functions = {
	--Linear
	Linear = function(t, b, c, d)
		return c * t / d + b 
	end,

	--Quad
	In_Quad = function(t, b, c, d) 
		return c * math.pow(t / d, 2) + b 
	end,

	Out_Quad = function(t, b, c, d)
		t = t / d
		return -c * t * (t - 2) + b
	end,

	In_Out_Quad = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 2) + b end
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end,

	Out_In_Quad = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuad(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Cubic
	In_Cubic = function(t, b, c, d) 
		return c * math.pow(t / d, 3) + b 
	end,

	Out_Cubic = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 3) + 1) + b 
	end,

	In_Out_Cubic = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * t * t * t + b end
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end,

	Out_In_Cubic = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCubic(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end,


	--Quart

	On_Quart = function(t, b, c, d) 
		return c * math.pow(t / d, 4) + b 
	end,

	Out_Quart = function(t, b, c, d) 
		return -c * (math.pow(t / d - 1, 4) - 1) + b 
	end,

	In_Out_Quart = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 4) + b end
		return -c / 2 * (math.pow(t - 2, 4) - 2) + b
	end,

	Out_In_Quart = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuart(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Quint

	In_Quint = function(t, b, c, d)
		return c * math.pow(t / d, 5) + b 
	end,

	Out_Quint = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 5) + 1) + b 
	end,

	In_Out_Quint = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 5) + b end
		return c / 2 * (math.pow(t - 2, 5) + 2) + b
	end,

	Out_In_Quint = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuint(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Sine

	In_Sine = function(t, b, c, d) 
		return -c * math.cos(t / d * (math.pi / 2)) + c + b 
	end,

	Out_Sine = function(t, b, c, d) 
		return c * math.sin(t / d * (math.pi / 2)) + b 
	end,

	In_Out_Sine = function(t, b, c, d) 
		return -c / 2 * (math.cos(math.pi * t / d) - 1) + b 
	end,

	Out_In_Sine = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outSine(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inSine((t * 2) -d, b + c / 2, c / 2, d)
	end,

	--Expo

	In_Expo = function(t, b, c, d)
		if t == 0 then return b end
		return c * math.pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end,

	Out_Expo = function(t, b, c, d)
		if t == d then return b + c end
		return c * 1.001 * (-math.pow(2, -10 * t / d) + 1) + b
	end,

	In_Out_Expo = function(t, b, c, d)
		if t == 0 then return b end
		if t == d then return b + c end
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(2, 10 * (t - 1)) + b - c * 0.0005 end
		return c / 2 * 1.0005 * (-math.pow(2, -10 * (t - 1)) + 2) + b
	end,

	Out_In_Expo = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outExpo(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Circ

	In_Circ = function(t, b, c, d) 
		return(-c * (math.sqrt(1 - math.pow(t / d, 2)) - 1) + b) 
	end,

	Out_Circ = function(t, b, c, d)  
		return(c * math.sqrt(1 - math.pow(t / d - 1, 2)) + b) 
	end,

	In_Out_Circ = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return -c / 2 * (math.sqrt(1 - t * t) - 1) + b end
		t = t - 2
		return c / 2 * (math.sqrt(1 - t * t) + 1) + b
	end,

	Out_In_Circ = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCirc(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end,



	--Back
	Out_Back = function(t, b, c, d, s)
		s = s or 1.2
		t = t / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	end,

	In_Back = function(t, b, c, d, s)
		s = s or 1.70158
		t = t / d
		return c * t * t * ((s + 1) * t - s) + b
	end,

	In_Out_Back = function(t, b, c, d, s)
		s = (s or 1.70158) * 1.525
		t = t / d * 2
		if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end,

	Out_In_Back = function(t, b, c, d, s)
		if t < d / 2 then return module.easingStyles.types.outBack(t * 2, b, c / 2, d, s) end
		return module.easingStyles.types.inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end,

	--bounce

	Out_Bounce = function(t, b, c, d)
		t = t / d
		if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end
		if t < 2 / 2.75 then
			t = t - (1.5 / 2.75)
			return c * (7.5625 * t * t + 0.75) + b
		elseif t < 2.5 / 2.75 then
			t = t - (2.25 / 2.75)
			return c * (7.5625 * t * t + 0.9375) + b
		end
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end,

	In_Bounce = function(t, b, c, d) 
		return c - module.easingStyles.types.outBounce(d - t, 0, c, d) + b 
	end,

	In_Out_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.inBounce(t * 2, 0, c, d) * 0.5 + b end
		return module.easingStyles.types.outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end,

	Out_In_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outBounce(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end,
}

local function checkBreakStatements(statements)
	for i,v in pairs((statements and typeof(statements) == 'function') and statements() or {}) do
		if (v) then return true end
	end
	return false
end

local codeName = 'InterpolationCode'

local runningThreads = {}

local signal = require(script.Parent.Signal)

function module.interpolate(weld: Weld, c0: CFrame, easingStyle: any, duration: number, breakStatements: any)
	easingStyle = easingStyle or 'Linear'
	easingStyle = module.easingStyles.functions[easingStyle] or module.easingStyles.functions.Linear
	if (not runningThreads[weld]) then runningThreads[weld] = {} end
	for i, v in pairs(runningThreads[weld]) do
		v.event:Fire(false)
		v.event:Destroy()
		pcall(task.cancel, v.thread)
		runningThreads[weld][i] = nil
	end
	local event = signal.new()
	local thread = task.spawn(function()
		local startTime = os.clock()
		local startC0 = weld.C0
		local alpha = 0
		while (alpha < 1) do
			alpha = math.clamp(((os.clock()-startTime)/duration), 0, 1)
			weld.C0 = startC0:Lerp(c0, easingStyle(alpha, 0, 1, 1))
			if (checkBreakStatements(breakStatements)) then event:Fire(false) return end
			HEARTBEAT:Wait()
		end
		event:Fire(alpha >= 1)
	end)
	if (runningThreads[weld]) then
		table.insert(runningThreads[weld], { ['thread'] = thread, ['event'] = event})
	end
	return event:Wait()
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX6EB1EC1C36904BC2AC6EFD738E723411">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Core_Modules_INTERNAL</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX762A6F9624034ACD9E48A121A2F133D3">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Storage</string>
								<string name="ScriptGuid">{09EA6047-4AB2-4093-924A-145F781CFC3D}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXD3C3AC141BF74418BDCF74B5122453FF">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Legacy_Easing</string>
								<string name="ScriptGuid">{63F52CE0-0761-447D-B918-A3EB1011E0BC}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

module.easingStyles = {
	['Linear'] = {Enum.EasingStyle.Linear, Enum.EasingDirection.InOut},
	['In_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.In},
	['Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.Out},
	['In_Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.InOut},
	['In_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.In},
	['Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.Out},
	['In_Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.InOut},
	['In_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.In},
	['Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.Out},
	['In_Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.InOut},
	['In_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.In},
	['Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.Out},
	['In_Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.InOut},
	['In_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.In},
	['Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.Out},
	['In_Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.InOut},
	['In_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.In},
	['Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.Out},
	['In_Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.InOut},
	['In_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.In},
	['Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.Out},
	['In_Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.InOut},
	['In_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.In},
	['Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.Out},
	['In_Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut},
	['In_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.In},
	['In_Out_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.Out},
	['In_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.In},
	['Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.Out},
	['In_Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.InOut},
}
module.easingStyles.functions = {
	--Linear
	Linear = function(t, b, c, d)
		return c * t / d + b 
	end,

	--Quad
	In_Quad = function(t, b, c, d) 
		return c * math.pow(t / d, 2) + b 
	end,

	Out_Quad = function(t, b, c, d)
		t = t / d
		return -c * t * (t - 2) + b
	end,

	In_Out_Quad = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 2) + b end
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end,

	Out_In_Quad = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuad(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Cubic
	In_Cubic = function(t, b, c, d) 
		return c * math.pow(t / d, 3) + b 
	end,

	Out_Cubic = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 3) + 1) + b 
	end,

	In_Out_Cubic = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * t * t * t + b end
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end,

	Out_In_Cubic = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCubic(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end,


	--Quart

	On_Quart = function(t, b, c, d) 
		return c * math.pow(t / d, 4) + b 
	end,

	Out_Quart = function(t, b, c, d) 
		return -c * (math.pow(t / d - 1, 4) - 1) + b 
	end,

	In_Out_Quart = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 4) + b end
		return -c / 2 * (math.pow(t - 2, 4) - 2) + b
	end,

	Out_In_Quart = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuart(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Quint

	In_Quint = function(t, b, c, d)
		return c * math.pow(t / d, 5) + b 
	end,

	Out_Quint = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 5) + 1) + b 
	end,

	In_Out_Quint = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 5) + b end
		return c / 2 * (math.pow(t - 2, 5) + 2) + b
	end,

	Out_In_Quint = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuint(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Sine

	In_Sine = function(t, b, c, d) 
		return -c * math.cos(t / d * (math.pi / 2)) + c + b 
	end,

	Out_Sine = function(t, b, c, d) 
		return c * math.sin(t / d * (math.pi / 2)) + b 
	end,

	In_Out_Sine = function(t, b, c, d) 
		return -c / 2 * (math.cos(math.pi * t / d) - 1) + b 
	end,

	Out_In_Sine = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outSine(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inSine((t * 2) -d, b + c / 2, c / 2, d)
	end,

	--Expo

	In_Expo = function(t, b, c, d)
		if t == 0 then return b end
		return c * math.pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end,

	Out_Expo = function(t, b, c, d)
		if t == d then return b + c end
		return c * 1.001 * (-math.pow(2, -10 * t / d) + 1) + b
	end,

	In_Out_Expo = function(t, b, c, d)
		if t == 0 then return b end
		if t == d then return b + c end
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(2, 10 * (t - 1)) + b - c * 0.0005 end
		return c / 2 * 1.0005 * (-math.pow(2, -10 * (t - 1)) + 2) + b
	end,

	Out_In_Expo = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outExpo(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Circ

	In_Circ = function(t, b, c, d) 
		return(-c * (math.sqrt(1 - math.pow(t / d, 2)) - 1) + b) 
	end,

	Out_Circ = function(t, b, c, d)  
		return(c * math.sqrt(1 - math.pow(t / d - 1, 2)) + b) 
	end,

	In_Out_Circ = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return -c / 2 * (math.sqrt(1 - t * t) - 1) + b end
		t = t - 2
		return c / 2 * (math.sqrt(1 - t * t) + 1) + b
	end,

	Out_In_Circ = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCirc(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end,



	--Back
	Out_Back = function(t, b, c, d, s)
		s = s or 1.2
		t = t / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	end,

	In_Back = function(t, b, c, d, s)
		s = s or 1.70158
		t = t / d
		return c * t * t * ((s + 1) * t - s) + b
	end,

	In_Out_Back = function(t, b, c, d, s)
		s = (s or 1.70158) * 1.525
		t = t / d * 2
		if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end,

	Out_In_Back = function(t, b, c, d, s)
		if t < d / 2 then return module.easingStyles.types.outBack(t * 2, b, c / 2, d, s) end
		return module.easingStyles.types.inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end,

	--bounce

	Out_Bounce = function(t, b, c, d)
		t = t / d
		if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end
		if t < 2 / 2.75 then
			t = t - (1.5 / 2.75)
			return c * (7.5625 * t * t + 0.75) + b
		elseif t < 2.5 / 2.75 then
			t = t - (2.25 / 2.75)
			return c * (7.5625 * t * t + 0.9375) + b
		end
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end,

	In_Bounce = function(t, b, c, d) 
		return c - module.easingStyles.types.outBounce(d - t, 0, c, d) + b 
	end,

	In_Out_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.inBounce(t * 2, 0, c, d) * 0.5 + b end
		return module.easingStyles.types.outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end,

	Out_In_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outBounce(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end,
}

local function checkBreakStatements(statements)
	for i,v in pairs((statements and typeof(statements) == 'function') and statements() or {}) do
		if (v) then return true end
	end
	return false
end

local codeName = 'InterpolationCode'

function module:interpolate(weld: Weld, c0: CFrame, c1: CFrame, easingStyle: any, duration: number, breakStatements: any)
	easingStyle = easingStyle or 'Linear'
	easingStyle = module.easingStyles.functions[easingStyle] or module.easingStyles.functions.Linear
	local newCode = tostring(math.random(0,1e5))
	weld:SetAttribute(codeName, newCode)
	local startTime = os.clock()
	local startC0 = weld.C0
	local startC1 = weld.C1
	local oldCode = weld:GetAttribute(codeName)
	local alpha = 0
	while (alpha <= 1 and weld.C0 ~= c0) do
		alpha = math.clamp(((os.clock()-startTime)/duration), 0, 1)
		weld.C0 = startC0:Lerp(c0, easingStyle(alpha, 0, 1, 1))
		weld.C1 = startC1:Lerp(c1, easingStyle(alpha, 0, 1, 1))
		oldCode = weld:GetAttribute(codeName)
		if (oldCode ~= newCode or checkBreakStatements(breakStatements)) then return false end
		HEARTBEAT:Wait()
	end
	return true
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX644A07341B6A45A0A7E207998C85BBB0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Voice_Module</string>
							<string name="ScriptGuid">{D8718903-C579-4AA7-9372-52F32808DA05}</string>
							<ProtectedString name="Source"><![CDATA[local RunService = game:GetService("RunService")

local voiceModule = {}
voiceModule.__index = voiceModule

local modules = script.Parent:WaitForChild("Modules")
local coreFunctions = require(modules.Core_Functions)

function voiceModule.new(voiceSettings)
	local self = setmetatable(voiceModule, {})
	
	self.voiceSettings = voiceSettings
	
	return self
end

function voiceModule:PlayClip(voiceAudio, clip, pauseThread)
	if (not voiceAudio) then return warn('Cortex Voice Module - No sound instance supplied!') end
	if (not clip) then return warn('Cortex Voice Module - No voice clip supplied!') end
	
	local function run()
		voiceAudio.SoundId = clip.SoundId and "rbxassetid://" .. (clip.SoundId) or "rbxassetid://" .. (self.voiceSettings.SoundId)
		
		if not voiceAudio.IsLoaded then
			coreFunctions.conditionalWait(4, function() return {not voiceAudio.IsLoaded} end)
			if not voiceAudio.IsLoaded then
				return warn("Cortex Voice Module - Sound ID: " .. (voiceAudio.SoundId) .. " has failed to load within 4 seconds, please check if you have access to this audio.")
			end
		end
		
		voiceAudio.Volume = clip.Volume and clip.Volume or self.voiceSettings.Volume
		voiceAudio.Pitch = clip.Pitch and clip.Pitch or self.voiceSettings.Pitch
		voiceAudio.TimePosition = clip.Start or 0
		voiceAudio:Play()
		local clipEnd = clip.End or voiceAudio.TimeLength
		while (voiceAudio.IsPlaying and voiceAudio.TimePosition < clipEnd) do RunService.Heartbeat:Wait() end
		voiceAudio:Stop()
	end
	
	if (pauseThread) then
		run()
	else
		task.spawn(run)
	end
end

return voiceModule]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX87778E4C37C740988B3E4BC1661A6663">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">STOCK_VoiceModule</string>
								<string name="ScriptGuid">{F8A7E9C1-E83F-46F2-AF6B-B4B8850E24A3}</string>
								<ProtectedString name="Source"><![CDATA[return {
	['SoundId'] = 8492151402,
	['Volume'] = 2,
	['Pitch'] = 1,

	['Voice_Clips'] = {
		--[[ Options
			['SoundId'] = Id - Optional
			['Start'] = number -- If not provided it will default to 0
			['End'] = number -- If not provided it will default to clip time length
			['Volume'] = number - Optional
			['Pitch'] = number - Optional
			
			Optional options fallback to the main values at the top of the script if not present
		]]

		--//Floors\\--
		['1st'] = {['Start']=36.709, ['End']=37.334},
		['2nd'] = {['Start']=37.505, ['End']=38.086},
		['3rd'] = {['Start']=38.364, ['End']=38.903},
		['4th'] = {['Start']=39.142, ['End']=39.771},
		['5th'] = {['Start']=39.892, ['End']=40.430},

		--//Labels\\--
		['Floor'] = {['Start']=12.788, ['End']=13.360},
		['Level'] = {['Start']=14.657, ['End']=15.129},
		['Level_Suffix'] = {['Start']=67.700, ['End']=68.209},

		['Lobby'] = {['Start']=66.186, ['End']=66.749},
		['Parking'] = {['Start']=168.366, ['End']=168.992},

		--//Door Announcements\\--
		['Doors_Opening'] = {['Start']=165.380, ['End']=166.381},
		['Doors_Closing'] = {['Start']=166.678, ['End']=167.763},
		['Please_Remove_Obstruction'] = {['Start']=162.309, ['End']=164.397},

		--//Directional Announcements\\--
		['Going_Up'] = {['Start']=159.886, ['End']=160.686},
		['Going_Down'] = {['Start']=160.903, ['End']=161.741},

		--//Other Destination Dispatch Messages\\--
		['Select_Destination'] = {['Start']=0.022, ['End']=1.672},
		['Take_Car'] = {['Start']=1.800, ['End']=2.652},
		['Please_Scan_Access_Card'] = {['Start']=2.986, ['End']=4.469},
		['Handicap_Message'] = {['Start']=5.259, ['End']=10.653},
		['Fire_Recall'] = {['Start']=11.302, ['End']=12.227},
		['Through'] = {['Start']=15.645, ['End']=16.340},
		['And'] = {['Start']=16.456, ['End']=16.968},
		['Going_To'] = {['Start']=13.545, ['End']=14.371},

		--//DESTINATION DISPATCH LETTERING\\--
		['A'] = {['Start']=18.888, ['End']=19.326},
		['B'] = {['Start']=19.524, ['End']=19.889},
		['C'] = {['Start']=20.050, ['End']=20.543},
		['D'] = {['Start']=20.860, ['End']=21.293},
		['E'] = {['Start']=21.585, ['End']=22.033},
		['F'] = {['Start']=22.253, ['End']=22.651},
		['G'] = {['Start']=22.928, ['End']=23.366},
		['H'] = {['Start']=23.391, ['End']=24.578},

		--//FLOOR NUMBERS\\--
		['1'] = {['Start']=111.744, ['End']=112.268},
		['2'] = {['Start']=112.517, ['End']=113.019},
		['3'] = {['Start']=113.325, ['End']=113.942},
	},

	['Floor_Announcements'] = { --To add a voice segment for a floor, add: {{'Segment', ['Delay'] = .1}}
		['1'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'1', ['Delay'] = 0}},
		['2'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'2', ['Delay'] = 0}},
		['3'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'3', ['Delay'] = 0}},
	},

	['Settings'] = {
		['Floor_Announcements'] = {
			['Announce_Floor_On_Arrival'] = true, --Announces the floor the elevators arriving on
			['Announce_Floor_On_Stop'] = false, --Announces the floor the elevators on when the car comes to a full stop
		},
		['Directional_Announcements'] = {
			['Announce_After_Floor_Announcement'] = false, --Announces the direction after the floor announcement
			['Announce_After_Door_Open'] = true, --Announces the direction after the doors have fully opened
			['Up_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Going_Up', ['Delay'] = 0}}},
			['Down_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Going_Down', ['Delay'] = 0}}},
		},
		['Door_Announcements'] = {
			['Open_Announcement'] = {['Enabled'] = false, ['Sequence'] = {{'Doors_Opening', ['Delay'] = 0}}},
			['Close_Announcement'] = {['Enabled'] = false, ['Sequence'] = {{'Doors_Closing', ['Delay'] = 0}}},
			['Nudge_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Please_Remove_Obstruction', ['Delay'] = 0}}},
		},
		['Other_Announcements'] = {
			['Independent_Service_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Fire_Recall_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Safety_Brake_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Inspection_Service_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Out_Of_Service_Announcement'] = {['Enabled'] = true, ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
		},
	},
}]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX1945AEC3757A43FCBFA483255D08874A">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DefaultVoiceModule</string>
								<string name="ScriptGuid">{21394072-366A-42B4-8B5F-D2C899F53416}</string>
								<ProtectedString name="Source"><![CDATA[return function (config, source)
	if config.Voice_Config or config.Options then
		warn("-----------------------------------------------")
		warn("CORTEX VOICE CONFIG: Old config detected!")
		if config.Voice_Config then
			warn("Please rename 'Voice_Config' to 'Floor_Announcements'")
		end
		if config.Options then
			warn("Please rename 'Options' to 'Settings'")
		end
		warn("Or replace the whole file with the updated version")
		warn("Elevator location: " .. (source:GetFullName()))
		warn("-----------------------------------------------")
	end
	return {
		['SoundId'] = config.SoundId and config.SoundId or config.Voice_ID and config.Voice_ID or 0,
		['Volume'] = config.Volume and config.Volume or 1,
		['Pitch'] = config.Pitch and config.Pitch or 1,

		['Voice_Clips'] = config.Voice_Clips and config.Voice_Clips or {},
		['Floor_Announcements'] = config.Floor_Announcements and config.Floor_Announcements or config.Voice_Config and config.Voice_Config or {},

		['Settings'] = {
			['Floor_Announcements'] = {
				['Announce_Floor_On_Arrival'] = config.Settings and config.Settings.Floor_Announcements and config.Settings.Floor_Announcements.Announce_Floor_On_Arrival or false, --Announces the floor the elevators arriving on
				['Announce_Floor_On_Stop'] = config.Settings and config.Settings.Floor_Announcements and config.Settings.Floor_Announcements.Announce_Floor_On_Stop or false, --Announces the floor the elevators on when the car comes to a full stop
			},

			['Directional_Announcements'] = {
				['Announce_After_Floor_Announcement'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Announce_After_Floor_Announcement or false, --Announces the direction after the floor announcement
				['Announce_After_Door_Open'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Announce_After_Door_Open or false, --Announces the direction after the doors have fully opened
				['Up_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Up_Announcement and config.Settings.Directional_Announcements.Up_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Up_Announcement and config.Settings.Directional_Announcements.Up_Announcement.Sequence or {},
				},
				['Down_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Down_Announcement and config.Settings.Directional_Announcements.Down_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Down_Announcement and config.Settings.Directional_Announcements.Down_Announcement.Sequence or {},
				},
			},

			['Door_Announcements'] = {
				['Open_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Open_Announcement and config.Settings.Door_Announcements.Open_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Open_Announcement and config.Settings.Door_Announcements.Open_Announcement.Sequence or {},
				},
				['Close_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Close_Announcement and config.Settings.Door_Announcements.Close_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Close_Announcement and config.Settings.Door_Announcements.Close_Announcement.Sequence or {},
				},
				['Nudge_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Nudge_Announcement and config.Settings.Door_Announcements.Nudge_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Nudge_Announcement and config.Settings.Door_Announcements.Nudge_Announcement.Sequence or {},
				},
			},

			['Other_Announcements'] = {
				['Independent_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Independent_Service_Announcement and config.Settings.Other_Announcements.Independent_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Independent_Service_Announcement and config.Settings.Other_Announcements.Independent_Service_Announcement.Sequence or {},
				},
				['Fire_Recall_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Fire_Recall_Announcement and config.Settings.Other_Announcements.Fire_Recall_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Fire_Recall_Announcement and config.Settings.Other_Announcements.Fire_Recall_Announcement.Sequence or {},
				},
				['Safety_Brake_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Safety_Brake_Announcement and config.Settings.Other_Announcements.Safety_Brake_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Safety_Brake_Announcement and config.Settings.Other_Announcements.Safety_Brake_Announcement.Sequence or {},
				},
				['Inspection_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Inspection_Service_Announcement and config.Settings.Other_Announcements.Inspection_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Inspection_Service_Announcement and config.Settings.Other_Announcements.Inspection_Service_Announcement.Sequence or {},
				},
				['Out_Of_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Out_Of_Service_Announcement and config.Settings.Other_Announcements.Out_Of_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Out_Of_Service_Announcement and config.Settings.Other_Announcements.Out_Of_Service_Announcement.Sequence or {},
				}
			}
		},
	}
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
			</Item>
			<Item class="Folder" referent="RBX666CD25D14BE4E1695B19D6897FC28E3">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<string name="Name">STABLE</string>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBXC58699026275483599406B43C7907177">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Auto_Door_Controller</string>
						<string name="ScriptGuid">{F4946EC1-0FB0-4AC7-AF0E-701456E0F7C7}</string>
						<ProtectedString name="Source"><![CDATA[return function(Script)
	warn('Cortex Auto Door Controller: Initializing...')
	local ranBool,debugInfo = coroutine.resume(coroutine.create(function()
		local this = Script.Parent
		local level = this:WaitForChild('Level')
		local config = this:FindFirstChild('Config')

		if not Script.Parent:FindFirstChild('Config') then
			return assert(false, 'Cortex Sliding Door Engine v1.2.7: Config module not found')
		end

		config = require(config)

		local engines = {}
		local status = 'closed'
		local delta = 0
		local heartbeat = game:GetService('RunService').Heartbeat
		local players = {}
		local doorTime = 0
		local isInSensor,prevInSensor = false,false

		local sensors = this:FindFirstChild('Sensors')

		local weld = function(model, weldPart)
			for i,v in pairs(model:GetDescendants()) do
				if v:IsA('BasePart') then
					if v ~= weldPart then
						local scaler = v.Parent:FindFirstChild('Scaler')
						if scaler then
							for i,v in pairs(scaler.Parent:GetDescendants()) do
								if v:IsA('BasePart') then
									if v ~= weldPart then
										if v ~= scaler and v ~= scaler.Open then
											local wd = Instance.new('Weld', v)
											wd.Name = v.Name..'To'..scaler.Name..'Weld'
											wd.Part0 = v
											wd.C0 = CFrame.new()
											wd.C1 = scaler.CFrame:ToObjectSpace(v.CFrame)
											wd.Part1 = scaler
										elseif v == scaler and not scaler:FindFirstChild('Engine') then
											local wd = Instance.new('ManualWeld', v)
											wd.Name = 'Engine'
											wd.Part0 = v
											wd.C0 = CFrame.new()
											wd.C1 = v.Open.CFrame:ToObjectSpace(v.CFrame)
											wd.Part1 = v.Open
											local openv = Instance.new('CFrameValue', wd)
											openv.Name = 'Open_Pos'
											openv.Value = wd.C1
											local closev = Instance.new('CFrameValue', wd)
											closev.Name = 'Close_Pos'
											closev.Value = wd.C0
											engines[#engines+1] = wd
										elseif v == scaler.Open then
											local wd = Instance.new('Weld', v)
											wd.Name = v.Name..'To'..weldPart.Name..'Weld'
											wd.Part0 = v
											wd.C0 = CFrame.new()
											wd.C1 = weldPart.CFrame:ToObjectSpace(v.CFrame)
											wd.Part1 = weldPart
										end
									end
								end
							end
						end
					end
					v.Anchored = false
				end
			end
		end

		local outputDebugMessage = function(message, outputType, bypass)
			local prefixMessage = 'Cortex Auto Door Controller: '
			if (not config.Debug) and not bypass then return end
			if outputType == 'print' then
				print(prefixMessage..message)
			elseif outputType == 'warn' then
				warn(prefixMessage..message)
			elseif outputType == 'error' then
				error(prefixMessage..message)
			elseif outputType == 'assert' then
				assert(false, prefixMessage..message)
			end
		end

		weld(this.Doors, level)

		for i,v in pairs(this:GetChildren()) do
			if v.Name == 'SensorLight' then
				for i,g in pairs(v:GetDescendants()) do
					if g.Name == 'LED' then
						g.Color = Color3.fromRGB(0, 0, 0)
					end
				end
			end
		end

		local addSound = function(name, id, volume, pitch, looped, part)
			local sound = part:FindFirstChild(name) or Instance.new('Sound', part)
			sound.Name = name
			sound.SoundId = 'rbxassetid://'..tostring(id)
			sound.Volume = volume
			sound.RollOffMaxDistance = 100
			sound.RollOffMinDistance = 4
			sound.Looped = looped
			sound.PlaybackSpeed = pitch
			return sound
		end

		if config.Door_Sound_Loop then
			soundLoop = addSound('Door_Motor_Loop', 142724164, .13, 0, true, level)
			soundLoop:Play()
		end
		local openSound = addSound('Open_Sound', config.Open_Sound.Sound_Id, config.Open_Sound.Volume, config.Open_Sound.Pitch, false, level)
		local closeSound = addSound('Close_Sound', config.Close_Sound.Sound_Id, config.Close_Sound.Volume, config.Close_Sound.Pitch, false, level)
		local sensorBeep = addSound('Sensor_Beep', 1283290053, .7, 2.46, false, level)

		local open = function()
			if status ~= 'closed' and status ~= 'closing' then return end
			status = 'opening'
			openSound:Play()
			outputDebugMessage('Opening doors', 'print', false)
			for i,v in pairs(this:GetChildren()) do
				if v.Name == 'SensorLight' then
					for i,g in pairs(v:GetDescendants()) do
						if g.Name == 'LED' then
							coroutine.wrap(function()
								while status == 'opening' do
									g.Color = Color3.fromRGB(255, 0, 0)
									heartbeat:Wait()
								end
							end)()
						end
					end
				end
			end
			if soundLoop then
				coroutine.wrap(function()
					local tween1 = game:GetService('TweenService'):Create(soundLoop, TweenInfo.new(config.Door_Open_Speed/2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {PlaybackSpeed = .7-(config.Door_Open_Speed/math.pi/2)})
					local tween2 = game:GetService('TweenService'):Create(soundLoop, TweenInfo.new(config.Door_Open_Speed/2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {PlaybackSpeed = 0})
					tween1:Play()
					wait(config.Door_Open_Speed/1)
					tween2:Play()
				end)()
			end
			for i,v in pairs(engines) do
				coroutine.wrap(function()
					local lerpTime = config.Door_Open_Speed*60
					for i=1,lerpTime do
						v.C0 = v.C0:Lerp(v.Open_Pos.Value, (i*i)*delta*.012/math.rad(lerpTime*math.pi)/config.Door_Open_Speed)
						heartbeat:Wait()
						if status ~= 'opening' then return end
					end
					status = 'open'
					outputDebugMessage('Doors opened', 'print', false)
				end)()
			end
			repeat wait() until status == 'open'
		end
		local close = function()
			if status ~= 'open' then return end
			status = 'closing'
			outputDebugMessage('Closing doors', 'print', false)
			for i,v in pairs(this:GetChildren()) do
				if v.Name == 'SensorLight' then
					for i,g in pairs(v:GetDescendants()) do
						if g.Name == 'LED' then
							coroutine.wrap(function()
								while status == 'closing' do
									g.Color = Color3.fromRGB(255, 0, 0)
									wait(.15)
									if status ~= 'closing' then return end
									g.Color = Color3.fromRGB(0, 0, 0)
									wait(.15)
									if status ~= 'closing' then return end
								end
							end)()
						end
					end
				end
			end
			if soundLoop then
				coroutine.wrap(function()
					local tween1 = game:GetService('TweenService'):Create(soundLoop, TweenInfo.new(config.Door_Close_Speed/2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.In), {PlaybackSpeed = .7-(config.Door_Close_Speed/math.pi/2)})
					local tween2 = game:GetService('TweenService'):Create(soundLoop, TweenInfo.new(config.Door_Close_Speed/2.5, Enum.EasingStyle.Linear, Enum.EasingDirection.Out), {PlaybackSpeed = 0})
					tween1:Play()
					wait(config.Door_Close_Speed/1)
					tween2:Play()
				end)()
			end
			for i,v in pairs(engines) do
				coroutine.wrap(function()
					local lerpTime = config.Door_Close_Speed*60
					for i=1,lerpTime do
						v.C0 = v.C0:Lerp(v.Close_Pos.Value, (i*i)*delta*.01/math.rad(lerpTime*math.pi)/config.Door_Close_Speed)
						heartbeat:Wait()
						if status ~= 'closing' then return end
					end
					status = 'closed'
					outputDebugMessage('Doors closed', 'print', false)
				end)()
			end
			if not config.Close_Sound_After_Close then
				closeSound:Play()
			end
			repeat wait() until status == 'closed'
			if config.Close_Sound_After_Close then
				closeSound:Play()
			end
		end

		for i,v in pairs(workspace:GetDescendants()) do
			local human = v:FindFirstChildWhichIsA('Humanoid')
			if human then
				players[#players+1] = v
			end
		end
		workspace.ChildAdded:Connect(function(c)
			wait()
			if c:FindFirstChildWhichIsA('Humanoid') then
				players[#players+1] = c
			end
		end)
		workspace.ChildRemoved:Connect(function(c)
			wait()
			if c:FindFirstChildWhichIsA('Humanoid') then
				for i,v in pairs(players) do
					if v == c then
						table.remove(players, i)
					end
				end
			end
		end)

		if sensors then
			for i,v in pairs(sensors:GetChildren()) do
				if config.Sensor_Type == 'Touch' then
					v.Touched:Connect(function(hit)
						if hit.Parent:FindFirstChild('Humanoid') then
							spawn(open)
						end
					end)
				end
			end
		end

		local api = this:FindFirstChild('API') or Instance.new('BindableEvent', this)
		api.Name = 'API'
		api.Event:Connect(function(event, param1, param2)
			if event == 'Open' then
				spawn(open)
			end
			if event == 'Close' then
				spawn(close)
			end
		end)

		heartbeat:Connect(function(d)
			delta = d
			if status == 'open' then
				doorTime += .025
			else
				doorTime = 0
			end
			if doorTime >= config.Open_Time then
				doorTime = 0
				spawn(close)
			end
			if config.Sensor_Type == 'Region' then
				for i,v in pairs(sensors:GetChildren()) do
					local region = Region3.new(
						Vector3.new(
							v.Position.X - v.Size.X/2,
							v.Position.Y - v.Size.Y/2,
							v.Position.Z - v.Size.Z/2
						),
						Vector3.new(
							v.Position.X + v.Size.X/2,
							v.Position.Y + v.Size.Y/2,
							v.Position.Z + v.Size.Z/2
						)
					)
					isInSensor = #workspace:FindPartsInRegion3WithWhiteList(region, players, math.huge) > 0
					if isInSensor then
						spawn(open)
						doorTime = 0
					end
					if prevInSensor ~= isInSensor then
						prevInSensor = isInSensor
						if prevInSensor and config.Sensor_Beep then
							sensorBeep:Play()
						end
					end
				end
			end
		end)
	end))
	if not ranBool then
		assert(false, 'Cortex Auto Door Controller: Error occured in controller\nStack trace: '..debug.traceback()..'\nError Message: '..debugInfo)
	end
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="ModuleScript" referent="RBX2CA045FCAD324A4FBFD4491018CF920C">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Security_Guard_AI</string>
						<string name="ScriptGuid">{91FB2C19-0D05-48BA-BCB2-CE549CC9D1DE}</string>
						<ProtectedString name="Source"><![CDATA[return function(loader, whitelist, config)
	wait(4)
	local guardModel = loader.Parent
	local npc = loader.Parent:WaitForChild('Security Guard')
	local backup = npc:Clone()
	local root = npc.HumanoidRootPart
	local hum = npc.Humanoid
	local pathService = game:GetService("PathfindingService")	
	local handcuffs = script:WaitForChild("handcuffs"):Clone()
	handcuffs.Parent = game.ReplicatedStorage
	handcuffs.weld.Disabled = false
	local taser = script:WaitForChild("taser"):Clone()
	taser.Parent = game.ReplicatedStorage
	taser.Handle.Anchored = false
	local start = root.Position
	local currentlyArresting
	local isOpeningDoor = false
	local chasing = false
	local delta = 0
	local goingBack = false
	local path = pathService:CreatePath()
	
	
	local whitelist,config = require(whitelist),require(guardModel:FindFirstChild('Config'))
	if not config then return assert(false, 'Security Guard AI: Config module not found') end
	if not whitelist then return assert(false, 'Security Guard AI: Whitelist module not found') end
	local webhookModule = require(script.webhookModule)

	local violators,isViolatorEscorted = {},{}
	
	local api = guardModel:FindFirstChild('API') or Instance.new('BindableEvent', guardModel)
	api.Name = 'API'
	api.Event:Connect(function(protocol, params)

		if (protocol == 'addUsersToViolators') then
			for i,v in pairs(params) do
				local pl = game.Players:GetPlayerFromCharacter(v)
				if ((not pl) or whitelist[tostring(pl.UserId)]) then return end
				if (not violators[pl.UserId]) then
					violators[pl.UserId] = {v, pl}
				end
			end
		end

	end)

	local isChasing = false
	local escorting = false

	local collisions = guardModel.Collisions

	local setNetworkOwner = function(target, owner)
		for i,v in pairs(target:GetDescendants()) do
			if v:IsA("BasePart") then
				local anchor = v.Anchored
				v.Anchored = false
				pcall(function()
					v:SetNetworkOwner(owner)
				end)
				v.Anchored = anchor
			end
		end
	end

	root.Anchored = true

	workspace.ChildAdded:Connect(function(c)
		local pl = game.Players:GetPlayerFromCharacter(c)
		if pl then
			local plrGui = pl:WaitForChild('PlayerGui')
			local bind = script.bindControls:Clone()
			bind.Parent = plrGui
		end
	end)

	for i,pl in pairs(game.Players:GetChildren()) do
		local plrGui = pl:WaitForChild('PlayerGui')
		local bind = script.bindControls:Clone()
		bind.Parent = plrGui
	end

	local bv,bg
	local doors = {}

	local plrRoot,plrHum,plr,char
	local pathfind

	local checkDist = function(target)
		return (root.Position-target.Position).Magnitude
	end

	local toVector2 = function(inputPos)
		return Vector2.new(inputPos.X, inputPos.Z)
	end

	local goBack = function()
		warn(config.guardName..': Something went wrong, going back...', debug.traceback())
		hum:UnequipTools()
		isOpeningDoor = false
		escorting = false
		plrRoot = nil
		chasing = false
		goingBack = true
		pcall(function()
			violators[plr.UserId] = nil
		end)
		plr = nil
		pathfind(root.Position, start)
		isChasing = false
		goingBack = false
	end
	
	function checkSight(target)
		local ray = Ray.new(root.Position,(target.Position - root.Position).Unit * 75)
		local hit,position = workspace:FindPartOnRayWithIgnoreList(ray,{script.Parent})
		if hit then
			if hit:IsDescendantOf(target.Parent) then
				return true
			end
		end
		return false
	end

	pathfind = function(from, to)
		api:Fire('Path_Point_Fire')
		path:ComputeAsync(from, to)
		for i,v in pairs(npc:GetDescendants()) do
			if v:IsA('BasePart') then
				v.Anchored = false
			end
		end
		setNetworkOwner(npc, nil)
		print(config.guardName, path.Status)
		if path.Status == Enum.PathStatus.Success then
			local waypoints = path:GetWaypoints()
			for i=1,#waypoints do
				if (chasing and not goingBack) and ((not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace))) then
					return goBack()
				end
				local point = waypoints[i]
				local pointPos = point.Position
				hum:MoveTo(pointPos)
				if point.Action == Enum.PathWaypointAction.Jump or hum.Sit then
					hum.JumpPower = 50
					hum.Jump = true
				end
				hum.MoveToFinished:Wait()
				if (chasing and not goingBack) and ((not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace))) then
					return goBack()
				end
				if (chasing) then
					if i % 5 == 0 or (plrRoot.Position - waypoints[#waypoints].Position).Magnitude > 15 then
						break 
					end
				end
				if point.Action == Enum.PathWaypointAction.Jump or hum.Sit then
					hum.JumpPower = 50
					hum.Jump = true
				end
			end
		else
			hum:MoveTo(root.Position+Vector3.new(math.random(-30,30), 0, math.random(-30,30)))
			hum.MoveToFinished:Wait()
		end
	end

	hum:GetPropertyChangedSignal('Sit'):Connect(function()
		wait()
		if hum.Sit then
			hum.JumpPower = 50
			hum.Jump = true
		end
	end)

	hum.Died:Connect(function()
		wait(5)
		pcall(function()
			if config.webhookData.sendWebhookDataEnabled.guardDeath.enable then
				webhookModule.sendMsg(config.guardName, '', config.webhookData.profileIcon, {{
					["author"] = {
						["name"] = config.guardName,
						["icon_url"] = config.webhookData.authorIcon
					},
					["description"] = 'Guard died. Respawning...',
					["type"] = "rich",
					["color"] = config.webhookData.sendWebhookDataEnabled.guardDeath.color,
					["image"] = {
						["url"] = config.webhookData.imageUrl
					}
				}}, config.webhookData.webhookUrl)
			end
		end)
		backup.Parent = npc.Parent
		pcall(function()
			handcuffs.Parent = script
		end)
		npc:Destroy()
		local cl = script.reset:Clone()
		cl.Parent = loader
		isChasing = false
		escorting = false
		pcall(function()
			if bv and bg then
				bv:Destroy()
				bg:Destroy()
			end
		end)
		cl.Disabled = false
	end)

	local escortPlayer = function(v, hit)
		--local ran, message = pcall(function()
		plr = game.Players:GetPlayerFromCharacter(hit.Parent)
		if (not isChasing) and plr then
			isChasing = true
			chasing = true
			local val = Instance.new('BoolValue', plr.Character)
			val.Name = 'isChased'
			val.Value = true
			warn(config.guardName..': Now chasing player '..plr.Name..'!')
			currentlyArresting = plr
			char = plr.Character
			plrRoot = char.HumanoidRootPart
			plrHum = char.Humanoid
			if config.tasePlayer then
				hum:EquipTool(taser)
			else
				hum:EquipTool(handcuffs)
			end
			hum.WalkSpeed = 35
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			pathfind(root.Position, plrRoot.Position)
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			if config.tasePlayer then
				taser.Handle.Anchored = false
				hum:EquipTool(taser)
				spawn(function()
					for i=1,15 do
						wait()
						hum.PlatformStand = false
						hum:ChangeState(Enum.HumanoidStateType.RunningNoPhysics)
					end
				end)
				local at1,at2 = Instance.new('Attachment', taser.Handle),Instance.new('Attachment', plrRoot)
				local rod = Instance.new('RopeConstraint', taser.Handle)
				rod.Name = 'taserRod'
				rod.Color = BrickColor.new('Mid gray')
				rod.Attachment0,rod.Attachment1 = at1,at2
				rod.Length = rod.CurrentDistance
				rod.Visible = true
				rod.Thickness = .08
				game:GetService("Debris"):AddItem(at1, 2)
				game:GetService("Debris"):AddItem(at2, 2)
				game:GetService("Debris"):AddItem(rod, 2)
				taser.Handle.Deploy:Play()
				plrHum.PlatformStand = true
				local lastSpeed,lastJp = plrHum.WalkSpeed,plrHum.JumpPower
				plrHum.WalkSpeed = 0
				plrHum.JumpPower = 50
				delay(taser.Handle.Deploy.TimeLength, function()
					if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
						return goBack()
					end
					pathfind(root.Position, plrRoot.Position, false)
					plrHum.PlatformStand = false
					plrHum.WalkSpeed = lastSpeed
					plrHum.JumpPower = lastJp
				end)
				pcall(function()
					hum:EquipTool(handcuffs)
				end)
				wait(4)
				if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
					return goBack()
				end
				local ff = plr.Character:FindFirstChildWhichIsA('ForceField')
				if ff then
					ff:Destroy()
				end
			end
			while (root.Position-plrRoot.Position).Magnitude >= 12 do
				pathfind(root.Position, plrRoot.Position, false)
				if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
					return goBack()
				end
				game:GetService("RunService").Heartbeat:Wait()
			end
			chasing = false
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			pcall(function()
				local noReset = script.noReset:Clone()
				noReset.Parent = plr.PlayerGui
				game:GetService("Debris"):AddItem(noReset, .1)
			end)
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			local anim
			if plrHum.RigType == Enum.HumanoidRigType.R15 then
				anim = plrHum:LoadAnimation(script.arrest_R15)
			elseif plrHum.RigType == Enum.HumanoidRigType.R6 then
				anim = plrHum:LoadAnimation(script.arrest_R6)
			end
			anim:Play()
			handcuffs.Handle.Click:Play()
			warn(config.guardName..': Cuffed '..plr.Name..', escorting...')
			delay(handcuffs.Handle.Click.TimeLength, function()
				hum:UnequipTools()
			end)
			pcall(function()
				if config.webhookData.sendWebhookDataEnabled.arrestPlayer.enable then
					webhookModule.sendMsg(config.guardName, '', config.webhookData.profileIcon, {{
						["author"] = {
							["name"] = config.guardName,
							["icon_url"] = config.webhookData.authorIcon
						},
						["description"] = "User "..plr.Name.." has been arrested and escorted out of the building.",
						["type"] = "rich",
						["color"] = config.webhookData.sendWebhookDataEnabled.arrestPlayer.color,
						["image"] = {
							["url"] = config.webhookData.imageUrl
						}
					}}, config.webhookData.webhookUrl)
				end
			end)
			spawn(function()
				while not escorting do
					if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
						return goBack()
					end
					plrHum.WalkSpeed = 0
					plrHum.JumpPower = 0
					game:GetService("RunService").Heartbeat:Wait()
				end
				while escorting do
					if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
						return goBack()
					end
					plrHum.WalkSpeed = 0
					plrHum.JumpPower = 0
					game:GetService("RunService").Heartbeat:Wait()
				end
			end)
			wait(2)
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			hum.WalkSpeed = 18
			bv = Instance.new("BodyVelocity", plrRoot)
			bv.MaxForce = Vector3.new(100000, 0, 100000)
			bv.Velocity = Vector3.new(0, 0, 0)
			bg = Instance.new("BodyGyro", plrRoot.Parent:FindFirstChild('LowerTorso') or plrRoot.Parent:FindFirstChild('Torso'))
			bg.MaxTorque = Vector3.new(0, 100000, 0)
			bg.CFrame = plrRoot.CFrame
			bg.D = 100
			if config.forceCameraTowardsGuard then
				pcall(function()
					local client = script.forceCamera:Clone()
					client.guard.Value = npc
					client.Parent = plr.PlayerGui
				end)
			end
			wait(1)
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			escorting = true
			isViolatorEscorted[plr.UserId] = plr.UserId
			-- dooropenlock
			--for i,l in pairs(workspace.Doors:GetChildren()) do
			--	if l.Name =="PeponDoorsV2" then
			--		l.securityguardopen:Fire()
			--	end
			--end
			-- dooropenlock end
			spawn(function()
				pathfind(root.Position, guardModel.escortPos.Position, false)
				wait(1)
				escorting = false
			end)
			while escorting do
				wait()
				if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
					return goBack()
				end
				bv.Velocity = -(plrRoot.Position-(root.Position-(root.CFrame.LookVector*4)))*3
				bg.CFrame = CFrame.new(plrRoot.Position, (root.Position-(root.CFrame.LookVector*4)))
			end
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			pcall(function()
				val:Destroy()
				bv:Destroy()
				bg:Destroy()
			end)
			pcall(function()
				if plr.PlayerGui:FindFirstChild('forceCamera') then
					plr.PlayerGui.forceCamera.guard.Value = nil
					plr.PlayerGui.forceCamera:Destroy()
				end
			end)
			pcall(function()
				if config.webhookData.sendWebhookDataEnabled.playerRelease.enable then
					webhookModule.sendMsg(config.guardName, '', config.webhookData.profileIcon, {{
						["author"] = {
							["name"] = config.guardName,
							["icon_url"] = config.webhookData.authorIcon
						},
						["description"] = "User "..plr.Name.." has been released.",
						["type"] = "rich",
						["color"] = config.webhookData.sendWebhookDataEnabled.playerRelease.color,
						["image"] = {
							["url"] = config.webhookData.imageUrl
						}
					}}, config.webhookData.webhookUrl)
				end
			end)
			wait(2)
			if (not isChasing) or (not plr) or (not plr.Character) or (not plrHum:IsDescendantOf(workspace)) then
				return goBack()
			end
			hum:UnequipTools()
			anim:Stop()
			delay(.1, function()
				plrHum.JumpPower = 50
				plrHum.WalkSpeed = 16
			end)
			isViolatorEscorted[plr.UserId] = nil
			api:Fire('userReleased', plr)
			-- dooropenlock
			--for i,l in pairs(workspace.Doors:GetChildren()) do
			--	if l.Name =="PeponDoorsV2" then
			--		l.securityguardopen:Fire()
			--	end
			--end
			-- dooropenlock end
			wait(1)
			pathfind(root.Position, start, hum)
			wait(.5)
			root.Anchored = true
			isChasing = false
			chasing = false
			violators[plr.UserId] = nil
		end
		--end)
		--return ran, message
	end
	
	game.Players.PlayerRemoving:Connect(function(plr)
		
		wait()
		if ((not violators[plr.UserId]) or currentlyArresting ~= plr) then return end
		api:Fire('userReleased', plr)
		
	end)

	local run = function(v, hit)
		--local ran, message = escortPlayer(v, hit)
		--return assert(ran, message)
		local pl = game.Players:GetPlayerFromCharacter(hit.Parent)
		if pl then
			if hit then
				escortPlayer(v, hit)
			end
		end
	end

	for i,v in pairs(collisions:GetChildren()) do
		v.Touched:Connect(function(hit)
			local pl = game.Players:GetPlayerFromCharacter(hit.Parent)
			if pl and whitelist[tostring(pl.UserId)] then return end
			pcall(function()
				if not isViolatorEscorted[pl.UserId] and not pl.Character:FindFirstChild('isChased') then
					pl.Character:MoveTo(v.tpPos.Position)
				end
			end)
			if pl and not violators[pl.UserId] then
				violators[pl.UserId] = {v, hit, pl}
			end
		end)
	end

	spawn(function()
		while wait() do
			for i,v in pairs(violators) do
				--pcall(function()
				run(v[1], v[2])
				--end)
			end
		end
	end)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Tool" referent="RBXD917085AFD114C25B92F7997169CF4C0">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="CanBeDropped">false</bool>
							<bool name="Enabled">true</bool>
							<CoordinateFrame name="Grip">
								<X>0</X>
								<Y>0</Y>
								<Z>0</Z>
								<R00>0</R00>
								<R01>1</R01>
								<R02>0</R02>
								<R10>1</R10>
								<R11>0</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>-1</R22>
							</CoordinateFrame>
							<bool name="ManualActivationOnly">false</bool>
							<string name="Name">handcuffs</string>
							<bool name="RequiresHandle">true</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureId"><null></null></Content>
							<string name="ToolTip"></string>
						</Properties>
						<Item class="UnionOperation" referent="RBXB3BD65EBF616460087EE0AD3EADC5138">
							<Properties>
								<bool name="Anchored">true</bool>
								<Content name="AssetId"><url>http://www.roblox.com//asset/?id=200429635</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.3168335</X>
									<Y>-35.2185326</Y>
									<Z>-26.1496735</Z>
									<R00>-3.97830036e-07</R00>
									<R01>-1</R01>
									<R02>0</R02>
									<R10>1</R10>
									<R11>3.97830036e-07</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<BinaryString name="ChildData"></BinaryString>
								<SharedString name="ChildData2">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<token name="FormFactor">0</token>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<Vector3 name="InitialSize">
									<X>2.00001526</X>
									<Y>5.00000048</Y>
									<Z>1.05004883</Z>
								</Vector3>
								<BinaryString name="LODData"></BinaryString>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="MaterialVariantSerialized"></string>
								<BinaryString name="MeshData"></BinaryString>
								<SharedString name="MeshData2">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<string name="Name">Handle</string>
								<SharedString name="PhysicalConfigData">bsGaillY16UJhg3GeV9BEw==</SharedString>
								<BinaryString name="PhysicsData"></BinaryString>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<token name="RenderFidelity">1</token>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="SmoothingAngle">0</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">1</float>
								<bool name="UsePartColor">true</bool>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="size">
									<X>0.800006151</X>
									<Y>2.00000048</Y>
									<Z>0.420019567</Z>
								</Vector3>
							</Properties>
							<Item class="Sound" referent="RBX43EF2B60D8C140C2A8D426CF4491DC65">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<bool name="Looped">false</bool>
									<string name="Name">Click</string>
									<bool name="PlayOnRemove">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://1279090548</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">2</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBXFA251610B7FF44DAA9C2DD5CD93CF876">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.4003296</X>
									<Y>-34.5832405</Y>
									<Z>-26.0553131</Z>
									<R00>-0.999922693</R00>
									<R01>-0.0124348849</R01>
									<R02>1.92787647e-05</R02>
									<R10>-0.000282016845</R10>
									<R11>0.0242916401</R11>
									<R12>0.999704897</R12>
									<R20>-0.0124316849</R20>
									<R21>0.99962759</R21>
									<R22>-0.02429327</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX4B36288B51F8478285A7C7B4D468EEF8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBXD38600ECA4E246F998F327A157BE0E52">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>70.9271774</X>
									<Y>-34.6803093</Y>
									<Z>-26.0589142</Z>
									<R00>-0.865951002</R00>
									<R01>0.49997434</R01>
									<R02>0.0124327447</R02>
									<R10>0.499604553</R10>
									<R11>0.865913153</R11>
									<R12>-0.0242882352</R12>
									<R20>-0.0229091719</R20>
									<R21>-0.0148209697</R21>
									<R22>-0.99962765</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBXC2CBE69787174548BE28CEF4A15EAA3B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="UnionOperation" referent="RBXF188ED3F0A3647C09271D37BE57CB8E8">
							<Properties>
								<bool name="Anchored">true</bool>
								<Content name="AssetId"><url>http://www.roblox.com//asset/?id=375935302</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.961731</X>
									<Y>-35.1594276</Y>
									<Z>-26.032547</Z>
									<R00>0.865959406</R00>
									<R01>-0.499959916</R01>
									<R02>-0.0124315713</R02>
									<R10>0.500111938</R10>
									<R11>0.865620196</R11>
									<R12>0.0242863204</R12>
									<R20>-0.00138116803</R20>
									<R21>-0.0272481423</R21>
									<R22>0.999627769</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<BinaryString name="ChildData"></BinaryString>
								<SharedString name="ChildData2">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<token name="FormFactor">0</token>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<Vector3 name="InitialSize">
									<X>14.1999722</X>
									<Y>16.3999996</Y>
									<Z>1.2300086</Z>
								</Vector3>
								<BinaryString name="LODData"></BinaryString>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<BinaryString name="MeshData"></BinaryString>
								<SharedString name="MeshData2">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<string name="Name">Union</string>
								<SharedString name="PhysicalConfigData">R/kNg3o2+1j2PvHmTgPeDA==</SharedString>
								<BinaryString name="PhysicsData"></BinaryString>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<token name="RenderFidelity">1</token>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="SmoothingAngle">0</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<bool name="UsePartColor">false</bool>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="size">
									<X>0.860320091</X>
									<Y>0.993610203</Y>
									<Z>0.0745215267</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Part" referent="RBXDDE9C0AC8E674EFAAD251A9A90162D64">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.1193161</X>
									<Y>-34.6195564</Y>
									<Z>-26.0579987</Z>
									<R00>-0.865951002</R00>
									<R01>0.49997434</R01>
									<R02>0.0124327447</R02>
									<R10>0.499604553</R10>
									<R11>0.865913153</R11>
									<R12>-0.0242882352</R12>
									<R20>-0.0229091719</R20>
									<R21>-0.0148209697</R21>
									<R22>-0.99962765</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBXFEE3DF94D0024A8595E071EA035FC5DB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBXA3B8F1FE6CE8488E989B5DD7D9701E5D">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.5930176</X>
									<Y>-34.6439133</Y>
									<Z>-26.0515289</Z>
									<R00>-0.865947306</R00>
									<R01>-0.0124336928</R01>
									<R02>0.499980688</R02>
									<R10>0.499610871</R10>
									<R11>0.0242911279</R11>
									<R12>0.865909398</R12>
									<R20>-0.0229115486</R20>
									<R21>0.99962759</R21>
									<R22>-0.0148228314</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX63C8419860E342BC81EFAE01D479DAA0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX6E6184C56DEC411EA6ACEF7FC9843A68">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.2162476</X>
									<Y>-34.5833397</Y>
									<Z>-26.0576401</Z>
									<R00>-0.999922693</R00>
									<R01>-0.0124348849</R01>
									<R02>1.92787647e-05</R02>
									<R10>-0.000282016845</R10>
									<R11>0.0242916401</R11>
									<R12>0.999704897</R12>
									<R20>-0.0124316849</R20>
									<R21>0.99962759</R21>
									<R22>-0.02429327</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBXA7718F413B0A4C46B78BFF75E7588047">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="UnionOperation" referent="RBX192C443F76CE4E758433B944036B664C">
							<Properties>
								<bool name="Anchored">true</bool>
								<Content name="AssetId"><url>http://www.roblox.com//asset/?id=375935302</url></Content>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>70.6766891</X>
									<Y>-35.1600266</Y>
									<Z>-26.0484772</Z>
									<R00>-0.865951002</R00>
									<R01>0.49997434</R01>
									<R02>0.0124327447</R02>
									<R10>0.499604553</R10>
									<R11>0.865913153</R11>
									<R12>-0.0242882352</R12>
									<R20>-0.0229091719</R20>
									<R21>-0.0148209697</R21>
									<R22>-0.99962765</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<BinaryString name="ChildData"></BinaryString>
								<SharedString name="ChildData2">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<token name="FormFactor">0</token>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<Vector3 name="InitialSize">
									<X>14.1999722</X>
									<Y>16.3999996</Y>
									<Z>1.2300086</Z>
								</Vector3>
								<BinaryString name="LODData"></BinaryString>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<BinaryString name="MeshData"></BinaryString>
								<SharedString name="MeshData2">yuZpQdnvvUBOTYh1jqZ2cA==</SharedString>
								<string name="Name">Union</string>
								<SharedString name="PhysicalConfigData">R/kNg3o2+1j2PvHmTgPeDA==</SharedString>
								<BinaryString name="PhysicsData"></BinaryString>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<token name="RenderFidelity">1</token>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="SmoothingAngle">0</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<bool name="UsePartColor">false</bool>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="size">
									<X>0.860320091</X>
									<Y>0.993610203</Y>
									<Z>0.0745215267</Z>
								</Vector3>
							</Properties>
						</Item>
						<Item class="Part" referent="RBX647BB78F0E864A828C9FA2B6E4E171FF">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.4970093</X>
									<Y>-34.6195641</Y>
									<Z>-26.053299</Z>
									<R00>-0.865951002</R00>
									<R01>0.49997434</R01>
									<R02>0.0124327447</R02>
									<R10>0.499604553</R10>
									<R11>0.865913153</R11>
									<R12>-0.0242882352</R12>
									<R20>-0.0229091719</R20>
									<R21>-0.0148209697</R21>
									<R22>-0.99962765</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBXDE4F06903D7D46CCAB8C437AA72D0773">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX84A3AFC3C2374892B6C30CACB8CFB315">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.0232468</X>
									<Y>-34.6439018</Y>
									<Z>-26.058609</Z>
									<R00>-0.865962684</R00>
									<R01>-0.0124344341</R01>
									<R02>-0.499954194</R02>
									<R10>-0.500106275</R10>
									<R11>0.0242909547</R11>
									<R12>0.865623415</R12>
									<R20>0.00138082774</R20>
									<R21>0.99962759</R21>
									<R22>-0.027253598</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBXC9ED35C117B34342B238D5F78A2E5DBB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX467C81CA6A124B058CF2CD41C5693200">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.3058472</X>
									<Y>-34.5711632</Y>
									<Z>-26.056778</Z>
									<R00>-0.865951002</R00>
									<R01>0.49997434</R01>
									<R02>0.0124327447</R02>
									<R10>0.499604553</R10>
									<R11>0.865913153</R11>
									<R12>-0.0242882352</R12>
									<R20>-0.0229091719</R20>
									<R21>-0.0148209697</R21>
									<R22>-0.99962765</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX355A8A9237FF47B284FBFF2C444386CF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Part" referent="RBX0FA9FAF48D074DB4B2A193DA38FB38E2">
							<Properties>
								<bool name="Anchored">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>71.6773071</X>
									<Y>-34.6921692</Y>
									<Z>-26.0493317</Z>
									<R00>-0.865951002</R00>
									<R01>0.49997434</R01>
									<R02>0.0124327447</R02>
									<R10>0.499604553</R10>
									<R11>0.865913153</R11>
									<R12>-0.0242882352</R12>
									<R20>-0.0229091719</R20>
									<R21>-0.0148209697</R21>
									<R22>-0.99962765</R22>
								</CoordinateFrame>
								<bool name="CanCollide">false</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4288914085</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">false</bool>
								<bool name="Massless">false</bool>
								<token name="Material">272</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Part</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0.100000001</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>0.265064001</X>
									<Y>0.200000003</Y>
									<Z>0.265064627</Z>
								</Vector3>
							</Properties>
							<Item class="SpecialMesh" referent="RBX8BED349F85BC4894AF8BB75F0E011C58">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=3270017</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>0.132532001</X>
										<Y>0.132531911</Y>
										<Z>0.132532313</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><null></null></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
						<Item class="Script" referent="RBXBF7F926A2492471DA709776F03D9AE72">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">weld</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{F8151E60-864E-46DB-BFEA-A60FDB6A1BA4}</string>
								<ProtectedString name="Source"><![CDATA[-- Created by Quenty (@Quenty, follow me on twitter).
-- Should work with only ONE copy, seamlessly with weapons, trains, et cetera.
-- Parts should be ANCHORED before use. It will, however, store relatives values and so when tools are reparented, it'll fix them.

--[[ INSTRUCTIONS
- Place in the model
- Make sure model is anchored
- That's it. It will weld the model and all children. 

THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 
THIS SCRIPT SHOULD BE USED ONLY BY ITSELF. THE MODEL SHOULD BE ANCHORED. 

This script is designed to be used is a regular script. In a local script it will weld, but it will not attempt to handle ancestory changes. 
]]

--[[ DOCUMENTATION
- Will work in tools. If ran more than once it will not create more than one weld.  This is especially useful for tools that are dropped and then picked up again.
- Will work in PBS servers
- Will work as long as it starts out with the part anchored
- Stores the relative CFrame as a CFrame value
- Takes careful measure to reduce lag by not having a joint set off or affected by the parts offset from origin
- Utilizes a recursive algorith to find all parts in the model
- Will reweld on script reparent if the script is initially parented to a tool.
- Welds as fast as possible
]]

-- qPerfectionWeld.lua
-- Created 10/6/2014
-- Author: Quenty
-- Version 1.0.3

-- Updated 10/14/2014 - Updated to 1.0.1
--- Bug fix with existing ROBLOX welds ? Repro by asimo3089

-- Updated 10/14/2014 - Updated to 1.0.2
--- Fixed bug fix. 

-- Updated 10/14/2014 - Updated to 1.0.3
--- Now handles joints semi-acceptably. May be rather hacky with some joints. :/

local NEVER_BREAK_JOINTS = false -- If you set this to true it will never break joints (this can create some welding issues, but can save stuff like hinges).


local function CallOnChildren(Instance, FunctionToCall)
	-- Calls a function on each of the children of a certain object, using recursion.  

	FunctionToCall(Instance)

	for _, Child in next, Instance:GetChildren() do
		CallOnChildren(Child, FunctionToCall)
	end
end

local function GetNearestParent(Instance, ClassName)
	-- Returns the nearest parent of a certain class, or returns nil

	local Ancestor = Instance
	repeat
		Ancestor = Ancestor.Parent
		if Ancestor == nil then
			return nil
		end
	until Ancestor:IsA(ClassName)

	return Ancestor
end

local function GetBricks(StartInstance)
	local List = {}

	-- if StartInstance:IsA("BasePart") then
	-- 	List[#List+1] = StartInstance
	-- end

	CallOnChildren(StartInstance, function(Item)
		if Item:IsA("BasePart") then
			List[#List+1] = Item;
		end
	end)

	return List
end

local function Modify(Instance, Values)
	-- Modifies an Instance by using a table.  

	assert(type(Values) == "table", "Values is not a table");

	for Index, Value in next, Values do
		if type(Index) == "number" then
			Value.Parent = Instance
		else
			Instance[Index] = Value
		end
	end
	return Instance
end

local function Make(ClassType, Properties)
	-- Using a syntax hack to create a nice way to Make new items.  

	return Modify(Instance.new(ClassType), Properties)
end

local Surfaces = {"TopSurface", "BottomSurface", "LeftSurface", "RightSurface", "FrontSurface", "BackSurface"}
local HingSurfaces = {"Hinge", "Motor", "SteppingMotor"}

local function HasWheelJoint(Part)
	for _, SurfaceName in pairs(Surfaces) do
		for _, HingSurfaceName in pairs(HingSurfaces) do
			if Part[SurfaceName].Name == HingSurfaceName then
				return true
			end
		end
	end
	
	return false
end

local function ShouldBreakJoints(Part)
	--- We do not want to break joints of wheels/hinges. This takes the utmost care to not do this. There are
	--  definitely some edge cases. 

	if NEVER_BREAK_JOINTS then
		return false
	end
	
	if HasWheelJoint(Part) then
		return false
	end
	
	local Connected = Part:GetConnectedParts()
	
	if #Connected == 1 then
		return false
	end
	
	for _, Item in pairs(Connected) do
		if HasWheelJoint(Item) then
			return false
		elseif not Item:IsDescendantOf(script.Parent) then
			return false
		end
	end
	
	return true
end

local function WeldTogether(Part0, Part1, JointType, WeldParent)
	--- Weld's 2 parts together
	-- @param Part0 The first part
	-- @param Part1 The second part (Dependent part most of the time).
	-- @param [JointType] The type of joint. Defaults to weld.
	-- @param [WeldParent] Parent of the weld, Defaults to Part0 (so GC is better).
	-- @return The weld created.

	JointType = JointType or "Weld"
	local RelativeValue = Part1:FindFirstChild("qRelativeCFrameWeldValue")
	
	local NewWeld = Part1:FindFirstChild("qCFrameWeldThingy") or Instance.new(JointType)
	Modify(NewWeld, {
		Name = "qCFrameWeldThingy";
		Part0  = Part0;
		Part1  = Part1;
		C0     = CFrame.new();--Part0.CFrame:inverse();
		C1     = RelativeValue and RelativeValue.Value or Part1.CFrame:toObjectSpace(Part0.CFrame); --Part1.CFrame:inverse() * Part0.CFrame;-- Part1.CFrame:inverse();
		Parent = Part1;
	})

	if not RelativeValue then
		RelativeValue = Make("CFrameValue", {
			Parent     = Part1;
			Name       = "qRelativeCFrameWeldValue";
			Archivable = true;
			Value      = NewWeld.C1;
		})
	end

	return NewWeld
end

local function WeldParts(Parts, MainPart, JointType, DoNotUnanchor)
	-- @param Parts The Parts to weld. Should be anchored to prevent really horrible results.
	-- @param MainPart The part to weld the model to (can be in the model).
	-- @param [JointType] The type of joint. Defaults to weld. 
	-- @parm DoNotUnanchor Boolean, if true, will not unachor the model after cmopletion.
	
	for _, Part in pairs(Parts) do
		if ShouldBreakJoints(Part) then
			Part:BreakJoints()
		end
	end
	
	for _, Part in pairs(Parts) do
		if Part ~= MainPart then
			WeldTogether(MainPart, Part, JointType, MainPart)
		end
	end

	if not DoNotUnanchor then
		for _, Part in pairs(Parts) do
			Part.Anchored = false
		end
		MainPart.Anchored = false
	end
end

local function PerfectionWeld()	
	local Tool = GetNearestParent(script, "Tool")

	local Parts = GetBricks(script.Parent)
	local PrimaryPart = Tool and Tool:FindFirstChild("Handle") and Tool.Handle:IsA("BasePart") and Tool.Handle or script.Parent:IsA("Model") and script.Parent.PrimaryPart or Parts[1]

	if PrimaryPart then
		WeldParts(Parts, PrimaryPart, "Weld", false)
	else
		warn("qWeld - Unable to weld part")
	end
	
	return Tool
end

local Tool = PerfectionWeld()


if Tool and script.ClassName == "Script" then
	--- Don't bother with local scripts

	script.Parent.AncestryChanged:connect(function()
		PerfectionWeld()
	end)
end

-- Created by Quenty (@Quenty, follow me on twitter).
]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Script" referent="RBX3EA3D2ADFC9E45A2A78C9FE1B68175BC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">reset</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{9060E24F-6544-4D87-98AE-331808F3270B}</string>
							<ProtectedString name="Source"><![CDATA[script.Parent.Disabled = true
wait(.2)
script.Parent.Disabled = false
script:Destroy()]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBXDF7E27F9267F4E16AAC6DF06B855EB84">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">bindControls</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{6F7499A9-F14B-4BDE-8BCA-9106591B700E}</string>
							<ProtectedString name="Source"><![CDATA[local controlScript = require(game.Players.LocalPlayer.PlayerScripts:WaitForChild("PlayerModule"):WaitForChild("ControlModule"))

function script.binder.OnClientInvoke(bind)
	if bind then
		controlScript:Enable()
	else
		controlScript:Disable()
	end
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="RemoteFunction" referent="RBX8D6DF7FE7AAD456CA1F1556E5B556B81">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">binder</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBXB83D9B1BA38B4610B850B6A4D2C58748">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">noReset</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{A941C495-50D2-4B2C-967E-6FE3D03C325E}</string>
							<ProtectedString name="Source">game.StarterGui:SetCore(&quot;ResetButtonCallback&quot;, false)</ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="LocalScript" referent="RBXB655C732D70842978264F3CBE37E45D4">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">setSpeed</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{86620AD5-1BE4-4773-A0AC-8D4A6BE29B53}</string>
							<ProtectedString name="Source"><![CDATA[game.Players.LocalPlayer.Character:WaitForChild("Humanoid"):GetPropertyChangedSignal("WalkSpeed"):Connect(function()
	game.Players.LocalPlayer.Character:WaitForChild("Humanoid").WalkSpeed = 0
	game.Players.LocalPlayer.Character:WaitForChild("Humanoid").JumpPower = 0
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBXC341BAEF106C4181B172C117F00E6586">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://4214898369</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">arrest_R15</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Animation" referent="RBX97B654EC6FC643E79CF4E5118A776DBC">
						<Properties>
							<Content name="AnimationId"><url>rbxassetid://5931094202</url></Content>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">arrest_R6</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="Tool" referent="RBX5897948805B143BCB359B22DAD5D0CBB">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="CanBeDropped">true</bool>
							<bool name="Enabled">true</bool>
							<CoordinateFrame name="Grip">
								<X>0</X>
								<Y>-0.400000006</Y>
								<Z>0.400000006</Z>
								<R00>1</R00>
								<R01>0</R01>
								<R02>0</R02>
								<R10>0</R10>
								<R11>1</R11>
								<R12>0</R12>
								<R20>0</R20>
								<R21>0</R21>
								<R22>1</R22>
							</CoordinateFrame>
							<bool name="ManualActivationOnly">false</bool>
							<string name="Name">taser</string>
							<bool name="RequiresHandle">true</bool>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
							<Content name="TextureId"><url>http://www.roblox.com/asset/?id=242902382</url></Content>
							<string name="ToolTip">Taser</string>
						</Properties>
						<Item class="Part" referent="RBX07610A6F3723433A9BD2B3AEF4DE58C0">
							<Properties>
								<bool name="Anchored">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<float name="BackParamA">-0.5</float>
								<float name="BackParamB">0.5</float>
								<token name="BackSurface">0</token>
								<token name="BackSurfaceInput">0</token>
								<float name="BottomParamA">-0.5</float>
								<float name="BottomParamB">0.5</float>
								<token name="BottomSurface">0</token>
								<token name="BottomSurfaceInput">0</token>
								<CoordinateFrame name="CFrame">
									<X>-158.286514</X>
									<Y>47.2720528</Y>
									<Z>-144.739594</Z>
									<R00>0</R00>
									<R01>-1.69406589e-21</R01>
									<R02>-1</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>1.69406589e-21</R12>
									<R20>1</R20>
									<R21>0</R21>
									<R22>0</R22>
								</CoordinateFrame>
								<bool name="CanCollide">true</bool>
								<bool name="CanQuery">true</bool>
								<bool name="CanTouch">true</bool>
								<bool name="CastShadow">true</bool>
								<int name="CollisionGroupId">0</int>
								<Color3uint8 name="Color3uint8">4279970357</Color3uint8>
								<PhysicalProperties name="CustomPhysicalProperties">
									<CustomPhysics>false</CustomPhysics>
								</PhysicalProperties>
								<float name="FrontParamA">-0.5</float>
								<float name="FrontParamB">0.5</float>
								<token name="FrontSurface">0</token>
								<token name="FrontSurfaceInput">0</token>
								<float name="LeftParamA">-0.5</float>
								<float name="LeftParamB">0.5</float>
								<token name="LeftSurface">0</token>
								<token name="LeftSurfaceInput">0</token>
								<bool name="Locked">true</bool>
								<bool name="Massless">false</bool>
								<token name="Material">256</token>
								<string name="MaterialVariantSerialized"></string>
								<string name="Name">Handle</string>
								<CoordinateFrame name="PivotOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
									<R00>1</R00>
									<R01>0</R01>
									<R02>0</R02>
									<R10>0</R10>
									<R11>1</R11>
									<R12>0</R12>
									<R20>0</R20>
									<R21>0</R21>
									<R22>1</R22>
								</CoordinateFrame>
								<float name="Reflectance">0</float>
								<float name="RightParamA">-0.5</float>
								<float name="RightParamB">0.5</float>
								<token name="RightSurface">0</token>
								<token name="RightSurfaceInput">0</token>
								<int name="RootPriority">0</int>
								<Vector3 name="RotVelocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="TopParamA">-0.5</float>
								<float name="TopParamB">0.5</float>
								<token name="TopSurface">0</token>
								<token name="TopSurfaceInput">0</token>
								<float name="Transparency">0</float>
								<Vector3 name="Velocity">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<token name="formFactorRaw">3</token>
								<token name="shape">1</token>
								<Vector3 name="size">
									<X>1</X>
									<Y>1.61800003</Y>
									<Z>0.617999971</Z>
								</Vector3>
							</Properties>
							<Item class="Sound" referent="RBX0D46BB787684438AA5A0363FC42009BF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<float name="EmitterSize">10</float>
									<bool name="Looped">false</bool>
									<string name="Name">Deploy</string>
									<bool name="PlayOnRemove">false</bool>
									<float name="PlaybackSpeed">1</float>
									<bool name="Playing">false</bool>
									<token name="RollOffMode">0</token>
									<Ref name="SoundGroup">null</Ref>
									<Content name="SoundId"><url>rbxassetid://277635663</url></Content>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="TimePosition">0</double>
									<float name="Volume">1</float>
									<float name="xmlRead_MaxDistance_3">10000</float>
								</Properties>
							</Item>
							<Item class="SpecialMesh" referent="RBXEC353A9604884201B09A5B4683B3BB18">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<token name="LODX">2</token>
									<token name="LODY">2</token>
									<Content name="MeshId"><url>http://www.roblox.com/asset/?id=82337638</url></Content>
									<token name="MeshType">5</token>
									<string name="Name">Mesh</string>
									<Vector3 name="Offset">
										<X>0</X>
										<Y>0</Y>
										<Z>0</Z>
									</Vector3>
									<Vector3 name="Scale">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Content name="TextureId"><url>http://www.roblox.com/asset/?id=82337709</url></Content>
									<Vector3 name="VertexColor">
										<X>1</X>
										<Y>1</Y>
										<Z>1</Z>
									</Vector3>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Script" referent="RBX6384BEA3119644FA9BB659BD6ECFEE90">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ragdollR6</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{5297D23E-C9EF-4954-A5D6-78B8844E828E}</string>
							<ProtectedString name="Source"><![CDATA[function ragdoll(noob)

	local dead = Instance.new("VelocityMotor",noob)
	dead.Name = "Ragdolled"

	if noob:FindFirstChild('Head') then
		local socket = Instance.new("BallSocketConstraint",noob.Head)
		local acth1 = Instance.new("Attachment",noob.Head)
		acth1.Position = Vector3.new(0,-0.5,0)
		local acth2 = Instance.new("Attachment",noob.Torso)
		acth2.Position = Vector3.new(0,1,0)
		socket.Attachment0 = acth1
		socket.Attachment1 = acth2
	end

	if noob:FindFirstChild('Right Arm') then
		local socket2 = Instance.new("BallSocketConstraint",noob["Right Arm"])
		local acth3 = Instance.new("Attachment",noob["Right Arm"])
		acth3.Position = Vector3.new(0,0.5,0)
		local acth4 = Instance.new("Attachment",noob.Torso)
		acth4.Position = Vector3.new(1.5,0.5,0)
		socket2.Attachment0 = acth3
		socket2.Attachment1 = acth4
	end

	if noob:FindFirstChild('Left Arm') then
		local socket3 = Instance.new("BallSocketConstraint",noob["Left Arm"])
		local acth5 = Instance.new("Attachment",noob["Left Arm"])
		acth5.Position = Vector3.new(0,0.5,0)
		local acth6 = Instance.new("Attachment",noob.Torso)
		acth6.Position = Vector3.new(-1.5,0.5,0)
		socket3.Attachment0 = acth5
		socket3.Attachment1 = acth6
	end

	if noob:FindFirstChild('Right Leg') then
		local socket4 = Instance.new("BallSocketConstraint",noob["Right Leg"])
		local acth7 = Instance.new("Attachment",noob["Right Leg"])
		acth7.Position = Vector3.new(0,1,0)
		local acth8 = Instance.new("Attachment",noob.Torso)
		acth8.Position = Vector3.new(0.5,-1,0)
		socket4.Attachment0 = acth7
		socket4.Attachment1 = acth8
	end

	if noob:FindFirstChild('Left Leg') then
		local socket5 = Instance.new("BallSocketConstraint",noob["Left Leg"])
		local acth9 = Instance.new("Attachment",noob["Left Leg"])
		acth9.Position = Vector3.new(0,1,0)
		local acth10 = Instance.new("Attachment",noob.Torso)
		acth10.Position = Vector3.new(-0.5,-1,0)
		socket5.Attachment0 = acth9
		socket5.Attachment1 = acth10
	end
end

function ragdoll2(person)
	local RM = Instance.new("Model",workspace)
	for _, c in pairs(person:GetChildren()) do
		if (not c:IsA('LocalScript')) and (not c:IsA('Script')) and (not c:IsA('ModuleScript')) then
			c.Parent = RM
		end
	end
	ragdoll(RM)
	local RH2 = RM:FindFirstChildWhichIsA("Humanoid")
	RH2.DisplayDistanceType = 'None'
	local RH3 = RH2:Clone()
	RH3.Parent = RM
	RH3.Health = 100
	RH3.PlatformStand = true
	RH2:Destroy()

	for _, c in pairs(RM:GetChildren()) do
		if c:IsA("Part") or c:IsA("MeshPart") then
			local LC = c:Clone()
			LC.Parent = RM
			LC.Name = 'FakeLimb'
			LC.Size = c.Size - Vector3.new(0.3,0.3,0.3)
			LC.Transparency = 1
			LC.CanCollide = true
			local weld = Instance.new("Weld",c)
			weld.Part0 = c
			weld.Part1 = LC
			if c.Name == 'Head' then
				local camscript = script.CamAttach:Clone()
				camscript.Parent = script.Parent
				camscript.CamPart.Value = c
			end
		end
	end


	wait(4.5)
	RM:Destroy()

end

local Hum = script.Parent:WaitForChild('Humanoid')
if Hum then
	ragdoll2(script.Parent)
	script:Destroy()
end
]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="LocalScript" referent="RBXA1365C729783489A96930F72CBB2A487">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="Disabled">false</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">CamAttach</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{D0268BE7-F56B-4588-BED8-6F43B0E7E352}</string>
								<ProtectedString name="Source"><![CDATA[wait()
game.Workspace.CurrentCamera.CameraSubject = script.CamPart.Value]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ObjectValue" referent="RBX10388FC4498F4ADFBACB75708BD0D27C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">CamPart</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Ref name="Value">null</Ref>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="Script" referent="RBX58189FA8A9C5423184C6CC782C431D68">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">true</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">ragdollR15</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{ED7324AE-CDED-43AF-93CD-1035E5BA6FC2}</string>
							<ProtectedString name="Source"><![CDATA[--------------------------------------------------------
---------- Version 2.0 ---------------------------------
---------- Released 8/17/2017 --------------------------
---------- Written by orange451 ------------------------
--------------------------------------------------------
wait();

local DEBUG = false;

function waitFor( directory, name ) 
	while ( directory == nil or (name ~= nil and directory:FindFirstChild(name) == nil) ) do
		wait(0.1);
	end
	if ( name == nil ) then
		return directory;
	else
		return directory:FindFirstChild(name);
	end
end

function getCharacter()
	return script.Parent;
end

function getPlayer()
	return game.Players:GetPlayerFromCharacter(getCharacter());
end

function getHumanoid()
	return waitFor( getCharacter(), "Humanoid" );
end

function getNearestPlayer( position )
	local Players = game.Players:GetChildren();
	local dist = math.huge;
	local ret = nil;
	for i=1,#Players do
		local Player = Players[i];
		local Character = Player.Character;
		if ( Character ~= nil ) then
			local Root = Character:FindFirstChild("HumanoidRootPart");
			if ( Root ~= nil ) then
				local t = (position - Root.Position).magnitude;
				if ( t < dist ) then
					dist = t;
					ret = Player;
				end
			end
		end
	end
	
	return ret;
end

local RootLimbData = {
	{
		["WeldTo"]			= "LowerTorso",
		["WeldRoot"]		= "HumanoidRootPart",
		["AttachmentName"]	= "Root",
		["NeedsCollider"]	= false,
		["UpperAngle"]		= 10
	},
	{
		["WeldTo"]			= "UpperTorso",
		["WeldRoot"]		= "LowerTorso",
		["AttachmentName"]	= "Waist",
		["ColliderOffset"]	= CFrame.new(0, 0.5, 0),
		["UpperAngle"]		= 0
	},
	{
		["WeldTo"]			= "Head",
		["WeldRoot"]		= "UpperTorso",
		["AttachmentName"]	= "Neck",
		["ColliderOffset"]	= CFrame.new(),
		["UpperAngle"]		= 20
	},
	{
		["WeldTo"]			= "LeftUpperLeg",
		["WeldRoot"]		= "LowerTorso",
		["AttachmentName"]	= "LeftHip",
		["ColliderOffset"]	= CFrame.new(0, -0.5, 0)
	},
	{
		["WeldTo"]			= "RightUpperLeg",
		["WeldRoot"]		= "LowerTorso",
		["AttachmentName"]	= "RightHip",
		["ColliderOffset"]	= CFrame.new(0, -0.5, 0)
	},
	{
		["WeldTo"]			= "RightLowerLeg",
		["WeldRoot"]		= "RightUpperLeg",
		["AttachmentName"]	= "RightKnee",
		["ColliderOffset"]	= CFrame.new(0, -0.5, 0)
	},
	{
		["WeldTo"]			= "LeftLowerLeg",
		["WeldRoot"]		= "LeftUpperLeg",
		["AttachmentName"]	= "LeftKnee",
		["ColliderOffset"]	= CFrame.new(-0.05, -0.5, 0)
	},
	{
		["WeldTo"]			= "RightUpperArm",
		["WeldRoot"]		= "UpperTorso",
		["AttachmentName"]	= "RightShoulder",
		["ColliderOffset"]	= CFrame.new(0.05, 0.45, 0.15),
	},
	{
		["WeldTo"]			= "LeftUpperArm",
		["WeldRoot"]		= "UpperTorso",
		["AttachmentName"]	= "LeftShoulder",
		["ColliderOffset"]	= CFrame.new(0, 0.45, 0.15),
	},
	{
		["WeldTo"]			= "LeftLowerArm",
		["WeldRoot"]		= "LeftUpperArm",
		["AttachmentName"]	= "LeftElbow",
		["ColliderOffset"]	= CFrame.new(0, 0.125, 0),
		["UpperAngle"]		= 10
	},
	{
		["WeldTo"]			= "RightLowerArm",
		["WeldRoot"]		= "RightUpperArm",
		["AttachmentName"]	= "RightElbow",
		["ColliderOffset"]	= CFrame.new(0, 0.125, 0),
		["UpperAngle"]		= 10
	},
	{
		["WeldTo"]			= "RightHand",
		["WeldRoot"]		= "RightLowerArm",
		["AttachmentName"]	= "RightWrist",
		["ColliderOffset"]	= CFrame.new(0, 0.125, 0),
		["UpperAngle"]		= 0
	},
	{
		["WeldTo"]			= "LeftHand",
		["WeldRoot"]		= "LeftLowerArm",
		["AttachmentName"]	= "LeftWrist",
		["ColliderOffset"]	= CFrame.new(0, 0.125, 0),
		["UpperAngle"]		= 0
	},
	{
		["WeldTo"]			= "LeftFoot",
		["WeldRoot"]		= "LeftLowerLeg",
		["AttachmentName"]	= "LeftAnkle",
		["NeedsCollider"]	= false,
		["UpperAngle"]		= 0
	},
	{
		["WeldTo"]			= "RightFoot",
		["WeldRoot"]		= "RightLowerLeg",
		["AttachmentName"]	= "RightAnkle",
		["NeedsCollider"]	= false,
		["UpperAngle"]		= 0
	},
}

local RootPart = nil;
local MotorList = {};
local GlueList = {};
local ColliderList = {};

function deactivate()
	print("Unragdolling");
	if ( RootPart == nil ) then
		return;
	end
	
	-- Move to Players Location
	local UpperTorso = getCharacter():FindFirstChild("UpperTorso");
	if ( UpperTorso ~= nil ) then
		UpperTorso:SetNetworkOwner(nil);
		RootPart.CFrame = UpperTorso.CFrame;
	end
	
	-- Replace Motors
	for i=1,#MotorList do
		local MotorData = MotorList[i];
		local PartTo = MotorData[1];
		local Motor = MotorData[2];
		Motor.Parent = PartTo;
	end
	
	-- Remove Glues
	for i=1,#GlueList do
		GlueList[i]:Destroy();
	end
	
	-- Remove Colliders
	for i=1,#ColliderList do
		ColliderList[i]:Destroy();
	end
	
	-- Replace Humanoid Stuff
	getHumanoid().PlatformStand = false;
	RootPart.Parent = getCharacter();
	
	-- Restart
	MotorList = {};
	GlueList = {};
	RootPart = nil;
end

function activate()
	print("Ragdolling");
	local Character = getCharacter();
	local Humanoid = getHumanoid();
	local HumanoidRoot = script.Parent:FindFirstChild("HumanoidRootPart");
	if ( HumanoidRoot == nil ) then
		print("Cannot create ragdoll");
		return;
	end
	local Position = script.Parent.HumanoidRootPart.Position;
	Humanoid.PlatformStand = true;
	
	-- Handle death specific ragdoll. Will Clone you, then destroy you.
	local RagDollModel = Character;
	if ( (Humanoid.Health <= 0) and script.ActivateOnDeath.CloneAndDestroy.Value ) then
		Character:FindFirstChild("HumanoidRootPart"):Destroy();
		Character.Archivable = true;
		RagDollModel = Character:Clone();
		RagDollModel.Name = "RagDoll";
			
		local t = RagDollModel:GetChildren();
		for i=1,#t do
			local t2 = t[i];
			if ( t2:IsA("Script") or t2:IsA("LocalScript") ) then
				t2:Destroy();
			end
		end
		
		spawn(function()
			wait();
			RagDollModel.Humanoid.PlatformStand = true;
			game.Debris:AddItem(RagDollModel, script.ActivateOnDeath.CloneAndDestroy.Delay.Value);
		end)
		
		RagDollModel.Humanoid.DisplayDistanceType = Enum.HumanoidDisplayDistanceType.None;
		RagDollModel.Humanoid.HealthDisplayType = Enum.HumanoidHealthDisplayType.AlwaysOff;
		RagDollModel.Humanoid.Health = 0;
		RagDollModel.Parent = game.Workspace;
		
		local RagDollPointer = Instance.new("ObjectValue");
		RagDollPointer.Value = RagDollModel;
		RagDollPointer.Name = "RagDoll";
		RagDollPointer.Parent = Character;
	end
	
	-- Reglue The Character
	for i=1,#RootLimbData do
		local limbData = RootLimbData[i];
		local partName = limbData["WeldTo"];
		local weldName = limbData["WeldRoot"];
		local PartTo = RagDollModel:FindFirstChild(partName);
		local WeldTo = RagDollModel:FindFirstChild(weldName);
		
		if ( PartTo ~= nil and WeldTo ~= nil ) then
			if ( RagDollModel ~= nil ) then
				if ( script.ApplyRandomVelocity.Value ) then
					local scale = script.ApplyRandomVelocity.Force.Value;
					local vecX = (math.random()-math.random())*scale;
					local vecY = (math.random()-math.random())*scale;
					local vecZ = (math.random()-math.random())*scale;
					PartTo.Velocity = PartTo.Velocity + Vector3.new(vecX, vecY, vecZ);
				end
				PartTo.Parent = RagDollModel;
			end
			-- Create New Constraint
			local UpperAngle = limbData["UpperAngle"];
			local Joint = Instance.new("BallSocketConstraint");
			if ( (UpperAngle ~= nil and UpperAngle == 0) or (script.WeldHead.Value and partName == "Head") ) then
				Joint = Instance.new("HingeConstraint");
				Joint.UpperAngle = 0;
				Joint.LowerAngle = 0;
			end
			Joint.Name = limbData["AttachmentName"];
			Joint.LimitsEnabled = true;
			Joint.Attachment0 = PartTo:FindFirstChild(Joint.Name .. "RigAttachment");
			Joint.Attachment1 = WeldTo:FindFirstChild(Joint.Name .. "RigAttachment");
			Joint.Parent = PartTo;
			GlueList[#GlueList+1] = Joint;
			if ( UpperAngle ~= nil ) then
				Joint.UpperAngle = UpperAngle;
			end
			
			-- Destroy the motor attaching it
			local Motor = PartTo:FindFirstChildOfClass("Motor6D");
			if ( Motor ~= nil ) then
				if ( Humanoid.Health <= 0 ) then
					Motor:Destroy();
				else
					MotorList[#MotorList+1] = { PartTo, Motor };
					Motor.Parent = nil;
				end
			end
			
			-- Create Collider
			local needsCollider = limbData["NeedsCollider"];
			if ( needsCollider == nil ) then
				needsCollider = true;
			end
			if ( needsCollider ) then
				local B = Instance.new("Part");
				B.CanCollide = true;
				B.TopSurface = 0;
				B.BottomSurface = 0;
				B.formFactor = "Symmetric";
				B.Size = Vector3.new(0.7, 0.7, 0.7);
				B.Transparency = 1;
				B.BrickColor = BrickColor.Red();
				B.Parent = RagDollModel;
				local W = Instance.new("Weld");
				W.Part0 = PartTo;
				W.Part1 = B;
				W.C0 = limbData["ColliderOffset"];
				W.Parent = PartTo;
				ColliderList[#ColliderList+1] = B;
			end
		end
	end

	-- Destroy Root Part
	local root = Character:FindFirstChild("HumanoidRootPart");
	if ( root ~= nil ) then
		RootPart = root;
		if ( Humanoid.Health <= 0 ) then
			RootPart:Destroy();
		else
			RootPart.Parent = nil;
		end
	end	
	
	-- Delete all my parts if we made a new ragdoll
	if ( RagDollModel ~= Character ) then
		print("Deleting character");
		local children = Character:GetChildren();
		for i=1,#children do
			local child = children[i];
			if ( child:IsA("BasePart") or child:IsA("Accessory") ) then
				child:Destroy();
			end
		end
	end
	
	-- Give player physics
	if ( script.GivePlayerPhysics.Value ) then
		local PlayerPhysics = getPlayer();
		if ( script.GivePlayerPhysics.ForceNearestPlayer.Value ) then
			PlayerPhysics = getNearestPlayer( Position );
		end
		
		local Children = RagDollModel:GetChildren();
		for i=1,#Children do
			local Child = Children[i];
			if ( Child:IsA("BasePart") ) then
				Child:SetNetworkOwner(PlayerPhysics);
			end
		end
	end
	
	-- Copy plugins into ragdoll
	local Plugins = script.Plugins:GetChildren();
	for i=1,#Plugins do
		local Plugin = Plugins[i];
		local Copy = Plugin:Clone();
		if ( Copy:IsA("Script") ) then
			Copy.Disabled = false;
		end
		Copy.Parent = RagDollModel;
	end
end

-- Wait for torso (assume everything else will load at the same time)
waitFor( getCharacter(), "UpperTorso" );

-- Activate when we die.
getHumanoid().Died:Connect(function()
	if ( script.ActivateOnDeath.Value ) then
		script.Activate.Value = true;
	end
end);

-- Activate when setting is checked.
script.Activate.Changed:Connect(function(value)
	if ( value ) then
		activate();
	else
		deactivate();
	end
end);

-- Activate it on start.
if ( script.Activate.Value ) then
	activate();
	script:Destroy()
end]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="BoolValue" referent="RBXFC5CF96416974C6F8580611FC60179D6">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">GivePlayerPhysics</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Value">true</bool>
							</Properties>
							<Item class="BoolValue" referent="RBX7D85CC618C70498F921ACF4FA2E34D05">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">ForceNearestPlayer</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
						</Item>
						<Item class="BoolValue" referent="RBXEDB3624BA22E405F94BB27FF50949DB7">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">ActivateOnDeath</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Value">false</bool>
							</Properties>
							<Item class="BoolValue" referent="RBX776A17F247504E4E9B0866C1445E3075">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">CloneAndDestroy</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">true</bool>
								</Properties>
								<Item class="IntValue" referent="RBXA1C3B21FFF8E4A1F8DB35B0A8C67FA09">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<string name="Name">Delay</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<int64 name="Value">12</int64>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Script" referent="RBX5DC7B010909246D18488E4E6819B9851">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Readme</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{3AC21394-1359-425B-9E4C-116463E1F135}</string>
								<ProtectedString name="Source"><![CDATA[--------------------------------------------------------
---------- Version 2.0 ---------------------------------
---------- Released 8/17/2017 --------------------------
---------- Written by orange451 ------------------------
--------------------------------------------------------

--[[
	
To use this script, place it in: (( Game --> StarterPlayer --> StarterCharacterScripts ))


To activate it, set the scripts Activate boolean value to TRUE.

SETTINGS:
	- Activate
		- This flag, when set to true, will activate the ragdoll effect (alive or dead)
		
	- Weld Head
		- If set to true, a stuff joint will be used on the neck to prevent the head from moving while ragdolled.
		
	- GivePlayerPhysics
		- When the ragdoll effect is active, this flag will force the player who is being ragdolled to control the physics of the ragdoll. 
		- If it is set to false, the roblox server decides who has the physics.
		
			- ForceClosestPlayer
				- For this to work, GivePlayerPhysics must be set to true
				- This will search for the nearest Player object to thie ragdoll, and set him as the physics holder.
				- This is useful for NPC's, who are not owned by a player, and you want accurate Ragdolls.
		
	- ApplyRandomVelocity
		- This will set every part in the player to have a random amount of velocity applied.
		- Helps to keep ragdolls unique every time

	- ActiveOnDeath
		- This flag, when set to true, will force the ragdoll to activate when your character dies.	
			
			- CloneAndDestroy
				- For this to work, ActiveOnDeath must be set to true.
				- This will, when your character dies, clone your body into a new model named "RagDoll". (Parent is workspace)
				- Can be useful to set the collision group of ragdolls, as you can listen for models named "RagDoll" to be added to the workspace.
				- This will also place an ObjectValue named "RagDoll" inside your Character, so it is easy to find the newly created RagDoll.
					
					- Delay
						- For this to work, CloneAndDestroy must be set to true.
						- This is the amount of time before the ragdoll is removed from the workspace. 
	

EXAMPLE PROGRAM:
	local Character = game.Workspace.Player1;
	local Ragdoll = Character.RagdollR15;
	Ragdoll.Activate.Value = true;
	wait(5);
	Ragdoll.Activate.Value = false;
--]]

]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX5AF4E227E5174BAB915326703C69BC1F">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">WeldHead</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Value">true</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBXACFD6685E42B47A18A11D33C7468AE82">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Activate</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Value">true</bool>
							</Properties>
						</Item>
						<Item class="BoolValue" referent="RBX7D0F8B5F3632406B8055A390ABB7E387">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">ApplyRandomVelocity</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<bool name="Value">false</bool>
							</Properties>
							<Item class="NumberValue" referent="RBXBA91BA15E08B4B6C8DD9143E31C9F84D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Force</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">20</double>
								</Properties>
							</Item>
						</Item>
						<Item class="Folder" referent="RBX3F8CC7114C564A409377205FDAD67DB4">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Plugins</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="LocalScript" referent="RBX2CF3F346280749FFBD1A6796360AF0A5">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">forceCamera</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{A2E5D6C8-D845-491A-A4F4-E5B4ED23A338}</string>
							<ProtectedString name="Source"><![CDATA[local connection
connection = game:GetService("RunService").RenderStepped:Connect(function()
	if (not script.guard.Value) or (not script.guard.Value:FindFirstChild('HumanoidRootPart')) then return connection:Disconnect() end
	workspace.CurrentCamera.CFrame = workspace.CurrentCamera.CFrame:Lerp(CFrame.new(workspace.CurrentCamera.CFrame.p, script.guard.Value.Head.CFrame.p), .16)
end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ObjectValue" referent="RBX277A50BEEBD044BDAE7E792A75E4311E">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">guard</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Ref name="Value">null</Ref>
							</Properties>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX26453CDE25CE47BE9D8683EA7B6E9511">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">webhookModule</string>
							<string name="ScriptGuid">{45264533-B505-4122-82BB-B364BD8416F3}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

local https = game:GetService("HttpService")

module.sendMsg = function(username, message, pfp, embed, webhookUrl)
	local data
	if not embed then
		data = {
			['username'] = username,
			['content'] = message,
			['avatar_url'] = pfp,
		}
	elseif embed then
		data = {
			['username'] = username,
			['avatar_url'] = pfp,
			['embeds'] = embed
		}
	end
	https:PostAsync(webhookUrl, https:JSONEncode(data))
end

return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXED5992B8F19142D7B73F7A0E4A7160A5">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">TravelFiccient</string>
						<string name="ScriptGuid">{37719238-2DC2-4747-9623-AAEAF7AE60F9}</string>
						<ProtectedString name="Source"><![CDATA[local module = {}
return function(A, _Settings, _Voice_Module)
	local _Pad_Settings = require(A:WaitForChild('Settings'))
	local Model = _Settings.Parent
	local oriSettings = _Settings
	_Settings = require(_Settings)
	local _Display = A:WaitForChild('Screen'):FindFirstChild('Display') or script.Assets.Display:Clone()
	_Display.Parent = A:WaitForChild('Screen')
	local _Services = {
		['_Run_Service'] = game:GetService('RunService'),
		['_Tween_Service'] = game:GetService('TweenService')
	}
	local collectionService = game:GetService('CollectionService')
	local _Transitioning = false
	local _Input_Time = 0
	local _Keypad_Input_Time = 0
	local _Timeout_Locked = false
	local _Pad_Timeout = _Settings['Display']['Pad_Fade_Timeout']
	local _Input = ''
	local _Keypad_Enabled = true
	local _Elevator_Found
	local _Input_Locked = false
	local _Handicap_Locked = false
	local running = false
	local isScannerActivated = false
	local _Handicap = false
	local isFireRecall = false
	local lastFrame
	local thisFloor = tonumber(_Display.Parent.Parent.Parent.Name:sub(7))
	local screenTransitioning = false
	local _Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive
	local _Btn_Debounce = false
	local _Btn_Debounce_M = false
	local _Is_Handicap_Used = false
	local voiceModule = _Voice_Module;
	_Voice_Module = require(_Voice_Module);


	local voiceConfig = require(voiceModule.STOCK_VoiceModule);

	if (_Settings.Voice_Config and _Settings.Voice_Config.Enabled) then
		voiceConfig = _Settings.Voice_Config
	end

	local _Voice = Instance.new('Sound', _Display.Parent)
	_Voice.SoundId = 'rbxassetid://'..tostring(voiceConfig.Voice_ID)
	_Voice.MaxDistance = 30
	_Voice.EmitterSize = 3
	_Voice.Volume = voiceConfig.Volume
	_Voice.Name = 'Voice'
	local _Equalizer = Instance.new('EqualizerSoundEffect', _Voice)
	_Equalizer.HighGain = 0
	_Equalizer.LowGain = -80
	_Equalizer.MidGain = 0
	local _Voice_Labels = _Settings['Voice_Config']['Voice_Labels']

	local scannerReady = false
	local scannerActive = false
	local currentFrame
	local scannerLight = A.LED
	local scannerLogo = A.SCAN_LOGO
	local scannerTouchConnection
	local readerBeep = Instance.new('Sound', A.Screen)
	readerBeep.Name = 'Reader_Beep'
	readerBeep.SoundId = 'rbxassetid://3378132335'
	readerBeep.Volume = 2
	readerBeep.MaxDistance = 70
	readerBeep.EmitterSize = 3

	print('TravelFiccient v2.0 starting...')
	--//Pasted from the config
	local themeConfig = _Settings['Theme']

	local elevators = Model:WaitForChild('Elevators')
	
	function check(dest, elevs)
		return require(script.Allocator).allocateElevator(tonumber(dest), (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name)), elevs)
	end

	if not themeConfig then
		themeConfig = {['Theme'] = {
			['Theme_Type'] = 'Dark', --Default theme is Dark if this setting does not exist. If set to Custom, the panel will use the settings below.
			['Custom_Theme'] = {
				--//Type: Gradient, uses Start and End input color values. Type: Solid, only uses the Start input color value.
				['Background_Color'] = {['Type'] = {'Gradient', ['Start'] = Color3.fromRGB(0, 0, 0), ['End'] = Color3.fromRGB(0, 0, 0),
					['Rotation'] = 0,
					['Transparency'] = 0,
					['Offset'] = Vector2.new(0, 0) --First number resembles the X axis (horizontal), and the second number resembles the Y axis (vertical).
				}},
				['Text_Color'] = Color3.fromRGB(255, 255, 255),
				['Button_Config'] = {

					['Background'] = {
						['Neutral'] = Color3.fromRGB(0, 0, 0),
						['Active'] = Color3.fromRGB(255, 255, 255),
					},
					['Text'] = {
						['Neutral'] = Color3.fromRGB(255, 255, 255),
						['Active'] = Color3.fromRGB(0, 0, 0),
					},

				}
			}
		}}
	else
		if themeConfig.Theme_Type == 'Dark' then
			themeConfig = {['Theme'] = {
				['Theme_Type'] = themeConfig.Theme_Type, --Default theme is Dark if this setting does not exist. If set to Custom, the panel will use the settings below.
				['Custom_Theme'] = {
					--//Type: Gradient, uses Start and End input color values. Type: Solid, only uses the Start input color value.
					['Background_Color'] = {['Type'] = {'Solid', ['Start'] = Color3.fromRGB(0, 0, 0), ['End'] = Color3.fromRGB(0, 0, 0),
						['Rotation'] = 0,
						['Transparency'] = 0,
						['Offset'] = Vector2.new(0, 0) --First number resembles the X axis (horizontal), and the second number resembles the Y axis (vertical).
					}},
					['Text_Color'] = Color3.fromRGB(255, 255, 255),
					['Button_Config'] = {

						['Background'] = {
							['Neutral'] = Color3.fromRGB(0, 0, 0),
							['Active'] = Color3.fromRGB(255, 255, 255),
						},
						['Text'] = {
							['Neutral'] = Color3.fromRGB(255, 255, 255),
							['Active'] = Color3.fromRGB(0, 0, 0),
						},

					}
				}
			}}
		elseif themeConfig.Theme_Type == 'Light' then
			themeConfig = {['Theme'] = {
				['Theme_Type'] = themeConfig.Theme_Type, --Default theme is Dark if this setting does not exist. If set to Custom, the panel will use the settings below.
				['Custom_Theme'] = {
					--//Type: Gradient, uses Start and End input color values. Type: Solid, only uses the Start input color value.
					['Background_Color'] = {['Type'] = {'Solid', ['Start'] = Color3.fromRGB(255, 255, 255), ['End'] = Color3.fromRGB(255, 255, 255),
						['Rotation'] = 0,
						['Transparency'] = 0,
						['Offset'] = Vector2.new(0, 0) --First number resembles the X axis (horizontal), and the second number resembles the Y axis (vertical).
					}},
					['Text_Color'] = Color3.fromRGB(0, 0, 0),
					['Button_Config'] = {

						['Background'] = {
							['Neutral'] = Color3.fromRGB(255, 255, 255),
							['Active'] = Color3.fromRGB(154, 154, 154),
						},
						['Text'] = {
							['Neutral'] = Color3.fromRGB(0, 0, 0),
							['Active'] = Color3.fromRGB(0, 0, 0),
						},

					}
				}
			}}
		elseif themeConfig.Theme_Type == 'Custom' then
			themeConfig = {['Theme'] = themeConfig}
		end
	end

	for i,v in pairs(_Display:GetDescendants()) do
		if v.Name == 'Theme_Gradient_Controller' then
			local nd = (themeConfig.Theme.Custom_Theme.Background_Color.Type[1] == 'Gradient') and themeConfig.Theme.Custom_Theme.Background_Color.Type.End or themeConfig.Theme.Custom_Theme.Background_Color.Type.Start
			v.Color = ColorSequence.new(themeConfig.Theme.Custom_Theme.Background_Color.Type.Start, nd)
			v.Offset = themeConfig.Theme.Custom_Theme.Background_Color.Type.Offset
			v.Rotation = themeConfig.Theme.Custom_Theme.Background_Color.Type.Rotation
			v.Transparency = NumberSequence.new(themeConfig.Theme.Custom_Theme.Background_Color.Type.Transparency)
			if v.Parent:IsA('TextLabel') then
				v.Parent.BackgroundColor3 = themeConfig.Theme.Custom_Theme.Text_Color
				v.Color = ColorSequence.new(themeConfig.Theme.Custom_Theme.Text_Color, themeConfig.Theme.Custom_Theme.Text_Color)
			elseif v.Parent:IsA('ImageLabel') then
				v.Color = ColorSequence.new(themeConfig.Theme.Custom_Theme.Text_Color, themeConfig.Theme.Custom_Theme.Text_Color)
				v.Parent.ImageColor3 = themeConfig.Theme.Custom_Theme.Text_Color
			end
		elseif v:IsA('TextLabel') then
			v.TextColor3 = themeConfig.Theme.Custom_Theme.Text_Color
			v.BorderColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral
		end
	end

	local T_API = game.ServerScriptService:FindFirstChild('TravelFiccient_API') or Instance.new('BindableFunction', game.ServerScriptService)
	T_API.Name = 'TravelFiccient_API'
	local L_API = Model:FindFirstChild('Local_API') or Instance.new('BindableEvent', Model)
	L_API.Name = 'Local_API'
	function T_API.OnInvoke(Target_Model, Event, Part1, Part2, Part3)
		if Target_Model == Model then
			if Event == 'Allocate_Elevator' then
				local elevator = check(Part1, elevators:GetChildren())
				if elevator then
					if (_Handicap) then
						Hall_Lanterns(elevator, Part1)
					end
					_Keypad_Input_Time = 0
					if (not elevator) then
						return spawn(function()
							_Timeout_Locked = true
							_Input_Locked = true
							_TransitionTo(lastFrame, _Display.No_Elevator)
							wait(2.5)
							_Input = ''
							_Display.Keypad.Input.Text = ''
							_TransitionTo(_Display.No_Elevator, lastFrame)
							_Timeout_Locked = false
							_Input_Locked = false
							_Btn_Debounce = false
							_Handicap = false
							_Handicap_Locked = false
							_Is_Handicap_Used = false
						end)
					end
					coroutine.wrap(function()
						_Request_Elevator_Call(elevator, Part1, Part2)
					end)()
					_Timeout_Locked = true
					_Input_Locked = true
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
					wait(.2)
					_Display.Elevator.Visible = true
					_Display.Elevator.Main.Elevator.Text = elevator.Name
					_Display.Elevator.Floor.Text = 'To '..(_Settings['Display']['Custom_Floor_Label'][tostring(Part1)] or tostring(Part1))
					local direction = _Pad_Settings['Directionals'][elevator.Name]
					local arrow = _Display.Elevator.Main.Arrow
					_Is_Handicap_Used = false
					local rotation_index = {
						['Right'] = -90,
						['Right_Behind'] = -50,
						['Right_Ahead'] = -140,
						['Left'] = 90,
						['Left_Behind'] = 50,
						['Left_Ahead'] = 140,
						['Ahead'] = 180,
						['Behind'] = 0,
					}
					if (direction and rotation_index[direction]) then
						arrow.Rotation = rotation_index[direction]
					end
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
					wait(5)
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
					wait(.2)
					_Display.Elevator.Visible = false
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
					wait(.2)
					for i,grp in pairs(_Display.Floor_Selection:GetChildren()) do
						if string.match(grp.Name, 'Group_') then
							for i,btn in pairs(grp:GetChildren()) do
								if btn:IsA('TextButton') then
									_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
									_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
								end
							end
						end
					end
					for i,grp in pairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
						if string.match(grp.Name, 'Group_') then
							if grp:IsA('TextButton') then
								_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
								_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
							end
						end
					end
					_Btn_Debounce = false
					_Handicap = false
					_Handicap_Locked = false
					_Is_Handicap_Used = false
					_Input = ''
					_Display.Keypad.Input.Text = ''
					_Timeout_Locked = false
					_Input_Locked = false
					_Request_Elevator_Call(elevator, Part1, Part2)
					return elevator
				else
					return error('TravelFiccient: Unable to allocate nearest elevator.')
				end
			end
		end
	end

	local function playVoiceClip(clipName, pauseThread)

		_Voice_Module:PlayClip(_Voice, voiceConfig.Voice_Clips[clipName], pauseThread)

	end

	local function playVoiceSequenceProtocol(clipSequence, pauseThread)

		local function run()
			for index,item in pairs(clipSequence) do
				playVoiceClip(item[1], true)
				wait(item.Delay)
			end
		end
		if (pauseThread) then
			run()
		else
			coroutine.wrap(function()
				run()
			end)()
		end

	end

	L_API.Event:Connect(function(Event, Part1, Part2, Part3)
		if Event == 'Fire_Recall' then
			while (_Transitioning) do wait() end
			_TransitionTo(_Display.Home, _Display.Fire_Recall)
			_Input_Locked = true
			_Timeout_Locked = true
			_Handicap = false
			_Handicap_Locked = true
			_Is_Handicap_Used = false
			coroutine.wrap(function()
				for i=1,5 do
					if (not isFireRecall) then return end
					playVoiceClip('Fire_Recall', true)
					wait(2.5)
				end
			end)()
		end
		if Event == 'Fire_Recall_Off' then
			_Btn_Debounce = false
			_Handicap = false
			_Handicap_Locked = false
			_Is_Handicap_Used = false
			_Input = ''
			_Display.Keypad.Input.Text = ''
			_Timeout_Locked = false
			_Input_Locked = false
			_Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive = nil,nil,nil,nil
			while (_Transitioning) do wait() end
			_TransitionTo(_Display.Fire_Recall, _Display.Home)
		end
	end)

	local _HM_Click = Instance.new('Sound', A:WaitForChild('Handicap_Button'))
	_HM_Click.SoundId = 'rbxassetid://5163941878'
	_HM_Click.MaxDistance = 70
	_HM_Click.EmitterSize = 3
	_HM_Click.Volume = 1.3
	local _HB_In,_HB_Out = A:WaitForChild('Handicap_Button').CFrame * CFrame.new(0, 0, math.rad(.4)),A:WaitForChild('Handicap_Button').CFrame * CFrame.new(0, 0, -math.rad(.4))
	A:WaitForChild('Handicap_Button').Button.Handicap.MouseButton1Click:Connect(function()

		if (_Btn_Debounce_M or _Handicap_Locked) then return end
		_Btn_Debounce_M = true
		spawn(function()
			wait(.1)
			_Btn_Debounce_M = false
		end)

		local _C = _HM_Click:Clone()
		_C.Parent = _HM_Click.Parent
		_C:Play()
		game.Debris:AddItem(_C, _C.TimeLength)
		coroutine.wrap(function()
			_Services['_Tween_Service']:Create(A:WaitForChild('Handicap_Button'), TweenInfo.new(.04, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {CFrame = _HB_In}):Play()
			wait(.04)
			_Services['_Tween_Service']:Create(A:WaitForChild('Handicap_Button'), TweenInfo.new(.04, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {CFrame = _HB_Out}):Play()
			wait(.05)
		end)()
		if (isScannerActivated or isFireRecall or _Handicap_Locked) then return end
		_Handicap = true
		_Handicap_Locked = true
		_Input_Locked = true
		_Display.Floor_Selection.Floor_Groups.Visible = true
		for i,v in ipairs(_Display.Floor_Selection:GetChildren()) do
			if string.match(string.lower(v.Name), 'group_') then
				v.Visible = false
			end
		end
		if (_Highlighted_Button) then
			_Floor_Inactive = true
			for i,v in ipairs(_Display.Floor_Selection:GetChildren()) do
				if string.match(string.lower(v.Name), 'group_') then
					v.Visible = false
				end
			end
			local elevator
			local dest = _Highlighted_Button.Name
			_Btn_Debounce = true
			_Voice:Stop()
			spawn(function()
				lastFrame = _Display.Home

				elevator = check(dest, elevators:GetChildren())
				if (_Handicap) then
					Hall_Lanterns(elevator, thisFloor)
				end
				_Keypad_Input_Time = 0
				if (not elevator) then
					return spawn(function()
						_Timeout_Locked = true
						_Input_Locked = true
						_TransitionTo(lastFrame, _Display.No_Elevator)
						wait(2.5)
						_Input = ''
						_Display.Keypad.Input.Text = ''
						_TransitionTo(_Display.No_Elevator, lastFrame)
						_Timeout_Locked = false
						_Input_Locked = false
						_Btn_Debounce = false
						_Handicap = false
						_Handicap_Locked = false
						_Is_Handicap_Used = false
					end)
				end
				local callFloor = (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name))
				coroutine.wrap(function()
					_Request_Elevator_Call(elevator, callFloor, dest)
				end)()
				coroutine.wrap(function()
					_Timeout_Locked = true
					_Input_Locked = true
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
					wait(.2)
					_Display.Elevator.Visible = true
					_Display.Elevator.Main.Elevator.Text = elevator.Name
					_Display.Elevator.Floor.Text = 'To '..(_Settings['Display']['Custom_Floor_Label'][tostring(dest)] or tostring(dest))
					local direction = _Pad_Settings['Directionals'][elevator.Name]
					local arrow = _Display.Elevator.Main.Arrow
					_Is_Handicap_Used = false
					local rotation_index = {
						['Right'] = -90,
						['Right_Behind'] = -50,
						['Right_Ahead'] = -140,
						['Left'] = 90,
						['Left_Behind'] = 50,
						['Left_Ahead'] = 140,
						['Ahead'] = 180,
						['Behind'] = 0,
					}
					if (direction and rotation_index[direction]) then
						arrow.Rotation = rotation_index[direction]
					end
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
					wait(5)
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
					wait(.2)
					_Display.Elevator.Visible = false
					_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
					wait(.2)
					for i,grp in pairs(_Display.Floor_Selection:GetChildren()) do
						if string.match(grp.Name, 'Group_') then
							for i,btn in pairs(grp:GetChildren()) do
								if btn:IsA('TextButton') then
									_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
									_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
								end
							end
						end
					end
					for i,grp in pairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
						if string.match(grp.Name, 'Group_') then
							if grp:IsA('TextButton') then
								_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
								_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
							end
						end
					end
					_Btn_Debounce = false
					_Handicap = false
					_Handicap_Locked = false
					_Is_Handicap_Used = false
					_Input = ''
					_Display.Keypad.Input.Text = ''
					_Timeout_Locked = false
					_Input_Locked = false
					_Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive = nil,nil,nil,nil
				end)()
			end)
			coroutine.resume(coroutine.create(function()
				wait(.3)
				playVoiceClip('Take_Car', true)
				wait(.08)
				pcall(function()
					playVoiceClip(elevator.Name, true)
				end)
				wait(.12)
				playVoiceClip('Going_To', true)
				wait(.04)
				playVoiceSequenceProtocol(voiceConfig.Voice_Config[tostring(dest)] or {{tostring(dest), ['Delay'] = 0}}, true)
				_Floor_Inactive = false
				_Group_Inactive = false
			end))
			_Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive = nil,nil,nil,nil
		elseif _Highlighted_Group then
			_Voice:Stop()
			_Group_Inactive = true
			_Floor_Inactive = false
			_Display.Floor_Selection.Floor_Groups.Visible = false
			_Display.Floor_Selection[_Highlighted_Group.Name].Visible = true
			local _Voicing = false
			wait(1)
			_Handicap_Locked = false
			if (not _Highlighted_Group) then
				_Btn_Debounce = false
				_Handicap = false
				_Handicap_Locked = false
				_Is_Handicap_Used = false
				_Input = ''
				_Display.Keypad.Input.Text = ''
				_Timeout_Locked = false
				_Input_Locked = false
				_Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive = nil,nil,nil,nil
				_Voice:Stop()
				_TransitionTo(_Display.Floor_Selection, _Display.Home)
				return
			end
			for flr,v in ipairs(_Display.Floor_Selection[_Highlighted_Group.Name]:GetChildren()) do
				if (v:IsA('TextButton') and v.BackgroundTransparency == 0) then
					if _Floor_Inactive then return end
					_Voicing = false
					_Highlighted_Button = v
					for i,grp2 in ipairs(_Display.Floor_Selection[_Highlighted_Group.Name]:GetChildren()) do
						if grp2:IsA('TextButton') then
							_Services['_Tween_Service']:Create(grp2, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
							_Services['_Tween_Service']:Create(grp2, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
						end
					end
					if v:IsA('TextButton') then
						_Services['_Tween_Service']:Create(v, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Active}):Play()
						_Services['_Tween_Service']:Create(v, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Active}):Play()
					end
					if _Floor_Inactive then return end
					if not _Voicing then
						_Voicing = true
						if _Floor_Inactive then return end
						pcall(function()
							playVoiceSequenceProtocol(voiceConfig.Voice_Config[v.Name] or {{v.Name, ['Delay'] = 0}}, true)
						end)
						if _Floor_Inactive then return end
					end
					wait(1.5)
					if _Floor_Inactive then return end
				end
			end
			_Btn_Debounce = false
			_Handicap = false
			_Handicap_Locked = false
			_Is_Handicap_Used = false
			_Input = ''
			_Display.Keypad.Input.Text = ''
			_Timeout_Locked = false
			_Input_Locked = false
			_Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive = nil,nil,nil,nil
			return
		elseif not _Is_Handicap_Used then
			_Is_Handicap_Used = true
			while (_Transitioning) do wait() end
			_TransitionTo(_Display.Home, _Display.Floor_Selection)
			_Timeout_Locked = true
			_Handicap_Locked = true
			_Btn_Debounce = true
			_Handicap = true
			playVoiceClip('Handicap_Message', true)
			local _Voicing = false
			wait(1)
			if _Group_Inactive then return end
			_Handicap_Locked = false
			coroutine.resume(coroutine.create(function()
				wait(.1)
				_Btn_Debounce = false
			end))
			for i=1, #_Display.Floor_Selection.Floor_Groups:GetChildren() do
				local v = _Display.Floor_Selection.Floor_Groups:FindFirstChild('Group_'..tostring(i))
				if v then
					_Voicing = false
					if _Group_Inactive then return end
					_Highlighted_Group = v
					for i,grp2 in ipairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
						if string.match(string.lower(grp2.Name), 'group_') then
							if grp2:IsA('TextButton') then
								_Services['_Tween_Service']:Create(grp2, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
								_Services['_Tween_Service']:Create(grp2, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
							end
						end
					end
					if v:IsA('TextButton') then
						_Services['_Tween_Service']:Create(v, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Active}):Play()
						_Services['_Tween_Service']:Create(v, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Active}):Play()
					end
					if _Group_Inactive then return end
					if not _Voicing then
						_Voicing = true
						local split = string.split(v.Real_Floor_Group_Label.Value, '-')
						local first,last
						for i,vc in ipairs(split) do
							if not first then first = tostring(vc) end
							break
						end
						for i,vc in ipairs(split) do
							last = tostring(vc)
						end
						pcall(function()
							playVoiceSequenceProtocol(voiceConfig.Voice_Config[first] or {{first, ['Delay'] = 0}}, true)
						end)
						if _Group_Inactive then return end
						wait(.1)
						if _Group_Inactive then return end
						pcall(function()
							playVoiceClip('Through', true)
						end)
						if _Group_Inactive then return end
						wait(.1)
						if _Group_Inactive then return end
						pcall(function()
							playVoiceSequenceProtocol(voiceConfig.Voice_Config[last] or {{last, ['Delay'] = 0}}, true)
						end)
						if _Group_Inactive then return end
					end
					wait(1)
					if _Group_Inactive then return end
				end
			end
			for i,grp in ipairs(_Display.Floor_Selection:GetChildren()) do
				if string.match(grp.Name, 'Group_') then
					if grp:IsA('TextButton') then
						_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
						_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
					end
				end
			end
			for i,grp in ipairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
				if string.match(grp.Name, 'Group_') then
					for i,grp2 in ipairs(grp:GetChildren()) do
						if grp2:IsA('TextButton') then
							_Services['_Tween_Service']:Create(grp2, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
							_Services['_Tween_Service']:Create(grp2, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
						end
					end
				end
			end
			wait(.5)
			if (not _Handicap) then return end
			_TransitionTo(_Display.Floor_Selection, _Display.Home)
			_Btn_Debounce = false
			_Handicap = false
			_Handicap_Locked = false
			_Is_Handicap_Used = false
			_Input = ''
			_Display.Keypad.Input.Text = ''
			_Timeout_Locked = false
			_Input_Locked = false
			_Highlighted_Group,_Highlighted_Button,_Group_Inactive,_Floor_Inactive = nil,nil,nil,nil
		end
	end)

	_Display.Logo.Size = UDim2.new(0, 0, 0, 0)
	_Display.Home.Header.Text = _Settings['Naming']['Home_Header']
	_Display.Blackscreen.BackgroundTransparency = 0
	for i,v in pairs(_Display:GetChildren()) do
		if v.Name ~= 'Home' then
			pcall(function()
				v.Visible = false
			end)
		end
	end
	_Display.Home.Visible = true
	_Display.Blackscreen.Visible = true
	_Display.Keypad.Input.Text = ''
	function _Transition()
		if _Transitioning then return end
		_Timeout_Locked = true
		_Transitioning = true
		_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
		wait(.3)
		_Services['_Tween_Service']:Create(_Display.Logo, TweenInfo.new(.6, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Size = UDim2.new(.2, 0, .2, 0)}):Play()
		wait(.6)
		_Services['_Tween_Service']:Create(_Display.Logo, TweenInfo.new(.5, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Rotation = _Display.Logo.Rotation+360}):Play()
		_Services['_Tween_Service']:Create(_Display.Logo, TweenInfo.new(.3, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Position = _Display.Logo.Position-UDim2.new(0, 0, .15, 0)}):Play()
		wait(.3)
		_Services['_Tween_Service']:Create(_Display.Logo, TweenInfo.new(.5, Enum.EasingStyle.Bounce, Enum.EasingDirection.Out), {Position = _Display.Logo.Position+UDim2.new(0, 0, .15, 0)}):Play()
		wait(.3)
		_Services['_Tween_Service']:Create(_Display.Logo, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.InOut), {Size = UDim2.new(0, 0, 0, 0)}):Play()
		wait(.4)
		_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.6, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
		wait(.6)
		_Transitioning = false
		_Timeout_Locked = false
	end
	function _TransitionTo(_From_Frame, _To_Frame)
		if _Transitioning then return end
		_Transitioning = true
		_Timeout_Locked = true
		_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
		wait(.2)
		_From_Frame.Visible = false
		_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
		_To_Frame.Visible = true
		wait(.2)
		_Transitioning = false
		_Timeout_Locked = false
	end
	_Transition()
	_Display.Home.Buttons_List.Floor_Selection.MouseButton1Click:Connect(function()
		_Display.Floor_Selection.Floor_Groups.Visible = true
		for i,v in ipairs(_Display.Floor_Selection:GetChildren()) do
			if string.match(string.lower(v.Name), 'group_') then
				v.Visible = false
			end
		end
		_TransitionTo(_Display.Home, _Display.Floor_Selection)
	end)
	_Display.Home.Buttons_List.Destination_Keypad.MouseButton1Click:Connect(function()
		_Keypad_Enabled = true
		_TransitionTo(_Display.Home, _Display.Keypad)
	end)
	_Display.Keypad.Home.MouseButton1Click:Connect(function()
		_TransitionTo(_Display.Keypad, _Display.Home)
	end)

	_Display.Floor_Selection.Home.MouseButton1Click:Connect(function()
		if _Handicap then return end
		coroutine.resume(coroutine.create(function()
			wait(.6)
			_Display.Floor_Selection.Floor_Groups.Visible = true
			for i,v in ipairs(_Display.Floor_Selection:GetChildren()) do
				if string.match(string.lower(v.Name), 'group_') then
					v.Visible = false
				end
			end
		end))
		_TransitionTo(_Display.Floor_Selection, _Display.Home)
	end)
	
	local startTime = tick();
	local updating = false;
	
	local function handleScreenUpdater()
		
		coroutine.wrap(function()
			if (updating) then return end
			updating = true;
			while (math.abs(tick()-startTime) <= (_Settings.Display.Pad_Fade_Timeout or 5)) do
				wait(.25)
				if (_Timeout_Locked) then startTime = tick() end
				if (isFireRecall) then updating = false return end
			end
			_Display.Blackscreen.Theme_Gradient_Controller.Color = ColorSequence.new(Color3.fromRGB(0, 0, 0), Color3.fromRGB(0, 0, 0))
			_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
			updating = false;
		end)();
		
	end

	_Display.Blackscreen.MouseEnter:Connect(function()
		if (_Transitioning) then return end
		_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
		startTime = tick();
		handleScreenUpdater();
		wait(.4)
	end)
	_Display.Blackscreen.MouseMoved:Connect(function()
		if (_Transitioning) then return end
		_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.4, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
		startTime = tick();
		handleScreenUpdater();
		wait(.4)
		local nd = (themeConfig.Theme.Custom_Theme.Background_Color.Type[1] == 'Gradient') and themeConfig.Theme.Custom_Theme.Background_Color.Type.End or themeConfig.Theme.Custom_Theme.Background_Color.Type.Start
		_Display.Blackscreen.Theme_Gradient_Controller.Color = ColorSequence.new(themeConfig.Theme.Custom_Theme.Background_Color.Type.Start, nd)
	end)
	startTime = tick();
	handleScreenUpdater();

	local firstNum = 0

	for i,v in pairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
		if (v:IsA('TextButton')) then
			v:Destroy()
		end
	end

	for i,v in pairs(_Display.Floor_Selection:GetChildren()) do
		if (v.Name:match('Group_')) then
			v:Destroy()
		end
	end

	for grp,v in pairs(_Settings['Display']['Floor_Groups']) do
		for i,f in ipairs(A.Parent.Parent:GetChildren()) do
			if not _Display.Floor_Selection.Floor_Groups:FindFirstChild(grp) then
				local group = script.Assets.Group_Button:Clone()
				group.Parent = _Display.Floor_Selection.Floor_Groups
				group.Name = tostring(grp)
				local firstnumberto,lastnumberto = 0,0
				for grp2,v2 in pairs(_Settings['Display']['Floor_Groups']) do
					for flr2,r2 in ipairs(v) do
						if firstnumberto == 0 then
							firstnumberto = {tonumber(r2),_Settings['Display']['Custom_Floor_Label'][tostring(r2)] or tostring(r2)}
							firstNum = tonumber(r2)
							break
						end
					end
				end
				for grp2,v2 in pairs(_Settings['Display']['Floor_Groups']) do
					for flr2,r2 in ipairs(v) do
						lastnumberto = {tonumber(r2),_Settings['Display']['Custom_Floor_Label'][tostring(r2)] or tostring(r2)}
					end
				end
				group.LayoutOrder = firstnumberto[1]
				group.Text = firstnumberto[2]..'-'..lastnumberto[2]
				local newVal = Instance.new('StringValue', group)
				newVal.Name = 'Real_Floor_Group_Label'
				newVal.Value = tostring(firstnumberto[1])..'-'..tostring(lastnumberto[1])
				local frame = script.Assets.Group:Clone()
				frame.Parent = _Display.Floor_Selection
				frame.Name = grp
				for grp2,v2 in pairs(_Settings['Display']['Floor_Groups']) do
					for flr2,r2 in ipairs(v) do
						if not frame:FindFirstChild(tostring(r2)) and A.Parent.Parent:FindFirstChild('Floor_'..tostring(r2)) or A.Parent.Parent:FindFirstChild(tostring(r2)) then
							local btn = script.Assets.Group_Button:Clone()
							btn.Parent = frame
							btn.Name = tostring(r2)
							btn.Text = _Settings['Display']['Custom_Floor_Label'][tostring(r2)] or tostring(r2)
							btn.LayoutOrder = r2
							if (r2 == thisFloor) then
								btn.BackgroundTransparency = .8
								btn.TextTransparency = .8
							end
							if (table.find((_Settings.Locking and _Settings.Locking.Locked_Floors or {}), r2)) then

								btn.BackgroundTransparency = .4
								btn.TextTransparency = .4
								local img = Instance.new('ImageButton', btn)
								img.Image = 'rbxassetid://7643218021'
								img.Size = UDim2.new(.85, 0, .85, 0)
								img.AnchorPoint = Vector2.new(.5, .5)
								img.Position = UDim2.new(.5, 0, .5, 0)
								img.BackgroundTransparency = 1
								img.ScaleType = Enum.ScaleType.Fit
								img.Name = 'Lock_Icon'
								local uiScale = Instance.new('UIScale', img)
								uiScale.Scale = 1
								img.InputBegan:Connect(function(input)
									if ((not img.Visible) or _Input_Locked or _Handicap) then return end
									if (input.UserInputType == Enum.UserInputType.Focus or input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1) then
										_Services._Tween_Service:Create(uiScale, TweenInfo.new(.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Scale = .8}):Play()
									end
								end)
								img.InputEnded:Connect(function(input)
									if ((not img.Visible) or _Input_Locked or _Handicap) then return end
									if (input.UserInputType == Enum.UserInputType.Focus or input.UserInputType == Enum.UserInputType.Touch or input.UserInputType == Enum.UserInputType.MouseButton1) then
										_Services._Tween_Service:Create(uiScale, TweenInfo.new(.2, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {Scale = 1}):Play()
									end
								end)
								img.MouseButton1Click:Connect(function()
									if ((not img.Visible) or _Input_Locked or _Handicap) then return end
									scannerReady = true
									currentFrame = _Display.Floor_Selection
									_TransitionTo(_Display.Floor_Selection, _Display.Scan_Card)
									activateScanner('unlockFloor', function()

										img.Visible = false
										btn.BackgroundTransparency = 0
										btn.TextTransparency = 0
										delay(3, function()
											if (img.Visible) then return end
											img.Visible = true
											btn.BackgroundTransparency = .4
											btn.TextTransparency = .4
										end)
										_TransitionTo(_Display.Scan_Card, _Display.Floor_Selection)

									end)
								end)

							end
							btn.MouseButton1Click:Connect(function()
								if (_Input_Locked or _Handicap or btn.BackgroundTransparency ~= 0) then return end
								lastFrame = _Display.Floor_Selection
								local elevator = check(r2, elevators:GetChildren())
								if (_Handicap) then
									Hall_Lanterns(elevator, thisFloor)
								end
								_Keypad_Input_Time = 0
								if (not elevator) then
									return spawn(function()
										_Timeout_Locked = true
										_Input_Locked = true
										_TransitionTo(lastFrame, _Display.No_Elevator)
										wait(2.5)
										_Input = ''
										_Display.Keypad.Input.Text = ''
										_TransitionTo(_Display.No_Elevator, lastFrame)
										_Timeout_Locked = false
										_Input_Locked = false
										_Btn_Debounce = false
										_Handicap = false
										_Handicap_Locked = false
										_Is_Handicap_Used = false
									end)
								end
								local callFloor = (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name))
								coroutine.wrap(function()
									_Request_Elevator_Call(elevator, callFloor, r2)
								end)()
								_Timeout_Locked = true
								_Input_Locked = true
								_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
								wait(.2)
								_Display.Elevator.Visible = true
								_Display.Elevator.Main.Elevator.Text = elevator.Name
								_Display.Elevator.Floor.Text = 'To '..(_Settings['Display']['Custom_Floor_Label'][tostring(r2)] or tostring(r2))
								local direction = _Pad_Settings['Directionals'][elevator.Name]
								local arrow = _Display.Elevator.Main.Arrow
								_Is_Handicap_Used = false
								local rotation_index = {
									['Right'] = -90,
									['Right_Behind'] = -50,
									['Right_Ahead'] = -140,
									['Left'] = 90,
									['Left_Behind'] = 50,
									['Left_Ahead'] = 140,
									['Ahead'] = 180,
									['Behind'] = 0,
								}
								if (direction and rotation_index[direction]) then
									arrow.Rotation = rotation_index[direction]
								end
								_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
								wait(5)
								_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 0}):Play()
								wait(.2)
								_Display.Elevator.Visible = false
								_Services['_Tween_Service']:Create(_Display.Blackscreen, TweenInfo.new(.2, Enum.EasingStyle.Quad, Enum.EasingDirection.Out), {BackgroundTransparency = 1}):Play()
								wait(.2)
								for i,grp in pairs(_Display.Floor_Selection:GetChildren()) do
									if string.match(grp.Name, 'Group_') then
										for i,btn in pairs(grp:GetChildren()) do
											if btn:IsA('TextButton') then
												_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
												_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
											end
										end
									end
								end
								for i,grp in pairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
									if string.match(grp.Name, 'Group_') then
										if grp:IsA('TextButton') then
											_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
											_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
										end
									end
								end
								_Btn_Debounce = false
								_Handicap = false
								_Handicap_Locked = false
								_Is_Handicap_Used = false
								_Input = ''
								_Display.Keypad.Input.Text = ''
								_Timeout_Locked = false
								_Input_Locked = false
							end)
						end
					end
				end
				group.MouseButton1Click:Connect(function()
					if _Handicap then return end
					_Display.Floor_Selection.Floor_Groups.Visible = false
					_Display.Floor_Selection[grp].Visible = true
				end)
			end
		end
	end
	
	local isUpdating = false
	local startTime = tick();
	local function handleUpdater()
		
		if (isUpdating) then return end
		isUpdating = true
		coroutine.wrap(function()
			while (math.abs(tick()-startTime) < 2) do
				wait(.25)
				if (isFireRecall) then isUpdating = false return end
			end
			_Keypad_Enabled = false
			if _Input == '*' then _Input = '1' end
			if not A.Parent.Parent:FindFirstChild(('Floor_'..tostring(_Input)) or (tostring(_Input))) then
				_Input = ''
				_Input_Locked = true
				_Keypad_Input_Time = 0
				local tween = _Services._Tween_Service:Create(_Display.Keypad.Input, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextTransparency=1});
				tween:Play();
				tween.Completed:Wait();
				_Display.Keypad.Input.Text = '???'
				local tween = _Services._Tween_Service:Create(_Display.Keypad.Input, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextTransparency=0});
				tween:Play();
				tween.Completed:Wait();
				wait(1)
				local tween = _Services._Tween_Service:Create(_Display.Keypad.Input, TweenInfo.new(.15, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextTransparency=1});
				tween:Play();
				tween.Completed:Wait();
				_Display.Keypad.Input.Text = ''
				_Input_Locked = false
				isUpdating = false;
				return
			end
			lastFrame = _Display.Keypad

			local function run(frame)

				local elevator = check(tonumber(_Input), elevators:GetChildren())
				_Keypad_Input_Time = 0
				if (_Handicap) then
					Hall_Lanterns(elevator, thisFloor)
				end
				if (not elevator) then
					return spawn(function()
						_Timeout_Locked = true
						_Input_Locked = true
						_TransitionTo(lastFrame, _Display.No_Elevator)
						wait(2.5)
						_Input = ''
						_Display.Keypad.Input.Text = ''
						_TransitionTo(_Display.No_Elevator, lastFrame)
						_Timeout_Locked = false
						_Input_Locked = false
						_Btn_Debounce = false
						_Handicap = false
						_Handicap_Locked = false
						_Is_Handicap_Used = false
					end)
				end
				local callFloor = (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name))
				coroutine.wrap(function()
					_Request_Elevator_Call(elevator, callFloor, tonumber(_Input))
				end)()
				_Timeout_Locked = true
				_Input_Locked = true
				coroutine.wrap(function()
					_TransitionTo(frame, _Display.Elevator)
				end)()
				_Display.Elevator.Main.Elevator.Text = elevator.Name
				_Display.Elevator.Floor.Text = 'To '..(_Settings['Display']['Custom_Floor_Label'][tostring(_Input)] or tostring(_Input))
				local direction = _Pad_Settings['Directionals'][elevator.Name]
				local arrow = _Display.Elevator.Main.Arrow
				_Is_Handicap_Used = false
				local rotation_index = {
					['Right'] = -90,
					['Right_Behind'] = -50,
					['Right_Ahead'] = -140,
					['Left'] = 90,
					['Left_Behind'] = 50,
					['Left_Ahead'] = 140,
					['Ahead'] = 180,
					['Behind'] = 0,
				}
				if (direction and rotation_index[direction]) then
					arrow.Rotation = rotation_index[direction]
				end
				wait(5)
				coroutine.wrap(function()
					_TransitionTo(_Display.Elevator, _Display.Keypad)
				end)()
				for i,grp in pairs(_Display.Floor_Selection:GetChildren()) do
					if string.match(grp.Name, 'Group_') then
						for i,btn in pairs(grp:GetChildren()) do
							if btn:IsA('TextButton') then
								_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
								_Services['_Tween_Service']:Create(btn, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
							end
						end
					end
				end
				for i,grp in pairs(_Display.Floor_Selection.Floor_Groups:GetChildren()) do
					if string.match(grp.Name, 'Group_') then
						if grp:IsA('TextButton') then
							_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
							_Services['_Tween_Service']:Create(grp, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
						end
					end
				end
				_Btn_Debounce = false
				_Handicap = false
				_Handicap_Locked = false
				_Is_Handicap_Used = false
				_Input = ''
				_Display.Keypad.Input.Text = ''
				_Timeout_Locked = false
				_Input_Locked = false
				isUpdating = false

			end
			if (table.find(_Settings.Locking and _Settings.Locking.Locked_Floors or {}, tonumber(_Input))) then
				scannerReady = true
				currentFrame = _Display.Keypad
				_TransitionTo(_Display.Keypad, _Display.Scan_Card)
				activateScanner('unlockFloor', function()

					run(_Display.Scan_Card)

				end)
			else
				run(_Display.Keypad)
			end
		end)()

	end

	for i,btn in pairs(_Display.Keypad.Buttons:GetChildren()) do
		if btn:IsA('TextButton') then
			btn.MouseButton1Click:Connect(function()
				if (_Handicap or (string.len(_Input) >= 4 or _Input_Locked)) then return end
				startTime = tick();
				handleUpdater();
				_Input = _Input..btn.Name
				_Keypad_Input_Time = 0
				_Services['_Tween_Service']:Create(_Display.Keypad.Input, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextTransparency = 1}):Play()
				wait(.1)
				_Display.Keypad.Input.Text = _Input
				_Services['_Tween_Service']:Create(_Display.Keypad.Input, TweenInfo.new(.1, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextTransparency = 0}):Play()
			end)
		end
	end

	function _Request_Elevator_Call(Elevator, Floor, Destination)
		Elevator.Cortex_API:Fire('Request_Call_F', Floor)
		local doorConnections = {}
		for i,v in pairs(Elevator.Legacy:GetChildren()) do
			if (v.Name:match('Door_State')) then
				doorConnections[v] = v:GetPropertyChangedSignal('Value'):Connect(function()

					if (Elevator.Legacy.Floor.Value == Floor and Elevator.Legacy.Move_Value.Value == 0 and v.Value ~= 'Closed') then
						Elevator.Cortex_API:Fire('Request_Call_F', Destination)
						for i,c in pairs(doorConnections) do
							c:Disconnect()
						end
					end

				end)
			end
		end
	end

	for i,v in pairs(A.Parent.Parent.Parent:FindFirstChild('Hall_Lanterns'):GetChildren()) do
		for i,l in pairs(v:GetChildren()) do
			for i,led in pairs(l:GetChildren()) do
				if (led:IsA('BasePart') and led.Name == 'Light') then
					led.Color,led.Material = _Settings['Hall_Lanterns']['Neutral']['Color'],_Settings['Hall_Lanterns']['Neutral']['Material']
				end
			end
		end
	end

	function Hall_Lanterns(Elevator, Floor)
		if Elevator then
			local _HL = A.Parent.Parent.Parent:FindFirstChild('Hall_Lanterns')
			if _HL then
				local _H = _HL:FindFirstChild(Elevator.Name):FindFirstChild('Floor_'..tostring(Floor))
				if _H then
					for i,v in pairs(_H:GetChildren()) do
						if v.Name == 'Light' then
							if _Settings['Hall_Lanterns']['Light_Mode'] == 'Flash' then
								coroutine.resume(coroutine.create(function()
									repeat
										v.Color,v.Material = _Settings['Hall_Lanterns']['Active']['Color'],_Settings['Hall_Lanterns']['Active']['Material']
										wait(.3)
										v.Color,v.Material = _Settings['Hall_Lanterns']['Neutral']['Color'],_Settings['Hall_Lanterns']['Neutral']['Material']
										wait(.3)
									until Elevator.Legacy.Floor.Value == tonumber(Floor) and Elevator.Legacy.Move_Direction.Value == 'N'
									for i=1,4 do
										v.Color,v.Material = _Settings['Hall_Lanterns']['Active']['Color'],_Settings['Hall_Lanterns']['Active']['Material']
										wait(.3)
										v.Color,v.Material = _Settings['Hall_Lanterns']['Neutral']['Color'],_Settings['Hall_Lanterns']['Neutral']['Material']
										wait(.3)
									end
								end))
							elseif _Settings['Hall_Lanterns']['Light_Mode'] == 'Solid' then
								coroutine.resume(coroutine.create(function()
									v.Color,v.Material = _Settings['Hall_Lanterns']['Active']['Color'],_Settings['Hall_Lanterns']['Active']['Material']
									repeat wait() until Elevator.Legacy.Floor.Value == tonumber(Floor) and Elevator.Legacy.Move_Direction.Value == 'N'
									wait(5)
									v.Color,v.Material = _Settings['Hall_Lanterns']['Neutral']['Color'],_Settings['Hall_Lanterns']['Neutral']['Material']
								end))
							elseif _Settings['Hall_Lanterns']['Light_Mode'] == 'Both' then
								coroutine.resume(coroutine.create(function()
									v.Color,v.Material = _Settings['Hall_Lanterns']['Active']['Color'],_Settings['Hall_Lanterns']['Active']['Material']
									repeat wait() until Elevator.Legacy.Floor.Value == tonumber(Floor)
									repeat
										v.Color,v.Material = _Settings['Hall_Lanterns']['Active']['Color'],_Settings['Hall_Lanterns']['Active']['Material']
										wait(.3)
										v.Color,v.Material = _Settings['Hall_Lanterns']['Neutral']['Color'],_Settings['Hall_Lanterns']['Neutral']['Material']
										wait(.3)
									until Elevator.Legacy.Floor.Value == tonumber(Floor) and Elevator.Legacy.Move_Direction.Value == 'N'
								end))
							end
						end
					end
				end
			end
		end
	end

	--function check(dest, elevs)
	--	print("run", dest, elevs)
	--	return require(script.Allocator).allocateElevator(tonumber(dest), (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name)), elevs)

	--end

	for i,button in ipairs(_Display:GetDescendants()) do
		if button:IsA('TextButton') and button.BorderSizePixel == 3 then
			button.AutoButtonColor = false
			button.BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral
			button.BorderColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral
			button.TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral
			button.MouseButton1Down:Connect(function()
				if _Handicap or button.BackgroundTransparency ~= 0 then return end
				_Services['_Tween_Service']:Create(button, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Active}):Play()
				_Services['_Tween_Service']:Create(button, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Active}):Play()
			end)
			button.MouseLeave:Connect(function()
				if _Handicap or button.BackgroundTransparency ~= 0 then return end
				_Services['_Tween_Service']:Create(button, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
				_Services['_Tween_Service']:Create(button, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
			end)
			button.MouseButton1Up:Connect(function()
				if _Handicap or button.BackgroundTransparency ~= 0 then return end
				_Services['_Tween_Service']:Create(button, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {BackgroundColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Background.Neutral}):Play()
				_Services['_Tween_Service']:Create(button, TweenInfo.new(.085, Enum.EasingStyle.Sine, Enum.EasingDirection.InOut), {TextColor3 = themeConfig.Theme.Custom_Theme.Button_Config.Text.Neutral}):Play()
			end)
		end
		if button.Name ~= 'Elevator' and button:IsA('TextLabel') or button:IsA('TextBox') or button:IsA('TextButton') then
			--local custom_font = script.Assets.Custom_Font:Clone()
			--custom_font.Parent = button
			--custom_font.Disabled = false
		end
	end

	--Fire recall and card control, new values created too, old ones are older--
	
	collectionService:AddTag(_Display.Admin_Panel, 'Locked');

	activateScanner = function(scannerType, optionalCallback)
		if ((not scannerReady) or scannerActive or scannerType == '') then return end
		scannerLight.Color = Color3.fromRGB(163, 162, 165)
		scannerLight.Material = Enum.Material.Neon
		scannerLight.Transparency = 0
		isScannerActivated = true
		_Timeout_Locked = true
		_Input_Locked = true
		_Handicap_Locked = true
		playVoiceClip('Please_Scan_Access_Card', false)
		delay(5, function()
			if not scannerReady then return end
			scannerActive = false
			scannerReady = false
			_Input = ''
			_Display.Keypad.Input.Text = ''
			_Timeout_Locked = false
			_Input_Locked = false
			_Btn_Debounce = false
			_Handicap = false
			_Handicap_Locked = false
			_Is_Handicap_Used = false
			scannerLight.Color = Color3.fromRGB(91, 93, 105)
			scannerLight.Material = Enum.Material.Glass
			scannerLight.Transparency = .15
			scannerTouchConnection:Disconnect()
			_TransitionTo(_Display.Scan_Card, currentFrame)
			currentFrame = nil
			isScannerActivated = false
		end)
		scannerTouchConnection = scannerLogo.Touched:Connect(function(hit)
			if not scannerReady or scannerActive or scannerType == '' then return end
			local accessLevel = hit.Parent:FindFirstChild('Access_Level')
			if accessLevel then
				scannerActive = true
				delay(1.3, function()
					scannerActive = false
					scannerReady = false
					isScannerActivated = false
					_Timeout_Locked = isFireRecall
					scannerLight.Color = Color3.fromRGB(91, 93, 105)
					scannerLight.Material = Enum.Material.Glass
					scannerLight.Transparency = .15
					scannerTouchConnection:Disconnect()
				end)
				local lvl
				if (_Settings['Display']['Access_Level']) then
					lvl = _Settings['Display']['Access_Level']
				else
					lvl = 5
				end
				if (accessLevel.Value >= lvl) then
					readerBeep:Play()
					_Input_Locked = false;
					scannerLight.Color = Color3.fromRGB(121, 212, 109)
					if scannerType == 'disableFS' then
						currentFrame = _Display.FS_Disable_Success
						_TransitionTo(_Display.Scan_Card, _Display.FS_Disable_Success)
						isFireRecall = false
						_Handicap_Locked = false
						L_API:Fire('Fire_Recall_Off')
						local elevators = A.Parent.Parent.Parent:WaitForChild('Elevators')
						for i,elev in pairs(elevators:GetChildren()) do
							if elev:FindFirstChild('Cortex_API') then
								spawn(function()
									elev.Cortex_API:Fire('Fire_Recall', false, (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name)))
								end)
							end
						end
						delay(2.5, function()
							_TransitionTo(_Display.FS_Disable_Success, _Display.Home)
							scannerReady = false
							scannerActive = false
							isScannerActivated = false
							scannerType = ''
						end)
					elseif (scannerType == 'adminPanelAccess') then
						local hasTag = collectionService:HasTag(_Display.Admin_Panel, 'Locked');
						if (not hasTag) then collectionService:AddTag(_Display.Admin_Panel, 'Locked'); end
						_TransitionTo(_Display.Scan_Card, _Display.Admin_Panel);
						if (hasTag) then collectionService:RemoveTag(_Display.Admin_Panel, 'Locked'); end
					elseif (scannerType == 'unlockFloor') then
						if (optionalCallback) then
							optionalCallback()
						end
					end
				else
					scannerLight.Color = Color3.fromRGB(212, 88, 88)
					spawn(function()
						readerBeep:Play()
						wait(.15)
						readerBeep:Play()
					end)
					delay(1, function()
						scannerActive = false
						scannerReady = false
						_Input = ''
						_Display.Keypad.Input.Text = ''
						_Timeout_Locked = false
						_Input_Locked = false
						_Btn_Debounce = false
						_Handicap = false
						_Handicap_Locked = false
						_Is_Handicap_Used = false
						_TransitionTo(_Display.Scan_Card, _Display.Home)
					end)
				end
			end
		end)
	end

	_Display.Fire_Recall.Disable.MouseButton1Click:Connect(function()
		scannerReady = true
		currentFrame = _Display.Fire_Recall
		_TransitionTo(_Display.Fire_Recall, _Display.Scan_Card)
		activateScanner('disableFS')
	end)

	_Display.Home.Buttons_List.Admin_Panel.MouseButton1Click:Connect(function()
		_TransitionTo(_Display.Home, _Display.Scan_Card)
		scannerReady = true
		currentFrame = _Display.Home
		activateScanner('adminPanelAccess')
	end)

	_Display.Admin_Panel.Home.MouseButton1Click:Connect(function()
		_TransitionTo(_Display.Admin_Panel, _Display.Home)
	end)

	_Display.Admin_Panel.Buttons_List.Reboot_Panel.MouseButton1Click:Connect(function()
		if (collectionService:HasTag(_Display.Admin_Panel, 'Locked')) then return end;
		_Display.Blackscreen.BackgroundTransparency = 1
		_Timeout_Locked = true
		local reset = script.Assets.Reset:Clone()
		reset.Parent = oriSettings.Parent.Loader
		reset.Disabled = false
	end)

	_Display.Admin_Panel.Buttons_List.Enable_FS.MouseButton1Click:Connect(function()
		if (collectionService:HasTag(_Display.Admin_Panel, 'Locked')) then return end;
		_TransitionTo(_Display.Admin_Panel, _Display.Fire_Recall)
		_Timeout_Locked = true
		isFireRecall = true
		_Handicap_Locked = true
		L_API:Fire('Fire_Recall')
		local elevators = A.Parent.Parent.Parent:WaitForChild('Elevators')
		for i,elev in pairs(elevators:GetChildren()) do
			if elev:FindFirstChild('Cortex_API') then
				spawn(function()
					elev.Cortex_API:Fire('Fire_Recall', true, (tonumber(A.Parent.Name:sub(7)) or tonumber(A.Parent.Name)))
				end)
			end
		end
	end)
	
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBXB93A8096C1E64B9C8B94D447DA1610F9">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Ripple</string>
							<string name="ScriptGuid">{B9451D70-CC19-4649-BCFA-B9841C039214}</string>
							<ProtectedString name="Source"><![CDATA[local image = script.Circle

function RippleEffect(btn,mX,mY)
	coroutine.resume(coroutine.create(function()
		local clone = image:Clone()
		clone.Parent = btn
		clone.ZIndex = btn.ZIndex
		local newX = mX - clone.AbsolutePosition.X
		local newY = mY - clone.AbsolutePosition.Y
		clone.Position = UDim2.new(0,newX,0,newY)
		local Size = 0
		if btn.AbsoluteSize.X > btn.AbsoluteSize.Y then
			 Size = btn.AbsoluteSize.X*3
		elseif btn.AbsoluteSize.X < btn.AbsoluteSize.Y then
			 Size = btn.AbsoluteSize.Y*3
		elseif btn.AbsoluteSize.X == btn.AbsoluteSize.Y then																																																																													
			Size = btn.AbsoluteSize.X*3
		end
		clone:TweenSizeAndPosition(UDim2.new(0,Size,0,Size),UDim2.new(0.5, -Size/2, 0.5, -Size/2), "Out", "Quart", 1.4, false, nil)
		for i = .25,1,.05 do
			clone.ImageTransparency = i
			wait(.01)
		end
		clone:Destroy()
	end))
end

return RippleEffect]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ImageLabel" referent="RBX215D8F80F436465C96001053A42E8497">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<Content name="Image"><url>rbxassetid://1940045519</url></Content>
								<Color3 name="ImageColor3">
									<R>0.647058845</R>
									<G>0.647058845</G>
									<B>0.647058845</B>
								</Color3>
								<Vector2 name="ImageRectOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<Vector2 name="ImageRectSize">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<float name="ImageTransparency">0.25</float>
								<int name="LayoutOrder">0</int>
								<string name="Name">Circle</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.200000003</XS>
									<XO>0</XO>
									<YS>0.200000003</YS>
									<YO>0</YO>
								</UDim2>
								<token name="ResampleMode">0</token>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<token name="ScaleType">3</token>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.200000003</XS>
									<XO>0</XO>
									<YS>0.200000003</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<Rect2D name="SliceCenter">
									<min>
										<X>0</X>
										<Y>0</Y>
									</min>
									<max>
										<X>0</X>
										<Y>0</Y>
									</max>
								</Rect2D>
								<float name="SliceScale">1</float>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<UDim2 name="TileSize">
									<XS>1</XS>
									<XO>0</XO>
									<YS>1</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX117DA4F131A443AEAD6EC2A6DA7E22AD">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Assets</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextButton" referent="RBX1CBD4A87AFCE4CD998D39975B9002200">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoButtonColor">true</bool>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.0666666701</R>
									<G>0.0666666701</G>
									<B>0.0666666701</B>
								</Color3>
								<float name="BackgroundTransparency">0</float>
								<Color3 name="BorderColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<token name="BorderMode">2</token>
								<int name="BorderSizePixel">3</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">1</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/Arial.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/arial.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<bool name="Modal">false</bool>
								<string name="Name">Group_Button</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.100000001</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">true</bool>
								<bool name="Selected">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.150000006</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<token name="Style">0</token>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">X-X</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">43</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="ScrollingFrame" referent="RBX545EBED082354337970C777789884DC7">
							<Properties>
								<bool name="Active">true</bool>
								<Vector2 name="AnchorPoint">
									<X>0.5</X>
									<Y>0.5</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticCanvasSize">0</token>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>0.0666666701</R>
									<G>0.0666666701</G>
									<B>0.0666666701</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">0</int>
								<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
								<Vector2 name="CanvasPosition">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<UDim2 name="CanvasSize">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0.699999988</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Draggable">false</bool>
								<token name="ElasticBehavior">0</token>
								<token name="HorizontalScrollBarInset">0</token>
								<int name="LayoutOrder">0</int>
								<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
								<string name="Name">Group</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0.5</XS>
									<XO>0</XO>
									<YS>0.519999981</YS>
									<YO>0</YO>
								</UDim2>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<Color3 name="ScrollBarImageColor3">
									<R>0.760784388</R>
									<G>0.760784388</G>
									<B>0.760784388</B>
								</Color3>
								<float name="ScrollBarImageTransparency">0</float>
								<int name="ScrollBarThickness">12</int>
								<token name="ScrollingDirection">4</token>
								<bool name="ScrollingEnabled">true</bool>
								<bool name="Selectable">true</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">true</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0.800000012</XS>
									<XO>0</XO>
									<YS>0.600000024</YS>
									<YO>0</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
								<token name="VerticalScrollBarInset">0</token>
								<token name="VerticalScrollBarPosition">0</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
							<Item class="UIGridLayout" referent="RBXDFF0151DA33F45B48238D3595823B490">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<UDim2 name="CellPadding">
										<XS>0</XS>
										<XO>10</XO>
										<YS>0</YS>
										<YO>10</YO>
									</UDim2>
									<UDim2 name="CellSize">
										<XS>0.150000006</XS>
										<XO>0</XO>
										<YS>0.150000006</YS>
										<YO>0</YO>
									</UDim2>
									<token name="FillDirection">0</token>
									<int name="FillDirectionMaxCells">0</int>
									<token name="HorizontalAlignment">0</token>
									<string name="Name">UIGridLayout</string>
									<token name="SortOrder">2</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="StartCorner">0</token>
									<BinaryString name="Tags"></BinaryString>
									<token name="VerticalAlignment">1</token>
								</Properties>
							</Item>
						</Item>
						<Item class="Script" referent="RBXC06228DABF3E4812B64B1B1A3668CCDA">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Custom_Font</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{91010F80-3980-4E24-984D-E5EA0A3E5E86}</string>
								<ProtectedString name="Source">require(script.Rbx_CustomFont).Replace(&apos;urial&apos;, script.Parent)</ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="ModuleScript" referent="RBX3BD07A508FB944AE924CAB747BC4EEDF">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">Rbx_CustomFont</string>
									<string name="ScriptGuid">{45E26D2E-D304-429A-9B83-71745697B384}</string>
									<ProtectedString name="Source"><![CDATA[--[[
	Custom Font Tools
	A system that uses spritesheets to produce unique font style for use in game
	@author EgoMoose
	@link http://www.roblox.com/Rbx-CustomFont-item?id=230767320
	@date 19/10/2016
--]]

-- Github	: https://github.com/EgoMoose/Rbx_CustomFont
-- Fonts 	: https://github.com/EgoMoose/Rbx_CustomFont/wiki/Creating-your-own-font

------------------------------------------------------------------------------------------------------------------------------
--// Setup

local fonts = script;
local content = game:GetService("ContentProvider");

------------------------------------------------------------------------------------------------------------------------------
--// Built-in local declerations

local next = next;
local type = type;
local pcall = pcall;
local unpack = unpack;
local tostring = tostring;
local tonumber = tonumber;

local abs = math.abs;
local min = math.min;
local max = math.max;

local sub = string.sub;
local rep = string.rep;
local byte = string.byte;
local gsub = string.gsub;
local find = string.find;
local char = string.char;
local match = string.match;
local upper = string.upper;
local gmatch = string.gmatch;

local sort = table.sort;
local insert = table.insert;

local udim2 = UDim2.new;
local color3 = Color3.new;
local vector2 = Vector2.new;
local instance = Instance.new;

------------------------------------------------------------------------------------------------------------------------------
--// Other declerations

local IMGFRAME = instance("ImageLabel");
IMGFRAME.Size = udim2(0, 0, 0, 0);
IMGFRAME.BackgroundTransparency = 1;
IMGFRAME.ScaleType = Enum.ScaleType.Stretch;

local REPLACE = string.byte("?");

local justify1 = {
	["Right"] = true;
	["Bottom"] = true
};

local justify0 = {
	["Left"] = true;
	["Top"] = true
};

local redraws = {
	["AbsoluteSize"] = true;
	["TextWrapped"] = true;
	["TextScaled"] = true;
	["TextXAlignment"] = true;
	["TextYAlignment"] = true;
};

local overwrites = {
	["TextTransparency"] = true;
	["TextStrokeTransparency"] = true;
	["BackgroundTransparency"] = true;
};

local noReplicate = {
	["AbsolutePosition"] = true;
	["AbsoluteSize"] = true;
	["Position"] = true;
	["Size"] = true;
	["Rotation"] = true;
	["Parent"] = true;
};

local customProperties = {
	["FontName"] = true;
	["Style"] = true;
};

------------------------------------------------------------------------------------------------------------------------------
--// Static functions

local function getAlignMultiplier(enum)
	return (justify1[enum.Name] and 1) or (justify0[enum.Name] and 0) or 0.5;
end;

local function getClosestNumber(n, set)
	sort(set, function(a, b) return abs(n - a) < abs(n - b); end);
	return set[1];
end;

-- wrapper function

local function wrapper(child, addition)
	local this = newproxy(true);
	local mt = getmetatable(this);
	mt.__index = function(t, k) return addition[k] or child[k]; end;
	mt.__newindex = function(t, k, v) if addition[k] then addition[k] = v; else child[k] = v; end; end;
	mt.__call = function() return child; end;
	mt.__tostring = function(t) return tostring(child); end;
	mt.__metatable = "The metatable is locked.";
	return this;
end;

-- background stuff

local function defaultHide(child)
	child.TextTransparency = 2;
	child.BackgroundTransparency = 2;
	child.TextStrokeTransparency = 2;
end;

local function newBackground(child, class)
	local frame = instance("Frame", child);
	frame.Name = "_background";
	frame.Size = udim2(1, 0, 1, 0);
	frame.BackgroundTransparency = child.BackgroundTransparency;
	frame.BackgroundColor3 = child.BackgroundColor3;
	frame.BorderSizePixel = child.BorderSizePixel;
	frame.BorderColor3 = child.BorderColor3;
	frame.ZIndex = child.ZIndex;
	if (class == "TextButton") then
		frame.MouseEnter:connect(function()
			if child.AutoButtonColor then 
				local origin = child.BackgroundColor3;
				frame.BackgroundColor3 = color3(origin.r - 75/255, origin.g - 75/255, origin.b - 75/255); 
			end;
		end);
		child.MouseLeave:connect(function()
			if child.AutoButtonColor then
				frame.BackgroundColor3 = child.BackgroundColor3;
			end;
		end);
	end;
	return frame;
end;

-- functions for grabbing data from input strings

local function split(text, pattern)
	local t = {};
	local lp = 0;
	while (true) do
		local p = find(text, pattern, lp, true);
		if (p) then
			insert(t, sub(text, lp, p - 1));
			lp = p + 1;
		else
			insert(t, sub(text, lp));
			break;
		end;
	end;
	return t;
end;

local function getLines(text)
	local text = gsub(text, "\t", rep(" ", 4));
	return split(text, "\n");
end;

local function getWords(text, includeNewLines)
	local text = gsub(text, "\t", rep(" ", 4));
	local lines , words = split(text, "\n"), {};
	local nlines = #lines;
	for i = 1, nlines do
		local line = lines[i];
		for word in gmatch(line, " *[^%s]+ *") do
			insert(words, word);
		end;
		if (includeNewLines and i < nlines) then
			insert(words, "\n"); 
		end;
	end;
	return words;
end;

-- functions for calculating data for text from spritesheets

local function getStringWidth(text, sizeSet)
	local length, ntext = 0, #text;
	for i = 1, ntext do
		local i2 = i + 1 <= #text and i + 1;
		local b = byte(sub(text, i, i));
		local b2 = i2 and byte(sub(text, i2, i2));
		local character = sizeSet.characters[b];
		local kernx = 0
		if (b2 and sizeSet.kerning[b] and sizeSet.kerning[b][b2]) then
			kernx = sizeSet.kerning[b][b2].x;
		end;
		length = length + sizeSet.characters[b].xadvance + kernx;
	end;
	return length;
end;

local function getMaxHeight(text, sizeSet)
	local mheight, ntext = 0, #text;
	for i = 1, ntext do
		local b = byte(sub(text, i, i));
		local character = sizeSet.characters[b];
		local height = sizeSet.characters[b].height + sizeSet.characters[b].yoffset;
		if (height > mheight) then
			mheight = height;
		end;
	end;
	return mheight;
end;

-- functions for formatting spritesheet strings

local function wrapText(text, size, settings)
	local index = 1;
	local lines, words = {""}, getWords(text, true);
	local lineWidth, maxWidth = 0, abs(settings.child.AbsoluteSize.x);
	for i = 1, #words do
		local word = words[i];
		if (word ~= "\n") then
			local width = getStringWidth(word, settings.styles[settings.style][size]);
			if (width + lineWidth <= maxWidth) then
				lines[index] = lines[index] .. word;
			else
				lineWidth = 0;
				index = index + 1;
				lines[index] = word;
			end;
			lineWidth = lineWidth + width;
		else
			lineWidth = 0;
			index = index + 1;
			lines[index] = "";
		end;
	end;
	return lines;
end;

function scaleText(text, settings)
	local child = settings.child;
	local attached = settings.attached;

	sort(settings.information.sizes, function(a, b) return a > b; end);
	local bestSize = settings.information.sizes[1];
	local broke = false;
	
	for i = 1, #settings.information.sizes do
		local size = settings.information.sizes[i];
		local sizeSet = settings.styles[settings.style][size];
		local lines = child.TextWrapped and wrapText(text, size, settings) or getLines(text);
	
		local widths = {};
		local height = -sizeSet.firstAdjust;
		for j = 1, #lines do
			local line = lines[j];
			height = height + getMaxHeight(line, sizeSet)
			insert(widths, getStringWidth(line, sizeSet));
		end;
		
		local width = max(unpack(widths));
		if (width <= abs(child.AbsoluteSize.x) and height <= abs(child.AbsoluteSize.y)) then
			bestSize = size;
			broke = true;
			break;
		end;
	end;
	
	return broke and bestSize or settings.information.sizes[#settings.information.sizes];
end;

-- functions for drawing

local function drawSprite(byte, nextByte, settings)
	local sprite = IMGFRAME:Clone();
	local child = settings.child;
	local attached = settings.attached;
	
	local sizeSet = settings.styles[settings.style][settings.size];
	local character = sizeSet.characters[byte];
	
	-- fill in the defining properties
	sprite.Name = byte;
	sprite.ImageColor3 = child.TextColor3;
	sprite.ImageTransparency = attached.TextTransparency;
	sprite.ZIndex = child.ZIndex;
	
	-- setup the image
	sprite.Image = settings.atlases[character.atlas + 1];
	sprite.ImageRectSize = vector2(character.width, character.height);
	sprite.ImageRectOffset = vector2(character.x, character.y);
	
	-- kerning
	local kernx, kerny = 0, 0
	if (nextByte and sizeSet.kerning[byte] and sizeSet.kerning[byte][nextByte]) then
		local k = sizeSet.kerning[byte][nextByte];
		kernx = k.x;
		kerny = k.y;
	end;
	
	-- positioning
	sprite.Position = udim2(0, kernx, 0, character.yoffset + kerny);
	sprite.Size = udim2(0, character.width, 0, character.height);
	
	return sprite, kernx, kerny + character.yoffset + character.height;
end;

local function drawLine(text, height, gsprites, settings)
	local width = 0;
	local maxheight = 0;
	local sprites = {};

	local child = settings.child;
	local attached = settings.attached;
	
	local ntext = #text;
	local sizeSet = settings.styles[settings.style][settings.size];
	
	for i = 1, ntext do
		local i2 = i + 1 <= ntext and i + 1;
		local b = byte(sub(text, i, i));
		local b2 = i2 and byte(sub(text, i2, i2));
		local character, kernx, mheight = drawSprite(b, b2, settings);
		maxheight = mheight > maxheight and mheight or maxheight
		character.Position = character.Position + udim2(0, width, 0, height);
		width = width + (i2 and sizeSet.characters[b].xadvance or sizeSet.characters[b].width) + kernx;
		insert(sprites, character);
		insert(gsprites, character);
	end;
	
	local xalign = getAlignMultiplier(child.TextXAlignment);
	local adjust = (abs(child.AbsoluteSize.x) - width) * xalign;
	for i = 1, ntext do
		local character = sprites[i];
		character.Position = character.Position + udim2(0, adjust, 0, 0);
	end;
	
	return width, maxheight;
end;

local function drawLines(text, settings, parent)
	local child = settings.child;	
	
	if (child.TextScaled) then
		settings.size = scaleText(text, settings);
	end;

	local lines = child.TextWrapped and wrapText(text, settings.size, settings) or getLines(text);
	local lineHeight = settings.styles[settings.style][settings.size].lineHeight;
	
	local widths = {0};
	local height = -settings.styles[settings.style][settings.size].firstAdjust;
	local sprites = {};
	
	for i = 1, #lines do
		local line = lines[i];
		local width, lh = drawLine(line, height, sprites, settings);
		height = height + lh;
		insert(widths, width);
	end;
	
	local yalign = getAlignMultiplier(child.TextYAlignment);
	local adjust = (abs(child.AbsoluteSize.y) - height) * yalign;
	for i = 1, #sprites do
		local character = sprites[i];
		character.Position = character.Position + udim2(0, 0, 0, adjust);
		character.Parent = parent;
	end;
	
	return sprites;
end;
------------------------------------------------------------------------------------------------------------------------------
--// Classes

local event = {};

function event.new(t)
	local evnts = {};
	local self = setmetatable({},{
		__index = t;
		__newindex = function(tt, k, v)
			if (t[k] ~= v) then
				t[k] = v;
				if (type(evnts[k]) == "function") then
					evnts[k](v);
				end;
			end;
		end;
		__metatable = "The metatable is locked.";
	});
	
	function self:connect(k, f)
		evnts[k] = f;
	end;
	
	return self;
end;

local settings = {};

function settings.new(fontModule, attached, child)
	local self = setmetatable({}, {__index = settings});
	
	settings.child = child;
	settings.attached = attached;
	
	-- place data in new format for easy access
	self.information = fontModule.font.information;
	self.atlases = fontModule.atlases;
	self.styles = fontModule.font.styles;
	
	-- sort from least to greatest
	sort(self.information.sizes, function(a, b) return a > b; end);
	
	-- establish some settings variables
	self.style = self.information.styles[1];
	self.size = child.TextSize;
	
	-- failsafes
	for styleName, style in next, self.styles do
		-- characters that DNE
		for sizeName, size in next, style do
			setmetatable(size.characters, {
				__index = function(t, k)
					local k = tostring(k);
					local v = rawget(t, k)
					if (not v) then
						return rawget(t, tostring(REPLACE));
					end;
					return v;
				end;
			})
		end;
		-- sizes that DNE
		setmetatable(style, {
			__index = function(t, k)
				local k = tostring(k);
				local v = rawget(t, k);
				if (not v) then
					local closest = getClosestNumber(k, self.information.sizes);
					self.size = closest;
					child.TextSize = closest;
					return rawget(t, tostring(closest));
				end;
				return v;
			end;
		});
	end;
	-- styles that DNE
	setmetatable(self.styles, {
		__index = function(t, k)
			local v = rawget(t, k);
			if (not v) then 
				local nstyle = self.information.styles[1];
				self.style = nstyle;
				attached.Style = nstyle;
				return rawget(t, nstyle);
			end;
			return v;
		end;
	});
	
	return self;
end;

function settings:preload()
	for _, atlas in next, self.atlases do
		content:Preload(atlas);
	end;
end;

-- custom font class (this is what the player interacts with)

local customFont = {};

function customFont.new(fontName, class, isButton)
	local self = event.new {};
	
	local exists = not (type(class) == "string");
	local child = exists and class or instance(class);
	local fontModule = fonts:FindFirstChild(fontName);
	--local folder = instance("Folder", child);
	
	local settings = settings.new(require(fontModule), self, child);
	settings:preload();
	
	local events = {};
	local properties = {};
	local propertyobjects = {};
	local drawncharacters = {};
	
	self.FontName = fontName;
	self.Style = settings.style;
	self.TextTransparency = child.TextTransparency;
	self.TextStrokeTransparency = child.TextStrokeTransparency;
	self.BackgroundTransparency = child.BackgroundTransparency;
	self.TextFits = false;
	
	-- create the physical representation of the custom properties
	for name, _ in next, customProperties do
		local property = self[name];
		local t = type(property);
		local className = upper(sub(t, 1, 1)) .. sub(t, 2) .. "Value";
		local physicalProperty = Instance.new(className, child);
		
		physicalProperty.Name = name;
		physicalProperty.Value = property;
		
		physicalProperty.Changed:connect(function(newValue)
			self[name] = newValue;
		end);
		
		propertyobjects[physicalProperty.Name] = physicalProperty;
		properties[physicalProperty] = true;
	end;
	
	local background = newBackground(child, isButton and "TextButton");
	defaultHide(child);	
	
	-- common function
	
	local function drawText()
		background:ClearAllChildren();
		drawncharacters = drawLines(child.Text, settings, background);
	end;
	
	-- custom events
	
	self:connect("FontName", function(value) drawText(); end);
	self:connect("TextStrokeTransparency", function(value) drawText(); end);
	
	self:connect("BackgroundTransparency", function(value)
		background.BackgroundTransparency = value;
	end);
	
	self:connect("Style", function(value)
		settings.style = value;
		propertyobjects["Style"].Value = value;
		drawText();
	end);
	
	self:connect("TextTransparency", function(value)
		for i = 1, #drawncharacters do
			drawncharacters[i].ImageTransparency = value;
		end;
	end);
	
	self:connect("FontName", function(value)
		local fontModule = fonts:FindFirstChild(value);
		settings = settings.new(require(fontModule), self, child);
		settings:preload();
		propertyobjects["FontName"].Value = value;
		if (not child.TextScaled) then
			settings.size = child.TextSize;
		end;
		settings.style = self.Style;
		drawText();
	end);
	
	-- real events
	
	insert(events, child.Changed:connect(function(property)
		if (overwrites[property]) then	
			if (child[property] ~= 2) then
				self[property] = child[property]	
			end;
			child[property] = 2;
		elseif (property == "TextSize") then
			settings.size = child[property];
			drawText();
		elseif (property == "TextColor3") then
			for _, sprite in next, drawncharacters do
				sprite.ImageColor3 = child[property];
			end;
		elseif (property == "ZIndex") then
			background.ZIndex = child[property];
			for _, sprite in next, drawncharacters do
				sprite.ZIndex = child[property];
			end;
		elseif (property == "Text") then
			drawText();
		elseif (redraws[property]) then
			if (property == "TextScaled" and not child[property]) then
				settings.size = child.TextSize;
			end;
			drawText();
		elseif (not match(property, "Text") and not noReplicate[property]) then
			pcall(function() background[property] = child[property]; end);
		end;
	end));
	
	if (child:IsA("TextBox")) then
		insert(events, child.Focused:connect(function()
			if (child.ClearTextOnFocus) then
				child.Text = "";
			end;
		end));
	end;
	
	-- methods
	
	function self:Revert()
		for _, property in next, propertyobjects do property:Destroy(); end;
		for _, event in next, events do event:disconnect(); end;
		background:Destroy();
		child.TextTransparency = self.TextTransparency;
		child.BackgroundTransparency = self.BackgroundTransparency;
		self, properties, propertyobjects, events = nil, nil, nil, nil;
		return child;
	end;
	
	function self:GetChildren()
		local children = {};
		for _, kid in next, child:GetChildren() do
			if (kid ~= background and not properties[kid]) then
				insert(children, kid);
			end;
		end;
		return children;
	end;
	
	function self:ClearAllChildren()
		for _, kid in next, child:GetChildren() do
			if (kid ~= background and not properties[kid]) then
				kid:Destroy();
			end;
		end;
	end;
	
	function self:Destroy()
		self:Revert():Destroy();
	end;
	
	-- return
	drawText();
	return wrapper(child, self);
end;

------------------------------------------------------------------------------------------------------------------------------
--// Module

local module = {};

for _, class in next, {"TextLabel", "TextBox", "TextButton", "TextReplace"} do
	module[string.sub(class, 5)] = function(fontName, child)
		return customFont.new(fontName, class == "TextReplace" and child or class, class == "TextButton" or (class == "TextReplace" and child:IsA("TextButton")));
	end;
end;

wait(); -- top bar can mess with stuff if fonts called instantly

return module;]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBX25437FAC32004C6099DF023CE7EC6570">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">urial</string>
										<string name="ScriptGuid">{1438528B-D48C-4362-8C7A-78B67CD33791}</string>
										<ProtectedString name="Source"><![CDATA[--[[
	@Font Urial
	@Sizes {96, 60, 48, 42, 36, 32, 28, 24, 18, 14, 12, 11, 10, 9, 8}
	@Author N/A
	@Link N/A
--]]

local module = {}

module.atlases = {
	[1] = "rbxassetid://5168742723";
	[2] = "rbxassetid://5168742693";
};

module.font = {
	information = {
		family = "Urial",
		styles = {"Regular"},
		sizes = {96, 60, 48, 42, 36, 32, 28, 24, 18, 14, 12, 11, 10, 9, 8},
		useEnums = true
	},
	styles = {
		["Regular"] = {
			["96"] = {
				lineHeight = 97,
				firstAdjust = 20,
				characters = {
					["32"] = { x = 0, y = 0, width = 0, height = 0, xadvance = 17, yoffset = 96, atlas = 0 },
					["33"] = { x = 5, y = 0, width = 7, height = 76, xadvance = 14, yoffset = 20, atlas = 0 },
					["34"] = { x = 17, y = 0, width = 17, height = 25, xadvance = 20, yoffset = 20, atlas = 0 },
					["35"] = { x = 39, y = 0, width = 34, height = 55, xadvance = 41, yoffset = 31, atlas = 0 },
					["36"] = { x = 78, y = 0, width = 35, height = 76, xadvance = 42, yoffset = 20, atlas = 0 },
					["37"] = { x = 118, y = 0, width = 55, height = 76, xadvance = 62, yoffset = 20, atlas = 0 },
					["38"] = { x = 178, y = 0, width = 55, height = 76, xadvance = 61, yoffset = 20, atlas = 0 },
					["39"] = { x = 238, y = 0, width = 7, height = 25, xadvance = 14, yoffset = 20, atlas = 0 },
					["40"] = { x = 250, y = 0, width = 21, height = 76, xadvance = 27, yoffset = 20, atlas = 0 },
					["41"] = { x = 276, y = 0, width = 21, height = 76, xadvance = 28, yoffset = 20, atlas = 0 },
					["42"] = { x = 302, y = 0, width = 21, height = 24, xadvance = 28, yoffset = 45, atlas = 0 },
					["43"] = { x = 328, y = 0, width = 21, height = 34, xadvance = 28, yoffset = 41, atlas = 0 },
					["44"] = { x = 354, y = 0, width = 7, height = 25, xadvance = 14, yoffset = 86, atlas = 0 },
					["45"] = { x = 366, y = 0, width = 21, height = 7, xadvance = 28, yoffset = 55, atlas = 0 },
					["46"] = { x = 392, y = 0, width = 7, height = 10, xadvance = 14, yoffset = 86, atlas = 0 },
					["47"] = { x = 404, y = 0, width = 45, height = 76, xadvance = 48, yoffset = 20, atlas = 0 },
					["48"] = { x = 454, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["49"] = { x = 493, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["50"] = { x = 532, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["51"] = { x = 571, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["52"] = { x = 610, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["53"] = { x = 649, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["54"] = { x = 688, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["55"] = { x = 727, y = 0, width = 35, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["56"] = { x = 767, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["57"] = { x = 806, y = 0, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["58"] = { x = 845, y = 0, width = 7, height = 31, xadvance = 14, yoffset = 65, atlas = 0 },
					["59"] = { x = 857, y = 0, width = 7, height = 45, xadvance = 14, yoffset = 65, atlas = 0 },
					["60"] = { x = 869, y = 0, width = 27, height = 56, xadvance = 34, yoffset = 30, atlas = 0 },
					["61"] = { x = 901, y = 0, width = 21, height = 28, xadvance = 28, yoffset = 44, atlas = 0 },
					["62"] = { x = 927, y = 0, width = 28, height = 56, xadvance = 34, yoffset = 30, atlas = 0 },
					["63"] = { x = 960, y = 0, width = 35, height = 76, xadvance = 42, yoffset = 20, atlas = 0 },
					["64"] = { x = 0, y = 102, width = 41, height = 76, xadvance = 48, yoffset = 20, atlas = 0 },
					["65"] = { x = 46, y = 102, width = 43, height = 76, xadvance = 48, yoffset = 20, atlas = 0 },
					["66"] = { x = 94, y = 102, width = 41, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["67"] = { x = 140, y = 102, width = 48, height = 76, xadvance = 54, yoffset = 20, atlas = 0 },
					["68"] = { x = 193, y = 102, width = 41, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["69"] = { x = 239, y = 102, width = 41, height = 76, xadvance = 47, yoffset = 20, atlas = 0 },
					["70"] = { x = 285, y = 102, width = 41, height = 76, xadvance = 47, yoffset = 20, atlas = 0 },
					["71"] = { x = 331, y = 102, width = 48, height = 76, xadvance = 58, yoffset = 20, atlas = 0 },
					["72"] = { x = 384, y = 102, width = 41, height = 76, xadvance = 55, yoffset = 20, atlas = 0 },
					["73"] = { x = 430, y = 102, width = 10, height = 76, xadvance = 20, yoffset = 20, atlas = 0 },
					["74"] = { x = 445, y = 102, width = 34, height = 76, xadvance = 44, yoffset = 20, atlas = 0 },
					["75"] = { x = 484, y = 102, width = 43, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["76"] = { x = 532, y = 102, width = 34, height = 76, xadvance = 41, yoffset = 20, atlas = 0 },
					["77"] = { x = 571, y = 102, width = 51, height = 76, xadvance = 61, yoffset = 20, atlas = 0 },
					["78"] = { x = 627, y = 102, width = 48, height = 76, xadvance = 58, yoffset = 20, atlas = 0 },
					["79"] = { x = 680, y = 102, width = 48, height = 76, xadvance = 62, yoffset = 20, atlas = 0 },
					["80"] = { x = 733, y = 102, width = 41, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["81"] = { x = 779, y = 102, width = 48, height = 76, xadvance = 58, yoffset = 20, atlas = 0 },
					["82"] = { x = 832, y = 102, width = 41, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["83"] = { x = 878, y = 102, width = 38, height = 76, xadvance = 48, yoffset = 20, atlas = 0 },
					["84"] = { x = 921, y = 102, width = 37, height = 76, xadvance = 40, yoffset = 20, atlas = 0 },
					["85"] = { x = 963, y = 102, width = 48, height = 76, xadvance = 58, yoffset = 20, atlas = 0 },
					["86"] = { x = 0, y = 204, width = 43, height = 76, xadvance = 48, yoffset = 20, atlas = 0 },
					["87"] = { x = 48, y = 204, width = 78, height = 76, xadvance = 86, yoffset = 20, atlas = 0 },
					["88"] = { x = 131, y = 204, width = 45, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["89"] = { x = 181, y = 204, width = 49, height = 76, xadvance = 55, yoffset = 20, atlas = 0 },
					["90"] = { x = 235, y = 204, width = 45, height = 76, xadvance = 51, yoffset = 20, atlas = 0 },
					["91"] = { x = 285, y = 204, width = 21, height = 76, xadvance = 27, yoffset = 20, atlas = 0 },
					["92"] = { x = 311, y = 204, width = 45, height = 76, xadvance = 48, yoffset = 20, atlas = 0 },
					["93"] = { x = 361, y = 204, width = 21, height = 76, xadvance = 28, yoffset = 20, atlas = 0 },
					["94"] = { x = 387, y = 204, width = 28, height = 21, xadvance = 34, yoffset = 20, atlas = 0 },
					["95"] = { x = 420, y = 204, width = 21, height = 7, xadvance = 28, yoffset = 103, atlas = 0 },
					["96"] = { x = 446, y = 204, width = 18, height = 21, xadvance = 21, yoffset = 20, atlas = 0 },
					["97"] = { x = 469, y = 204, width = 34, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["98"] = { x = 508, y = 204, width = 36, height = 76, xadvance = 43, yoffset = 20, atlas = 0 },
					["99"] = { x = 549, y = 204, width = 35, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["100"] = { x = 589, y = 204, width = 34, height = 76, xadvance = 43, yoffset = 20, atlas = 0 },
					["101"] = { x = 628, y = 204, width = 34, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["102"] = { x = 667, y = 204, width = 19, height = 76, xadvance = 22, yoffset = 20, atlas = 0 },
					["103"] = { x = 691, y = 204, width = 34, height = 76, xadvance = 41, yoffset = 41, atlas = 0 },
					["104"] = { x = 730, y = 204, width = 36, height = 76, xadvance = 43, yoffset = 20, atlas = 0 },
					["105"] = { x = 771, y = 204, width = 10, height = 76, xadvance = 18, yoffset = 20, atlas = 0 },
					["106"] = { x = 786, y = 204, width = 14, height = 97, xadvance = 22, yoffset = 20, atlas = 0 },
					["107"] = { x = 805, y = 204, width = 33, height = 76, xadvance = 38, yoffset = 20, atlas = 0 },
					["108"] = { x = 843, y = 204, width = 10, height = 76, xadvance = 18, yoffset = 20, atlas = 0 },
					["109"] = { x = 858, y = 204, width = 48, height = 55, xadvance = 54, yoffset = 41, atlas = 0 },
					["110"] = { x = 911, y = 204, width = 34, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["111"] = { x = 950, y = 204, width = 34, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["112"] = { x = 0, y = 306, width = 34, height = 76, xadvance = 41, yoffset = 41, atlas = 0 },
					["113"] = { x = 39, y = 306, width = 34, height = 76, xadvance = 41, yoffset = 41, atlas = 0 },
					["114"] = { x = 78, y = 306, width = 21, height = 55, xadvance = 26, yoffset = 41, atlas = 0 },
					["115"] = { x = 104, y = 306, width = 34, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["116"] = { x = 143, y = 306, width = 19, height = 69, xadvance = 23, yoffset = 27, atlas = 0 },
					["117"] = { x = 167, y = 306, width = 34, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["118"] = { x = 206, y = 306, width = 33, height = 55, xadvance = 34, yoffset = 41, atlas = 0 },
					["119"] = { x = 244, y = 306, width = 54, height = 55, xadvance = 57, yoffset = 41, atlas = 0 },
					["120"] = { x = 303, y = 306, width = 35, height = 55, xadvance = 38, yoffset = 41, atlas = 0 },
					["121"] = { x = 343, y = 306, width = 33, height = 76, xadvance = 38, yoffset = 41, atlas = 0 },
					["122"] = { x = 381, y = 306, width = 35, height = 55, xadvance = 41, yoffset = 41, atlas = 0 },
					["123"] = { x = 421, y = 306, width = 21, height = 76, xadvance = 27, yoffset = 20, atlas = 0 },
					["124"] = { x = 447, y = 306, width = 7, height = 83, xadvance = 14, yoffset = 16, atlas = 0 },
					["125"] = { x = 459, y = 306, width = 21, height = 76, xadvance = 27, yoffset = 20, atlas = 0 },
					["126"] = { x = 485, y = 306, width = 38, height = 21, xadvance = 41, yoffset = 47, atlas = 0 }
				},
				kerning = {
				}
			},
			["60"] = {
				lineHeight = 60,
				firstAdjust = 13,
				characters = {
					["32"] = { x = 0, y = 408, width = 0, height = 0, xadvance = 11, yoffset = 60, atlas = 0 },
					["33"] = { x = 5, y = 408, width = 5, height = 47, xadvance = 9, yoffset = 13, atlas = 0 },
					["34"] = { x = 15, y = 408, width = 11, height = 15, xadvance = 13, yoffset = 13, atlas = 0 },
					["35"] = { x = 31, y = 408, width = 21, height = 34, xadvance = 25, yoffset = 20, atlas = 0 },
					["36"] = { x = 57, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["37"] = { x = 84, y = 408, width = 35, height = 47, xadvance = 39, yoffset = 13, atlas = 0 },
					["38"] = { x = 124, y = 408, width = 34, height = 47, xadvance = 38, yoffset = 13, atlas = 0 },
					["39"] = { x = 163, y = 408, width = 5, height = 15, xadvance = 9, yoffset = 13, atlas = 0 },
					["40"] = { x = 173, y = 408, width = 13, height = 47, xadvance = 17, yoffset = 13, atlas = 0 },
					["41"] = { x = 191, y = 408, width = 14, height = 47, xadvance = 18, yoffset = 13, atlas = 0 },
					["42"] = { x = 210, y = 408, width = 13, height = 15, xadvance = 17, yoffset = 28, atlas = 0 },
					["43"] = { x = 228, y = 408, width = 13, height = 21, xadvance = 17, yoffset = 26, atlas = 0 },
					["44"] = { x = 246, y = 408, width = 5, height = 15, xadvance = 9, yoffset = 54, atlas = 0 },
					["45"] = { x = 256, y = 408, width = 13, height = 5, xadvance = 17, yoffset = 34, atlas = 0 },
					["46"] = { x = 274, y = 408, width = 5, height = 6, xadvance = 9, yoffset = 54, atlas = 0 },
					["47"] = { x = 284, y = 408, width = 28, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["48"] = { x = 317, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["49"] = { x = 344, y = 408, width = 21, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["50"] = { x = 370, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["51"] = { x = 397, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["52"] = { x = 424, y = 408, width = 21, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["53"] = { x = 450, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["54"] = { x = 477, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["55"] = { x = 504, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["56"] = { x = 531, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["57"] = { x = 558, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["58"] = { x = 585, y = 408, width = 5, height = 19, xadvance = 9, yoffset = 41, atlas = 0 },
					["59"] = { x = 595, y = 408, width = 5, height = 28, xadvance = 9, yoffset = 41, atlas = 0 },
					["60"] = { x = 605, y = 408, width = 17, height = 35, xadvance = 21, yoffset = 19, atlas = 0 },
					["61"] = { x = 627, y = 408, width = 13, height = 17, xadvance = 17, yoffset = 28, atlas = 0 },
					["62"] = { x = 645, y = 408, width = 18, height = 35, xadvance = 21, yoffset = 19, atlas = 0 },
					["63"] = { x = 668, y = 408, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["64"] = { x = 695, y = 408, width = 26, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["65"] = { x = 726, y = 408, width = 27, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["66"] = { x = 758, y = 408, width = 26, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["67"] = { x = 789, y = 408, width = 30, height = 47, xadvance = 34, yoffset = 13, atlas = 0 },
					["68"] = { x = 824, y = 408, width = 26, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["69"] = { x = 855, y = 408, width = 26, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["70"] = { x = 886, y = 408, width = 26, height = 47, xadvance = 29, yoffset = 13, atlas = 0 },
					["71"] = { x = 917, y = 408, width = 30, height = 47, xadvance = 36, yoffset = 13, atlas = 0 },
					["72"] = { x = 952, y = 408, width = 26, height = 47, xadvance = 34, yoffset = 13, atlas = 0 },
					["73"] = { x = 983, y = 408, width = 7, height = 47, xadvance = 13, yoffset = 13, atlas = 0 },
					["74"] = { x = 995, y = 408, width = 22, height = 47, xadvance = 28, yoffset = 13, atlas = 0 },
					["75"] = { x = 0, y = 473, width = 27, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["76"] = { x = 32, y = 473, width = 22, height = 47, xadvance = 26, yoffset = 13, atlas = 0 },
					["77"] = { x = 59, y = 473, width = 32, height = 47, xadvance = 38, yoffset = 13, atlas = 0 },
					["78"] = { x = 96, y = 473, width = 30, height = 47, xadvance = 36, yoffset = 13, atlas = 0 },
					["79"] = { x = 131, y = 473, width = 30, height = 47, xadvance = 39, yoffset = 13, atlas = 0 },
					["80"] = { x = 166, y = 473, width = 26, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["81"] = { x = 197, y = 473, width = 30, height = 47, xadvance = 36, yoffset = 13, atlas = 0 },
					["82"] = { x = 232, y = 473, width = 26, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["83"] = { x = 263, y = 473, width = 24, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["84"] = { x = 292, y = 473, width = 23, height = 47, xadvance = 25, yoffset = 13, atlas = 0 },
					["85"] = { x = 320, y = 473, width = 30, height = 47, xadvance = 36, yoffset = 13, atlas = 0 },
					["86"] = { x = 355, y = 473, width = 27, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["87"] = { x = 387, y = 473, width = 49, height = 47, xadvance = 54, yoffset = 13, atlas = 0 },
					["88"] = { x = 441, y = 473, width = 28, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["89"] = { x = 474, y = 473, width = 31, height = 47, xadvance = 34, yoffset = 13, atlas = 0 },
					["90"] = { x = 510, y = 473, width = 28, height = 47, xadvance = 32, yoffset = 13, atlas = 0 },
					["91"] = { x = 543, y = 473, width = 13, height = 47, xadvance = 17, yoffset = 13, atlas = 0 },
					["92"] = { x = 561, y = 473, width = 28, height = 47, xadvance = 30, yoffset = 13, atlas = 0 },
					["93"] = { x = 594, y = 473, width = 14, height = 47, xadvance = 18, yoffset = 13, atlas = 0 },
					["94"] = { x = 613, y = 473, width = 18, height = 13, xadvance = 21, yoffset = 13, atlas = 0 },
					["95"] = { x = 636, y = 473, width = 13, height = 5, xadvance = 17, yoffset = 63, atlas = 0 },
					["96"] = { x = 654, y = 473, width = 11, height = 13, xadvance = 13, yoffset = 13, atlas = 0 },
					["97"] = { x = 670, y = 473, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["98"] = { x = 697, y = 473, width = 23, height = 47, xadvance = 27, yoffset = 13, atlas = 0 },
					["99"] = { x = 725, y = 473, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["100"] = { x = 752, y = 473, width = 22, height = 47, xadvance = 27, yoffset = 13, atlas = 0 },
					["101"] = { x = 779, y = 473, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["102"] = { x = 806, y = 473, width = 12, height = 47, xadvance = 14, yoffset = 13, atlas = 0 },
					["103"] = { x = 823, y = 473, width = 22, height = 47, xadvance = 26, yoffset = 26, atlas = 0 },
					["104"] = { x = 850, y = 473, width = 23, height = 47, xadvance = 27, yoffset = 13, atlas = 0 },
					["105"] = { x = 878, y = 473, width = 7, height = 47, xadvance = 11, yoffset = 13, atlas = 0 },
					["106"] = { x = 890, y = 473, width = 10, height = 60, xadvance = 15, yoffset = 13, atlas = 0 },
					["107"] = { x = 905, y = 473, width = 21, height = 47, xadvance = 24, yoffset = 13, atlas = 0 },
					["108"] = { x = 931, y = 473, width = 7, height = 47, xadvance = 11, yoffset = 13, atlas = 0 },
					["109"] = { x = 943, y = 473, width = 30, height = 34, xadvance = 34, yoffset = 26, atlas = 0 },
					["110"] = { x = 978, y = 473, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["111"] = { x = 0, y = 538, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["112"] = { x = 27, y = 538, width = 22, height = 47, xadvance = 26, yoffset = 26, atlas = 0 },
					["113"] = { x = 54, y = 538, width = 22, height = 47, xadvance = 26, yoffset = 26, atlas = 0 },
					["114"] = { x = 81, y = 538, width = 13, height = 34, xadvance = 16, yoffset = 26, atlas = 0 },
					["115"] = { x = 99, y = 538, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["116"] = { x = 126, y = 538, width = 12, height = 43, xadvance = 15, yoffset = 17, atlas = 0 },
					["117"] = { x = 143, y = 538, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["118"] = { x = 170, y = 538, width = 21, height = 34, xadvance = 21, yoffset = 26, atlas = 0 },
					["119"] = { x = 196, y = 538, width = 34, height = 34, xadvance = 35, yoffset = 26, atlas = 0 },
					["120"] = { x = 235, y = 538, width = 22, height = 34, xadvance = 24, yoffset = 26, atlas = 0 },
					["121"] = { x = 262, y = 538, width = 21, height = 47, xadvance = 24, yoffset = 26, atlas = 0 },
					["122"] = { x = 288, y = 538, width = 22, height = 34, xadvance = 26, yoffset = 26, atlas = 0 },
					["123"] = { x = 315, y = 538, width = 14, height = 47, xadvance = 18, yoffset = 13, atlas = 0 },
					["124"] = { x = 334, y = 538, width = 5, height = 51, xadvance = 9, yoffset = 11, atlas = 0 },
					["125"] = { x = 344, y = 538, width = 14, height = 47, xadvance = 18, yoffset = 13, atlas = 0 },
					["126"] = { x = 363, y = 538, width = 24, height = 13, xadvance = 26, yoffset = 30, atlas = 0 }
				},
				kerning = {
				}
			},
			["48"] = {
				lineHeight = 49,
				firstAdjust = 10,
				characters = {
					["32"] = { x = 0, y = 603, width = 0, height = 0, xadvance = 9, yoffset = 49, atlas = 0 },
					["33"] = { x = 5, y = 603, width = 4, height = 39, xadvance = 7, yoffset = 10, atlas = 0 },
					["34"] = { x = 14, y = 603, width = 9, height = 13, xadvance = 10, yoffset = 10, atlas = 0 },
					["35"] = { x = 28, y = 603, width = 17, height = 28, xadvance = 20, yoffset = 16, atlas = 0 },
					["36"] = { x = 50, y = 603, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["37"] = { x = 73, y = 603, width = 28, height = 39, xadvance = 31, yoffset = 10, atlas = 0 },
					["38"] = { x = 106, y = 603, width = 28, height = 39, xadvance = 31, yoffset = 10, atlas = 0 },
					["39"] = { x = 139, y = 603, width = 4, height = 13, xadvance = 7, yoffset = 10, atlas = 0 },
					["40"] = { x = 148, y = 603, width = 11, height = 39, xadvance = 14, yoffset = 10, atlas = 0 },
					["41"] = { x = 164, y = 603, width = 11, height = 39, xadvance = 14, yoffset = 10, atlas = 0 },
					["42"] = { x = 180, y = 603, width = 10, height = 12, xadvance = 13, yoffset = 23, atlas = 0 },
					["43"] = { x = 195, y = 603, width = 10, height = 18, xadvance = 13, yoffset = 21, atlas = 0 },
					["44"] = { x = 210, y = 603, width = 4, height = 13, xadvance = 7, yoffset = 44, atlas = 0 },
					["45"] = { x = 219, y = 603, width = 10, height = 4, xadvance = 13, yoffset = 27, atlas = 0 },
					["46"] = { x = 234, y = 603, width = 4, height = 5, xadvance = 7, yoffset = 44, atlas = 0 },
					["47"] = { x = 243, y = 603, width = 23, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["48"] = { x = 271, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["49"] = { x = 293, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["50"] = { x = 315, y = 603, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["51"] = { x = 338, y = 603, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["52"] = { x = 361, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["53"] = { x = 383, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["54"] = { x = 405, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["55"] = { x = 427, y = 603, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["56"] = { x = 450, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["57"] = { x = 472, y = 603, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["58"] = { x = 494, y = 603, width = 4, height = 16, xadvance = 7, yoffset = 33, atlas = 0 },
					["59"] = { x = 503, y = 603, width = 4, height = 23, xadvance = 7, yoffset = 33, atlas = 0 },
					["60"] = { x = 512, y = 603, width = 14, height = 29, xadvance = 17, yoffset = 15, atlas = 0 },
					["61"] = { x = 531, y = 603, width = 10, height = 14, xadvance = 13, yoffset = 23, atlas = 0 },
					["62"] = { x = 546, y = 603, width = 14, height = 29, xadvance = 17, yoffset = 15, atlas = 0 },
					["63"] = { x = 565, y = 603, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["64"] = { x = 588, y = 603, width = 21, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["65"] = { x = 614, y = 603, width = 22, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["66"] = { x = 641, y = 603, width = 21, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["67"] = { x = 667, y = 603, width = 25, height = 39, xadvance = 28, yoffset = 10, atlas = 0 },
					["68"] = { x = 697, y = 603, width = 21, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["69"] = { x = 723, y = 603, width = 21, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["70"] = { x = 749, y = 603, width = 21, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["71"] = { x = 775, y = 603, width = 25, height = 39, xadvance = 30, yoffset = 10, atlas = 0 },
					["72"] = { x = 805, y = 603, width = 21, height = 39, xadvance = 28, yoffset = 10, atlas = 0 },
					["73"] = { x = 831, y = 603, width = 6, height = 39, xadvance = 11, yoffset = 10, atlas = 0 },
					["74"] = { x = 842, y = 603, width = 17, height = 39, xadvance = 22, yoffset = 10, atlas = 0 },
					["75"] = { x = 864, y = 603, width = 22, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["76"] = { x = 891, y = 603, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["77"] = { x = 914, y = 603, width = 26, height = 39, xadvance = 31, yoffset = 10, atlas = 0 },
					["78"] = { x = 945, y = 603, width = 25, height = 39, xadvance = 30, yoffset = 10, atlas = 0 },
					["79"] = { x = 975, y = 603, width = 25, height = 39, xadvance = 31, yoffset = 10, atlas = 0 },
					["80"] = { x = 0, y = 657, width = 21, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["81"] = { x = 26, y = 657, width = 25, height = 39, xadvance = 30, yoffset = 10, atlas = 0 },
					["82"] = { x = 56, y = 657, width = 21, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["83"] = { x = 82, y = 657, width = 19, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["84"] = { x = 106, y = 657, width = 19, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["85"] = { x = 130, y = 657, width = 25, height = 39, xadvance = 30, yoffset = 10, atlas = 0 },
					["86"] = { x = 160, y = 657, width = 22, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["87"] = { x = 187, y = 657, width = 39, height = 39, xadvance = 43, yoffset = 10, atlas = 0 },
					["88"] = { x = 231, y = 657, width = 23, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["89"] = { x = 259, y = 657, width = 24, height = 39, xadvance = 27, yoffset = 10, atlas = 0 },
					["90"] = { x = 288, y = 657, width = 23, height = 39, xadvance = 26, yoffset = 10, atlas = 0 },
					["91"] = { x = 316, y = 657, width = 11, height = 39, xadvance = 14, yoffset = 10, atlas = 0 },
					["92"] = { x = 332, y = 657, width = 23, height = 39, xadvance = 24, yoffset = 10, atlas = 0 },
					["93"] = { x = 360, y = 657, width = 11, height = 39, xadvance = 14, yoffset = 10, atlas = 0 },
					["94"] = { x = 376, y = 657, width = 14, height = 11, xadvance = 17, yoffset = 10, atlas = 0 },
					["95"] = { x = 395, y = 657, width = 10, height = 4, xadvance = 13, yoffset = 52, atlas = 0 },
					["96"] = { x = 410, y = 657, width = 9, height = 11, xadvance = 10, yoffset = 10, atlas = 0 },
					["97"] = { x = 424, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["98"] = { x = 446, y = 657, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["99"] = { x = 469, y = 657, width = 18, height = 28, xadvance = 21, yoffset = 21, atlas = 0 },
					["100"] = { x = 492, y = 657, width = 17, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["101"] = { x = 514, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["102"] = { x = 536, y = 657, width = 9, height = 39, xadvance = 11, yoffset = 10, atlas = 0 },
					["103"] = { x = 550, y = 657, width = 17, height = 38, xadvance = 20, yoffset = 21, atlas = 0 },
					["104"] = { x = 572, y = 657, width = 18, height = 39, xadvance = 21, yoffset = 10, atlas = 0 },
					["105"] = { x = 595, y = 657, width = 5, height = 39, xadvance = 8, yoffset = 10, atlas = 0 },
					["106"] = { x = 605, y = 657, width = 8, height = 49, xadvance = 12, yoffset = 10, atlas = 0 },
					["107"] = { x = 618, y = 657, width = 17, height = 39, xadvance = 19, yoffset = 10, atlas = 0 },
					["108"] = { x = 640, y = 657, width = 5, height = 39, xadvance = 8, yoffset = 10, atlas = 0 },
					["109"] = { x = 650, y = 657, width = 25, height = 28, xadvance = 28, yoffset = 21, atlas = 0 },
					["110"] = { x = 680, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["111"] = { x = 702, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["112"] = { x = 724, y = 657, width = 17, height = 38, xadvance = 20, yoffset = 21, atlas = 0 },
					["113"] = { x = 746, y = 657, width = 17, height = 38, xadvance = 20, yoffset = 21, atlas = 0 },
					["114"] = { x = 768, y = 657, width = 11, height = 28, xadvance = 13, yoffset = 21, atlas = 0 },
					["115"] = { x = 784, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["116"] = { x = 806, y = 657, width = 9, height = 35, xadvance = 11, yoffset = 14, atlas = 0 },
					["117"] = { x = 820, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["118"] = { x = 842, y = 657, width = 17, height = 28, xadvance = 17, yoffset = 21, atlas = 0 },
					["119"] = { x = 864, y = 657, width = 27, height = 28, xadvance = 28, yoffset = 21, atlas = 0 },
					["120"] = { x = 896, y = 657, width = 18, height = 28, xadvance = 19, yoffset = 21, atlas = 0 },
					["121"] = { x = 919, y = 657, width = 17, height = 38, xadvance = 19, yoffset = 21, atlas = 0 },
					["122"] = { x = 941, y = 657, width = 17, height = 28, xadvance = 20, yoffset = 21, atlas = 0 },
					["123"] = { x = 963, y = 657, width = 11, height = 39, xadvance = 14, yoffset = 10, atlas = 0 },
					["124"] = { x = 979, y = 657, width = 4, height = 42, xadvance = 7, yoffset = 9, atlas = 0 },
					["125"] = { x = 988, y = 657, width = 11, height = 39, xadvance = 14, yoffset = 10, atlas = 0 },
					["126"] = { x = 0, y = 711, width = 19, height = 11, xadvance = 21, yoffset = 24, atlas = 0 }
				},
				kerning = {
				}
			},
			["42"] = {
				lineHeight = 42,
				firstAdjust = 9,
				characters = {
					["32"] = { x = 0, y = 765, width = 0, height = 0, xadvance = 8, yoffset = 42, atlas = 0 },
					["33"] = { x = 5, y = 765, width = 3, height = 33, xadvance = 6, yoffset = 9, atlas = 0 },
					["34"] = { x = 13, y = 765, width = 7, height = 11, xadvance = 9, yoffset = 9, atlas = 0 },
					["35"] = { x = 25, y = 765, width = 15, height = 24, xadvance = 18, yoffset = 14, atlas = 0 },
					["36"] = { x = 45, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["37"] = { x = 65, y = 765, width = 24, height = 33, xadvance = 27, yoffset = 9, atlas = 0 },
					["38"] = { x = 94, y = 765, width = 24, height = 33, xadvance = 27, yoffset = 9, atlas = 0 },
					["39"] = { x = 123, y = 765, width = 3, height = 11, xadvance = 6, yoffset = 9, atlas = 0 },
					["40"] = { x = 131, y = 765, width = 9, height = 33, xadvance = 12, yoffset = 9, atlas = 0 },
					["41"] = { x = 145, y = 765, width = 9, height = 33, xadvance = 12, yoffset = 9, atlas = 0 },
					["42"] = { x = 159, y = 765, width = 9, height = 11, xadvance = 12, yoffset = 19, atlas = 0 },
					["43"] = { x = 173, y = 765, width = 9, height = 15, xadvance = 12, yoffset = 18, atlas = 0 },
					["44"] = { x = 187, y = 765, width = 3, height = 11, xadvance = 6, yoffset = 38, atlas = 0 },
					["45"] = { x = 195, y = 765, width = 9, height = 3, xadvance = 12, yoffset = 24, atlas = 0 },
					["46"] = { x = 209, y = 765, width = 3, height = 4, xadvance = 6, yoffset = 38, atlas = 0 },
					["47"] = { x = 217, y = 765, width = 20, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["48"] = { x = 242, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["49"] = { x = 262, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["50"] = { x = 282, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["51"] = { x = 302, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["52"] = { x = 322, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["53"] = { x = 342, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["54"] = { x = 362, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["55"] = { x = 382, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["56"] = { x = 402, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["57"] = { x = 422, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["58"] = { x = 442, y = 765, width = 3, height = 14, xadvance = 6, yoffset = 28, atlas = 0 },
					["59"] = { x = 450, y = 765, width = 3, height = 20, xadvance = 6, yoffset = 28, atlas = 0 },
					["60"] = { x = 458, y = 765, width = 12, height = 25, xadvance = 15, yoffset = 13, atlas = 0 },
					["61"] = { x = 475, y = 765, width = 9, height = 12, xadvance = 12, yoffset = 19, atlas = 0 },
					["62"] = { x = 489, y = 765, width = 12, height = 25, xadvance = 15, yoffset = 13, atlas = 0 },
					["63"] = { x = 506, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["64"] = { x = 526, y = 765, width = 18, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["65"] = { x = 549, y = 765, width = 19, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["66"] = { x = 573, y = 765, width = 18, height = 33, xadvance = 22, yoffset = 9, atlas = 0 },
					["67"] = { x = 596, y = 765, width = 21, height = 33, xadvance = 24, yoffset = 9, atlas = 0 },
					["68"] = { x = 622, y = 765, width = 17, height = 33, xadvance = 22, yoffset = 9, atlas = 0 },
					["69"] = { x = 644, y = 765, width = 18, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["70"] = { x = 667, y = 765, width = 18, height = 33, xadvance = 20, yoffset = 9, atlas = 0 },
					["71"] = { x = 690, y = 765, width = 21, height = 33, xadvance = 25, yoffset = 9, atlas = 0 },
					["72"] = { x = 716, y = 765, width = 17, height = 33, xadvance = 23, yoffset = 9, atlas = 0 },
					["73"] = { x = 738, y = 765, width = 4, height = 33, xadvance = 9, yoffset = 9, atlas = 0 },
					["74"] = { x = 747, y = 765, width = 15, height = 33, xadvance = 20, yoffset = 9, atlas = 0 },
					["75"] = { x = 767, y = 765, width = 19, height = 33, xadvance = 22, yoffset = 9, atlas = 0 },
					["76"] = { x = 791, y = 765, width = 15, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["77"] = { x = 811, y = 765, width = 22, height = 33, xadvance = 27, yoffset = 9, atlas = 0 },
					["78"] = { x = 838, y = 765, width = 21, height = 33, xadvance = 25, yoffset = 9, atlas = 0 },
					["79"] = { x = 864, y = 765, width = 21, height = 33, xadvance = 27, yoffset = 9, atlas = 0 },
					["80"] = { x = 890, y = 765, width = 17, height = 33, xadvance = 22, yoffset = 9, atlas = 0 },
					["81"] = { x = 912, y = 765, width = 21, height = 33, xadvance = 25, yoffset = 9, atlas = 0 },
					["82"] = { x = 938, y = 765, width = 17, height = 33, xadvance = 22, yoffset = 9, atlas = 0 },
					["83"] = { x = 960, y = 765, width = 16, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["84"] = { x = 981, y = 765, width = 16, height = 33, xadvance = 18, yoffset = 9, atlas = 0 },
					["85"] = { x = 0, y = 812, width = 21, height = 33, xadvance = 25, yoffset = 9, atlas = 0 },
					["86"] = { x = 26, y = 812, width = 19, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["87"] = { x = 50, y = 812, width = 34, height = 33, xadvance = 38, yoffset = 9, atlas = 0 },
					["88"] = { x = 89, y = 812, width = 20, height = 33, xadvance = 23, yoffset = 9, atlas = 0 },
					["89"] = { x = 114, y = 812, width = 21, height = 33, xadvance = 24, yoffset = 9, atlas = 0 },
					["90"] = { x = 140, y = 812, width = 20, height = 33, xadvance = 23, yoffset = 9, atlas = 0 },
					["91"] = { x = 165, y = 812, width = 9, height = 33, xadvance = 12, yoffset = 9, atlas = 0 },
					["92"] = { x = 179, y = 812, width = 20, height = 33, xadvance = 21, yoffset = 9, atlas = 0 },
					["93"] = { x = 204, y = 812, width = 9, height = 33, xadvance = 12, yoffset = 9, atlas = 0 },
					["94"] = { x = 218, y = 812, width = 12, height = 9, xadvance = 15, yoffset = 9, atlas = 0 },
					["95"] = { x = 235, y = 812, width = 9, height = 3, xadvance = 12, yoffset = 45, atlas = 0 },
					["96"] = { x = 249, y = 812, width = 8, height = 9, xadvance = 9, yoffset = 9, atlas = 0 },
					["97"] = { x = 262, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["98"] = { x = 282, y = 812, width = 16, height = 33, xadvance = 19, yoffset = 9, atlas = 0 },
					["99"] = { x = 303, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["100"] = { x = 323, y = 812, width = 15, height = 33, xadvance = 19, yoffset = 9, atlas = 0 },
					["101"] = { x = 343, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["102"] = { x = 363, y = 812, width = 8, height = 33, xadvance = 9, yoffset = 9, atlas = 0 },
					["103"] = { x = 376, y = 812, width = 15, height = 33, xadvance = 18, yoffset = 18, atlas = 0 },
					["104"] = { x = 396, y = 812, width = 16, height = 33, xadvance = 19, yoffset = 9, atlas = 0 },
					["105"] = { x = 417, y = 812, width = 4, height = 33, xadvance = 7, yoffset = 9, atlas = 0 },
					["106"] = { x = 426, y = 812, width = 6, height = 42, xadvance = 10, yoffset = 9, atlas = 0 },
					["107"] = { x = 437, y = 812, width = 15, height = 33, xadvance = 17, yoffset = 9, atlas = 0 },
					["108"] = { x = 457, y = 812, width = 4, height = 33, xadvance = 7, yoffset = 9, atlas = 0 },
					["109"] = { x = 466, y = 812, width = 21, height = 24, xadvance = 24, yoffset = 18, atlas = 0 },
					["110"] = { x = 492, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["111"] = { x = 512, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["112"] = { x = 532, y = 812, width = 15, height = 33, xadvance = 18, yoffset = 18, atlas = 0 },
					["113"] = { x = 552, y = 812, width = 15, height = 33, xadvance = 18, yoffset = 18, atlas = 0 },
					["114"] = { x = 572, y = 812, width = 9, height = 24, xadvance = 11, yoffset = 18, atlas = 0 },
					["115"] = { x = 586, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["116"] = { x = 606, y = 812, width = 8, height = 30, xadvance = 10, yoffset = 12, atlas = 0 },
					["117"] = { x = 619, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["118"] = { x = 639, y = 812, width = 15, height = 24, xadvance = 15, yoffset = 18, atlas = 0 },
					["119"] = { x = 659, y = 812, width = 24, height = 24, xadvance = 25, yoffset = 18, atlas = 0 },
					["120"] = { x = 688, y = 812, width = 15, height = 24, xadvance = 17, yoffset = 18, atlas = 0 },
					["121"] = { x = 708, y = 812, width = 15, height = 33, xadvance = 17, yoffset = 18, atlas = 0 },
					["122"] = { x = 728, y = 812, width = 15, height = 24, xadvance = 18, yoffset = 18, atlas = 0 },
					["123"] = { x = 748, y = 812, width = 9, height = 33, xadvance = 12, yoffset = 9, atlas = 0 },
					["124"] = { x = 762, y = 812, width = 3, height = 36, xadvance = 6, yoffset = 7, atlas = 0 },
					["125"] = { x = 770, y = 812, width = 9, height = 33, xadvance = 12, yoffset = 9, atlas = 0 },
					["126"] = { x = 784, y = 812, width = 17, height = 9, xadvance = 18, yoffset = 21, atlas = 0 }
				},
				kerning = {
				}
			},
			["36"] = {
				lineHeight = 37,
				firstAdjust = 8,
				characters = {
					["32"] = { x = 0, y = 859, width = 0, height = 0, xadvance = 6, yoffset = 37, atlas = 0 },
					["33"] = { x = 5, y = 859, width = 3, height = 29, xadvance = 5, yoffset = 8, atlas = 0 },
					["34"] = { x = 13, y = 859, width = 7, height = 10, xadvance = 8, yoffset = 8, atlas = 0 },
					["35"] = { x = 25, y = 859, width = 13, height = 21, xadvance = 16, yoffset = 12, atlas = 0 },
					["36"] = { x = 43, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["37"] = { x = 61, y = 859, width = 21, height = 29, xadvance = 23, yoffset = 8, atlas = 0 },
					["38"] = { x = 87, y = 859, width = 21, height = 29, xadvance = 23, yoffset = 8, atlas = 0 },
					["39"] = { x = 113, y = 859, width = 3, height = 10, xadvance = 5, yoffset = 8, atlas = 0 },
					["40"] = { x = 121, y = 859, width = 8, height = 29, xadvance = 10, yoffset = 8, atlas = 0 },
					["41"] = { x = 134, y = 859, width = 8, height = 29, xadvance = 10, yoffset = 8, atlas = 0 },
					["42"] = { x = 147, y = 859, width = 8, height = 9, xadvance = 11, yoffset = 17, atlas = 0 },
					["43"] = { x = 160, y = 859, width = 8, height = 13, xadvance = 11, yoffset = 16, atlas = 0 },
					["44"] = { x = 173, y = 859, width = 3, height = 10, xadvance = 5, yoffset = 33, atlas = 0 },
					["45"] = { x = 181, y = 859, width = 8, height = 3, xadvance = 11, yoffset = 21, atlas = 0 },
					["46"] = { x = 194, y = 859, width = 3, height = 4, xadvance = 5, yoffset = 33, atlas = 0 },
					["47"] = { x = 202, y = 859, width = 17, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["48"] = { x = 224, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["49"] = { x = 242, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["50"] = { x = 260, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["51"] = { x = 278, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["52"] = { x = 296, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["53"] = { x = 314, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["54"] = { x = 332, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["55"] = { x = 350, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["56"] = { x = 368, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["57"] = { x = 386, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["58"] = { x = 404, y = 859, width = 3, height = 12, xadvance = 5, yoffset = 25, atlas = 0 },
					["59"] = { x = 412, y = 859, width = 3, height = 18, xadvance = 5, yoffset = 25, atlas = 0 },
					["60"] = { x = 420, y = 859, width = 10, height = 22, xadvance = 13, yoffset = 12, atlas = 0 },
					["61"] = { x = 435, y = 859, width = 8, height = 11, xadvance = 11, yoffset = 17, atlas = 0 },
					["62"] = { x = 448, y = 859, width = 11, height = 22, xadvance = 13, yoffset = 12, atlas = 0 },
					["63"] = { x = 464, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["64"] = { x = 482, y = 859, width = 16, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["65"] = { x = 503, y = 859, width = 17, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["66"] = { x = 525, y = 859, width = 15, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["67"] = { x = 545, y = 859, width = 18, height = 29, xadvance = 20, yoffset = 8, atlas = 0 },
					["68"] = { x = 568, y = 859, width = 15, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["69"] = { x = 588, y = 859, width = 15, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["70"] = { x = 608, y = 859, width = 15, height = 29, xadvance = 17, yoffset = 8, atlas = 0 },
					["71"] = { x = 628, y = 859, width = 18, height = 29, xadvance = 21, yoffset = 8, atlas = 0 },
					["72"] = { x = 651, y = 859, width = 15, height = 29, xadvance = 20, yoffset = 8, atlas = 0 },
					["73"] = { x = 671, y = 859, width = 4, height = 29, xadvance = 7, yoffset = 8, atlas = 0 },
					["74"] = { x = 680, y = 859, width = 13, height = 29, xadvance = 17, yoffset = 8, atlas = 0 },
					["75"] = { x = 698, y = 859, width = 16, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["76"] = { x = 719, y = 859, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["77"] = { x = 737, y = 859, width = 19, height = 29, xadvance = 23, yoffset = 8, atlas = 0 },
					["78"] = { x = 761, y = 859, width = 18, height = 29, xadvance = 21, yoffset = 8, atlas = 0 },
					["79"] = { x = 784, y = 859, width = 18, height = 29, xadvance = 23, yoffset = 8, atlas = 0 },
					["80"] = { x = 807, y = 859, width = 15, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["81"] = { x = 827, y = 859, width = 18, height = 29, xadvance = 21, yoffset = 8, atlas = 0 },
					["82"] = { x = 850, y = 859, width = 15, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["83"] = { x = 870, y = 859, width = 14, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["84"] = { x = 889, y = 859, width = 14, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["85"] = { x = 908, y = 859, width = 18, height = 29, xadvance = 21, yoffset = 8, atlas = 0 },
					["86"] = { x = 931, y = 859, width = 17, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["87"] = { x = 953, y = 859, width = 29, height = 29, xadvance = 32, yoffset = 8, atlas = 0 },
					["88"] = { x = 987, y = 859, width = 17, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["89"] = { x = 0, y = 901, width = 19, height = 29, xadvance = 21, yoffset = 8, atlas = 0 },
					["90"] = { x = 24, y = 901, width = 17, height = 29, xadvance = 19, yoffset = 8, atlas = 0 },
					["91"] = { x = 46, y = 901, width = 8, height = 29, xadvance = 10, yoffset = 8, atlas = 0 },
					["92"] = { x = 59, y = 901, width = 17, height = 29, xadvance = 18, yoffset = 8, atlas = 0 },
					["93"] = { x = 81, y = 901, width = 8, height = 29, xadvance = 10, yoffset = 8, atlas = 0 },
					["94"] = { x = 94, y = 901, width = 11, height = 8, xadvance = 13, yoffset = 8, atlas = 0 },
					["95"] = { x = 110, y = 901, width = 8, height = 3, xadvance = 11, yoffset = 39, atlas = 0 },
					["96"] = { x = 123, y = 901, width = 7, height = 8, xadvance = 8, yoffset = 8, atlas = 0 },
					["97"] = { x = 135, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["98"] = { x = 153, y = 901, width = 14, height = 29, xadvance = 17, yoffset = 8, atlas = 0 },
					["99"] = { x = 172, y = 901, width = 13, height = 21, xadvance = 15, yoffset = 16, atlas = 0 },
					["100"] = { x = 190, y = 901, width = 13, height = 29, xadvance = 16, yoffset = 8, atlas = 0 },
					["101"] = { x = 208, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["102"] = { x = 226, y = 901, width = 7, height = 29, xadvance = 8, yoffset = 8, atlas = 0 },
					["103"] = { x = 238, y = 901, width = 13, height = 29, xadvance = 16, yoffset = 16, atlas = 0 },
					["104"] = { x = 256, y = 901, width = 14, height = 29, xadvance = 17, yoffset = 8, atlas = 0 },
					["105"] = { x = 275, y = 901, width = 4, height = 29, xadvance = 6, yoffset = 8, atlas = 0 },
					["106"] = { x = 284, y = 901, width = 6, height = 37, xadvance = 9, yoffset = 8, atlas = 0 },
					["107"] = { x = 295, y = 901, width = 13, height = 29, xadvance = 15, yoffset = 8, atlas = 0 },
					["108"] = { x = 313, y = 901, width = 4, height = 29, xadvance = 6, yoffset = 8, atlas = 0 },
					["109"] = { x = 322, y = 901, width = 18, height = 21, xadvance = 20, yoffset = 16, atlas = 0 },
					["110"] = { x = 345, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["111"] = { x = 363, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["112"] = { x = 381, y = 901, width = 13, height = 29, xadvance = 16, yoffset = 16, atlas = 0 },
					["113"] = { x = 399, y = 901, width = 13, height = 29, xadvance = 16, yoffset = 16, atlas = 0 },
					["114"] = { x = 417, y = 901, width = 8, height = 21, xadvance = 9, yoffset = 16, atlas = 0 },
					["115"] = { x = 430, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["116"] = { x = 448, y = 901, width = 7, height = 27, xadvance = 9, yoffset = 10, atlas = 0 },
					["117"] = { x = 460, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["118"] = { x = 478, y = 901, width = 13, height = 21, xadvance = 13, yoffset = 16, atlas = 0 },
					["119"] = { x = 496, y = 901, width = 20, height = 21, xadvance = 21, yoffset = 16, atlas = 0 },
					["120"] = { x = 521, y = 901, width = 13, height = 21, xadvance = 14, yoffset = 16, atlas = 0 },
					["121"] = { x = 539, y = 901, width = 13, height = 29, xadvance = 14, yoffset = 16, atlas = 0 },
					["122"] = { x = 557, y = 901, width = 13, height = 21, xadvance = 16, yoffset = 16, atlas = 0 },
					["123"] = { x = 575, y = 901, width = 8, height = 29, xadvance = 11, yoffset = 8, atlas = 0 },
					["124"] = { x = 588, y = 901, width = 3, height = 32, xadvance = 5, yoffset = 6, atlas = 0 },
					["125"] = { x = 596, y = 901, width = 8, height = 29, xadvance = 11, yoffset = 8, atlas = 0 },
					["126"] = { x = 609, y = 901, width = 15, height = 8, xadvance = 15, yoffset = 18, atlas = 0 }
				},
				kerning = {
				}
			},
			["32"] = {
				lineHeight = 32,
				firstAdjust = 7,
				characters = {
					["32"] = { x = 0, y = 943, width = 0, height = 0, xadvance = 6, yoffset = 32, atlas = 0 },
					["33"] = { x = 5, y = 943, width = 3, height = 25, xadvance = 5, yoffset = 7, atlas = 0 },
					["34"] = { x = 13, y = 943, width = 6, height = 8, xadvance = 7, yoffset = 7, atlas = 0 },
					["35"] = { x = 24, y = 943, width = 11, height = 18, xadvance = 13, yoffset = 11, atlas = 0 },
					["36"] = { x = 40, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["37"] = { x = 57, y = 943, width = 19, height = 25, xadvance = 21, yoffset = 7, atlas = 0 },
					["38"] = { x = 81, y = 943, width = 18, height = 25, xadvance = 20, yoffset = 7, atlas = 0 },
					["39"] = { x = 104, y = 943, width = 3, height = 8, xadvance = 5, yoffset = 7, atlas = 0 },
					["40"] = { x = 112, y = 943, width = 7, height = 25, xadvance = 9, yoffset = 7, atlas = 0 },
					["41"] = { x = 124, y = 943, width = 8, height = 25, xadvance = 10, yoffset = 7, atlas = 0 },
					["42"] = { x = 137, y = 943, width = 7, height = 8, xadvance = 9, yoffset = 15, atlas = 0 },
					["43"] = { x = 149, y = 943, width = 7, height = 11, xadvance = 9, yoffset = 14, atlas = 0 },
					["44"] = { x = 161, y = 943, width = 3, height = 8, xadvance = 5, yoffset = 29, atlas = 0 },
					["45"] = { x = 169, y = 943, width = 7, height = 3, xadvance = 9, yoffset = 18, atlas = 0 },
					["46"] = { x = 181, y = 943, width = 3, height = 3, xadvance = 5, yoffset = 29, atlas = 0 },
					["47"] = { x = 189, y = 943, width = 15, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["48"] = { x = 209, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["49"] = { x = 226, y = 943, width = 11, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["50"] = { x = 242, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["51"] = { x = 259, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["52"] = { x = 276, y = 943, width = 11, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["53"] = { x = 292, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["54"] = { x = 309, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["55"] = { x = 326, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["56"] = { x = 343, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["57"] = { x = 360, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["58"] = { x = 377, y = 943, width = 3, height = 10, xadvance = 5, yoffset = 22, atlas = 0 },
					["59"] = { x = 385, y = 943, width = 3, height = 15, xadvance = 5, yoffset = 22, atlas = 0 },
					["60"] = { x = 393, y = 943, width = 9, height = 19, xadvance = 11, yoffset = 10, atlas = 0 },
					["61"] = { x = 407, y = 943, width = 7, height = 9, xadvance = 9, yoffset = 15, atlas = 0 },
					["62"] = { x = 419, y = 943, width = 10, height = 19, xadvance = 11, yoffset = 10, atlas = 0 },
					["63"] = { x = 434, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["64"] = { x = 451, y = 943, width = 14, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["65"] = { x = 470, y = 943, width = 15, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["66"] = { x = 490, y = 943, width = 14, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["67"] = { x = 509, y = 943, width = 16, height = 25, xadvance = 18, yoffset = 7, atlas = 0 },
					["68"] = { x = 530, y = 943, width = 14, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["69"] = { x = 549, y = 943, width = 14, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["70"] = { x = 568, y = 943, width = 14, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["71"] = { x = 587, y = 943, width = 16, height = 25, xadvance = 19, yoffset = 7, atlas = 0 },
					["72"] = { x = 608, y = 943, width = 14, height = 25, xadvance = 18, yoffset = 7, atlas = 0 },
					["73"] = { x = 627, y = 943, width = 4, height = 25, xadvance = 7, yoffset = 7, atlas = 0 },
					["74"] = { x = 636, y = 943, width = 12, height = 25, xadvance = 15, yoffset = 7, atlas = 0 },
					["75"] = { x = 653, y = 943, width = 15, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["76"] = { x = 673, y = 943, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["77"] = { x = 690, y = 943, width = 17, height = 25, xadvance = 20, yoffset = 7, atlas = 0 },
					["78"] = { x = 712, y = 943, width = 16, height = 25, xadvance = 19, yoffset = 7, atlas = 0 },
					["79"] = { x = 733, y = 943, width = 16, height = 25, xadvance = 21, yoffset = 7, atlas = 0 },
					["80"] = { x = 754, y = 943, width = 14, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["81"] = { x = 773, y = 943, width = 16, height = 25, xadvance = 19, yoffset = 7, atlas = 0 },
					["82"] = { x = 794, y = 943, width = 14, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["83"] = { x = 813, y = 943, width = 13, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["84"] = { x = 831, y = 943, width = 12, height = 25, xadvance = 13, yoffset = 7, atlas = 0 },
					["85"] = { x = 848, y = 943, width = 16, height = 25, xadvance = 19, yoffset = 7, atlas = 0 },
					["86"] = { x = 869, y = 943, width = 15, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["87"] = { x = 889, y = 943, width = 26, height = 25, xadvance = 29, yoffset = 7, atlas = 0 },
					["88"] = { x = 920, y = 943, width = 15, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["89"] = { x = 940, y = 943, width = 17, height = 25, xadvance = 18, yoffset = 7, atlas = 0 },
					["90"] = { x = 962, y = 943, width = 15, height = 25, xadvance = 17, yoffset = 7, atlas = 0 },
					["91"] = { x = 982, y = 943, width = 7, height = 25, xadvance = 9, yoffset = 7, atlas = 0 },
					["92"] = { x = 994, y = 943, width = 15, height = 25, xadvance = 16, yoffset = 7, atlas = 0 },
					["93"] = { x = 0, y = 980, width = 8, height = 25, xadvance = 10, yoffset = 7, atlas = 0 },
					["94"] = { x = 13, y = 980, width = 10, height = 7, xadvance = 11, yoffset = 7, atlas = 0 },
					["95"] = { x = 28, y = 980, width = 7, height = 3, xadvance = 9, yoffset = 33, atlas = 0 },
					["96"] = { x = 40, y = 980, width = 6, height = 7, xadvance = 7, yoffset = 7, atlas = 0 },
					["97"] = { x = 51, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["98"] = { x = 68, y = 980, width = 13, height = 25, xadvance = 15, yoffset = 7, atlas = 0 },
					["99"] = { x = 86, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["100"] = { x = 103, y = 980, width = 12, height = 25, xadvance = 14, yoffset = 7, atlas = 0 },
					["101"] = { x = 120, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["102"] = { x = 137, y = 980, width = 7, height = 25, xadvance = 8, yoffset = 7, atlas = 0 },
					["103"] = { x = 149, y = 980, width = 12, height = 25, xadvance = 14, yoffset = 14, atlas = 0 },
					["104"] = { x = 166, y = 980, width = 13, height = 25, xadvance = 15, yoffset = 7, atlas = 0 },
					["105"] = { x = 184, y = 980, width = 4, height = 25, xadvance = 6, yoffset = 7, atlas = 0 },
					["106"] = { x = 193, y = 980, width = 6, height = 32, xadvance = 8, yoffset = 7, atlas = 0 },
					["107"] = { x = 204, y = 980, width = 12, height = 25, xadvance = 13, yoffset = 7, atlas = 0 },
					["108"] = { x = 221, y = 980, width = 4, height = 25, xadvance = 6, yoffset = 7, atlas = 0 },
					["109"] = { x = 230, y = 980, width = 16, height = 18, xadvance = 18, yoffset = 14, atlas = 0 },
					["110"] = { x = 251, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["111"] = { x = 268, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["112"] = { x = 285, y = 980, width = 12, height = 25, xadvance = 14, yoffset = 14, atlas = 0 },
					["113"] = { x = 302, y = 980, width = 12, height = 25, xadvance = 14, yoffset = 14, atlas = 0 },
					["114"] = { x = 319, y = 980, width = 7, height = 18, xadvance = 9, yoffset = 14, atlas = 0 },
					["115"] = { x = 331, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["116"] = { x = 348, y = 980, width = 6, height = 23, xadvance = 7, yoffset = 9, atlas = 0 },
					["117"] = { x = 359, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["118"] = { x = 376, y = 980, width = 11, height = 18, xadvance = 11, yoffset = 14, atlas = 0 },
					["119"] = { x = 392, y = 980, width = 18, height = 18, xadvance = 19, yoffset = 14, atlas = 0 },
					["120"] = { x = 415, y = 980, width = 12, height = 18, xadvance = 13, yoffset = 14, atlas = 0 },
					["121"] = { x = 432, y = 980, width = 11, height = 25, xadvance = 13, yoffset = 14, atlas = 0 },
					["122"] = { x = 448, y = 980, width = 12, height = 18, xadvance = 14, yoffset = 14, atlas = 0 },
					["123"] = { x = 465, y = 980, width = 8, height = 25, xadvance = 10, yoffset = 7, atlas = 0 },
					["124"] = { x = 478, y = 980, width = 3, height = 27, xadvance = 5, yoffset = 6, atlas = 0 },
					["125"] = { x = 486, y = 980, width = 8, height = 25, xadvance = 10, yoffset = 7, atlas = 0 },
					["126"] = { x = 499, y = 980, width = 13, height = 7, xadvance = 14, yoffset = 16, atlas = 0 }
				},
				kerning = {
				}
			},
			["28"] = {
				lineHeight = 28,
				firstAdjust = 6,
				characters = {
					["32"] = { x = 0, y = 0, width = 0, height = 0, xadvance = 5, yoffset = 28, atlas = 1 },
					["33"] = { x = 5, y = 0, width = 2, height = 22, xadvance = 4, yoffset = 6, atlas = 1 },
					["34"] = { x = 12, y = 0, width = 5, height = 7, xadvance = 6, yoffset = 6, atlas = 1 },
					["35"] = { x = 22, y = 0, width = 10, height = 16, xadvance = 12, yoffset = 9, atlas = 1 },
					["36"] = { x = 37, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["37"] = { x = 52, y = 0, width = 16, height = 22, xadvance = 18, yoffset = 6, atlas = 1 },
					["38"] = { x = 73, y = 0, width = 16, height = 22, xadvance = 18, yoffset = 6, atlas = 1 },
					["39"] = { x = 94, y = 0, width = 2, height = 7, xadvance = 4, yoffset = 6, atlas = 1 },
					["40"] = { x = 101, y = 0, width = 6, height = 22, xadvance = 8, yoffset = 6, atlas = 1 },
					["41"] = { x = 112, y = 0, width = 6, height = 22, xadvance = 8, yoffset = 6, atlas = 1 },
					["42"] = { x = 123, y = 0, width = 6, height = 7, xadvance = 8, yoffset = 13, atlas = 1 },
					["43"] = { x = 134, y = 0, width = 6, height = 10, xadvance = 8, yoffset = 12, atlas = 1 },
					["44"] = { x = 145, y = 0, width = 2, height = 7, xadvance = 4, yoffset = 25, atlas = 1 },
					["45"] = { x = 152, y = 0, width = 6, height = 2, xadvance = 8, yoffset = 16, atlas = 1 },
					["46"] = { x = 163, y = 0, width = 2, height = 3, xadvance = 4, yoffset = 25, atlas = 1 },
					["47"] = { x = 170, y = 0, width = 13, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["48"] = { x = 188, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["49"] = { x = 203, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["50"] = { x = 218, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["51"] = { x = 233, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["52"] = { x = 248, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["53"] = { x = 263, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["54"] = { x = 278, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["55"] = { x = 293, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["56"] = { x = 308, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["57"] = { x = 323, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["58"] = { x = 338, y = 0, width = 2, height = 9, xadvance = 4, yoffset = 19, atlas = 1 },
					["59"] = { x = 345, y = 0, width = 2, height = 13, xadvance = 4, yoffset = 19, atlas = 1 },
					["60"] = { x = 352, y = 0, width = 8, height = 16, xadvance = 10, yoffset = 9, atlas = 1 },
					["61"] = { x = 365, y = 0, width = 6, height = 8, xadvance = 8, yoffset = 13, atlas = 1 },
					["62"] = { x = 376, y = 0, width = 8, height = 16, xadvance = 10, yoffset = 9, atlas = 1 },
					["63"] = { x = 389, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["64"] = { x = 404, y = 0, width = 12, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["65"] = { x = 421, y = 0, width = 13, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["66"] = { x = 439, y = 0, width = 12, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["67"] = { x = 456, y = 0, width = 14, height = 22, xadvance = 16, yoffset = 6, atlas = 1 },
					["68"] = { x = 475, y = 0, width = 12, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["69"] = { x = 492, y = 0, width = 12, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["70"] = { x = 509, y = 0, width = 12, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["71"] = { x = 526, y = 0, width = 14, height = 22, xadvance = 17, yoffset = 6, atlas = 1 },
					["72"] = { x = 545, y = 0, width = 12, height = 22, xadvance = 16, yoffset = 6, atlas = 1 },
					["73"] = { x = 562, y = 0, width = 3, height = 22, xadvance = 6, yoffset = 6, atlas = 1 },
					["74"] = { x = 570, y = 0, width = 10, height = 22, xadvance = 13, yoffset = 6, atlas = 1 },
					["75"] = { x = 585, y = 0, width = 13, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["76"] = { x = 603, y = 0, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["77"] = { x = 618, y = 0, width = 15, height = 22, xadvance = 18, yoffset = 6, atlas = 1 },
					["78"] = { x = 638, y = 0, width = 14, height = 22, xadvance = 17, yoffset = 6, atlas = 1 },
					["79"] = { x = 657, y = 0, width = 14, height = 22, xadvance = 18, yoffset = 6, atlas = 1 },
					["80"] = { x = 676, y = 0, width = 12, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["81"] = { x = 693, y = 0, width = 14, height = 22, xadvance = 17, yoffset = 6, atlas = 1 },
					["82"] = { x = 712, y = 0, width = 12, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["83"] = { x = 729, y = 0, width = 11, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["84"] = { x = 745, y = 0, width = 11, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["85"] = { x = 761, y = 0, width = 14, height = 22, xadvance = 17, yoffset = 6, atlas = 1 },
					["86"] = { x = 780, y = 0, width = 13, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["87"] = { x = 798, y = 0, width = 23, height = 22, xadvance = 25, yoffset = 6, atlas = 1 },
					["88"] = { x = 826, y = 0, width = 13, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["89"] = { x = 844, y = 0, width = 14, height = 22, xadvance = 16, yoffset = 6, atlas = 1 },
					["90"] = { x = 863, y = 0, width = 13, height = 22, xadvance = 15, yoffset = 6, atlas = 1 },
					["91"] = { x = 881, y = 0, width = 6, height = 22, xadvance = 8, yoffset = 6, atlas = 1 },
					["92"] = { x = 892, y = 0, width = 13, height = 22, xadvance = 14, yoffset = 6, atlas = 1 },
					["93"] = { x = 910, y = 0, width = 6, height = 22, xadvance = 8, yoffset = 6, atlas = 1 },
					["94"] = { x = 921, y = 0, width = 8, height = 6, xadvance = 10, yoffset = 6, atlas = 1 },
					["95"] = { x = 934, y = 0, width = 6, height = 2, xadvance = 8, yoffset = 30, atlas = 1 },
					["96"] = { x = 945, y = 0, width = 5, height = 6, xadvance = 6, yoffset = 6, atlas = 1 },
					["97"] = { x = 955, y = 0, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["98"] = { x = 970, y = 0, width = 11, height = 22, xadvance = 13, yoffset = 6, atlas = 1 },
					["99"] = { x = 986, y = 0, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["100"] = { x = 1001, y = 0, width = 10, height = 22, xadvance = 13, yoffset = 6, atlas = 1 },
					["101"] = { x = 0, y = 33, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["102"] = { x = 15, y = 33, width = 6, height = 22, xadvance = 7, yoffset = 6, atlas = 1 },
					["103"] = { x = 26, y = 33, width = 10, height = 22, xadvance = 12, yoffset = 12, atlas = 1 },
					["104"] = { x = 41, y = 33, width = 11, height = 22, xadvance = 13, yoffset = 6, atlas = 1 },
					["105"] = { x = 57, y = 33, width = 3, height = 22, xadvance = 5, yoffset = 6, atlas = 1 },
					["106"] = { x = 65, y = 33, width = 4, height = 28, xadvance = 7, yoffset = 6, atlas = 1 },
					["107"] = { x = 74, y = 33, width = 10, height = 22, xadvance = 12, yoffset = 6, atlas = 1 },
					["108"] = { x = 89, y = 33, width = 3, height = 22, xadvance = 5, yoffset = 6, atlas = 1 },
					["109"] = { x = 97, y = 33, width = 14, height = 16, xadvance = 16, yoffset = 12, atlas = 1 },
					["110"] = { x = 116, y = 33, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["111"] = { x = 131, y = 33, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["112"] = { x = 146, y = 33, width = 10, height = 22, xadvance = 12, yoffset = 12, atlas = 1 },
					["113"] = { x = 161, y = 33, width = 10, height = 22, xadvance = 12, yoffset = 12, atlas = 1 },
					["114"] = { x = 176, y = 33, width = 6, height = 16, xadvance = 8, yoffset = 12, atlas = 1 },
					["115"] = { x = 187, y = 33, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["116"] = { x = 202, y = 33, width = 5, height = 20, xadvance = 6, yoffset = 8, atlas = 1 },
					["117"] = { x = 212, y = 33, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["118"] = { x = 227, y = 33, width = 10, height = 16, xadvance = 10, yoffset = 12, atlas = 1 },
					["119"] = { x = 242, y = 33, width = 16, height = 16, xadvance = 17, yoffset = 12, atlas = 1 },
					["120"] = { x = 263, y = 33, width = 10, height = 16, xadvance = 11, yoffset = 12, atlas = 1 },
					["121"] = { x = 278, y = 33, width = 10, height = 22, xadvance = 11, yoffset = 12, atlas = 1 },
					["122"] = { x = 293, y = 33, width = 10, height = 16, xadvance = 12, yoffset = 12, atlas = 1 },
					["123"] = { x = 308, y = 33, width = 6, height = 22, xadvance = 8, yoffset = 6, atlas = 1 },
					["124"] = { x = 319, y = 33, width = 2, height = 24, xadvance = 4, yoffset = 5, atlas = 1 },
					["125"] = { x = 326, y = 33, width = 6, height = 22, xadvance = 8, yoffset = 6, atlas = 1 },
					["126"] = { x = 337, y = 33, width = 11, height = 6, xadvance = 12, yoffset = 14, atlas = 1 }
				},
				kerning = {
				}
			},
			["24"] = {
				lineHeight = 24,
				firstAdjust = 5,
				characters = {
					["32"] = { x = 0, y = 66, width = 0, height = 0, xadvance = 4, yoffset = 24, atlas = 1 },
					["33"] = { x = 5, y = 66, width = 2, height = 19, xadvance = 3, yoffset = 5, atlas = 1 },
					["34"] = { x = 12, y = 66, width = 4, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["35"] = { x = 21, y = 66, width = 9, height = 14, xadvance = 11, yoffset = 7, atlas = 1 },
					["36"] = { x = 35, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["37"] = { x = 49, y = 66, width = 14, height = 19, xadvance = 15, yoffset = 5, atlas = 1 },
					["38"] = { x = 68, y = 66, width = 15, height = 19, xadvance = 16, yoffset = 5, atlas = 1 },
					["39"] = { x = 88, y = 66, width = 2, height = 7, xadvance = 3, yoffset = 5, atlas = 1 },
					["40"] = { x = 95, y = 66, width = 5, height = 19, xadvance = 7, yoffset = 5, atlas = 1 },
					["41"] = { x = 105, y = 66, width = 6, height = 19, xadvance = 7, yoffset = 5, atlas = 1 },
					["42"] = { x = 116, y = 66, width = 5, height = 7, xadvance = 7, yoffset = 10, atlas = 1 },
					["43"] = { x = 126, y = 66, width = 5, height = 9, xadvance = 7, yoffset = 10, atlas = 1 },
					["44"] = { x = 136, y = 66, width = 2, height = 7, xadvance = 3, yoffset = 21, atlas = 1 },
					["45"] = { x = 143, y = 66, width = 5, height = 2, xadvance = 7, yoffset = 13, atlas = 1 },
					["46"] = { x = 153, y = 66, width = 2, height = 3, xadvance = 3, yoffset = 21, atlas = 1 },
					["47"] = { x = 160, y = 66, width = 12, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["48"] = { x = 177, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["49"] = { x = 191, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["50"] = { x = 205, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["51"] = { x = 219, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["52"] = { x = 233, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["53"] = { x = 247, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["54"] = { x = 261, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["55"] = { x = 275, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["56"] = { x = 289, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["57"] = { x = 303, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["58"] = { x = 317, y = 66, width = 2, height = 8, xadvance = 3, yoffset = 16, atlas = 1 },
					["59"] = { x = 324, y = 66, width = 2, height = 12, xadvance = 3, yoffset = 16, atlas = 1 },
					["60"] = { x = 331, y = 66, width = 7, height = 15, xadvance = 9, yoffset = 7, atlas = 1 },
					["61"] = { x = 343, y = 66, width = 5, height = 7, xadvance = 7, yoffset = 11, atlas = 1 },
					["62"] = { x = 353, y = 66, width = 7, height = 15, xadvance = 9, yoffset = 7, atlas = 1 },
					["63"] = { x = 365, y = 66, width = 8, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["64"] = { x = 378, y = 66, width = 10, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["65"] = { x = 393, y = 66, width = 11, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["66"] = { x = 409, y = 66, width = 11, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["67"] = { x = 425, y = 66, width = 13, height = 19, xadvance = 14, yoffset = 5, atlas = 1 },
					["68"] = { x = 443, y = 66, width = 11, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["69"] = { x = 459, y = 66, width = 11, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["70"] = { x = 475, y = 66, width = 11, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["71"] = { x = 491, y = 66, width = 12, height = 19, xadvance = 15, yoffset = 5, atlas = 1 },
					["72"] = { x = 508, y = 66, width = 11, height = 19, xadvance = 14, yoffset = 5, atlas = 1 },
					["73"] = { x = 524, y = 66, width = 3, height = 19, xadvance = 5, yoffset = 5, atlas = 1 },
					["74"] = { x = 532, y = 66, width = 9, height = 19, xadvance = 11, yoffset = 5, atlas = 1 },
					["75"] = { x = 546, y = 66, width = 12, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["76"] = { x = 563, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["77"] = { x = 577, y = 66, width = 13, height = 19, xadvance = 16, yoffset = 5, atlas = 1 },
					["78"] = { x = 595, y = 66, width = 12, height = 19, xadvance = 15, yoffset = 5, atlas = 1 },
					["79"] = { x = 612, y = 66, width = 12, height = 19, xadvance = 15, yoffset = 5, atlas = 1 },
					["80"] = { x = 629, y = 66, width = 11, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["81"] = { x = 645, y = 66, width = 12, height = 19, xadvance = 15, yoffset = 5, atlas = 1 },
					["82"] = { x = 662, y = 66, width = 11, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["83"] = { x = 678, y = 66, width = 10, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["84"] = { x = 693, y = 66, width = 10, height = 19, xadvance = 11, yoffset = 5, atlas = 1 },
					["85"] = { x = 708, y = 66, width = 12, height = 19, xadvance = 15, yoffset = 5, atlas = 1 },
					["86"] = { x = 725, y = 66, width = 11, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["87"] = { x = 741, y = 66, width = 20, height = 19, xadvance = 21, yoffset = 5, atlas = 1 },
					["88"] = { x = 766, y = 66, width = 12, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["89"] = { x = 783, y = 66, width = 12, height = 19, xadvance = 14, yoffset = 5, atlas = 1 },
					["90"] = { x = 800, y = 66, width = 11, height = 19, xadvance = 13, yoffset = 5, atlas = 1 },
					["91"] = { x = 816, y = 66, width = 5, height = 19, xadvance = 7, yoffset = 5, atlas = 1 },
					["92"] = { x = 826, y = 66, width = 12, height = 19, xadvance = 12, yoffset = 5, atlas = 1 },
					["93"] = { x = 843, y = 66, width = 6, height = 19, xadvance = 7, yoffset = 5, atlas = 1 },
					["94"] = { x = 854, y = 66, width = 7, height = 5, xadvance = 9, yoffset = 5, atlas = 1 },
					["95"] = { x = 866, y = 66, width = 5, height = 2, xadvance = 7, yoffset = 25, atlas = 1 },
					["96"] = { x = 876, y = 66, width = 5, height = 5, xadvance = 5, yoffset = 5, atlas = 1 },
					["97"] = { x = 886, y = 66, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["98"] = { x = 900, y = 66, width = 10, height = 19, xadvance = 11, yoffset = 5, atlas = 1 },
					["99"] = { x = 915, y = 66, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["100"] = { x = 929, y = 66, width = 9, height = 19, xadvance = 11, yoffset = 5, atlas = 1 },
					["101"] = { x = 943, y = 66, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["102"] = { x = 957, y = 66, width = 5, height = 19, xadvance = 6, yoffset = 5, atlas = 1 },
					["103"] = { x = 967, y = 66, width = 9, height = 19, xadvance = 10, yoffset = 10, atlas = 1 },
					["104"] = { x = 981, y = 66, width = 10, height = 19, xadvance = 11, yoffset = 5, atlas = 1 },
					["105"] = { x = 996, y = 66, width = 3, height = 19, xadvance = 5, yoffset = 5, atlas = 1 },
					["106"] = { x = 1004, y = 66, width = 4, height = 24, xadvance = 6, yoffset = 5, atlas = 1 },
					["107"] = { x = 0, y = 95, width = 9, height = 19, xadvance = 10, yoffset = 5, atlas = 1 },
					["108"] = { x = 14, y = 95, width = 3, height = 19, xadvance = 5, yoffset = 5, atlas = 1 },
					["109"] = { x = 22, y = 95, width = 13, height = 14, xadvance = 14, yoffset = 10, atlas = 1 },
					["110"] = { x = 40, y = 95, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["111"] = { x = 54, y = 95, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["112"] = { x = 68, y = 95, width = 9, height = 19, xadvance = 10, yoffset = 10, atlas = 1 },
					["113"] = { x = 82, y = 95, width = 9, height = 19, xadvance = 10, yoffset = 10, atlas = 1 },
					["114"] = { x = 96, y = 95, width = 5, height = 14, xadvance = 6, yoffset = 10, atlas = 1 },
					["115"] = { x = 106, y = 95, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["116"] = { x = 120, y = 95, width = 4, height = 18, xadvance = 5, yoffset = 6, atlas = 1 },
					["117"] = { x = 129, y = 95, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["118"] = { x = 143, y = 95, width = 9, height = 14, xadvance = 9, yoffset = 10, atlas = 1 },
					["119"] = { x = 157, y = 95, width = 14, height = 14, xadvance = 14, yoffset = 10, atlas = 1 },
					["120"] = { x = 176, y = 95, width = 9, height = 14, xadvance = 9, yoffset = 10, atlas = 1 },
					["121"] = { x = 190, y = 95, width = 9, height = 19, xadvance = 9, yoffset = 10, atlas = 1 },
					["122"] = { x = 204, y = 95, width = 9, height = 14, xadvance = 10, yoffset = 10, atlas = 1 },
					["123"] = { x = 218, y = 95, width = 6, height = 20, xadvance = 7, yoffset = 4, atlas = 1 },
					["124"] = { x = 229, y = 95, width = 2, height = 21, xadvance = 3, yoffset = 4, atlas = 1 },
					["125"] = { x = 236, y = 95, width = 6, height = 20, xadvance = 7, yoffset = 4, atlas = 1 },
					["126"] = { x = 247, y = 95, width = 10, height = 6, xadvance = 10, yoffset = 11, atlas = 1 }
				},
				kerning = {
				}
			},
			["18"] = {
				lineHeight = 18,
				firstAdjust = 4,
				characters = {
					["32"] = { x = 0, y = 124, width = 0, height = 0, xadvance = 3, yoffset = 18, atlas = 1 },
					["33"] = { x = 5, y = 124, width = 2, height = 14, xadvance = 2, yoffset = 4, atlas = 1 },
					["34"] = { x = 12, y = 124, width = 4, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["35"] = { x = 21, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 6, atlas = 1 },
					["36"] = { x = 33, y = 124, width = 8, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["37"] = { x = 46, y = 124, width = 11, height = 14, xadvance = 11, yoffset = 4, atlas = 1 },
					["38"] = { x = 62, y = 124, width = 11, height = 14, xadvance = 12, yoffset = 4, atlas = 1 },
					["39"] = { x = 78, y = 124, width = 2, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["40"] = { x = 85, y = 124, width = 4, height = 14, xadvance = 5, yoffset = 4, atlas = 1 },
					["41"] = { x = 94, y = 124, width = 5, height = 14, xadvance = 5, yoffset = 4, atlas = 1 },
					["42"] = { x = 104, y = 124, width = 4, height = 5, xadvance = 5, yoffset = 8, atlas = 1 },
					["43"] = { x = 113, y = 124, width = 4, height = 6, xadvance = 5, yoffset = 8, atlas = 1 },
					["44"] = { x = 122, y = 124, width = 2, height = 5, xadvance = 3, yoffset = 16, atlas = 1 },
					["45"] = { x = 129, y = 124, width = 4, height = 3, xadvance = 5, yoffset = 10, atlas = 1 },
					["46"] = { x = 138, y = 124, width = 2, height = 2, xadvance = 2, yoffset = 16, atlas = 1 },
					["47"] = { x = 145, y = 124, width = 9, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["48"] = { x = 159, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["49"] = { x = 171, y = 124, width = 6, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["50"] = { x = 182, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["51"] = { x = 194, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["52"] = { x = 206, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["53"] = { x = 218, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["54"] = { x = 230, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["55"] = { x = 242, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["56"] = { x = 254, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["57"] = { x = 266, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["58"] = { x = 278, y = 124, width = 2, height = 6, xadvance = 2, yoffset = 12, atlas = 1 },
					["59"] = { x = 285, y = 124, width = 2, height = 9, xadvance = 2, yoffset = 12, atlas = 1 },
					["60"] = { x = 292, y = 124, width = 5, height = 11, xadvance = 6, yoffset = 6, atlas = 1 },
					["61"] = { x = 302, y = 124, width = 4, height = 7, xadvance = 5, yoffset = 7, atlas = 1 },
					["62"] = { x = 311, y = 124, width = 6, height = 11, xadvance = 6, yoffset = 6, atlas = 1 },
					["63"] = { x = 322, y = 124, width = 8, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["64"] = { x = 335, y = 124, width = 8, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["65"] = { x = 348, y = 124, width = 9, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["66"] = { x = 362, y = 124, width = 8, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["67"] = { x = 375, y = 124, width = 10, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["68"] = { x = 390, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["69"] = { x = 404, y = 124, width = 8, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["70"] = { x = 417, y = 124, width = 8, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["71"] = { x = 430, y = 124, width = 10, height = 14, xadvance = 11, yoffset = 4, atlas = 1 },
					["72"] = { x = 445, y = 124, width = 9, height = 14, xadvance = 11, yoffset = 4, atlas = 1 },
					["73"] = { x = 459, y = 124, width = 3, height = 14, xadvance = 4, yoffset = 4, atlas = 1 },
					["74"] = { x = 467, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["75"] = { x = 479, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["76"] = { x = 493, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["77"] = { x = 505, y = 124, width = 11, height = 14, xadvance = 12, yoffset = 4, atlas = 1 },
					["78"] = { x = 521, y = 124, width = 10, height = 14, xadvance = 11, yoffset = 4, atlas = 1 },
					["79"] = { x = 536, y = 124, width = 10, height = 14, xadvance = 12, yoffset = 4, atlas = 1 },
					["80"] = { x = 551, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["81"] = { x = 565, y = 124, width = 10, height = 14, xadvance = 11, yoffset = 4, atlas = 1 },
					["82"] = { x = 580, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["83"] = { x = 594, y = 124, width = 8, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["84"] = { x = 607, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["85"] = { x = 619, y = 124, width = 10, height = 14, xadvance = 11, yoffset = 4, atlas = 1 },
					["86"] = { x = 634, y = 124, width = 9, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["87"] = { x = 648, y = 124, width = 15, height = 14, xadvance = 16, yoffset = 4, atlas = 1 },
					["88"] = { x = 668, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["89"] = { x = 682, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["90"] = { x = 696, y = 124, width = 9, height = 14, xadvance = 10, yoffset = 4, atlas = 1 },
					["91"] = { x = 710, y = 124, width = 4, height = 14, xadvance = 5, yoffset = 4, atlas = 1 },
					["92"] = { x = 719, y = 124, width = 9, height = 14, xadvance = 9, yoffset = 4, atlas = 1 },
					["93"] = { x = 733, y = 124, width = 5, height = 14, xadvance = 5, yoffset = 4, atlas = 1 },
					["94"] = { x = 743, y = 124, width = 6, height = 4, xadvance = 6, yoffset = 4, atlas = 1 },
					["95"] = { x = 754, y = 124, width = 4, height = 3, xadvance = 5, yoffset = 18, atlas = 1 },
					["96"] = { x = 763, y = 124, width = 4, height = 4, xadvance = 4, yoffset = 4, atlas = 1 },
					["97"] = { x = 772, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["98"] = { x = 784, y = 124, width = 8, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["99"] = { x = 797, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["100"] = { x = 809, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["101"] = { x = 821, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["102"] = { x = 833, y = 124, width = 4, height = 14, xadvance = 5, yoffset = 4, atlas = 1 },
					["103"] = { x = 842, y = 124, width = 7, height = 14, xadvance = 7, yoffset = 8, atlas = 1 },
					["104"] = { x = 854, y = 124, width = 8, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["105"] = { x = 867, y = 124, width = 3, height = 14, xadvance = 4, yoffset = 4, atlas = 1 },
					["106"] = { x = 875, y = 124, width = 4, height = 18, xadvance = 5, yoffset = 4, atlas = 1 },
					["107"] = { x = 884, y = 124, width = 7, height = 14, xadvance = 8, yoffset = 4, atlas = 1 },
					["108"] = { x = 896, y = 124, width = 3, height = 14, xadvance = 4, yoffset = 4, atlas = 1 },
					["109"] = { x = 904, y = 124, width = 10, height = 10, xadvance = 10, yoffset = 8, atlas = 1 },
					["110"] = { x = 919, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["111"] = { x = 931, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["112"] = { x = 943, y = 124, width = 7, height = 14, xadvance = 7, yoffset = 8, atlas = 1 },
					["113"] = { x = 955, y = 124, width = 7, height = 14, xadvance = 7, yoffset = 8, atlas = 1 },
					["114"] = { x = 967, y = 124, width = 4, height = 10, xadvance = 5, yoffset = 8, atlas = 1 },
					["115"] = { x = 976, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["116"] = { x = 988, y = 124, width = 4, height = 13, xadvance = 5, yoffset = 5, atlas = 1 },
					["117"] = { x = 997, y = 124, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["118"] = { x = 1009, y = 124, width = 7, height = 10, xadvance = 6, yoffset = 8, atlas = 1 },
					["119"] = { x = 0, y = 147, width = 10, height = 10, xadvance = 11, yoffset = 8, atlas = 1 },
					["120"] = { x = 15, y = 147, width = 7, height = 10, xadvance = 7, yoffset = 8, atlas = 1 },
					["121"] = { x = 27, y = 147, width = 7, height = 14, xadvance = 7, yoffset = 8, atlas = 1 },
					["122"] = { x = 39, y = 147, width = 7, height = 10, xadvance = 8, yoffset = 8, atlas = 1 },
					["123"] = { x = 51, y = 147, width = 5, height = 14, xadvance = 6, yoffset = 4, atlas = 1 },
					["124"] = { x = 61, y = 147, width = 2, height = 15, xadvance = 2, yoffset = 4, atlas = 1 },
					["125"] = { x = 68, y = 147, width = 5, height = 14, xadvance = 6, yoffset = 4, atlas = 1 },
					["126"] = { x = 78, y = 147, width = 8, height = 4, xadvance = 8, yoffset = 9, atlas = 1 }
				},
				kerning = {
				}
			},
			["14"] = {
				lineHeight = 14,
				firstAdjust = 3,
				characters = {
					["32"] = { x = 0, y = 170, width = 0, height = 0, xadvance = 3, yoffset = 14, atlas = 1 },
					["33"] = { x = 5, y = 170, width = 1, height = 11, xadvance = 2, yoffset = 3, atlas = 1 },
					["34"] = { x = 11, y = 170, width = 3, height = 4, xadvance = 3, yoffset = 3, atlas = 1 },
					["35"] = { x = 19, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 4, atlas = 1 },
					["36"] = { x = 29, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["37"] = { x = 39, y = 170, width = 8, height = 11, xadvance = 9, yoffset = 3, atlas = 1 },
					["38"] = { x = 52, y = 170, width = 9, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["39"] = { x = 66, y = 170, width = 1, height = 4, xadvance = 2, yoffset = 3, atlas = 1 },
					["40"] = { x = 72, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["41"] = { x = 80, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["42"] = { x = 88, y = 170, width = 3, height = 3, xadvance = 4, yoffset = 7, atlas = 1 },
					["43"] = { x = 96, y = 170, width = 3, height = 5, xadvance = 4, yoffset = 6, atlas = 1 },
					["44"] = { x = 104, y = 170, width = 1, height = 4, xadvance = 2, yoffset = 12, atlas = 1 },
					["45"] = { x = 110, y = 170, width = 3, height = 1, xadvance = 4, yoffset = 8, atlas = 1 },
					["46"] = { x = 118, y = 170, width = 1, height = 1, xadvance = 2, yoffset = 13, atlas = 1 },
					["47"] = { x = 124, y = 170, width = 7, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["48"] = { x = 136, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["49"] = { x = 146, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["50"] = { x = 156, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["51"] = { x = 166, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["52"] = { x = 176, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["53"] = { x = 186, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["54"] = { x = 196, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["55"] = { x = 206, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["56"] = { x = 216, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["57"] = { x = 226, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["58"] = { x = 236, y = 170, width = 1, height = 4, xadvance = 2, yoffset = 10, atlas = 1 },
					["59"] = { x = 242, y = 170, width = 1, height = 6, xadvance = 2, yoffset = 10, atlas = 1 },
					["60"] = { x = 248, y = 170, width = 4, height = 9, xadvance = 5, yoffset = 4, atlas = 1 },
					["61"] = { x = 257, y = 170, width = 3, height = 4, xadvance = 4, yoffset = 6, atlas = 1 },
					["62"] = { x = 265, y = 170, width = 4, height = 9, xadvance = 5, yoffset = 4, atlas = 1 },
					["63"] = { x = 274, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["64"] = { x = 284, y = 170, width = 6, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["65"] = { x = 295, y = 170, width = 7, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["66"] = { x = 307, y = 170, width = 7, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["67"] = { x = 319, y = 170, width = 8, height = 11, xadvance = 9, yoffset = 3, atlas = 1 },
					["68"] = { x = 332, y = 170, width = 7, height = 11, xadvance = 9, yoffset = 3, atlas = 1 },
					["69"] = { x = 344, y = 170, width = 7, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["70"] = { x = 356, y = 170, width = 7, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["71"] = { x = 368, y = 170, width = 8, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["72"] = { x = 381, y = 170, width = 7, height = 11, xadvance = 9, yoffset = 3, atlas = 1 },
					["73"] = { x = 393, y = 170, width = 2, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["74"] = { x = 400, y = 170, width = 5, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["75"] = { x = 410, y = 170, width = 7, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["76"] = { x = 422, y = 170, width = 6, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["77"] = { x = 433, y = 170, width = 8, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["78"] = { x = 446, y = 170, width = 8, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["79"] = { x = 459, y = 170, width = 8, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["80"] = { x = 472, y = 170, width = 7, height = 11, xadvance = 9, yoffset = 3, atlas = 1 },
					["81"] = { x = 484, y = 170, width = 8, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["82"] = { x = 497, y = 170, width = 7, height = 11, xadvance = 9, yoffset = 3, atlas = 1 },
					["83"] = { x = 509, y = 170, width = 6, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["84"] = { x = 520, y = 170, width = 6, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["85"] = { x = 531, y = 170, width = 8, height = 11, xadvance = 10, yoffset = 3, atlas = 1 },
					["86"] = { x = 544, y = 170, width = 7, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["87"] = { x = 556, y = 170, width = 12, height = 11, xadvance = 13, yoffset = 3, atlas = 1 },
					["88"] = { x = 573, y = 170, width = 7, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["89"] = { x = 585, y = 170, width = 7, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["90"] = { x = 597, y = 170, width = 7, height = 11, xadvance = 8, yoffset = 3, atlas = 1 },
					["91"] = { x = 609, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["92"] = { x = 617, y = 170, width = 7, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["93"] = { x = 629, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["94"] = { x = 637, y = 170, width = 4, height = 3, xadvance = 5, yoffset = 3, atlas = 1 },
					["95"] = { x = 646, y = 170, width = 3, height = 1, xadvance = 4, yoffset = 15, atlas = 1 },
					["96"] = { x = 654, y = 170, width = 3, height = 3, xadvance = 3, yoffset = 3, atlas = 1 },
					["97"] = { x = 662, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["98"] = { x = 672, y = 170, width = 6, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["99"] = { x = 683, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["100"] = { x = 693, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["101"] = { x = 703, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["102"] = { x = 713, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["103"] = { x = 721, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 6, atlas = 1 },
					["104"] = { x = 731, y = 170, width = 6, height = 11, xadvance = 7, yoffset = 3, atlas = 1 },
					["105"] = { x = 742, y = 170, width = 2, height = 11, xadvance = 3, yoffset = 3, atlas = 1 },
					["106"] = { x = 749, y = 170, width = 2, height = 14, xadvance = 3, yoffset = 3, atlas = 1 },
					["107"] = { x = 756, y = 170, width = 6, height = 11, xadvance = 6, yoffset = 3, atlas = 1 },
					["108"] = { x = 767, y = 170, width = 2, height = 11, xadvance = 3, yoffset = 3, atlas = 1 },
					["109"] = { x = 774, y = 170, width = 7, height = 8, xadvance = 8, yoffset = 6, atlas = 1 },
					["110"] = { x = 786, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["111"] = { x = 796, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["112"] = { x = 806, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 6, atlas = 1 },
					["113"] = { x = 816, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 6, atlas = 1 },
					["114"] = { x = 826, y = 170, width = 3, height = 8, xadvance = 4, yoffset = 6, atlas = 1 },
					["115"] = { x = 834, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["116"] = { x = 844, y = 170, width = 3, height = 10, xadvance = 4, yoffset = 4, atlas = 1 },
					["117"] = { x = 852, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["118"] = { x = 862, y = 170, width = 5, height = 8, xadvance = 5, yoffset = 6, atlas = 1 },
					["119"] = { x = 872, y = 170, width = 8, height = 8, xadvance = 8, yoffset = 6, atlas = 1 },
					["120"] = { x = 885, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["121"] = { x = 895, y = 170, width = 5, height = 11, xadvance = 6, yoffset = 6, atlas = 1 },
					["122"] = { x = 905, y = 170, width = 5, height = 8, xadvance = 6, yoffset = 6, atlas = 1 },
					["123"] = { x = 915, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["124"] = { x = 923, y = 170, width = 1, height = 12, xadvance = 2, yoffset = 2, atlas = 1 },
					["125"] = { x = 929, y = 170, width = 3, height = 11, xadvance = 4, yoffset = 3, atlas = 1 },
					["126"] = { x = 937, y = 170, width = 6, height = 3, xadvance = 6, yoffset = 7, atlas = 1 }
				},
				kerning = {
				}
			},
			["12"] = {
				lineHeight = 13,
				firstAdjust = 2,
				characters = {
					["32"] = { x = 0, y = 189, width = 0, height = 0, xadvance = 2, yoffset = 12, atlas = 1 },
					["33"] = { x = 5, y = 189, width = 1, height = 10, xadvance = 2, yoffset = 2, atlas = 1 },
					["34"] = { x = 11, y = 189, width = 3, height = 4, xadvance = 3, yoffset = 2, atlas = 1 },
					["35"] = { x = 19, y = 189, width = 5, height = 7, xadvance = 6, yoffset = 4, atlas = 1 },
					["36"] = { x = 29, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["37"] = { x = 39, y = 189, width = 7, height = 10, xadvance = 8, yoffset = 2, atlas = 1 },
					["38"] = { x = 51, y = 189, width = 7, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["39"] = { x = 63, y = 189, width = 1, height = 4, xadvance = 2, yoffset = 2, atlas = 1 },
					["40"] = { x = 69, y = 189, width = 3, height = 10, xadvance = 4, yoffset = 2, atlas = 1 },
					["41"] = { x = 77, y = 189, width = 3, height = 10, xadvance = 4, yoffset = 2, atlas = 1 },
					["42"] = { x = 85, y = 189, width = 3, height = 3, xadvance = 4, yoffset = 6, atlas = 1 },
					["43"] = { x = 93, y = 189, width = 3, height = 4, xadvance = 4, yoffset = 5, atlas = 1 },
					["44"] = { x = 101, y = 189, width = 1, height = 4, xadvance = 2, yoffset = 11, atlas = 1 },
					["45"] = { x = 107, y = 189, width = 3, height = 1, xadvance = 3, yoffset = 7, atlas = 1 },
					["46"] = { x = 115, y = 189, width = 1, height = 1, xadvance = 2, yoffset = 11, atlas = 1 },
					["47"] = { x = 121, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["48"] = { x = 132, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["49"] = { x = 141, y = 189, width = 5, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["50"] = { x = 151, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["51"] = { x = 160, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["52"] = { x = 169, y = 189, width = 5, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["53"] = { x = 179, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["54"] = { x = 188, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["55"] = { x = 197, y = 189, width = 5, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["56"] = { x = 207, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["57"] = { x = 216, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["58"] = { x = 225, y = 189, width = 1, height = 4, xadvance = 2, yoffset = 8, atlas = 1 },
					["59"] = { x = 231, y = 189, width = 1, height = 6, xadvance = 2, yoffset = 8, atlas = 1 },
					["60"] = { x = 237, y = 189, width = 3, height = 8, xadvance = 4, yoffset = 3, atlas = 1 },
					["61"] = { x = 245, y = 189, width = 3, height = 4, xadvance = 3, yoffset = 5, atlas = 1 },
					["62"] = { x = 253, y = 189, width = 4, height = 8, xadvance = 4, yoffset = 3, atlas = 1 },
					["63"] = { x = 262, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["64"] = { x = 272, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["65"] = { x = 282, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["66"] = { x = 293, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["67"] = { x = 303, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["68"] = { x = 314, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["69"] = { x = 324, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["70"] = { x = 334, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["71"] = { x = 344, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["72"] = { x = 355, y = 189, width = 5, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["73"] = { x = 365, y = 189, width = 1, height = 10, xadvance = 2, yoffset = 2, atlas = 1 },
					["74"] = { x = 371, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["75"] = { x = 380, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["76"] = { x = 391, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["77"] = { x = 400, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["78"] = { x = 411, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["79"] = { x = 422, y = 189, width = 6, height = 10, xadvance = 8, yoffset = 2, atlas = 1 },
					["80"] = { x = 433, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["81"] = { x = 443, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["82"] = { x = 454, y = 189, width = 5, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["83"] = { x = 464, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["84"] = { x = 475, y = 189, width = 5, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["85"] = { x = 485, y = 189, width = 6, height = 10, xadvance = 7, yoffset = 2, atlas = 1 },
					["86"] = { x = 496, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["87"] = { x = 507, y = 189, width = 10, height = 10, xadvance = 11, yoffset = 2, atlas = 1 },
					["88"] = { x = 522, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["89"] = { x = 533, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["90"] = { x = 544, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["91"] = { x = 555, y = 189, width = 3, height = 10, xadvance = 4, yoffset = 2, atlas = 1 },
					["92"] = { x = 563, y = 189, width = 6, height = 10, xadvance = 6, yoffset = 2, atlas = 1 },
					["93"] = { x = 574, y = 189, width = 3, height = 10, xadvance = 4, yoffset = 2, atlas = 1 },
					["94"] = { x = 582, y = 189, width = 4, height = 3, xadvance = 4, yoffset = 2, atlas = 1 },
					["95"] = { x = 591, y = 189, width = 3, height = 1, xadvance = 3, yoffset = 13, atlas = 1 },
					["96"] = { x = 599, y = 189, width = 3, height = 3, xadvance = 3, yoffset = 2, atlas = 1 },
					["97"] = { x = 607, y = 189, width = 4, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["98"] = { x = 616, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["99"] = { x = 625, y = 189, width = 5, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["100"] = { x = 635, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["101"] = { x = 644, y = 189, width = 4, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["102"] = { x = 653, y = 189, width = 3, height = 10, xadvance = 3, yoffset = 2, atlas = 1 },
					["103"] = { x = 661, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 5, atlas = 1 },
					["104"] = { x = 670, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["105"] = { x = 679, y = 189, width = 2, height = 10, xadvance = 2, yoffset = 2, atlas = 1 },
					["106"] = { x = 686, y = 189, width = 2, height = 13, xadvance = 3, yoffset = 2, atlas = 1 },
					["107"] = { x = 693, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 2, atlas = 1 },
					["108"] = { x = 702, y = 189, width = 1, height = 10, xadvance = 2, yoffset = 2, atlas = 1 },
					["109"] = { x = 708, y = 189, width = 7, height = 7, xadvance = 8, yoffset = 5, atlas = 1 },
					["110"] = { x = 720, y = 189, width = 4, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["111"] = { x = 729, y = 189, width = 4, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["112"] = { x = 738, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 5, atlas = 1 },
					["113"] = { x = 747, y = 189, width = 4, height = 10, xadvance = 5, yoffset = 5, atlas = 1 },
					["114"] = { x = 756, y = 189, width = 3, height = 7, xadvance = 3, yoffset = 5, atlas = 1 },
					["115"] = { x = 764, y = 189, width = 5, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["116"] = { x = 774, y = 189, width = 2, height = 9, xadvance = 2, yoffset = 3, atlas = 1 },
					["117"] = { x = 781, y = 189, width = 4, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["118"] = { x = 790, y = 189, width = 5, height = 7, xadvance = 4, yoffset = 5, atlas = 1 },
					["119"] = { x = 800, y = 189, width = 7, height = 7, xadvance = 7, yoffset = 5, atlas = 1 },
					["120"] = { x = 812, y = 189, width = 5, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["121"] = { x = 822, y = 189, width = 5, height = 10, xadvance = 5, yoffset = 5, atlas = 1 },
					["122"] = { x = 832, y = 189, width = 5, height = 7, xadvance = 5, yoffset = 5, atlas = 1 },
					["123"] = { x = 842, y = 189, width = 3, height = 10, xadvance = 3, yoffset = 2, atlas = 1 },
					["124"] = { x = 850, y = 189, width = 1, height = 11, xadvance = 2, yoffset = 1, atlas = 1 },
					["125"] = { x = 856, y = 189, width = 3, height = 10, xadvance = 3, yoffset = 2, atlas = 1 },
					["126"] = { x = 864, y = 189, width = 5, height = 3, xadvance = 5, yoffset = 5, atlas = 1 }
				},
				kerning = {
				}
			},
			["11"] = {
				lineHeight = 10,
				firstAdjust = 3,
				characters = {
					["32"] = { x = 0, y = 207, width = 0, height = 0, xadvance = 2, yoffset = 11, atlas = 1 },
					["33"] = { x = 5, y = 207, width = 1, height = 8, xadvance = 2, yoffset = 3, atlas = 1 },
					["34"] = { x = 11, y = 207, width = 2, height = 3, xadvance = 2, yoffset = 3, atlas = 1 },
					["35"] = { x = 18, y = 207, width = 5, height = 6, xadvance = 5, yoffset = 4, atlas = 1 },
					["36"] = { x = 28, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["37"] = { x = 38, y = 207, width = 7, height = 8, xadvance = 8, yoffset = 3, atlas = 1 },
					["38"] = { x = 50, y = 207, width = 6, height = 8, xadvance = 7, yoffset = 3, atlas = 1 },
					["39"] = { x = 61, y = 207, width = 1, height = 3, xadvance = 2, yoffset = 3, atlas = 1 },
					["40"] = { x = 67, y = 207, width = 3, height = 8, xadvance = 3, yoffset = 3, atlas = 1 },
					["41"] = { x = 75, y = 207, width = 2, height = 8, xadvance = 3, yoffset = 3, atlas = 1 },
					["42"] = { x = 82, y = 207, width = 3, height = 3, xadvance = 3, yoffset = 5, atlas = 1 },
					["43"] = { x = 90, y = 207, width = 3, height = 4, xadvance = 3, yoffset = 5, atlas = 1 },
					["44"] = { x = 98, y = 207, width = 1, height = 3, xadvance = 2, yoffset = 10, atlas = 1 },
					["45"] = { x = 104, y = 207, width = 3, height = 1, xadvance = 3, yoffset = 6, atlas = 1 },
					["46"] = { x = 112, y = 207, width = 1, height = 1, xadvance = 2, yoffset = 10, atlas = 1 },
					["47"] = { x = 118, y = 207, width = 6, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["48"] = { x = 129, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["49"] = { x = 138, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["50"] = { x = 147, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["51"] = { x = 156, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["52"] = { x = 165, y = 207, width = 5, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["53"] = { x = 175, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["54"] = { x = 184, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["55"] = { x = 193, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["56"] = { x = 202, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["57"] = { x = 211, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["58"] = { x = 220, y = 207, width = 1, height = 3, xadvance = 2, yoffset = 8, atlas = 1 },
					["59"] = { x = 226, y = 207, width = 1, height = 5, xadvance = 2, yoffset = 8, atlas = 1 },
					["60"] = { x = 232, y = 207, width = 3, height = 7, xadvance = 4, yoffset = 3, atlas = 1 },
					["61"] = { x = 240, y = 207, width = 3, height = 3, xadvance = 3, yoffset = 5, atlas = 1 },
					["62"] = { x = 248, y = 207, width = 4, height = 7, xadvance = 4, yoffset = 3, atlas = 1 },
					["63"] = { x = 257, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["64"] = { x = 266, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["65"] = { x = 276, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["66"] = { x = 286, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["67"] = { x = 296, y = 207, width = 6, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["68"] = { x = 307, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["69"] = { x = 317, y = 207, width = 5, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["70"] = { x = 327, y = 207, width = 5, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["71"] = { x = 337, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["72"] = { x = 347, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["73"] = { x = 357, y = 207, width = 1, height = 8, xadvance = 2, yoffset = 3, atlas = 1 },
					["74"] = { x = 363, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["75"] = { x = 372, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["76"] = { x = 382, y = 207, width = 4, height = 8, xadvance = 4, yoffset = 3, atlas = 1 },
					["77"] = { x = 391, y = 207, width = 6, height = 8, xadvance = 7, yoffset = 3, atlas = 1 },
					["78"] = { x = 402, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["79"] = { x = 412, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["80"] = { x = 422, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["81"] = { x = 432, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["82"] = { x = 442, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["83"] = { x = 452, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["84"] = { x = 462, y = 207, width = 5, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["85"] = { x = 472, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["86"] = { x = 482, y = 207, width = 5, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["87"] = { x = 492, y = 207, width = 9, height = 8, xadvance = 10, yoffset = 3, atlas = 1 },
					["88"] = { x = 506, y = 207, width = 6, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["89"] = { x = 517, y = 207, width = 6, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["90"] = { x = 528, y = 207, width = 6, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["91"] = { x = 539, y = 207, width = 3, height = 8, xadvance = 3, yoffset = 3, atlas = 1 },
					["92"] = { x = 547, y = 207, width = 6, height = 8, xadvance = 6, yoffset = 3, atlas = 1 },
					["93"] = { x = 558, y = 207, width = 2, height = 8, xadvance = 3, yoffset = 3, atlas = 1 },
					["94"] = { x = 565, y = 207, width = 4, height = 2, xadvance = 4, yoffset = 3, atlas = 1 },
					["95"] = { x = 574, y = 207, width = 3, height = 1, xadvance = 3, yoffset = 12, atlas = 1 },
					["96"] = { x = 582, y = 207, width = 2, height = 2, xadvance = 2, yoffset = 3, atlas = 1 },
					["97"] = { x = 589, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["98"] = { x = 598, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["99"] = { x = 607, y = 207, width = 5, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["100"] = { x = 617, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["101"] = { x = 626, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["102"] = { x = 635, y = 207, width = 2, height = 8, xadvance = 2, yoffset = 3, atlas = 1 },
					["103"] = { x = 642, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 5, atlas = 1 },
					["104"] = { x = 651, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 3, atlas = 1 },
					["105"] = { x = 660, y = 207, width = 2, height = 8, xadvance = 2, yoffset = 3, atlas = 1 },
					["106"] = { x = 667, y = 207, width = 2, height = 10, xadvance = 3, yoffset = 3, atlas = 1 },
					["107"] = { x = 674, y = 207, width = 4, height = 8, xadvance = 4, yoffset = 3, atlas = 1 },
					["108"] = { x = 683, y = 207, width = 1, height = 8, xadvance = 2, yoffset = 3, atlas = 1 },
					["109"] = { x = 689, y = 207, width = 5, height = 6, xadvance = 6, yoffset = 5, atlas = 1 },
					["110"] = { x = 699, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["111"] = { x = 708, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["112"] = { x = 717, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 5, atlas = 1 },
					["113"] = { x = 726, y = 207, width = 4, height = 8, xadvance = 5, yoffset = 5, atlas = 1 },
					["114"] = { x = 735, y = 207, width = 3, height = 6, xadvance = 3, yoffset = 5, atlas = 1 },
					["115"] = { x = 743, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["116"] = { x = 752, y = 207, width = 2, height = 8, xadvance = 2, yoffset = 3, atlas = 1 },
					["117"] = { x = 759, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["118"] = { x = 768, y = 207, width = 4, height = 6, xadvance = 4, yoffset = 5, atlas = 1 },
					["119"] = { x = 777, y = 207, width = 7, height = 6, xadvance = 6, yoffset = 5, atlas = 1 },
					["120"] = { x = 789, y = 207, width = 4, height = 6, xadvance = 4, yoffset = 5, atlas = 1 },
					["121"] = { x = 798, y = 207, width = 4, height = 8, xadvance = 4, yoffset = 5, atlas = 1 },
					["122"] = { x = 807, y = 207, width = 4, height = 6, xadvance = 5, yoffset = 5, atlas = 1 },
					["123"] = { x = 816, y = 207, width = 3, height = 9, xadvance = 3, yoffset = 2, atlas = 1 },
					["124"] = { x = 824, y = 207, width = 1, height = 9, xadvance = 2, yoffset = 2, atlas = 1 },
					["125"] = { x = 830, y = 207, width = 3, height = 9, xadvance = 3, yoffset = 2, atlas = 1 },
					["126"] = { x = 838, y = 207, width = 5, height = 3, xadvance = 5, yoffset = 5, atlas = 1 }
				},
				kerning = {
				}
			},
			["10"] = {
				lineHeight = 10,
				firstAdjust = 2,
				characters = {
					["32"] = { x = 0, y = 222, width = 0, height = 0, xadvance = 2, yoffset = 10, atlas = 1 },
					["33"] = { x = 5, y = 222, width = 1, height = 8, xadvance = 2, yoffset = 2, atlas = 1 },
					["34"] = { x = 11, y = 222, width = 2, height = 3, xadvance = 2, yoffset = 2, atlas = 1 },
					["35"] = { x = 18, y = 222, width = 4, height = 6, xadvance = 4, yoffset = 3, atlas = 1 },
					["36"] = { x = 27, y = 222, width = 3, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["37"] = { x = 35, y = 222, width = 6, height = 8, xadvance = 7, yoffset = 2, atlas = 1 },
					["38"] = { x = 46, y = 222, width = 6, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["39"] = { x = 57, y = 222, width = 1, height = 3, xadvance = 1, yoffset = 2, atlas = 1 },
					["40"] = { x = 63, y = 222, width = 3, height = 8, xadvance = 3, yoffset = 2, atlas = 1 },
					["41"] = { x = 71, y = 222, width = 2, height = 8, xadvance = 3, yoffset = 2, atlas = 1 },
					["42"] = { x = 78, y = 222, width = 3, height = 3, xadvance = 3, yoffset = 4, atlas = 1 },
					["43"] = { x = 86, y = 222, width = 3, height = 4, xadvance = 3, yoffset = 4, atlas = 1 },
					["44"] = { x = 94, y = 222, width = 1, height = 3, xadvance = 1, yoffset = 9, atlas = 1 },
					["45"] = { x = 100, y = 222, width = 3, height = 1, xadvance = 3, yoffset = 5, atlas = 1 },
					["46"] = { x = 108, y = 222, width = 1, height = 1, xadvance = 1, yoffset = 9, atlas = 1 },
					["47"] = { x = 114, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["48"] = { x = 124, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["49"] = { x = 133, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["50"] = { x = 142, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["51"] = { x = 151, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["52"] = { x = 160, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["53"] = { x = 169, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["54"] = { x = 178, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["55"] = { x = 187, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["56"] = { x = 196, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["57"] = { x = 205, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["58"] = { x = 214, y = 222, width = 1, height = 3, xadvance = 1, yoffset = 7, atlas = 1 },
					["59"] = { x = 220, y = 222, width = 1, height = 5, xadvance = 1, yoffset = 7, atlas = 1 },
					["60"] = { x = 226, y = 222, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["61"] = { x = 234, y = 222, width = 3, height = 3, xadvance = 3, yoffset = 4, atlas = 1 },
					["62"] = { x = 242, y = 222, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["63"] = { x = 250, y = 222, width = 3, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["64"] = { x = 258, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["65"] = { x = 268, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["66"] = { x = 278, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["67"] = { x = 288, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["68"] = { x = 298, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["69"] = { x = 307, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["70"] = { x = 317, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["71"] = { x = 327, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["72"] = { x = 337, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["73"] = { x = 346, y = 222, width = 1, height = 8, xadvance = 2, yoffset = 2, atlas = 1 },
					["74"] = { x = 352, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["75"] = { x = 361, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["76"] = { x = 371, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["77"] = { x = 380, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["78"] = { x = 390, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["79"] = { x = 400, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["80"] = { x = 410, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["81"] = { x = 419, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["82"] = { x = 429, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["83"] = { x = 438, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["84"] = { x = 447, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["85"] = { x = 457, y = 222, width = 5, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["86"] = { x = 467, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["87"] = { x = 477, y = 222, width = 9, height = 8, xadvance = 9, yoffset = 2, atlas = 1 },
					["88"] = { x = 491, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["89"] = { x = 501, y = 222, width = 6, height = 8, xadvance = 6, yoffset = 2, atlas = 1 },
					["90"] = { x = 512, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["91"] = { x = 522, y = 222, width = 3, height = 8, xadvance = 3, yoffset = 2, atlas = 1 },
					["92"] = { x = 530, y = 222, width = 5, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["93"] = { x = 540, y = 222, width = 2, height = 8, xadvance = 3, yoffset = 2, atlas = 1 },
					["94"] = { x = 547, y = 222, width = 3, height = 2, xadvance = 4, yoffset = 2, atlas = 1 },
					["95"] = { x = 555, y = 222, width = 3, height = 1, xadvance = 3, yoffset = 11, atlas = 1 },
					["96"] = { x = 563, y = 222, width = 2, height = 2, xadvance = 2, yoffset = 2, atlas = 1 },
					["97"] = { x = 570, y = 222, width = 4, height = 6, xadvance = 5, yoffset = 4, atlas = 1 },
					["98"] = { x = 579, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["99"] = { x = 588, y = 222, width = 4, height = 6, xadvance = 4, yoffset = 4, atlas = 1 },
					["100"] = { x = 597, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["101"] = { x = 606, y = 222, width = 4, height = 6, xadvance = 5, yoffset = 4, atlas = 1 },
					["102"] = { x = 615, y = 222, width = 2, height = 8, xadvance = 2, yoffset = 2, atlas = 1 },
					["103"] = { x = 622, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 4, atlas = 1 },
					["104"] = { x = 631, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 2, atlas = 1 },
					["105"] = { x = 640, y = 222, width = 1, height = 8, xadvance = 2, yoffset = 2, atlas = 1 },
					["106"] = { x = 646, y = 222, width = 2, height = 10, xadvance = 3, yoffset = 2, atlas = 1 },
					["107"] = { x = 653, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 2, atlas = 1 },
					["108"] = { x = 662, y = 222, width = 1, height = 8, xadvance = 2, yoffset = 2, atlas = 1 },
					["109"] = { x = 668, y = 222, width = 5, height = 6, xadvance = 6, yoffset = 4, atlas = 1 },
					["110"] = { x = 678, y = 222, width = 4, height = 6, xadvance = 5, yoffset = 4, atlas = 1 },
					["111"] = { x = 687, y = 222, width = 4, height = 6, xadvance = 5, yoffset = 4, atlas = 1 },
					["112"] = { x = 696, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 4, atlas = 1 },
					["113"] = { x = 705, y = 222, width = 4, height = 8, xadvance = 5, yoffset = 4, atlas = 1 },
					["114"] = { x = 714, y = 222, width = 3, height = 6, xadvance = 3, yoffset = 4, atlas = 1 },
					["115"] = { x = 722, y = 222, width = 4, height = 6, xadvance = 4, yoffset = 4, atlas = 1 },
					["116"] = { x = 731, y = 222, width = 2, height = 8, xadvance = 2, yoffset = 2, atlas = 1 },
					["117"] = { x = 738, y = 222, width = 4, height = 6, xadvance = 5, yoffset = 4, atlas = 1 },
					["118"] = { x = 747, y = 222, width = 4, height = 6, xadvance = 4, yoffset = 4, atlas = 1 },
					["119"] = { x = 756, y = 222, width = 6, height = 6, xadvance = 6, yoffset = 4, atlas = 1 },
					["120"] = { x = 767, y = 222, width = 4, height = 6, xadvance = 4, yoffset = 4, atlas = 1 },
					["121"] = { x = 776, y = 222, width = 4, height = 8, xadvance = 4, yoffset = 4, atlas = 1 },
					["122"] = { x = 785, y = 222, width = 4, height = 6, xadvance = 4, yoffset = 4, atlas = 1 },
					["123"] = { x = 794, y = 222, width = 2, height = 9, xadvance = 2, yoffset = 1, atlas = 1 },
					["124"] = { x = 801, y = 222, width = 1, height = 9, xadvance = 2, yoffset = 1, atlas = 1 },
					["125"] = { x = 807, y = 222, width = 3, height = 9, xadvance = 3, yoffset = 1, atlas = 1 },
					["126"] = { x = 815, y = 222, width = 4, height = 3, xadvance = 4, yoffset = 4, atlas = 1 }
				},
				kerning = {
				}
			},
			["9"] = {
				lineHeight = 9,
				firstAdjust = 2,
				characters = {
					["32"] = { x = 0, y = 237, width = 0, height = 0, xadvance = 2, yoffset = 9, atlas = 1 },
					["33"] = { x = 5, y = 237, width = 1, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["34"] = { x = 11, y = 237, width = 2, height = 3, xadvance = 2, yoffset = 2, atlas = 1 },
					["35"] = { x = 18, y = 237, width = 4, height = 5, xadvance = 4, yoffset = 3, atlas = 1 },
					["36"] = { x = 27, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["37"] = { x = 36, y = 237, width = 5, height = 7, xadvance = 6, yoffset = 2, atlas = 1 },
					["38"] = { x = 46, y = 237, width = 6, height = 7, xadvance = 6, yoffset = 2, atlas = 1 },
					["39"] = { x = 57, y = 237, width = 1, height = 3, xadvance = 1, yoffset = 2, atlas = 1 },
					["40"] = { x = 63, y = 237, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["41"] = { x = 71, y = 237, width = 2, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["42"] = { x = 78, y = 237, width = 2, height = 2, xadvance = 3, yoffset = 4, atlas = 1 },
					["43"] = { x = 85, y = 237, width = 3, height = 3, xadvance = 3, yoffset = 4, atlas = 1 },
					["44"] = { x = 93, y = 237, width = 1, height = 3, xadvance = 1, yoffset = 8, atlas = 1 },
					["45"] = { x = 99, y = 237, width = 2, height = 1, xadvance = 3, yoffset = 5, atlas = 1 },
					["46"] = { x = 106, y = 237, width = 1, height = 1, xadvance = 1, yoffset = 8, atlas = 1 },
					["47"] = { x = 112, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["48"] = { x = 122, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["49"] = { x = 131, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["50"] = { x = 140, y = 237, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["51"] = { x = 148, y = 237, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["52"] = { x = 156, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["53"] = { x = 165, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["54"] = { x = 174, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["55"] = { x = 183, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["56"] = { x = 192, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["57"] = { x = 201, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["58"] = { x = 210, y = 237, width = 1, height = 3, xadvance = 1, yoffset = 6, atlas = 1 },
					["59"] = { x = 216, y = 237, width = 1, height = 5, xadvance = 1, yoffset = 6, atlas = 1 },
					["60"] = { x = 222, y = 237, width = 3, height = 6, xadvance = 3, yoffset = 3, atlas = 1 },
					["61"] = { x = 230, y = 237, width = 2, height = 3, xadvance = 3, yoffset = 4, atlas = 1 },
					["62"] = { x = 237, y = 237, width = 3, height = 6, xadvance = 3, yoffset = 3, atlas = 1 },
					["63"] = { x = 245, y = 237, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["64"] = { x = 253, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["65"] = { x = 262, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["66"] = { x = 272, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["67"] = { x = 281, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["68"] = { x = 291, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["69"] = { x = 300, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["70"] = { x = 309, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["71"] = { x = 318, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["72"] = { x = 327, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["73"] = { x = 336, y = 237, width = 1, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["74"] = { x = 342, y = 237, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["75"] = { x = 350, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["76"] = { x = 359, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["77"] = { x = 368, y = 237, width = 5, height = 7, xadvance = 6, yoffset = 2, atlas = 1 },
					["78"] = { x = 378, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["79"] = { x = 387, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["80"] = { x = 396, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["81"] = { x = 405, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["82"] = { x = 414, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["83"] = { x = 423, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["84"] = { x = 432, y = 237, width = 4, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["85"] = { x = 441, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["86"] = { x = 450, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["87"] = { x = 460, y = 237, width = 8, height = 7, xadvance = 8, yoffset = 2, atlas = 1 },
					["88"] = { x = 473, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["89"] = { x = 483, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["90"] = { x = 493, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["91"] = { x = 503, y = 237, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["92"] = { x = 511, y = 237, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["93"] = { x = 521, y = 237, width = 2, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["94"] = { x = 528, y = 237, width = 3, height = 2, xadvance = 3, yoffset = 2, atlas = 1 },
					["95"] = { x = 536, y = 237, width = 2, height = 1, xadvance = 3, yoffset = 9, atlas = 1 },
					["96"] = { x = 543, y = 237, width = 2, height = 2, xadvance = 2, yoffset = 2, atlas = 1 },
					["97"] = { x = 550, y = 237, width = 3, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["98"] = { x = 558, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["99"] = { x = 567, y = 237, width = 4, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["100"] = { x = 576, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["101"] = { x = 585, y = 237, width = 4, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["102"] = { x = 594, y = 237, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["103"] = { x = 601, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 4, atlas = 1 },
					["104"] = { x = 610, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["105"] = { x = 619, y = 237, width = 1, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["106"] = { x = 625, y = 237, width = 3, height = 9, xadvance = 3, yoffset = 2, atlas = 1 },
					["107"] = { x = 633, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["108"] = { x = 642, y = 237, width = 1, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["109"] = { x = 648, y = 237, width = 5, height = 5, xadvance = 6, yoffset = 4, atlas = 1 },
					["110"] = { x = 658, y = 237, width = 4, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["111"] = { x = 667, y = 237, width = 4, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["112"] = { x = 676, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 4, atlas = 1 },
					["113"] = { x = 685, y = 237, width = 4, height = 7, xadvance = 5, yoffset = 4, atlas = 1 },
					["114"] = { x = 694, y = 237, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["115"] = { x = 702, y = 237, width = 4, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["116"] = { x = 711, y = 237, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["117"] = { x = 718, y = 237, width = 4, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["118"] = { x = 727, y = 237, width = 4, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["119"] = { x = 736, y = 237, width = 5, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["120"] = { x = 746, y = 237, width = 4, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["121"] = { x = 755, y = 237, width = 4, height = 7, xadvance = 4, yoffset = 4, atlas = 1 },
					["122"] = { x = 764, y = 237, width = 4, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["123"] = { x = 773, y = 237, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["124"] = { x = 781, y = 237, width = 1, height = 8, xadvance = 2, yoffset = 1, atlas = 1 },
					["125"] = { x = 787, y = 237, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["126"] = { x = 795, y = 237, width = 4, height = 2, xadvance = 4, yoffset = 4, atlas = 1 }
				},
				kerning = {
				}
			},
			["8"] = {
				lineHeight = 9,
				firstAdjust = 2,
				characters = {
					["32"] = { x = 0, y = 251, width = 0, height = 0, xadvance = 1, yoffset = 9, atlas = 1 },
					["33"] = { x = 5, y = 251, width = 1, height = 7, xadvance = 1, yoffset = 2, atlas = 1 },
					["34"] = { x = 11, y = 251, width = 2, height = 3, xadvance = 2, yoffset = 2, atlas = 1 },
					["35"] = { x = 18, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 3, atlas = 1 },
					["36"] = { x = 26, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["37"] = { x = 34, y = 251, width = 5, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["38"] = { x = 44, y = 251, width = 6, height = 7, xadvance = 6, yoffset = 2, atlas = 1 },
					["39"] = { x = 55, y = 251, width = 1, height = 3, xadvance = 1, yoffset = 2, atlas = 1 },
					["40"] = { x = 61, y = 251, width = 2, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["41"] = { x = 68, y = 251, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["42"] = { x = 75, y = 251, width = 2, height = 2, xadvance = 2, yoffset = 4, atlas = 1 },
					["43"] = { x = 82, y = 251, width = 2, height = 3, xadvance = 2, yoffset = 4, atlas = 1 },
					["44"] = { x = 89, y = 251, width = 1, height = 3, xadvance = 1, yoffset = 8, atlas = 1 },
					["45"] = { x = 95, y = 251, width = 2, height = 1, xadvance = 2, yoffset = 5, atlas = 1 },
					["46"] = { x = 102, y = 251, width = 1, height = 1, xadvance = 1, yoffset = 8, atlas = 1 },
					["47"] = { x = 108, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["48"] = { x = 117, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["49"] = { x = 125, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["50"] = { x = 133, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["51"] = { x = 141, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["52"] = { x = 149, y = 251, width = 4, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["53"] = { x = 158, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["54"] = { x = 166, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["55"] = { x = 174, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["56"] = { x = 182, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["57"] = { x = 190, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["58"] = { x = 198, y = 251, width = 1, height = 3, xadvance = 1, yoffset = 6, atlas = 1 },
					["59"] = { x = 204, y = 251, width = 1, height = 5, xadvance = 1, yoffset = 6, atlas = 1 },
					["60"] = { x = 210, y = 251, width = 2, height = 6, xadvance = 3, yoffset = 3, atlas = 1 },
					["61"] = { x = 217, y = 251, width = 2, height = 3, xadvance = 2, yoffset = 4, atlas = 1 },
					["62"] = { x = 224, y = 251, width = 3, height = 6, xadvance = 3, yoffset = 3, atlas = 1 },
					["63"] = { x = 232, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["64"] = { x = 240, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["65"] = { x = 249, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["66"] = { x = 258, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["67"] = { x = 267, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["68"] = { x = 276, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["69"] = { x = 285, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["70"] = { x = 294, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["71"] = { x = 303, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["72"] = { x = 312, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["73"] = { x = 321, y = 251, width = 1, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["74"] = { x = 327, y = 251, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["75"] = { x = 335, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["76"] = { x = 344, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["77"] = { x = 352, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["78"] = { x = 361, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["79"] = { x = 370, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["80"] = { x = 379, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["81"] = { x = 388, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["82"] = { x = 397, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["83"] = { x = 406, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["84"] = { x = 415, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["85"] = { x = 423, y = 251, width = 4, height = 7, xadvance = 5, yoffset = 2, atlas = 1 },
					["86"] = { x = 432, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["87"] = { x = 441, y = 251, width = 7, height = 7, xadvance = 7, yoffset = 2, atlas = 1 },
					["88"] = { x = 453, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["89"] = { x = 462, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["90"] = { x = 471, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["91"] = { x = 480, y = 251, width = 2, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["92"] = { x = 487, y = 251, width = 4, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["93"] = { x = 496, y = 251, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["94"] = { x = 503, y = 251, width = 3, height = 2, xadvance = 3, yoffset = 2, atlas = 1 },
					["95"] = { x = 511, y = 251, width = 2, height = 1, xadvance = 2, yoffset = 9, atlas = 1 },
					["96"] = { x = 518, y = 251, width = 2, height = 2, xadvance = 2, yoffset = 2, atlas = 1 },
					["97"] = { x = 525, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["98"] = { x = 533, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["99"] = { x = 541, y = 251, width = 4, height = 5, xadvance = 4, yoffset = 4, atlas = 1 },
					["100"] = { x = 550, y = 251, width = 3, height = 7, xadvance = 4, yoffset = 2, atlas = 1 },
					["101"] = { x = 558, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["102"] = { x = 566, y = 251, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["103"] = { x = 573, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 4, atlas = 1 },
					["104"] = { x = 581, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["105"] = { x = 589, y = 251, width = 1, height = 7, xadvance = 1, yoffset = 2, atlas = 1 },
					["106"] = { x = 595, y = 251, width = 2, height = 9, xadvance = 2, yoffset = 2, atlas = 1 },
					["107"] = { x = 602, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 2, atlas = 1 },
					["108"] = { x = 610, y = 251, width = 1, height = 7, xadvance = 1, yoffset = 2, atlas = 1 },
					["109"] = { x = 616, y = 251, width = 5, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["110"] = { x = 626, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["111"] = { x = 634, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["112"] = { x = 642, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 4, atlas = 1 },
					["113"] = { x = 650, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 4, atlas = 1 },
					["114"] = { x = 658, y = 251, width = 2, height = 5, xadvance = 2, yoffset = 4, atlas = 1 },
					["115"] = { x = 665, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["116"] = { x = 673, y = 251, width = 2, height = 6, xadvance = 2, yoffset = 3, atlas = 1 },
					["117"] = { x = 680, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["118"] = { x = 688, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["119"] = { x = 696, y = 251, width = 5, height = 5, xadvance = 5, yoffset = 4, atlas = 1 },
					["120"] = { x = 706, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["121"] = { x = 714, y = 251, width = 3, height = 7, xadvance = 3, yoffset = 4, atlas = 1 },
					["122"] = { x = 722, y = 251, width = 3, height = 5, xadvance = 3, yoffset = 4, atlas = 1 },
					["123"] = { x = 730, y = 251, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["124"] = { x = 737, y = 251, width = 1, height = 8, xadvance = 1, yoffset = 1, atlas = 1 },
					["125"] = { x = 743, y = 251, width = 2, height = 7, xadvance = 2, yoffset = 2, atlas = 1 },
					["126"] = { x = 750, y = 251, width = 4, height = 2, xadvance = 3, yoffset = 4, atlas = 1 }
				},
				kerning = {
				}
			}
		}
	}
}

return module]]></ProtectedString>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
							</Item>
						</Item>
						<Item class="Script" referent="RBX82BB8BEA42354023B4B7016DF99C44F0">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="Disabled">true</bool>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Reset</string>
								<token name="RunContext">0</token>
								<string name="ScriptGuid">{9D8C91C8-AFDE-41D6-819F-9B8733DB63DF}</string>
								<ProtectedString name="Source"><![CDATA[script.Parent.Disabled = true
delay(.1, function()
	script.Parent.Disabled = false
	script:Destroy()
end)]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="SurfaceGui" referent="RBX73CAB95033C0426A9A412C78EBA03A5F">
							<Properties>
								<bool name="Active">true</bool>
								<Ref name="Adornee">null</Ref>
								<bool name="AlwaysOnTop">false</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<float name="Brightness">1</float>
								<Vector2 name="CanvasSize">
									<X>800</X>
									<Y>600</Y>
								</Vector2>
								<bool name="ClipsDescendants">true</bool>
								<bool name="Enabled">true</bool>
								<token name="Face">2</token>
								<float name="LightInfluence">0</float>
								<string name="Name">Display</string>
								<float name="PixelsPerStud">1000</float>
								<bool name="ResetOnSpawn">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<token name="SizingMode">1</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<float name="ToolPunchThroughDistance">0</float>
								<token name="ZIndexBehavior">1</token>
								<float name="ZOffset">0</float>
							</Properties>
							<Item class="Frame" referent="RBXCA557D49CA144D39AC7952BDC81497B4">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Home</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="ScrollingFrame" referent="RBXB76C2D15814442F08AFA434FA4C9E44A">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticCanvasSize">0</token>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
										<Vector2 name="CanvasPosition">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<UDim2 name="CanvasSize">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.699999988</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="ClipsDescendants">true</bool>
										<bool name="Draggable">false</bool>
										<token name="ElasticBehavior">0</token>
										<token name="HorizontalScrollBarInset">0</token>
										<int name="LayoutOrder">0</int>
										<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
										<string name="Name">Buttons_List</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.699999988</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<Color3 name="ScrollBarImageColor3">
											<R>0.760784388</R>
											<G>0.760784388</G>
											<B>0.760784388</B>
										</Color3>
										<float name="ScrollBarImageTransparency">0</float>
										<int name="ScrollBarThickness">12</int>
										<token name="ScrollingDirection">4</token>
										<bool name="ScrollingEnabled">true</bool>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
										<token name="VerticalScrollBarInset">0</token>
										<token name="VerticalScrollBarPosition">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="TextButton" referent="RBXB214ABA5F38D473C840F6655B9C88833">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Floor_Selection</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.150000006</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Floor Selection</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">60</float>
											<Color3 name="TextStrokeColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UIListLayout" referent="RBX0BC3750271CE4E77B21F6EB1CF0CE23E">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="FillDirection">1</token>
											<token name="HorizontalAlignment">0</token>
											<string name="Name">UIListLayout</string>
											<UDim name="Padding">
												<S>0</S>
												<O>10</O>
											</UDim>
											<token name="SortOrder">2</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<token name="VerticalAlignment">1</token>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXE7E0B482A8BF4672A23F7A40FBB5EE35">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Destination_Keypad</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.150000006</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Open Keypad</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">60</float>
											<Color3 name="TextStrokeColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX2CC619D797334FD9B5CBB6DEF751B018">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Admin_Panel</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.150000006</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Admin Panel</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">60</float>
											<Color3 name="TextStrokeColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
								</Item>
								<Item class="TextLabel" referent="RBXE3CE85B1EB3C4675A6D628A67AF048EC">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Label</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBX08794CC2CE10456FA385F32C7AC97580">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="ImageLabel" referent="RBXDB8445E9001D429691ED9C3B41AC18EE">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">1</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<Content name="Image"><url>rbxassetid://5033004439</url></Content>
									<Color3 name="ImageColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<Vector2 name="ImageRectOffset">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<Vector2 name="ImageRectSize">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<float name="ImageTransparency">0</float>
									<int name="LayoutOrder">0</int>
									<string name="Name">Logo</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<token name="ResampleMode">0</token>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<token name="ScaleType">3</token>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>0.200000003</XS>
										<XO>0</XO>
										<YS>0.200000003</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<Rect2D name="SliceCenter">
										<min>
											<X>0</X>
											<Y>0</Y>
										</min>
										<max>
											<X>0</X>
											<Y>0</Y>
										</max>
									</Rect2D>
									<float name="SliceScale">1</float>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<UDim2 name="TileSize">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<bool name="Visible">false</bool>
									<int name="ZIndex">5</int>
								</Properties>
							</Item>
							<Item class="Frame" referent="RBX639377E0B8894C44BD5A6416BA1DBA71">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">1</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Blackscreen</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">4</int>
								</Properties>
								<Item class="UIGradient" referent="RBXCB14B4E0F35B4815924DEA2AB5419F6D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX2763390424C4451EB4A0F7B6100417B6">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Keypad</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBX9274EEB43E7740AEB4E9A4A4D48F24A0">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Enter your destination</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXCC3D0218DC974BA09FB3198DB9A6C351">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Buttons</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.699999988</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.200000003</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="TextButton" referent="RBXDB8729D54800404980A975AD1CAD3212">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">1</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">1</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX680AF9890F054965BA2B27C65A7F1DD7">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">2</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">2</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UIGridLayout" referent="RBX954F55B3A41F4F3B9F1ACF3D4AD977D0">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim2 name="CellPadding">
												<XS>0</XS>
												<XO>17</XO>
												<YS>0</YS>
												<YO>10</YO>
											</UDim2>
											<UDim2 name="CellSize">
												<XS>0.300999999</XS>
												<XO>0</XO>
												<YS>0.170000002</YS>
												<YO>0</YO>
											</UDim2>
											<token name="FillDirection">0</token>
											<int name="FillDirectionMaxCells">0</int>
											<token name="HorizontalAlignment">1</token>
											<string name="Name">UIGridLayout</string>
											<token name="SortOrder">2</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="StartCorner">0</token>
											<BinaryString name="Tags"></BinaryString>
											<token name="VerticalAlignment">1</token>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX0D1AE429CAA247839731214449221808">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">3</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">3</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX6A1981E5C09049ADAD0A2029EDA76E26">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">4</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">4</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX0A34C6C308DD461AADB19AC3C300119A">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">5</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">5</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX1B0466482E0E41A6B945958EFAE74F86">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">6</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">6</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX6D8EB7EC6F1240A9A0B16E5D808338D5">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">7</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">7</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX87243194FA1A430199AE963267D944CC">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">8</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">8</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX2044AB575A7446D99EC661CAEC99A900">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">9</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">9</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBX5EF3F28DE7D64AC1BFA412BBAFB67478">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">-</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">-</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXE88EADD10ECC49179D192BAF47531C64">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">0</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">0</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXCA1763F474754448A301907ACCBB1250">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">*</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.349999994</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">*</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">43</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
								</Item>
								<Item class="TextLabel" referent="RBX4679AE9EBAB049B9BD854036418F33B7">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">3</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Input</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.349999994</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.200000003</XS>
											<XO>0</XO>
											<YS>0.0599999987</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">X</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIGradient" referent="RBX045045C0E2A2400B852BB1BE70C950B3">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
											<bool name="Enabled">true</bool>
											<string name="Name">Theme_Gradient_Controller</string>
											<Vector2 name="Offset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="Rotation">0</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
										</Properties>
									</Item>
									<Item class="Frame" referent="RBXF92AED1B21AE45509E556089041C9DFE">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">Border</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>3</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIGradient" referent="RBXB35BF9136EE541BA802CE8B77DAC6A2D">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
												<bool name="Enabled">true</bool>
												<string name="Name">Theme_Gradient_Controller</string>
												<Vector2 name="Offset">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<float name="Rotation">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
											</Properties>
										</Item>
									</Item>
									<Item class="Frame" referent="RBXE257447215514F8F9D0388D2ADBACF7E">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>1</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">Border</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>3</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIGradient" referent="RBXAE841BDB9358463FA84EC3B828591D37">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
												<bool name="Enabled">true</bool>
												<string name="Name">Theme_Gradient_Controller</string>
												<Vector2 name="Offset">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<float name="Rotation">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
											</Properties>
										</Item>
									</Item>
									<Item class="Frame" referent="RBXDAB6612501F64D249D87BB830AAEBA4B">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">Border</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0</XS>
												<XO>3</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIGradient" referent="RBXE5E37E3654B741B0BFB24AEB537465FA">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
												<bool name="Enabled">true</bool>
												<string name="Name">Theme_Gradient_Controller</string>
												<Vector2 name="Offset">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<float name="Rotation">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
											</Properties>
										</Item>
									</Item>
									<Item class="Frame" referent="RBX7F74EFEAB1444C8A9244F5C90D540AC1">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>1</X>
												<Y>0</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<int name="LayoutOrder">0</int>
											<string name="Name">Border</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0</YS>
												<YO>0</YO>
											</UDim2>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0</XS>
												<XO>3</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UIGradient" referent="RBXAB94532AC8834F5598E4CB05EFE255EF">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
												<bool name="Enabled">true</bool>
												<string name="Name">Theme_Gradient_Controller</string>
												<Vector2 name="Offset">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<float name="Rotation">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="TextButton" referent="RBX1BBE302EFD7742CF8C4B96BF8ED568E1">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">3</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">Home</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.910000026</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.200000003</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Home</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">60</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBX552BA8F2D9C948FBAC235E0B537B9CAF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX04B5C72F900546DAB7CC5E9230BF4E05">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Floor_Selection</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="ScrollingFrame" referent="RBX250801A4A98A4C0EB43E84DAF1DE1112">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticCanvasSize">0</token>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
										<Vector2 name="CanvasPosition">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<UDim2 name="CanvasSize">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.699999988</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="ClipsDescendants">true</bool>
										<bool name="Draggable">false</bool>
										<token name="ElasticBehavior">0</token>
										<token name="HorizontalScrollBarInset">0</token>
										<int name="LayoutOrder">0</int>
										<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
										<string name="Name">Floor_Groups</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.569999993</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<Color3 name="ScrollBarImageColor3">
											<R>0.760784388</R>
											<G>0.760784388</G>
											<B>0.760784388</B>
										</Color3>
										<float name="ScrollBarImageTransparency">0</float>
										<int name="ScrollBarThickness">12</int>
										<token name="ScrollingDirection">4</token>
										<bool name="ScrollingEnabled">true</bool>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
										<token name="VerticalScrollBarInset">0</token>
										<token name="VerticalScrollBarPosition">0</token>
										<bool name="Visible">false</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIListLayout" referent="RBX1154C7C70CDA4124810B36B9B6CCD189">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="FillDirection">1</token>
											<token name="HorizontalAlignment">0</token>
											<string name="Name">UIListLayout</string>
											<UDim name="Padding">
												<S>0</S>
												<O>10</O>
											</UDim>
											<token name="SortOrder">2</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<token name="VerticalAlignment">1</token>
										</Properties>
									</Item>
								</Item>
								<Item class="TextLabel" referent="RBX0306FA4ED8C146E1AF2A9779B20B4D8C">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Select your destination</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX1ECFD40043F4439393A0572E6D95D9C4">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">3</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">Home</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.910000026</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.200000003</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Home</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">60</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBX16DDCB78C1244FB18837506C3012C507">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXEDEF20499CDA4F62855C342819C7DD34">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Elevator</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">3</int>
								</Properties>
								<Item class="TextLabel" referent="RBX89EE62964697454185D642A54EA1C654">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.0799999982</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Take elevator</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">4</int>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBXE38A27FA1F754A30B437D425925D8AA1">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Main</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">3</int>
									</Properties>
									<Item class="ImageLabel" referent="RBXD86DD5A30F224315B761D8EFF262461A">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<Content name="Image"><url>http://www.roblox.com/asset/?id=5168512835</url></Content>
											<Color3 name="ImageColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<Vector2 name="ImageRectOffset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<Vector2 name="ImageRectSize">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="ImageTransparency">0</float>
											<int name="LayoutOrder">0</int>
											<string name="Name">Arrow</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.649999976</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<token name="ResampleMode">0</token>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">-90</float>
											<token name="ScaleType">3</token>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.300000012</XS>
												<XO>0</XO>
												<YS>0.300000012</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<Rect2D name="SliceCenter">
												<min>
													<X>0</X>
													<Y>0</Y>
												</min>
												<max>
													<X>0</X>
													<Y>0</Y>
												</max>
											</Rect2D>
											<float name="SliceScale">1</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<UDim2 name="TileSize">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
										<Item class="UIGradient" referent="RBX539574ED3D7B4269B88B01A18A281FE3">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
												<bool name="Enabled">true</bool>
												<string name="Name">Theme_Gradient_Controller</string>
												<Vector2 name="Offset">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<float name="Rotation">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
											</Properties>
										</Item>
									</Item>
									<Item class="TextLabel" referent="RBXFCA86BBC3B8442F9B5AF61A06D317D47">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<string name="Name">Elevator</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.400000006</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.100000001</XS>
												<XO>0</XO>
												<YS>0.200000003</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">X</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">100</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">4</int>
										</Properties>
										<Item class="UIScale" referent="RBX1E7236ED24C849638A0E62CA21DB3386">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<string name="Name">UIScale</string>
												<float name="Scale">5</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="TextLabel" referent="RBXE4AAB0E3CECA43AB9DF02FFED0CACA19">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Floor</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.910000026</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Floor X</string>
										<Color3 name="TextColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">4</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBX4DC6058D66494FDD9D8A02CBB18F704A">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXCA3AB3B868014FAFB9D505A8CECAF83D">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Fire_Recall</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBX901E7331BE914B4CBD7A5A5E32D7C831">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Elevator bank is under fire recall</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBXBE4B183A1BE8421DBA8FE30D76E9B267">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://www.roblox.com/asset/?id=5934123127</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">ImageLabel</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.449999988</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.400000006</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="TextLabel" referent="RBXBA5A6DDCD43E440C87FE60AE7C59EEF3">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Text</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.75999999</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.140000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">This panel is temporarily disabled until returned to normal service</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">60</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX8A62002A19B14974AB8B2495A9F73437">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">3</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">Disable</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.200000003</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Disable</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">60</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBXF2950F074527417C8DFAFD5C030B78D8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXDA61CD85EE1B45AF95D3E70B479E7244">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">FS_Disable_Success</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBXC8618F1115B44A8C82D2721D1DF5020D">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Fire recall successfully disabled</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBXC263FA403ECE48C8BE461BE6E870DEC7">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>http://www.roblox.com/asset/?id=5853990158</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">ImageLabel</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.400000006</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBX41A482A0022D4F5F9E43F89A049FA2F8">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXE7990CE473BE43ECA80AFE437CD65A33">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Admin_Panel</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="ScrollingFrame" referent="RBXBD7456AEF24A4324A6F53830CB1F95F8">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticCanvasSize">0</token>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<Content name="BottomImage"><url>rbxasset://textures/ui/Scroll/scroll-bottom.png</url></Content>
										<Vector2 name="CanvasPosition">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<UDim2 name="CanvasSize">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.699999988</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="ClipsDescendants">true</bool>
										<bool name="Draggable">false</bool>
										<token name="ElasticBehavior">0</token>
										<token name="HorizontalScrollBarInset">0</token>
										<int name="LayoutOrder">0</int>
										<Content name="MidImage"><url>rbxasset://textures/ui/Scroll/scroll-middle.png</url></Content>
										<string name="Name">Buttons_List</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.699999988</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<Color3 name="ScrollBarImageColor3">
											<R>0.760784388</R>
											<G>0.760784388</G>
											<B>0.760784388</B>
										</Color3>
										<float name="ScrollBarImageTransparency">0</float>
										<int name="ScrollBarThickness">12</int>
										<token name="ScrollingDirection">4</token>
										<bool name="ScrollingEnabled">true</bool>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">true</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<Content name="TopImage"><url>rbxasset://textures/ui/Scroll/scroll-top.png</url></Content>
										<token name="VerticalScrollBarInset">0</token>
										<token name="VerticalScrollBarPosition">0</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="TextButton" referent="RBX845E0066B1F643DC8651FA2B51BDE1D0">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Enable_FS</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.150000006</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Recall Bank</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">60</float>
											<Color3 name="TextStrokeColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="UIListLayout" referent="RBX794D71E17E3346FB9BFAE5DF3292E529">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="FillDirection">1</token>
											<token name="HorizontalAlignment">0</token>
											<string name="Name">UIListLayout</string>
											<UDim name="Padding">
												<S>0</S>
												<O>10</O>
											</UDim>
											<token name="SortOrder">2</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<token name="VerticalAlignment">1</token>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXE11497AFF44C41FD806A78D3FC2579F3">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>0.0666666701</R>
												<G>0.0666666701</G>
												<B>0.0666666701</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<token name="BorderMode">2</token>
											<int name="BorderSizePixel">3</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Reboot_Panel</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.100000001</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.150000006</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Reboot Panels</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">60</float>
											<Color3 name="TextStrokeColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
								</Item>
								<Item class="TextLabel" referent="RBX0668BE4C5D8E411CAE3688D8069FEE15">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Admin Panel</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="TextButton" referent="RBX5383E18F4C01493C82C728D7D497A011">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoButtonColor">true</bool>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.0666666701</R>
											<G>0.0666666701</G>
											<B>0.0666666701</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<token name="BorderMode">2</token>
										<int name="BorderSizePixel">3</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<bool name="Modal">false</bool>
										<string name="Name">Home</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.910000026</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<bool name="Selected">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.200000003</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Home</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">false</bool>
										<float name="TextSize">60</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">false</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBX0C973D08A4E640F1A15036564ABB3EEF">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBX29483FBCA4444663AC05881F74A30B52">
								<Properties>
									<bool name="Active">true</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>0.5</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.956862807</R>
										<G>0.964705944</G>
										<B>1</B>
									</Color3>
									<token name="BorderMode">2</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">No_Elevator</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>0.5</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">false</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="TextLabel" referent="RBXEC4478B929334490AFC1E351159F04F3">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<token name="Font">39</token>
										<Font name="FontFace">
											<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
											<Weight>400</Weight>
											<Style>Normal</Style>
											<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
										</Font>
										<int name="LayoutOrder">0</int>
										<float name="LineHeight">1</float>
										<int name="MaxVisibleGraphemes">-1</int>
										<string name="Name">Header</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.150000006</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="RichText">false</bool>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.600000024</XS>
											<XO>0</XO>
											<YS>0.100000001</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<string name="Text">Unable to allocate elevator</string>
										<Color3 name="TextColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<bool name="TextScaled">true</bool>
										<float name="TextSize">14</float>
										<Color3 name="TextStrokeColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<float name="TextStrokeTransparency">1</float>
										<float name="TextTransparency">0</float>
										<token name="TextTruncate">0</token>
										<bool name="TextWrapped">true</bool>
										<token name="TextXAlignment">2</token>
										<token name="TextYAlignment">1</token>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
								</Item>
								<Item class="ImageLabel" referent="RBXBE059CFD6E644B0597A68B5518E20808">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882362</R>
											<G>0.164705887</G>
											<B>0.207843155</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">1</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://5851035537</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">ImageLabel</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.550000012</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0.400000006</XS>
											<XO>0</XO>
											<YS>0.400000006</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
								</Item>
								<Item class="UIGradient" referent="RBXDA4201663259472EA1829CA0DD35624D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
							<Item class="Frame" referent="RBXBE5802AAA91245378458BD3BE96D5B16">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0</X>
										<Y>0</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>1</R>
										<G>1</G>
										<B>1</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0.105882362</R>
										<G>0.164705887</G>
										<B>0.207843155</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">Scan_Card</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0</XS>
										<XO>0</XO>
										<YS>0</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">7</int>
								</Properties>
								<Item class="ImageLabel" referent="RBX451431F4C9BE494D826D44002FE52FE3">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0.105882354</R>
											<G>0.164705887</G>
											<B>0.20784314</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://6455742548</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Img</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">7</int>
									</Properties>
									<Item class="TextLabel" referent="RBX1C5C5FDEB0194F5FB2743EA6A7FFA65B">
										<Properties>
											<bool name="Active">false</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>1</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0.105882362</R>
												<G>0.164705887</G>
												<B>0.207843155</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">1</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">39</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/Roboto.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/Roboto-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<string name="Name">TextLabel</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>1.04999995</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>0.300000012</YS>
												<YO>0</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Please scan card</string>
											<Color3 name="TextColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<bool name="TextScaled">true</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">0</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">true</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">8</int>
										</Properties>
										<Item class="UIGradient" referent="RBX07F4F0D0068945829BE80ABBB817020F">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<ColorSequence name="Color">0 1 1 1 0 1 1 1 1 0 </ColorSequence>
												<bool name="Enabled">true</bool>
												<string name="Name">Theme_Gradient_Controller</string>
												<Vector2 name="Offset">
													<X>0</X>
													<Y>0</Y>
												</Vector2>
												<float name="Rotation">0</float>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
												<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
											</Properties>
										</Item>
									</Item>
									<Item class="UIGradient" referent="RBXCDCD2084019C47E0A8F8F9924A3CCFEB">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<ColorSequence name="Color">0 0 0 0 0 1 0 0 0 0 </ColorSequence>
											<bool name="Enabled">true</bool>
											<string name="Name">Theme_Gradient_Controller</string>
											<Vector2 name="Offset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="Rotation">0</float>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
											<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
										</Properties>
									</Item>
								</Item>
								<Item class="UIGradient" referent="RBX8BF196D22F0F4F4D89177D148398F82D">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<ColorSequence name="Color">0 1 1 1 0 1 0 0.0666667 1 0 </ColorSequence>
										<bool name="Enabled">true</bool>
										<string name="Name">Theme_Gradient_Controller</string>
										<Vector2 name="Offset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="Rotation">0</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<NumberSequence name="Transparency">0 0 0 1 0 0 </NumberSequence>
									</Properties>
								</Item>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX9870E7B1A816404AAB23DCD84C387D28">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">AllocatorOld</string>
							<string name="ScriptGuid">{A383807C-037D-4C2E-A5C2-F46AB89B9090}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

function module.allocateElevator(dest, callFloor, elevators)

	local dist = 324324324
	local chosenElevator
	
	local allocateDirection = (dest > callFloor and 'U' or dest < callFloor or 'D') or 'N'
	
	for i, elev in pairs(elevators) do
		if (elev.Legacy.Floor.Value == callFloor and (elev.Legacy.Move_Value.Value == 0 or elev.Legacy.Leveling.Value) and (not require(elev.Queue)[dest])) then
			chosenElevator = elev
			break
		elseif (((math.abs(elev.Legacy.Floor.Value-callFloor) <= dist) and ((((elev.Legacy.Floor.Value >= callFloor and ((elev.Legacy.Queue_Direction.Value == 'D' and elev.Legacy.Destination.Value <= callFloor) or elev.Legacy.Queue_Direction.Value == 'N')) or (elev.Legacy.Floor.Value <= callFloor and ((elev.Legacy.Queue_Direction.Value == 'U' and elev.Legacy.Destination.Value >= callFloor) or elev.Legacy.Queue_Direction.Value == 'N')))))) and ((not elev.Legacy.Out_Of_Service.Value) and (not elev.Legacy.Fire_Service.Value) and (not elev.Legacy.Inspection.Value))) then
			dist = math.abs(elev.Legacy.Floor.Value-callFloor)
			chosenElevator = elev
		end
	end
	
	--FALLBACK ELEVATOR ALLOCATOR
	if (not chosenElevator) then
		warn(':: Cortex EVO 4.3 :: Percise allocator failed, utilizing fallback allocator.')
	
		dist = 324324324
		for i, elev in pairs(elevators) do
			if (elev.Legacy.Floor.Value == callFloor and (elev.Legacy.Move_Value.Value == 0 or elev.Legacy.Leveling.Value) and (not require(elev.Queue)[dest])) then
				chosenElevator = elev
				break
			elseif (((math.abs(elev.Legacy.Floor.Value-callFloor) <= dist))) then
				dist = math.abs(elev.Legacy.Floor.Value-callFloor)
				chosenElevator = elev
			end
		end
	end
	
	return chosenElevator

end

return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
					<Item class="ModuleScript" referent="RBXEC625734ADF94C2396B719C450DD5441">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Allocator</string>
							<string name="ScriptGuid">{EE255FC5-B064-4D4E-B247-2B3054401708}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

function module.allocateElevator(dest, callDirection, elevators)

	local dist = math.huge
	local chosenElevator
		
	for i, elev in pairs(elevators) do
		if (elev:FindFirstChild('Legacy')) then
			if (elev.Legacy.Floor.Value == dest and (elev.Legacy.Move_Value.Value == 0 or elev.Legacy.Leveling.Value) and (elev.Legacy.Queue_Direction.Value == callDirection or elev.Legacy.Queue_Direction.Value == 'N') and ((not elev.Legacy.Out_Of_Service.Value) and (not elev.Legacy.Fire_Service.Value) and (not elev.Legacy.Inspection.Value) and (not elev.Legacy.Independent_Service.Value))) then
				chosenElevator = elev
				break
			elseif (elev.Legacy.Floor.Value ~= dest and ((math.abs(elev.Legacy.Floor.Value-dest) <= dist) and ((((elev.Legacy.Floor.Value >= dest and ((callDirection == 'U' and elev.Legacy.Destination.Value <= dest) or elev.Legacy.Queue_Direction.Value == 'N')) or (elev.Legacy.Floor.Value <= dest and ((callDirection == 'D' and elev.Legacy.Destination.Value >= dest) or elev.Legacy.Queue_Direction.Value == 'N')))))) and ((not elev.Legacy.Out_Of_Service.Value) and (not elev.Legacy.Fire_Service.Value) and (not elev.Legacy.Inspection.Value) and (not elev.Legacy.Independent_Service.Value))) then
				dist = math.abs(elev.Legacy.Floor.Value-dest)
				chosenElevator = elev
			end
		end
	end
	
	--FALLBACK ELEVATOR ALLOCATOR
	if (not chosenElevator) then
		warn(':: Cortex Allocator :: Precise allocator failed, utilizing fallback allocator.')
		
		dist = math.huge
		for i, elev in pairs(elevators) do
			if (elev:FindFirstChild('Legacy')) then
				if (elev.Legacy.Floor.Value == dest and (elev.Legacy.Move_Value.Value == 0 or elev.Legacy.Leveling.Value) and ((not elev.Legacy.Out_Of_Service.Value) and (not elev.Legacy.Fire_Service.Value) and (not elev.Legacy.Inspection.Value) and (not elev.Legacy.Independent_Service.Value))) then
					chosenElevator = elev
					break
				elseif (elev.Legacy.Floor.Value ~= dest and ((math.abs(elev.Legacy.Floor.Value-dest) <= dist)) and ((not elev.Legacy.Out_Of_Service.Value) and (not elev.Legacy.Fire_Service.Value) and (not elev.Legacy.Inspection.Value) and (not elev.Legacy.Independent_Service.Value))) then
					dist = math.abs(elev.Legacy.Floor.Value-dest)
					chosenElevator = elev
				end
			end
		end
	end
	
	return chosenElevator

end

return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBXD5A8DEC72A4C4BE7A9643CECE8A5C418">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Core</string>
						<string name="ScriptGuid">{22A33DAC-8422-4619-ABEB-E8D52ED55AD1}</string>
						<ProtectedString name="Source"><![CDATA[--[[

	04/14/2023

	Cortex Classic- OFFICIAL CORE MODULE- BRANCH 'ALPHA'
	Version Begin: v5.2.6
	Version Overhaul Start: v8.4
	
	WRITTEN BY AAXTATIOUS (540781721) & IMFIRSTPLACE (79641334)
	
	Â© 2023 Cortex Elevator Co.
	
	REDISTRIBUTION OF THIS SOURCE IS ACCEPTABLE- PLEASE CREDIT DEVELOPER(S) & ACCEPT TERMS
	
	--// 08-13-2023 - CLASSIC V9.0 IS RELEASED! ENTAILS FULL CALL QUEUE SYSTEM REWRITE --//

]]--

local module = {}
module.MODULE_STORAGE = {
	sounds={},
	statValues={},
	miscValues={},
	queue={},
} --Storage for variables replacing locals

local _V = _G['Core_CurrentVersion']
local _VERSION = "Classic " .. (_V)
local elevatorID = math.random(0,1e5)

function module.Start(source, config, BUILD, mainModuleDependencies)

	local thread
	local function restartElevator()
		--source.Enabled = false
		--source.Enabled = true
		--return coroutine.yield(thread)
	end
	thread = coroutine.create(function()
		local dateTime = DateTime.now()
		print("Cortex " .. (_VERSION) .. " :: " .. (source:GetFullName()) .. " | Elevator source controller '" .. (BUILD.BUILD) .. "' initiating...\nInitiation Timestamp: " .. (dateTime:FormatLocalTime('LLL', 'en-us')))

		local cfgRan,cfgMsg = pcall(require, config)
		if (not cfgRan) then
			return error((_VERSION) .. " ERROR WHILE REQUESTING ELEVATOR SETTINGS :: " .. (cfgMsg), 5)
		else
			config = cfgMsg
		end

		local httpService: HttpService = game:GetService('HttpService')

		if (config.TYPE == 'PLUGIN_GENERATED') then
			local DATA = httpService:JSONDecode(config.EXPORTED_DATA)
			config = DATA
			local function checkColorValues(list)

				for i,v in pairs(list) do
					if (typeof(v) == 'table') then
						if (v.TYPE == 'COLOR3') then
							list[i] = Color3.fromRGB(v.R*255, v.G*255, v.B*255)
						elseif (v.ENUM_DATA) then
							list[i] = Enum[v.ENUM_DATA.ENUM_TYPE][v.ENUM_DATA.ENUM_NAME]
						else
							checkColorValues(v)
						end
					end
				end

				return list

			end

			config = checkColorValues(config)
		end

		local configFile = require(script.Assets.ConfigFile--[[13443177628]])(config, script) -- LOADS CONFIG TEMPLATE FOR ELEVATOR CONFIGURATION --
		if configFile.Movement.Movement_Type ~= 1 then
			warn("WARNING!\nThis Module Only supports CFrame Movement as in this version, CollisionGroup throws restricted error because its not released\nSetting Movement_Type to 1")
			configFile.Movement.Movement_Type = 1
		end
		local function debugWarn(message)
			if (not configFile.Debug) then return end
			return print(string.format('%s :: %s', _VERSION, message))
		end

		--local prevCfgEnabled = configFile.Sound_Database.Voice_Config and configFile.Sound_Database.Voice_Config.Enabled
		--if (configFile.Sound_Database.Voice_Config.Voice_Clips == 'STOCK') then configFile.Sound_Database.Voice_Config = require(script.Voice_Module.STOCK_VoiceModule) end
		--configFile.Sound_Database.Voice_Config.Enabled = prevCfgEnabled

		--local prevCfgEnabled = configFile.Sound_Database.Voice_Config and configFile.Sound_Database.Voice_Config.Enabled
		if (configFile.Sound_Database.Voice_Config.Voice_Clips == 'STOCK') then
			configFile.Sound_Database.Voice_Config.Voice_Clips = require(script.Voice_Module.DefaultVoiceModule)(require(script.Voice_Module.STOCK_VoiceModule), source)
		elseif typeof(configFile.Sound_Database.Voice_Config.Voice_Clips) == 'table' then
			configFile.Sound_Database.Voice_Config.Voice_Clips = require(script.Voice_Module.DefaultVoiceModule)(configFile.Sound_Database.Voice_Config.Voice_Clips, source)
		end

		--configFile.Sound_Database.Voice_Config.Enabled = prevCfgEnabled;

		local voiceConfig = configFile.Sound_Database.Voice_Config.Voice_Clips
		local voiceModule = require(script.Voice_Module).new(voiceConfig)

		local function handleConfigValue(path, index, value, fallbackValue, expectedType)
			if (path[index] == nil or (expectedType ~= nil and typeof(path[index]) ~= expectedType)) then
				path[index] = fallbackValue
			elseif (value ~= nil) then
				path[index] = value
			else
				path[index] = fallbackValue
			end
		end

		handleConfigValue(configFile.Movement, 'Floor_Pass_Chime_On_Stop_Config', config.Movement.Floor_Pass_Chime_On_Stop_Config, {['Enable']=false,['Delay']=0,['Play_On_Arrival_Floor']=true}, 'table')
		handleConfigValue(configFile.Doors, 'Reopen_When_Nudge_Obstruction', config.Doors.Reopen_When_Nudge_Obstruction, false, 'boolean')
		handleConfigValue(configFile.Doors, 'Use_Old_Door_Sensors', config.Doors.Use_Old_Door_Sensors, true, 'boolean')
		handleConfigValue(configFile.Sound_Database.Others, 'Door_Obstruction_Signal', config.Sound_Database.Others.Door_Obstruction_Signal, {['Sound_Id'] = 0, ['Volume'] = .5, ['Pitch'] = 1, ['Enable'] = false}, 'table')
		handleConfigValue(configFile.Doors, 'Door_Motor', config.Doors.Door_Motor, true, 'boolean')
		handleConfigValue(configFile.Sound_Database.Others, 'Door_Motor_Sound', config.Sound_Database.Others.Door_Motor_Sound, {
			['Enable'] = configFile.Doors.Door_Motor,
			['Sound_Id'] = 6420222939,
			['Open'] = {
				['BaseVolume'] = 0,
				['BasePitch'] = 0,
				['PeakVolume'] = 5,
				['PeakPitch'] = 1,
			},
			['Close'] = {
				['BaseVolume'] = 0,
				['BasePitch'] = 0,
				['PeakVolume'] = 5,
				['PeakPitch'] = .85,
			}
		}, 'table')
		handleConfigValue(configFile.Sound_Database.Others, 'Safety_Brake_Sound', config.Sound_Database.Others.Safety_Brake_Sound, {['Sound_Id'] = 6389151811, ['Volume'] = .5, ['Pitch'] = 1}, 'table')

		handleConfigValue(configFile.Doors, 'Stay_Open_When_Idle', config.Doors.Stay_Open_When_Idle, false, 'boolean')
		handleConfigValue(configFile.Doors, 'Close_On_Button_Press', config.Doors.Close_On_Button_Press, {
			['Enable'] = false,
			['Delay'] = 1,
		}, 'table')

		handleConfigValue(configFile.Movement, 'Stop_Delay', config.Movement.Stop_Delay, 0, 'number')
		handleConfigValue(configFile.Movement, 'Open_Doors_On_Stop', config.Movement.Open_Doors_On_Stop, true, 'boolean')
		handleConfigValue(configFile.Movement, 'Open_Doors_On_Call', config.Movement.Open_Doors_On_Call, true, 'boolean')

		handleConfigValue(configFile.Doors, 'Manual_Door_Controls', config.Doors.Manual_Door_Controls, {
			['Enable_Open'] = false,
			['Enable_Close'] = false,
		}, 'table')

		config.Color_Database.Lanterns.Exterior = configFile.Color_Database.Lanterns.Exterior
		config.Color_Database.Lanterns.Interior = configFile.Color_Database.Lanterns.Interior
		handleConfigValue(configFile.Color_Database.Lanterns.Exterior, 'Reset_After_Door_Close', config.Color_Database.Lanterns.Exterior.Reset_After_Door_Close, true, 'boolean')
		handleConfigValue(configFile.Color_Database.Lanterns.Interior, 'Reset_After_Door_Close', config.Color_Database.Lanterns.Interior.Reset_After_Door_Close, true, 'boolean')

		local tweenService = game:GetService('TweenService')
		local runService = game:GetService('RunService')
		local collectionService = game:GetService('CollectionService')
		local contentProvider: ContentProvider = game:GetService('ContentProvider')
		local physicsService: PhysicsService = game:GetService('PhysicsService')

		local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

		local elevator = source.Parent
		elevator:SetAttribute('elevatorID', elevatorID)
		local car = elevator:FindFirstChild('Car')
		if (not car) then return warn(_VERSION..' :: FATAL INITIATION ERROR: No \'Car\' model found!') end
		local floors = elevator:FindFirstChild('Floors')
		if (not floors) then return warn(_VERSION..' :: FATAL INITIATION ERROR: No \'Floors\' model found!') end
		local platform = car:FindFirstChild('Platform')
		if (not platform) then return warn(_VERSION..' :: FATAL INITIATION ERROR: No \'Platform\' instance found in the car!') end
		local level = car:FindFirstChild('Level')
		if (not level) then level = platform warn(_VERSION..' :: Initiation warning: No \'Level\' instance found in the car! Defaulting to the \'Platform\' instance') end
		local carRegion = car:FindFirstChild('Cab_Region')
		if (not carRegion) then
			carRegion = Instance.new('Part')
			carRegion.Name = 'Cab_Region'
			local size = platform.Size+Vector3.new(0, 15, 0)
			carRegion.CFrame,carRegion.Size = CFrame.new(platform.Position.X, platform.Position.Y+size.Y/2, platform.Position.Z)*CFrame.Angles(platform.CFrame:ToEulerAnglesXYZ()),size
			carRegion.Parent = car
		end
		carRegion.Anchored = true
		carRegion.Transparency = 1
		carRegion.CanCollide = false
		carRegion.CanQuery = false
		local soundGroup = carRegion:FindFirstChildOfClass('SoundGroup') or Instance.new('SoundGroup')
		soundGroup.Parent = carRegion
		local equalizer = soundGroup:FindFirstChildOfClass('EqualizerSoundEffect') or Instance.new('EqualizerSoundEffect')
		equalizer.Name = 'Muffler'
		equalizer.Parent = soundGroup
		equalizer.HighGain = 0
		equalizer.LowGain = 0
		equalizer.MidGain = 0

		-- // NEWLY ADDED :: REGISTERED FLOOORING FOR ERROR PREVENTION //--
		local registeredFloors = {}
		for i,v in pairs(floors:GetChildren()) do
			local floorNumber,level = tonumber(string.split(v.Name,'Floor_')[2]),v:FindFirstChild('Level')
			if (floorNumber and level) then
				registeredFloors[floorNumber] = { ['floorInstance']=v,['floorNumber']=floorNumber,['exteriorCallDirections']={} }
			end
		end
		local function findRegisteredFloor(floor: number)
			return registeredFloors[tonumber(floor)]
		end

		function findFloor(floor)
			local result = floors:FindFirstChild('Floor_'..tostring(floor))
			if (result and result:FindFirstChild('Level')) then return result end
			return nil
		end
		function getFloorDistance(floor: number, absolute: boolean?)
			absolute = if (absolute == nil) then true else absolute
			if (not findFloor(floor)) then return 0 end
			local dist = level.Position.Y-findFloor(floor).Level.Position.Y
			return absolute and math.abs(dist) or dist
		end

		local counterweight = elevator:FindFirstChild('Counterweight')

		local function lerp(a, b, t)
			return a+(b-a)*t
		end
		local function getTableLength(table)
			local index = 0
			for i,v in pairs(table) do
				index += 1
			end
			return index
		end

		local function addSound(append, name, config, looped, autoRange, maxDist, minDist)
			if (not append) then return end
			local sound = append:FindFirstChild(name)
			if (not sound) then
				local assetId = "rbxassetid://" .. (config.Sound_Id)
				sound = Instance.new('Sound')
				sound.Name = name
				sound.SoundId = string.len(tostring(config.Sound_Id)) >= 6 and assetId or ''
				sound.Volume = typeof(config.Volume) == 'number' and config.Volume or 0
				sound.Pitch = typeof(config.Pitch) == 'number' and config.Pitch or 0
				sound.Looped = if (typeof(looped) == 'boolean') then looped elseif (typeof(config.Looped) == 'boolean') then config.Looped else false
				local thisSoundGroupPath = config.Sound_Group and string.split(config.Sound_Group, '.')[1] == 'Car' and car or nil
				sound.SoundGroup = thisSoundGroupPath and thisSoundGroupPath:FindFirstChild(string.split(config.Sound_Group, '.')[2], true) or append:IsDescendantOf(car) and soundGroup or nil
				sound.RollOffMaxDistance = autoRange and (append.Size+Vector3.new(0, 15, 0)).Magnitude or typeof(maxDist) == 'number' and maxDist or 0
				sound.RollOffMinDistance = autoRange and sound.RollOffMaxDistance/5 or typeof(minDist) == 'number' and minDist or 0
				sound.Parent = append
				if (config.Play_When_Added) then
					sound:Play()
				end
				if (config.On_Add_Event_Function and typeof(config.On_Add_Event_Function) == 'function') then
					config.On_Add_Event_Function(sound)
					--[[
					This new configuration plugin-in allows users to modify sounds directly
						from their insertion in the Settings rather than having to use
										third-party external scripts
					]]--
				end
			end
			return sound
		end
		local function addPlaySound(sound, part)
			if (not part) then return end
			local newSound: Sound = sound:Clone()
			newSound.Name = (newSound.Name) .. "_Playing"
			newSound.Parent = part
			newSound.SoundGroup = part:IsDescendantOf(car) and soundGroup or nil
			--if (not newSound.IsLoaded) then newSound.Loaded:Wait() end
			newSound:Play()
			game:GetService('Debris'):AddItem(newSound, newSound.TimeLength)
		end

		local function callTableRecursive(t: any, callback: any)
			if (typeof(t) == 'table') then
				for i,v in next,t do
					if (typeof(callback) == 'function') then
						callback(i, v)
					end
					callTableRecursive(v, callback)
				end
			end
		end

		--AUDIO IMPORTING--
		callTableRecursive(configFile.Sound_Database, function(i: any, t: any)
			if (typeof(t) == 'table' and t.Voice_ID) then t.Sound_Id = t.Voice_ID i = 'Voice_Audio' end
			if (typeof(t) == 'table' and t.Sound_Id and (not module.MODULE_STORAGE.sounds[i])) then
				module.MODULE_STORAGE.sounds[i] = addSound(t.Append or carRegion, i, t, i == 'Alarm' or i == 'Nudge_Buzzer' or (string.match(i, 'Motor_Run') ~= nil) or i == 'Traveling_Sound', true)
			end
		end)
		callTableRecursive(config.Sound_Database, function(i: any, t: any)
			if (typeof(t) == 'table' and t.Voice_ID) then t.Sound_Id = t.Voice_ID i = 'Voice_Audio' end
			if (typeof(t) == 'table' and t.Sound_Id and (not module.MODULE_STORAGE.sounds[i]) and (i ~= 'Start' and i ~= 'Run' and i ~= 'Stop' and i ~= 'Up_Chime' and i ~= 'Down_Chime')) then
				module.MODULE_STORAGE.sounds[i] = addSound(t.Append or carRegion, i, t, t.Looped, true)
			end
		end)

		module.MODULE_STORAGE.sounds.Voice_Audio = addSound(carRegion, 'Voice_Audio', {['Sound_Id'] = voiceConfig.SoundId, ['Volume'] = voiceConfig.Volume, ['Pitch'] = voiceConfig.Pitch}, false, true)
		module.MODULE_STORAGE.sounds.Traveling_Sound:Play()
		module.MODULE_STORAGE.sounds.Safety_Brake_Sound:SetAttribute('originalPitch', module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed)
		module.MODULE_STORAGE.sounds.Safety_Brake_Sound:SetAttribute('newPitch', module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed*2)

		-- Sounds that get initialized later
		local inspectionSwitchClick = nil
		local inspectionButtonClick = {}

		local pluginModules_INTERNAL = {}
		for i,t in next,{script.Core_Modules_INTERNAL:GetChildren(),source:FindFirstChild('Plugins_INTERNAL') and source.Plugins_INTERNAL:GetChildren() or {}} do
			for i,v in next,t do
				v = v:GetAttribute('overridable') and source:FindFirstChild('Plugins_INTERNAL') and source.Plugins_INTERNAL:FindFirstChild(v.Name) or v --If the plugin module's name can be found within the Plugins extension, replace internal with plugin module
				local ran,res = pcall(require, v)
				if (not ran) then return debugWarn("INTERNAL PLUGIN MODULE '" .. (v.Name) .. "' SETUP FAILED :: " .. (res)) end
				local ran,res2 = pcall(function()
					return task.spawn(function() return res:INITIATE_PLUGIN_INTERNAL(script, source) end)
				end)
				if (not ran) then debugWarn("INTERNAL PLUGIN MODULE '" .. (v.Name) .. "' INITIATION FAILED :: " .. (res))
				else
					pluginModules_INTERNAL[v.Name] = {CONTENT=res,MODULE=v}
				end
			end
		end

		local startPosition = platform.CFrame
		local positionOffset = 0

		local api = elevator:FindFirstChild('Cortex_API') or Instance.new('BindableEvent')
		api.Name = 'Cortex_API'
		api.Parent = elevator
		local remote = elevator:FindFirstChild('Cortex_Remote') or Instance.new('RemoteEvent')
		remote.Name = 'Cortex_Remote'
		remote.Parent = elevator
		local globalRemote: RemoteEvent = game.ReplicatedStorage:FindFirstChild('Cortex_Remote_GLOBAL') or Instance.new('RemoteEvent', game.ReplicatedStorage)
		globalRemote.Name = 'Cortex_Remote_GLOBAL'
		pluginModules_INTERNAL.Storage.CONTENT:save('mainElevatorData', 'car', car)

		local function getAccelerationTime(...)
			return pluginModules_INTERNAL.Core_Functions.CONTENT:getAccelerationTime(...)
		end
		local function getDecelerationRate(...)
			return pluginModules_INTERNAL.Core_Functions.CONTENT:getDecelerationRate(...)
		end
		local function smoothstep(min: number, max: number, value: number)
			return pluginModules_INTERNAL.Core_Functions.CONTENT.smoothstep(min, max, value)
		end
		pluginModules_INTERNAL.Storage.CONTENT:save('mainElevatorData', 'getAccelerationTime', getAccelerationTime)

		_G.Elevator_Output_Storage_GLOBAL[elevator.Name] = {}
		local function outputElevMessage(msg: string?, type: string?)
			--Check the amount the table has. If it exceeds 200, begin clearing indexes from the beginning.
			if (runService:IsRunMode()) then
				--warn(msg)
			end
			local removed = false
			if (getTableLength(_G.Elevator_Output_Storage_GLOBAL[elevator.Name]) >= 200) then
				for i,v in pairs(_G.Elevator_Output_Storage_GLOBAL[elevator.Name]) do
					if (removed) then return end
					globalRemote:FireAllClients('Cortex_Output_Message_Removed', i)
					_G.Elevator_Output_Storage_GLOBAL[elevator.Name][i] = nil
					removed = true
					return
				end
			end
			local now = DateTime.fromUnixTimestamp(os.clock())
			local function generateRandomId()
				local randId = httpService:GenerateGUID()
				if (_G.Elevator_Output_Storage_GLOBAL[elevator.Name][tostring(randId)]) then
					return generateRandomId()
				end
				return randId
			end

			local colorDatabase = {
				['statuses'] = {
					['generic'] = {
						['debug']=Color3.new(0.870588, 0.870588, 0.870588),
						['warning']=Color3.new(1, 0.870588, 0.360784),
						['critical']=Color3.new(1, 0.32549, 0.32549),
						['bluecode']=Color3.new(0.376471, 0.709804, 1),
					}
				}
			}

			local messageId = generateRandomId()
			local data = {
				['elevator']=elevator,
				['message']={
					['content']=msg,
					['id']=messageId
				},
				['type']=type,
				['timestamp']=now,
				['color']=colorDatabase.statuses.generic[type]
			}
			_G.Elevator_Output_Storage_GLOBAL[elevator.Name][messageId] = data
			globalRemote:FireAllClients('Cortex_Output_Message_Broadcast', data)
		end

		for i,v in pairs(floors:GetChildren()) do
			if v:FindFirstChild('Level') then
				local sound = Instance.new('Sound')
				sound.Name = 'Drop_Key_Sound'
				sound.SoundId = 'rbxassetid://4496280365'
				sound.Volume = 1
				sound.RollOffMaxDistance = 200
				sound.RollOffMinDistance = 5
				sound.Pitch = 2.55/config.Doors.Door_Open_Speed
				sound.Parent = v.Level
			end
		end
		local sound = Instance.new('Sound')
		sound.Name = 'Drop_Key_Sound'
		sound.SoundId = 'rbxassetid://4496280365'
		sound.Volume = 1
		sound.RollOffMaxDistance = 200
		sound.RollOffMinDistance = 5
		sound.Pitch = 2.55/config.Doors.Door_Open_Speed
		sound.Parent = level

		module.MODULE_STORAGE.statValues.currentSpeed = 0
		module.MODULE_STORAGE.statValues.currentFloor = -100000
		module.MODULE_STORAGE.statValues.rawFloor = module.MODULE_STORAGE.statValues.currentFloor
		module.MODULE_STORAGE.statValues.arriveFloor = -100000
		module.MODULE_STORAGE.statValues.moveValue = 0
		module.MODULE_STORAGE.statValues.direction = 'N'
		module.MODULE_STORAGE.statValues.queueDirection = 'N'
		module.MODULE_STORAGE.statValues.arrowDirection = 'N'
		module.MODULE_STORAGE.statValues.moveDirection = 'N'
		module.MODULE_STORAGE.statValues.destination = module.MODULE_STORAGE.statValues.rawFloor
		module.MODULE_STORAGE.statValues.departFloor = module.MODULE_STORAGE.statValues.rawFloor
		module.MODULE_STORAGE.miscValues.nFloor = 0
		module.MODULE_STORAGE.miscValues.rawNFloor = 0
		module.MODULE_STORAGE.statValues.nudging = false
		module.MODULE_STORAGE.statValues.leveling = false
		module.MODULE_STORAGE.miscValues.leaving = false
		module.MODULE_STORAGE.miscValues.arrivingving = false
		module.MODULE_STORAGE.statValues.fireService = false
		module.MODULE_STORAGE.statValues.fireRecall = false
		module.MODULE_STORAGE.statValues.phase1 = false
		module.MODULE_STORAGE.statValues.phase2 = false
		module.MODULE_STORAGE.statValues.inspection = false
		module.MODULE_STORAGE.miscValues.inspectionCommonEnabled = false
		module.MODULE_STORAGE.statValues.parking = false
		inspectionLocked = false
		outOfService = false
		independentService = false
		safetyBraking = false
		moveBrake = false
		preDooring = false
		releveling = false
		bouncing = false
		stopElevator = false
		overshot = false
		fireRecallFloor = -100000
		preDirection = 'N'
		preChimeFloor = -1000
		lockedFloors = {}
		lockedHallFloors = {}
		directionalFloorCalls = {}
		departPreStarting = false
		chimingAfterOpen = {}
		doorStateValues = {}
		dropKeyCheckValues = {}
		switchingDirectionFromNeutral = false
		lock = false
		elevatorPosition = startPosition
		idleAnimations = {}
		playerWeldData = {}
		dropKeyHandlers = {}

		local function checkIndependentService()
			return (not module.MODULE_STORAGE.statValues.fireService and independentService)
		end

		local function checkPhase2()
			return (not module.MODULE_STORAGE.statValues.fireRecall and module.MODULE_STORAGE.statValues.fireService and module.MODULE_STORAGE.statValues.phase2)
		end

		module.MODULE_STORAGE.miscValues.clientRefreshHandlers = {}

		local function addClientRefreshToPlayer(player)
			local newGui = player:WaitForChild('PlayerGui'):FindFirstChild('Cortex_ClientRefresh') or mainModuleDependencies.Cortex_ClientRefresh:Clone()
			if (configFile.ClientRefresh_Movement_Config.Enable) then
				local wl = httpService:JSONDecode(newGui.WHITELIST_META.Value)
				wl[tostring(elevatorID)] = {ENABLE=true}
				newGui.WHITELIST_META.Value = httpService:JSONEncode(wl)
				module.MODULE_STORAGE.miscValues.clientRefreshHandlers[player] = newGui
			end
			newGui.Parent = player.PlayerGui
		end
		game.Players.PlayerAdded:Connect(addClientRefreshToPlayer)
		for i, player in pairs(game.Players:GetPlayers()) do
			addClientRefreshToPlayer(player)
		end
		collectionService:AddTag(elevator, 'CortexElevatorInstance')
		if (not table.find(_G.CortexElevatorStorage, elevator)) then
			table.insert(_G.CortexElevatorStorage, elevator)
		end

		local floorsArray = {}
		for i,v in pairs(floors:GetChildren()) do
			local floorNumber = tonumber(string.gsub(v.Name, '%D', ''))
			if (floorNumber and findFloor(floorNumber) and findFloor(floorNumber):FindFirstChild('Level')) then
				table.insert(floorsArray, floorNumber)
			end
		end

		local statisticsValues = {}
		local statisticsFolder = elevator:FindFirstChild('Legacy') or Instance.new('Folder', elevator)
		statisticsFolder.Name = 'Legacy'
		local playerWeldsFolder = platform:FindFirstChild('Player_Welds') or Instance.new('Folder', platform)
		playerWeldsFolder.Name = 'Player_Welds'
		pluginModules_INTERNAL.Storage.CONTENT:save('mainElevatorData', 'legacy', statisticsFolder)

		local queueTableJSON = pluginModules_INTERNAL.Core_Functions.CONTENT.addInstance(statisticsFolder, 'StringValue', 'Queue', false, {Value=''})
		queueTableJSON.Value = httpService:JSONEncode({})

		local function addStatisticValue(type, name, updateValueFunc)
			local val = statisticsFolder:FindFirstChild(name) or Instance.new(type, statisticsFolder)
			val.Name = name
			statisticsValues[name] = {
				['value']=val,
				['updateValue']=updateValueFunc
			}
			return val
		end

		local floorVal = addStatisticValue('NumberValue', 'Floor', function(value)
			value.Value = module.MODULE_STORAGE.statValues.currentFloor
		end)
		local rawFloorVal = addStatisticValue('NumberValue', 'Raw_Floor', function(value)
			value.Value = module.MODULE_STORAGE.statValues.rawFloor
		end)
		local moveVal = addStatisticValue('NumberValue', 'Move_Value', function(value)
			value.Value = module.MODULE_STORAGE.statValues.moveValue
		end)
		local arrowDirVal = addStatisticValue('StringValue', 'Arrow_Direction', function(value)
			value.Value = module.MODULE_STORAGE.statValues.arrowDirection
		end)
		local queueDirVal = addStatisticValue('StringValue', 'Queue_Direction', function(value)
			value.Value = module.MODULE_STORAGE.statValues.queueDirection
		end)
		local destVal = addStatisticValue('NumberValue', 'Destination', function(value)
			value.Value = module.MODULE_STORAGE.statValues.destination
		end)
		local remoteCallVal = addStatisticValue('NumberValue', 'Remote_Call')
		local FSVal = addStatisticValue('BoolValue', 'Fire_Service', function(value)
			value.Value = module.MODULE_STORAGE.statValues.fireService
		end)
		local phase1Val = addStatisticValue('BoolValue', 'Phase_1', function(value)
			value.Value = module.MODULE_STORAGE.statValues.phase1
		end)
		local phase2Val = addStatisticValue('BoolValue', 'Phase_2', function(value)
			value.Value = module.MODULE_STORAGE.statValues.phase2
		end)
		local insVal = addStatisticValue('BoolValue', 'Inspection', function(value)
			value.Value = module.MODULE_STORAGE.statValues.inspection
		end)
		local oosVal = addStatisticValue('BoolValue', 'Out_Of_Service', function(value)
			value.Value = outOfService
		end)
		local indVal = addStatisticValue('BoolValue', 'Independent_Service', function(value)
			value.Value = independentService
		end)
		local speedVal = addStatisticValue('NumberValue', 'Current_Speed', function(value)
			value.Value = math.rad(module.MODULE_STORAGE.statValues.currentSpeed)
		end)
		local velocityVal = addStatisticValue('NumberValue', 'Velocity', function(value)
			value.Value = module.MODULE_STORAGE.statValues.currentSpeed
		end)
		local arriveFloorVal = addStatisticValue('NumberValue', 'Arrive_Floor', function(value)
			value.Value = module.MODULE_STORAGE.statValues.arriveFloor
		end)
		local levelingVal = addStatisticValue('BoolValue', 'Leveling', function(value)
			value.Value = module.MODULE_STORAGE.statValues.leveling
		end)
		local nudgeVal = addStatisticValue('BoolValue', 'Nudge', function(value)
			value.Value = module.MODULE_STORAGE.statValues.nudging
		end)
		local stopVal = addStatisticValue('BoolValue', 'Stop', function(value)
			value.Value = stopElevator
		end)
		local moveDirVal = addStatisticValue('StringValue', 'Move_Direction', function(value)
			value.Value = module.MODULE_STORAGE.statValues.moveDirection
		end)
		local preDirVal = addStatisticValue('StringValue', 'Pre_Direction', function(value)
			value.Value = preDirection
		end)

		local cabOccupancyValue = car:FindFirstChild('Occupancy') or Instance.new('NumberValue', car)
		cabOccupancyValue.Name = 'Occupancy'

		local function getDistance(target, origin, absolute)
			return absolute and math.abs(target-origin) or target-origin
		end

		pluginModules_INTERNAL.Storage.CONTENT:save('mainElevatorData', 'findFloor', findFloor)
		pluginModules_INTERNAL.Storage.CONTENT:save('mainElevatorData', 'getFloorDistance', getFloorDistance)

		--Set up top and bottom floors--
		local bottomFloor,topFloor
		local lastPos1,lastPos2 = math.huge,-math.huge
		for i,v in pairs(floors:GetChildren()) do
			local isAFloor = tonumber(string.split(v.Name, 'Floor_')[2])
			local level = v:FindFirstChild('Level')
			if ((isAFloor and level)) then
				local yPos = level.Position.Y
				if (level.Position.Y <= lastPos1) then
					bottomFloor = isAFloor
					lastPos1 = yPos
				end
				if (level.Position.Y >= lastPos2) then
					topFloor = isAFloor
					lastPos2 = yPos
				end
			end
		end

		local function getDoorState(side)

			if (not pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')[side]) then return assert(_V..': Get Door State function with argument '..tostring(side)..' set error: Index not found in door states dictionary') end
			return pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')[side]

		end

		remoteCallVal:GetPropertyChangedSignal('Value'):Connect(function()
			if (findFloor(remoteCallVal.Value)) then
				addCall(remoteCallVal.Value)
			end
		end)

		function isDropKeyOnElevator()
			for i,v in pairs(dropKeyCheckValues) do
				if (v.Value) then return false end
			end
			return true
		end

		local function conditionalStepWait(...)
			return pluginModules_INTERNAL.Core_Functions.CONTENT:conditionalStepWait(...)
		end

		local function isLevel()
			local regFloor = findRegisteredFloor(module.MODULE_STORAGE.statValues.rawFloor)
			if (not regFloor) then return end
			return ((regFloor.floorInstance.Level.Position.Y-level.Position.Y) <= .35) and true or false
		end

		function findAncestor(model, name)
			if (not model or typeof(model) ~= 'Instance') then return end
			local result = model:FindFirstChild(name)
			if (result) then
				return result
			else
				return findAncestor(model.Parent, name)
			end
		end

		local function doDropKey(params)
			local doorSide = string.split(string.split(params.Name, 'Doors')[1], '_')[1]
			local function getWelds()
				local welds = {}
				local floorNumber = tonumber(string.gsub(params.Parent.Name, '%D', ''))
				for i,v in next,pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData') do
					for i,w in next,(params:IsDescendantOf(car) and v.engineWelds.car[doorSide] or v.engineWelds.floors[tostring(floorNumber)] and v.engineWelds.floors[tostring(floorNumber)][doorSide] or {}) do
						table.insert(welds, w)
					end
				end
				return welds

			end
			local landingLevel = findAncestor(params, 'Level')
			if (not landingLevel) then return end

			if ((landingLevel.Parent == car and getDoorState(doorSide).state == 'Closed') or (landingLevel.Parent ~= car and (((getDoorState(doorSide).state == 'Closed' and tonumber(landingLevel.Parent.Name:sub(7)) == module.MODULE_STORAGE.statValues.rawFloor) or tonumber(landingLevel.Parent.Name:sub(7)) ~= module.MODULE_STORAGE.statValues.rawFloor)))) then
				for i,weld in pairs(getWelds()) do
					if (weld.instance.C0 == weld.closedPosition) then
						landingLevel.Drop_Key_Sound:Play()
						task.spawn(function()
							pluginModules_INTERNAL.Legacy_Easing.CONTENT:interpolate(weld.instance,weld.openPosition,weld.instance.C1,'Out_Bounce',configFile.Doors.Door_Open_Speed*1.3)
						end)
						if module.MODULE_STORAGE.statValues.moveValue ~= 0 and isDropKeyOnElevator() then
							module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed = module.MODULE_STORAGE.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
							safetyBrake()
						else
							moveBrake = true
						end
						outOfService = true
						params.Drop_Key_Open.Value = true
						getDoorData(doorSide).IsDropKey = true
						updateCore()
					elseif (weld.instance.C0 == weld.openPosition) then
						landingLevel.Drop_Key_Sound:Play()
						task.spawn(function()
							pluginModules_INTERNAL.Legacy_Easing.CONTENT:interpolate(weld.instance,weld.closedPosition,weld.instance.C1,'Out_Sine',configFile.Doors.Door_Open_Speed*1.3)
							params.Drop_Key_Open.Value = false
							getDoorData(doorSide).IsDropKey = false
							moveBrake = not isDropKeyOnElevator()
							outOfService = not isDropKeyOnElevator()
							preDooring = false
							releveling = false
							updateCore()
						end)
					end
				end
			end
		end

		local dropKeyUpdaters = {}

		local function dismountDropKeyClient(user,params)

			local doorSet = params
			if (not collectionService:HasTag(doorSet, 'IsInUse')) then return end
			local thisFloorName = doorSet:IsDescendantOf(floors) and string.split(doorSet.Parent.Name, 'Floor_')[2]
			local landingLevel = doorSet.Parent.Level
			local sideIndex = doorSet.Name:split('Doors')[1]:split('_')[1]
			local fullSideName = (sideIndex == '' and 'Front' or sideIndex)

			for i,v in pairs(dropKeyUpdaters[doorSet]) do
				v:Disconnect()
			end
			local index = table.find(dropKeyHandlers,user)
			if (index) then
				table.remove(dropKeyHandlers,index)
			end
			local doorBounds = doorSet:FindFirstChild('Door_Bounds')
			if (doorBounds) then doorBounds:Destroy() end
			dropKeyUpdaters[doorSet] = nil

			local welds = {}
			local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', sideIndex)
			for i,v in next,data and (doorSet:IsDescendantOf(car) and data.engineWelds.car[sideIndex] or data.engineWelds.floors[tostring(thisFloorName)][sideIndex]) or {} do
				table.insert(welds, v)
			end

			local function checkIfDoorIsClosed()
				for i,v in pairs(welds) do
					if (v.instance.C0 ~= v.closedPosition) then return false end
				end
				return true
			end

			local isClosed = checkIfDoorIsClosed()
			local function check()
				doorSet.Drop_Key_Open.Value = false
				moveBrake = not isDropKeyOnElevator()
				outOfService = not isDropKeyOnElevator()
				preDooring = false
				releveling = false
				api:Fire('onElevDoorKey',{doorSet=doorSet,status='release'})
				task.spawn(updateCore)
				task.spawn(function()
					local isCompleted = conditionalStepWait(1, function() return {moveBrake} end)
					if (not isCompleted) then return end
					task.spawn(safeCheckRelevel)
				end)
			end
			addPlaySound(addSound(landingLevel, 'Interlock_Click', {
				Sound_Id = 9116323848,
				Volume = 1,
				Pitch = 1.65
			}, false, false, 40, 3), landingLevel)
			if (not isClosed) then
				local connection: RBXScriptConnection
				local i = 0
				for _,v in pairs(welds) do
					v.startPosition = v.instance.C0
					v.alpha = 0
				end
				connection = HEARTBEAT:Connect(function(dtTime)
					i += .025*dtTime
					for _,v in pairs(welds) do
						v.alpha += i
						v.instance.C0 = v.startPosition:Lerp(v.closedPosition, math.min(v.alpha,1))
					end
					if (dropKeyUpdaters[doorSet]) then return connection:Disconnect() end
					if (checkIfDoorIsClosed()) then connection:Disconnect() return check() end
				end)
			end
			collectionService:RemoveTag(doorSet, 'IsInUse')

		end

		local chimeDebounce = false
		local isDown,isMoving,stopping = false,false,false
		local inspectionMoveDebounce = false

		local function stopInspection(params)
			if (stopping) then return end
			isDown = false
			local dir = params == 'Up' and 1 or params == 'Down' and -1
			if params ~= 'N' then -- bug fix to elevator being stuck when inspection is turned on and off when the elevator is idle
				stopping = true
			end
			if (not configFile.Movement.Motor_Stop_On_Open) then
				module.MODULE_STORAGE.statValues.leveling = true
			end
			moveBrake = false
			while (isMoving) do
				local delta = updateCore()
				module.MODULE_STORAGE.statValues.currentSpeed -= configFile.Movement.Inspection_Config.Deceleration_Rate
				if (module.MODULE_STORAGE.statValues.currentSpeed <= .1) then break end
				if (not stopping) then
					isMoving = false
					inspectionMoveDebounce = false
					return
				end
			end
			if (configFile.Movement.Motor_Stop_On_Open) then
				module.MODULE_STORAGE.statValues.leveling = true
			end
			removePlayerWelds()
			if (not isMoving) then inspectionMoveDebounce = false return end
			isMoving = false
			module.MODULE_STORAGE.statValues.leveling = false
			module.MODULE_STORAGE.statValues.moveValue = 0
			module.MODULE_STORAGE.statValues.currentSpeed = 0
			inspectionMoveDebounce = false
			task.spawn(updateCore)

		end

		local function playVoiceProtocol(clip, pauseThread)

			if (not configFile.Sound_Database.Voice_Config.Enabled) then return end
			voiceModule:PlayClip(module.MODULE_STORAGE.sounds.Voice_Audio, clip, pauseThread)

		end

		local function playVoiceSequenceProtocol(clipSequence, pauseThread)

			if (not configFile.Sound_Database.Voice_Config.Enabled) then return end
			local function run()
				for index,item in pairs(clipSequence) do
					voiceModule:PlayClip(module.MODULE_STORAGE.sounds.Voice_Audio, voiceConfig.Voice_Clips[item[1]], true)
					conditionalStepWait(item.Delay)
				end
			end
			if (pauseThread) then
				run()
			else
				task.spawn(function()
					run()
				end)
			end

		end

		local voiceSequenceQueue = {}
		local index = 0

		local function playVoiceSequenceProtocolWithQueue(clipSequence, pauseThread)
			if (not configFile.Sound_Database.Voice_Config.Enabled) then return end
			local length = #voiceSequenceQueue
			if (not table.find(voiceSequenceQueue, clipSequence)) then table.insert(voiceSequenceQueue, clipSequence) end
			if (length <= 0) then
				local function run()
					while (#voiceSequenceQueue > 0) do
						index += 1
						local sequence = voiceSequenceQueue[index]
						for index,item in pairs(sequence) do
							voiceModule:PlayClip(module.MODULE_STORAGE.sounds.Voice_Audio, voiceConfig.Voice_Clips[item[1]], true)
							conditionalStepWait(item.Delay)
						end
						local tindex = table.find(voiceSequenceQueue, sequence)
						if (tindex) then table.remove(voiceSequenceQueue, tindex) index -= 1 end
					end
					index = 0
				end
				if (pauseThread) then
					run()
				else
					task.spawn(run)
				end
			end

		end

		local platformPos = platform.Position

		local function doModelWeld(model, weldPart, ignoreList, append)
			local welds = {}
			for i,v in pairs(model:GetDescendants()) do
				if (v:IsA('BasePart')) then
					if (not weldPart) then
						weldPart = v
					end
					if ((typeof(ignoreList) ~= 'table' or (not table.find(ignoreList, v)))) then

						if (v ~= weldPart) then
							local weld = Instance.new('Weld')
							weld.Name = (v.Name) .. "_Weld"
							weld.Part0 = v
							weld.C0 = CFrame.new()
							weld.C1 = weldPart.CFrame:ToObjectSpace(v.CFrame)
							weld.Part1 = weldPart
							weld.Parent = append or weldPart
							table.insert(welds, weld)
						end
						v.Anchored = false
					end

				end
			end
			return welds
		end

		function weldTogether(part0, part1, joinInPlace, animatable)
			local weld = animatable and Instance.new('Motor6D') or Instance.new('Weld')
			weld.Part0 = part0
			if (joinInPlace) then
				weld.C0 = CFrame.new()
				weld.C1 = part1.CFrame:ToObjectSpace(part0.CFrame)
			end
			weld.Part1 = part1
			part0.Anchored = false
			weld.Parent = part0
			return weld
		end

		function getDoorData(side)
			local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', side)
			if (not data) then return end
			return data
		end

		local doorSensorsFolder = car:FindFirstChild('Door_Sensor_Parts') or Instance.new('Folder', car)
		doorSensorsFolder.Name = 'Door_Sensor_Parts'
		local carDoors = {}

		local doorWelds = {}
		local function doDoorWeld(model, weldPart)
			for i,v in pairs(model:GetChildren()) do
				if (string.match(v.Name:lower(), 'doors') and v:IsA('Model')) then
					if (v:IsDescendantOf(car)) then table.insert(carDoors, v) end

					local compactedSideName = v.Name:split('Doors')[1]
					local sideIndex = v.Name:split('Doors')[1]:split('_')[1]
					local fullSideName = (sideIndex == '' and 'Front' or sideIndex)
					local isOpen = v:FindFirstChild('Is_Open') or Instance.new('BoolValue', v)
					isOpen.Name = 'Is_Open'
					local dropOpen = v:FindFirstChild('Drop_Key_Open') or Instance.new('BoolValue', v)
					dropOpen.Name = 'Drop_Key_Open'
					table.insert(dropKeyCheckValues, dropOpen)
					local weldsModel = model:FindFirstChild(v.Name..'_Welds') or Instance.new('Folder', model)
					weldsModel.Name = (v.Name) .. "_Welds"

					local sensorPart,doorObstructionSignalAudio,doorOpenSound,doorCloseSound
					if (v:IsDescendantOf(car)) then
						local doorCFrame,doorSize = v:GetBoundingBox()
						sensorPart = Instance.new('Part')
						sensorPart.Name = string.format('%s_Sensor', sideIndex)
						sensorPart.Transparency = 1
						sensorPart.CanCollide = false
						sensorPart.CanTouch = false
						sensorPart.CanQuery = false
						--sensorPart.Massless = true
						local range = doorSize.Magnitude
						doorOpenSound = addSound(sensorPart, (fullSideName) .. "_Door_Open_Sound", configFile.Sound_Database.Doors.Open_Sound, false, false, range*3.4, range/2)
						doorCloseSound = addSound(sensorPart, (fullSideName) .. "_Door_Close_Sound", configFile.Sound_Database.Doors.Close_Sound, false, false, range*3.4, range/2)
						doorObstructionSignalAudio = addSound(sensorPart, 'Obstruction_Signal', configFile.Sound_Database.Others.Door_Obstruction_Signal, true, false, 60, 3)
						sensorPart.CFrame,sensorPart.Size = doorCFrame,doorSize+Vector3.new(0,0,1)
						weldTogether(sensorPart, platform, true)
						sensorPart.Anchored = false
						sensorPart.Parent = doorSensorsFolder
					end

					local doorStateValue = addStatisticValue('StringValue', (fullSideName) .. "_Door_State", function(value)
						local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', sideIndex)
						if (data) then
							value.Value = data.state
						end
					end)
					local doorHoldValue = addStatisticValue('BoolValue', (fullSideName) .. "_Door_Hold", function(value)
						local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', sideIndex)
						if (data) then
							value.Value = data.doorHold
						end
					end)

					local doorNudgingValue = addStatisticValue('BoolValue', (fullSideName) .. "_Door_Nudging", function(value)
						local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', sideIndex)
						if (data) then
							value.Value = data.nudging
						end
					end)

					local doorMotorSound = addSound(weldPart, 'Door_Motor', configFile.Sound_Database.Others.Door_Motor_Sound, true, false, 60, 3)
					local multiplierValue = doorMotorSound:FindFirstChild('Multiplier') or Instance.new('NumberValue', doorMotorSound)
					multiplierValue.Name = 'Multiplier'
					multiplierValue.Value = doorMotorSound:FindFirstChild('Multiplier') and multiplierValue.Value or 1

					local doorSpeedValue = weldPart.Parent:FindFirstChild((compactedSideName) .. "Door_Speed") or Instance.new('NumberValue')
					doorSpeedValue.Parent = v:IsDescendantOf(car) and statisticsFolder or weldPart.Parent
					doorSpeedValue.Name = (compactedSideName) .. "Door_Speed"

					local doorData = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', sideIndex) or pluginModules_INTERNAL.Door_Engine.CONTENT.new(sideIndex, {sounds={
						doorOpenSound=doorOpenSound,
						doorCloseSound=doorCloseSound,
						doorMotorSound=doorMotorSound
					}, values={
						doorStateValue=doorStateValue,
						doorSpeedValue=doorSpeedValue
					}, config=configFile, doorSensorPart=sensorPart,doorSet=v})
					local floorNumber = tonumber(string.split(model.Name, 'Floor_')[2])

					local touchDebounce = false
					for i,door in pairs(v:GetChildren()) do

						local scaler = door:FindFirstChild('Scaler')
						if (scaler) then

							--Creates the new 'Closed' part inside the Scaler part to enhance safety if the weld disconnects
							local closedPart = scaler:FindFirstChild('Closed') or Instance.new('Part', scaler)
							closedPart.Parent = scaler
							closedPart.Size = scaler.Size
							closedPart.CFrame = scaler.CFrame
							closedPart.Name = 'Closed'
							closedPart.Transparency = 1
							closedPart.CanCollide = false
							closedPart.CanTouch = false
							closedPart.CanQuery = false
							weldTogether(closedPart, weldPart, true)
							doModelWeld(door, scaler, scaler:GetDescendants())

							local open = scaler:FindFirstChild('Open')
							if (not open) then
								open = Instance.new('Part')
								open.Name = 'Open'
								open.Parent = scaler
								open.Size = scaler.Size
								open.CanCollide = false
								open.Color = scaler.Color
								local cf = scaler.CFrame:ToWorldSpace(CFrame.new(0, 0, -((scaler.Parent.Name:sub(2,2) == 'R' and 1 or scaler.Parent.Name:sub(2,2) == 'L' and -1 or 0)*scaler.Size.Magnitude*.9)*scaler.Parent.Name:sub(3)))
								open.CFrame = cf
								open.Transparency = 1
							end
							weldTogether(open, weldPart, true, false)
							open.Anchored = false
							scaler.CanQuery = true

							local engineWeld = weldTogether(scaler, open, true, false)
							engineWeld.Name = 'Door_Engine_Weld'
							engineWeld.Parent = weldsModel

							local doorsDataIndex = scaler:IsDescendantOf(car) and 'Realistic_Doors_Data' or 'Realistic_Outer_Doors_Data'
							local openDiv,closeDiv = configFile.Doors.Realistic_Doors_Data and (configFile.Doors[doorsDataIndex].Open_Ratio or configFile.Doors.Realistic_Doors_Data.Open_Ratio) or 1.03,configFile.Doors.Realistic_Doors_Data and (configFile.Doors[doorsDataIndex].Close_Ratio or configFile.Doors.Realistic_Doors_Data.Close_Ratio) or 1.03
							local rx, ry, rz = engineWeld.C1:ToOrientation()
							local openCf = Vector3.new(rz, rx, ry)-Vector3.new(rz, rx, ry)/openDiv
							local closeCf = Vector3.new(rz, rx, ry)-Vector3.new(rz, rx, ry)/closeDiv
							local data = {
								['instance']=engineWeld,
								['openPosition']=engineWeld.C1,
								['closedPosition']=engineWeld.C0,
								['interlockOpenPosition'] = CFrame.new((engineWeld.C1.Position)-(engineWeld.C1.Position)/openDiv)*CFrame.Angles(openCf.X, openCf.Y, openCf.Y),
								['interlockClosePosition'] = CFrame.new((engineWeld.C1.Position)-(engineWeld.C1.Position)/closeDiv)*CFrame.Angles(openCf.X, openCf.Y, openCf.Y),
								['distanceFromOpenPosition']=(engineWeld.C1.Position-engineWeld.C0.Position).Magnitude,
								['side'] = sideIndex,
							}
							function data:getCurrentDistance()
								return (engineWeld.C1.Position-engineWeld.C0.Position).Magnitude
							end
							function data:getDistanceFromOpenPosition()
								return (data.closedPosition.Position-engineWeld.C0.Position).Magnitude
							end
							if (engineWeld:IsDescendantOf(car) and sideIndex) then
								if (not doorData.engineWelds.car[sideIndex]) then
									doorData.engineWelds.car[sideIndex] = {}
								end
								doorData.engineWelds.car[sideIndex][engineWeld] = data
							elseif (engineWeld:IsDescendantOf(floors) and floorNumber and sideIndex) then
								if (not doorData.engineWelds.floors[tostring(floorNumber)]) then
									doorData.engineWelds.floors[tostring(floorNumber)] = {}
								end
								if (not doorData.engineWelds.floors[tostring(floorNumber)][sideIndex]) then
									doorData.engineWelds.floors[tostring(floorNumber)][sideIndex] = {}
								end
								doorData.engineWelds.floors[tostring(floorNumber)][sideIndex][engineWeld] = data
							end

							if (scaler:IsDescendantOf(car)) then
								for i,part in pairs(door:GetDescendants()) do
									if (part:IsA('BasePart') and part.Name == 'Sensor_LED') then
										table.insert(doorData.sensorLEDs, part)
									end
								end
							end
						end
					end
					pluginModules_INTERNAL.Storage.CONTENT:save('masterDoorData', sideIndex, doorData, {OVERWRITE=false})
				end
			end
		end

		doDoorWeld(car, level)
		for i,v in pairs(registeredFloors) do
			doDoorWeld(v.floorInstance, v.floorInstance.Level)
		end

		local carWeldsFolder = car:FindFirstChild('Car_Welds') or Instance.new('Folder')
		carWeldsFolder.Name = 'Car_Welds'
		carWeldsFolder.Parent = car
		carWeldsFolder:ClearAllChildren()

		local doorParts = {}
		for i,v in pairs(carDoors) do
			for i,b in pairs(v:GetDescendants()) do
				if (b:IsA('BasePart')) then
					table.insert(doorParts, b)
				end
			end
		end

		local modelWelds = doModelWeld(car, platform, doorParts, carWeldsFolder)
		for i,v in pairs(modelWelds) do
			v.Parent = carWeldsFolder
		end

		local cwStart,cwOffset
		if (counterweight and counterweight:FindFirstChild('Main')) then
			for i,v in pairs(counterweight:GetDescendants()) do
				if (string.match(v.ClassName, 'Weld') or v:IsA('Sound') or (string.match(v.ClassName, 'Script') and v.Parent == counterweight)) then
					v:Destroy()
				end
			end
			doModelWeld(counterweight, counterweight.Main, {})
			local travelingSound = addSound(counterweight.Main, 'Traveling_Sound', {Sound_Id=6003695467,Volume=0,Pitch=1.15}, true, false, 50, .2)
			local equalizer: EqualizerSoundEffect = travelingSound:FindFirstChildOfClass('EqualizerSoundEffect') or Instance.new('EqualizerSoundEffect')
			equalizer.HighGain = -8
			equalizer.LowGain = 7
			equalizer.MidGain = -2
			equalizer.Parent = travelingSound
			travelingSound:Play()
			counterweight.Main.Anchored = true

			local cwPos = counterweight.Main.CFrame.Y+(findFloor(bottomFloor).Level.Position.Y-level.Position.Y)
			local oriX,oriY,oriZ = counterweight.Main.CFrame:ToOrientation()
			--counterweight.Main.CFrame = CFrame.new(counterweight.Main.CFrame.X, cwPos, counterweight.Main.CFrame.Z)*CFrame.Angles(oriX, oriY, oriZ)
			cwStart = counterweight.Main.CFrame
			cwOffset = counterweight.Main.Position
		end
		local elevatorHeight = math.abs(findFloor(topFloor).Level.Position.Y-findFloor(bottomFloor).Level.Position.Y)

		local attachmentPart = {}
		function attachmentPart:Create()

			self.attachmentPart = elevator:FindFirstChild('Physics_Attachment') or Instance.new('Part', elevator)
			self.attachmentPart.Name = 'Physics_Attachment'
			self.attachmentPart.Anchored = true
			self.attachmentPart.Archivable = false
			self.attachmentPart.CFrame = platform.CFrame
			self.attachmentPart.Size = Vector3.new(1, 1, 1)*1
			self.attachmentPart.CanCollide = false
			self.attachmentPart.Transparency = 1
			self.attachmentPart.Position = Vector3.new(platformPos.X, findFloor(bottomFloor).Level.Position.Y, platformPos.Z)
			return self

		end

		local cables = {}

		if (configFile.Movement.Movement_Type == 2) then

			local attachmentPart = attachmentPart:Create().attachmentPart
			local att0,att1 = Instance.new('Attachment', platform),Instance.new('Attachment', attachmentPart)
			att0.Orientation,att1.Orientation = Vector3.new(0, 0, 90),Vector3.new(0, 0, 90)
			local att0,att1 = Instance.new('Attachment', platform),Instance.new('Attachment', attachmentPart)
			local alignPos: AlignPosition = Instance.new('AlignPosition', platform)
			alignPos.Attachment0,alignPos.Attachment1 = att0,att1
			alignPos.MaxForce = math.huge
			alignPos.MaxVelocity = 0
			alignPos.Responsiveness = 200
			--alignPos.ApplyAtCenterOfMass = true
			--alignPos.RigidityEnabled = true
			local alignOri = Instance.new('AlignOrientation', platform)
			alignOri.Attachment0,alignOri.Attachment1 = att0,att1
			alignOri.MaxTorque = math.huge
			alignOri.MaxAngularVelocity = math.huge
			alignOri.Responsiveness = 200
			--alignOri.RigidityEnabled = true

		elseif (configFile.Movement.Movement_Type == 3) then

			local attachmentPart = attachmentPart:Create().attachmentPart
			local att0,att1 = Instance.new('Attachment', platform),Instance.new('Attachment', attachmentPart)
			att0.Orientation,att1.Orientation = Vector3.new(0, 0, 90),Vector3.new(0, 0, 90)
			local pris: PrismaticConstraint = Instance.new('PrismaticConstraint', attachmentPart)
			pris.Name = 'Prismatic'
			pris.Attachment0,pris.Attachment1 = att1,att0
			pris.ActuatorType = Enum.ActuatorType.Motor
			pris.Velocity = 0
			pris.MotorMaxForce = 100000000
			pris.MotorMaxAcceleration = 100000000

		elseif (configFile.Movement.Movement_Type == 4) then

			local attachmentPart = attachmentPart:Create().attachmentPart
			local att0,att1 = Instance.new('Attachment', platform),Instance.new('Attachment', attachmentPart)
			att0.Orientation,att1.Orientation = Vector3.new(0, 0, 90),Vector3.new(0, 0, 90)
			--Holds the car in place for the hoisting system--
			local pris: PrismaticConstraint = Instance.new('PrismaticConstraint', attachmentPart)
			pris.Attachment0,pris.Attachment1 = att1,att0

		end

		if (elevator:FindFirstChild('Physics_Attachment')) and (configFile.Movement.Movement_Type ~= 1) then
			for i,v in pairs(elevator:GetDescendants()) do
				if ((v:IsA('RopeConstraint') or v:IsA('RodConstraint')) and ((v.Attachment0 and v.Attachment0:IsDescendantOf(car)) or (v.Attachment1 and v.Attachment1:IsDescendantOf(car)))) then
					if (configFile.Movement.Movement_Type ~= 4 or v.Name ~= 'Elevator_Cable') then
						v.Enabled = false
					else

						local carAttachment = (v.Attachment0:IsDescendantOf(car) and v.Attachment0 or v.Attachment1:IsDescendantOf(car) and v.Attachment1)
						local hoistwayAttachment = ((not v.Attachment0:IsDescendantOf(car)) and v.Attachment0 or (not v.Attachment1:IsDescendantOf(car)) and v.Attachment1)

						--Replace any valid RodConstraints with RopeConstraints--
						local rope: RopeConstraint = Instance.new('RopeConstraint')
						rope.Name = v.Name
						rope.Attachment0,rope.Attachment1 = carAttachment,hoistwayAttachment
						rope.Color = v.Color
						rope.Thickness = v.Thickness
						rope.Visible = v.Visible
						rope.Length = rope.CurrentDistance
						rope.WinchEnabled = true
						rope.WinchForce = math.huge
						rope.WinchResponsiveness = 200
						rope.WinchSpeed = 0
						rope.WinchTarget = rope.CurrentDistance
						rope.Enabled = true
						rope.Parent = v.Parent
						v:Destroy()
						v = rope
						cables[v] = {cable=v,carAttachment=carAttachment,hoistwayAttachment=hoistwayAttachment}

					end
				end
			end
		end

		local elevatorCollisionGroup = 'elevatorCollisionGroup'
		local elevatorButtonsCollisionGroup = 'elevatorButtonsCollisionGroup'
		pcall(function()
			physicsService:CreateCollisionGroup(elevatorCollisionGroup)
		end)
		pcall(function()
			physicsService:CreateCollisionGroup(elevatorButtonsCollisionGroup)
		end)

		platform.Anchored = true--elevator:FindFirstChild('Physics_Attachment') == nil
		physicsService:CollisionGroupSetCollidable(elevatorCollisionGroup, elevatorCollisionGroup, false)
		
		--[[
		The current identity (2) cannot CollisionGroup (lacking permission 5):
		
		for i,v in pairs(elevator:GetDescendants()) do
			if (v:IsA('BasePart')) then
				--if (configFile.Movement.Movement_Type ~= 1) then
				v.CollisionGroup = elevatorCollisionGroup
				--end
			end
		end
		]]

		local oversped = false
		local previousFloor = module.MODULE_STORAGE.statValues.currentFloor

		local function updateFloor()

			--Floor selector--
			local moveValue = module.MODULE_STORAGE.statValues.moveValue
			local nDist = math.huge
			local nRawDist = nDist
			for i,g in pairs(floors:GetChildren()) do
				if g:FindFirstChild('Level') then
					local lvl = g.Level
					local offset = (module.MODULE_STORAGE.statValues.moveValue == 1 and configFile.Sensors.Up_Level_Offset or module.MODULE_STORAGE.statValues.moveValue == -1 and configFile.Sensors.Down_Level_Offset or 0)
					local thisDist = math.abs((level.Position.Y+(module.MODULE_STORAGE.statValues.moveValue*(configFile.Sensors.Floor_Position_Offset*module.MODULE_STORAGE.statValues.currentSpeed))+(offset*math.rad(module.MODULE_STORAGE.statValues.moveValue*module.MODULE_STORAGE.statValues.currentSpeed)*.7))-lvl.Position.Y)
					local min = moveValue == 0 and bottomFloor or moveValue == 1 and module.MODULE_STORAGE.statValues.rawFloor or bottomFloor
					local max = moveValue == 0 and topFloor or moveValue == -1 and module.MODULE_STORAGE.statValues.rawFloor or topFloor
					if (thisDist <= nDist) then
						nDist = thisDist
						module.MODULE_STORAGE.miscValues.nFloor = math.clamp(tonumber(string.split(g.Name, 'Floor_')[2]), min <= max and min or max, max >= min and max or min)
					end
					if (math.abs(lvl.Position.Y-level.Position.Y) <= nRawDist) then
						module.MODULE_STORAGE.miscValues.rawNFloor = tonumber(string.split(g.Name, 'Floor_')[2])
						nRawDist = math.abs(lvl.Position.Y-level.Position.Y)
					end
				end
			end
			if (module.MODULE_STORAGE.miscValues.nFloor ~= module.MODULE_STORAGE.statValues.currentFloor and (preChimeFloor ~= module.MODULE_STORAGE.miscValues.nFloor)) then
				module.MODULE_STORAGE.statValues.currentFloor = module.MODULE_STORAGE.miscValues.nFloor
				if ((not module.MODULE_STORAGE.statValues.fireService) and (not checkIndependentService()) and (((not configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Play_On_Arrival_Floor) and module.MODULE_STORAGE.statValues.currentFloor ~= module.MODULE_STORAGE.statValues.destination) or configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Play_On_Arrival_Floor)) then
					task.delay(configFile.Sound_Database.Floor_Pass_Chime_Delay, function()
						addPlaySound(module.MODULE_STORAGE.sounds.Floor_Pass_Chime, platform)
					end)
				end
			end
			if (module.MODULE_STORAGE.miscValues.rawNFloor ~= module.MODULE_STORAGE.statValues.rawFloor) then
				module.MODULE_STORAGE.statValues.rawFloor = module.MODULE_STORAGE.miscValues.rawNFloor
			end

		end

		local startingPlatformCF = platform.CFrame
		local signalFiring = false

		local lastTick = os.clock()
		local dtTime = 0
		local lastPlatformPosition = platform.Position

		local targetPointVal: CFrameValue = platform:FindFirstChild('TARGET_POSITION_FRAME') or Instance.new('CFrameValue')
		targetPointVal.Name = 'TARGET_POSITION_FRAME'
		targetPointVal.Parent = platform
		targetPointVal:GetPropertyChangedSignal('Value'):Connect(function()
			platform.CFrame = targetPointVal.Value
		end)

		local initialDirection = 0
		function updateCore()

			local dtTime = HEARTBEAT:Wait()
			local function applyForce()
				platform:ApplyImpulse(platform.CFrame.UpVector*(module.MODULE_STORAGE.statValues.moveValue*module.MODULE_STORAGE.statValues.currentSpeed))
				for i,v in pairs(playerWeldData) do
					if (v.position) then
						v.position.Position = platform.Position+Vector3.new(0, 1, 0)*v.position:GetAttribute('playerWeldHeight')
					end
				end
			end

			--Move the platform--
			if (elevator:FindFirstChild('Physics_Attachment')) then
				if (platform:FindFirstChild('AlignPosition')) then
					platform.AlignPosition.MaxVelocity = (module.MODULE_STORAGE.statValues.currentSpeed)
					elevator.Physics_Attachment.Position = Vector3.new(elevator.Physics_Attachment.Position.X, (module.MODULE_STORAGE.statValues.moveValue == 1 and findFloor(topFloor).Level.Position.Y or module.MODULE_STORAGE.statValues.moveValue == -1 and findFloor(bottomFloor).Level.Position.Y) or elevator.Physics_Attachment.Position.Y, elevator.Physics_Attachment.Position.Z)
				elseif (elevator.Physics_Attachment:FindFirstChild('Prismatic')) then
					elevator.Physics_Attachment.Prismatic.Velocity = (module.MODULE_STORAGE.statValues.moveValue*module.MODULE_STORAGE.statValues.currentSpeed)
				end
				platform.Anchored = module.MODULE_STORAGE.statValues.currentSpeed == 0
				for i: RopeConstraint,v: {} in pairs(cables) do
					i.WinchTarget = -module.MODULE_STORAGE.statValues.moveValue*1000000
					i.WinchSpeed = module.MODULE_STORAGE.statValues.currentSpeed
				end
			else
				local priorPositionFrame = startPosition*CFrame.new(0, positionOffset, 0)
				positionOffset += (module.MODULE_STORAGE.statValues.moveValue*module.MODULE_STORAGE.statValues.currentSpeed)*math.min(math.round(dtTime*1000)/1000, 2)
				elevatorPosition = startPosition*CFrame.new(0, positionOffset, 0)
				local regBottomFlr,regTopFlr = findRegisteredFloor(bottomFloor),findRegisteredFloor(topFloor)
				if (regBottomFlr and regTopFlr) then
					elevatorPosition = CFrame.new(elevatorPosition.X,--[[math.clamp(elevatorPosition.Y,regBottomFlr.floorInstance.Level.Position.Y-2,regTopFlr.floorInstance.Level.Position.Y+2)]]elevatorPosition.Y,elevatorPosition.Z)*CFrame.fromEulerAnglesXYZ(startPosition:ToEulerAnglesXYZ())
					targetPointVal.Value = elevatorPosition
					applyForce()
				end
			end

			local carSpeed = (platform.Position-lastPlatformPosition)

			local tSpeedFactor = configFile.Sound_Database.Others.Traveling_Sound.Speed_Factor*(module.MODULE_STORAGE.statValues.currentSpeed/configFile.Movement.Travel_Speed)
			local volumeConstraint = configFile.Sound_Database.Others.Traveling_Sound.Constraints.Volume
			local pitchConstraint = configFile.Sound_Database.Others.Traveling_Sound.Constraints.Pitch

			if (counterweight and cwStart) then
				cwOffset -= carSpeed
				local oriX,oriY,oriZ = cwStart:ToOrientation()
				counterweight.Main.CFrame = CFrame.new(cwOffset)*CFrame.Angles(oriX, oriY, oriZ)
				counterweight.Main.Traveling_Sound.Volume = math.clamp(math.abs(module.MODULE_STORAGE.statValues.currentSpeed)/15, 0, 2)
			end

			--Master Nudge Value--
			local masterNudge = false
			for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
				if (v.nudging) then
					masterNudge = true
					break
				end
			end

			module.MODULE_STORAGE.statValues.nudging = masterNudge

			--Update statisticsFolder values--
			for i,value in pairs(statisticsValues) do
				if (value.updateValue and typeof(value.updateValue) == 'function') then
					value.updateValue(value.value)
				end
			end
			------
			if (module.MODULE_STORAGE.sounds.Traveling_Sound and configFile.Sound_Database.Others.Traveling_Sound.Enable) then
				local travelingSound = module.MODULE_STORAGE.sounds.Traveling_Sound
				travelingSound.Volume = configFile.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio' and ((volumeConstraint.Max-volumeConstraint.Min)*tSpeedFactor)+volumeConstraint.Min or math.abs(module.MODULE_STORAGE.statValues.currentSpeed)/30
				travelingSound.PlaybackSpeed = configFile.Sound_Database.Others.Traveling_Sound.Factor_Type == 'Travel_Speed_Ratio' and ((pitchConstraint.Max-pitchConstraint.Min)*tSpeedFactor)+pitchConstraint.Min or math.clamp(.5+math.abs(module.MODULE_STORAGE.statValues.currentSpeed)/30, pitchConstraint.Min, pitchConstraint.Max)
			end

			--Max limit--
			local absoluteDirection = carSpeed.Unit.Y > 0 and 1 or carSpeed.Unit.Y < 0 and -1 or 0
			local topRegFloor,bottomRegFloor = findRegisteredFloor(topFloor),findRegisteredFloor(bottomFloor)
			if (((topRegFloor and absoluteDirection == 1 and absoluteDirection*((topRegFloor.floorInstance.Level.Position.Y+1.5)-level.Position.Y) < 0) or (bottomRegFloor and absoluteDirection == -1 and absoluteDirection*((bottomRegFloor.floorInstance.Level.Position.Y-1.5)-level.Position.Y) < 0))) then
				if (not overshot) then
					initialDirection = absoluteDirection
					print('Elevator has over/undershot max limit')
					api:Fire('elevatorOvershoot')
					local isIdle = module.MODULE_STORAGE.statValues.currentSpeed < 0
					overshot = true
					if (not isIdle) then
						module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed = module.MODULE_STORAGE.sounds.Safety_Brake_Sound:GetAttribute('newPitch')
						module.MODULE_STORAGE.sounds.Safety_Brake_Sound:Play()
						--safetyBrake()
					end
					moveBrake = true
					module.MODULE_STORAGE.statValues.currentSpeed = 0
					module.MODULE_STORAGE.statValues.moveValue = 0
					updateCore()
					local initialT = os.clock()
					--if (((topRegFloor and module.MODULE_STORAGE.statValues.moveValue == 1 and module.MODULE_STORAGE.statValues.moveValue*((topRegFloor.floorInstance.Level.Position.Y+1.5)-level.Position.Y) < 0) or (bottomRegFloor and module.MODULE_STORAGE.statValues.moveValue == -1 and module.MODULE_STORAGE.statValues.moveValue*((bottomRegFloor.floorInstance.Level.Position.Y-1.5)-level.Position.Y) < 0))) then
					--end
					if (not module.MODULE_STORAGE.statValues.inspection) then
						overshot = false
					end
					while ((os.clock()-initialT)/3 < 1 and (not overshot) and moveBrake and isDropKeyOnElevator() and (not module.MODULE_STORAGE.statValues.inspection)) do task.wait() end
					if ((os.clock()-initialT)/3 < 1) then return dtTime end
					releveling = false
					moveBrake = false
					safeCheckRelevel()
					return dtTime
				elseif (initialDirection == -absoluteDirection) then
					overshot = false
				end
			end

			if (module.MODULE_STORAGE.statValues.currentSpeed >= configFile.Movement.Travel_Speed+1 and (not oversped)) then
				oversped = true
				api:Fire('Overspeed_Trip')
				module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed = module.MODULE_STORAGE.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
				safetyBrake()
				task.wait(2)
				if (isDropKeyOnElevator() and (not module.MODULE_STORAGE.statValues.inspection)) then
					moveBrake = false
					relevel()
				end
				oversped = false
			end

			if (lastPlatformPosition ~= platform.Position) then
				lastPlatformPosition = platform.Position
				updateFloor()
			end

			return dtTime,carSpeed.Unit.Y > 0 and 1 or carSpeed.Unit.Y < 0 and -1 or 0
		end
		updateFloor()

		function checkDoorStates(state, params)
			local thisFloor = findFloor(module.MODULE_STORAGE.statValues.rawFloor)
			local dontRequireAll = params and params.dontRequireAll or false
			local onlyPresentDoors = params and params.onlyPresentDoors or false
			local isAllStates = true
			for i,v in next,pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData') do
				if (not dontRequireAll) and v.state ~= state and (not onlyPresentDoors and true or thisFloor:FindFirstChild((v.side == '' and '' or v.side.."_").."Doors")) then
					isAllStates = false
					break
				elseif dontRequireAll and v.state == state then
					return true
				end
			end
			if (dontRequireAll) then
				return false
			elseif (not dontRequireAll) then
				return isAllStates
			end
		end

		function setDoorState(side, state)
			if (not pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')[side]) then return assert(_V..': Get Door State function with argument '..tostring(side)..' set error: Index not found in door states dictionary') end
			pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')[side].state = state
			task.spawn(updateCore)
		end

		function setDirection(floor, forceDirection)
			if (forceDirection == 'N') then
				module.MODULE_STORAGE.statValues.queueDirection = forceDirection
				module.MODULE_STORAGE.statValues.arrowDirection = forceDirection
				preDirection = forceDirection
				task.spawn(updateCore)
				return
			end
			if (floor == topFloor) then
				module.MODULE_STORAGE.statValues.queueDirection = 'D'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
				preDirection = module.MODULE_STORAGE.statValues.queueDirection
				task.spawn(updateCore)
				return
			elseif (floor == bottomFloor) then
				module.MODULE_STORAGE.statValues.queueDirection = 'U'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
				preDirection = module.MODULE_STORAGE.statValues.queueDirection
				task.spawn(updateCore)
				return
			end
			if (forceDirection) then
				module.MODULE_STORAGE.statValues.queueDirection = forceDirection
				module.MODULE_STORAGE.statValues.arrowDirection = forceDirection
				preDirection = forceDirection
				task.spawn(updateCore)
				return
			end
			if (#module.MODULE_STORAGE.queue <= 0 or not floor) and (module.MODULE_STORAGE.statValues.rawFloor ~= topFloor and module.MODULE_STORAGE.statValues.rawFloor ~= bottomFloor) then
				module.MODULE_STORAGE.statValues.queueDirection = 'N'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
				preDirection = module.MODULE_STORAGE.statValues.queueDirection
				task.spawn(updateCore)
				return
			end
			if (not module.MODULE_STORAGE.queue[1]) then return end
			if (module.MODULE_STORAGE.queue[1] > floor) then
				module.MODULE_STORAGE.statValues.queueDirection = 'U'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
				preDirection = module.MODULE_STORAGE.statValues.queueDirection
				task.spawn(updateCore)
				return
			elseif (module.MODULE_STORAGE.queue[1] < floor) then
				module.MODULE_STORAGE.statValues.queueDirection = 'D'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
				preDirection = module.MODULE_STORAGE.statValues.queueDirection
				task.spawn(updateCore)
				return
			end
		end

		local preparingParking = false
		local function parkTimer()
			if (not preparingParking) then
				task.spawn(function()
					if (configFile.Movement.Parking_Config.Enable and module.MODULE_STORAGE.statValues.rawFloor ~= configFile.Movement.Parking_Config.Park_Floor) then
						preparingParking = true
						local startTime = os.clock()
						while (os.clock()-startTime <= configFile.Movement.Parking_Config.Idle_Time) do
							task.wait(.5)
							if (module.MODULE_STORAGE.statValues.moveValue ~= 0 or (not checkDoorStates('Closed')) or (module.MODULE_STORAGE.statValues.fireService or checkIndependentService() or module.MODULE_STORAGE.statValues.inspection or outOfService)) then preparingParking = false return end
						end
						preparingParking = false
						if (not checkDoorStates('Closed')) then
							local connections = {}
							for i,v in pairs(doorStateValues) do
								connections[v] = v.Value:GetPropertyChangedSignal('Value'):Connect(function()
									if (not checkDoorStates('Closed')) then return end
									for i,v in pairs(connections) do
										v:Disconnect()
									end
									elevatorRun(configFile.Movement.Parking_Config.Park_Floor, true)
								end)
							end
						else
							elevatorRun(configFile.Movement.Parking_Config.Park_Floor, true)
						end
					end
				end)
			end
		end

		function bounceStop(bypass)

			local isEnabled = configFile.Movement.Bounce_Stop_Config.Enable or bypass

			if (isEnabled) then
				task.spawn(function()
					bouncing = true
					if (configFile.Movement.Bounce_Stop_Config.Stop_Sound.Enable) then
						local sound = addSound(platform, 'Bounce_Stop', configFile.Movement.Bounce_Stop_Config.Stop_Sound, false, true)
						sound.PlayOnRemove = true
						sound:Destroy()
					end
					local startTime = os.clock()
					local lastSpeed = module.MODULE_STORAGE.statValues.currentSpeed
					local div = 1
					local checked = false
					local min = .03
					local previousValue = module.MODULE_STORAGE.statValues.moveValue ~= 0 and module.MODULE_STORAGE.statValues.moveValue or 1
					preDooring = true
					while (bouncing) do

						updateCore()
						module.MODULE_STORAGE.statValues.moveValue = 1
						module.MODULE_STORAGE.statValues.currentSpeed = previousValue*(((math.sin(math.abs(os.clock()-startTime)*25))/div)*configFile.Movement.Bounce_Stop_Config.Amount)
						if (module.MODULE_STORAGE.statValues.currentSpeed ~= lastSpeed) then
							local diff = math.abs(lastSpeed-module.MODULE_STORAGE.statValues.currentSpeed)
							lastSpeed = module.MODULE_STORAGE.statValues.currentSpeed
							if (diff <= min and (not checked)) then
								checked = true
								div += 1/configFile.Movement.Bounce_Stop_Config.Times
							elseif (diff >= min) then
								checked = false
							end
							if (math.abs(lastSpeed) <= .005) then
								bouncing = false
							end
						end
						if (stopElevator or (not isDropKeyOnElevator()) or moveBrake) then
							break
						end

					end
					module.MODULE_STORAGE.statValues.moveValue = 0
					module.MODULE_STORAGE.statValues.currentSpeed = 0
					module.MODULE_STORAGE.statValues.leveling = false
					preDooring = false
					task.spawn(updateCore)
					--setDirection(module.MODULE_STORAGE.statValues.rawFloor)
				end)
			end
			return isEnabled

		end

		function removeAllCalls()
			for index,floor in pairs(registeredFloors) do
				removeCall(floor.floorNumber)
				pcall(function()
					resetLanterns(floor.floorNumber)
					resetButtons(floor.floorNumber)
				end)
			end
		end

		function safetyBrake()
			task.spawn(function()
				if (safetyBraking) then return end
				print(string.format('Elevator %s has safety broke!', elevator:GetFullName()))
				outputElevMessage("Elevator has safety broke!", 'critical')
				removeAllCalls()
				safetyBraking = true
				stopping = false
				releveling = false
				inspectionMoveDebounce = false
				isMoving = false
				module.MODULE_STORAGE.statValues.leveling = true
				module.MODULE_STORAGE.statValues.arrowDirection = 'N'
				for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
					v.nudging = false
				end
				module.MODULE_STORAGE.statValues.nudging = false
				module.MODULE_STORAGE.statValues.queueDirection = 'N'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
				preChimeFloor = nil
				lock = false
				local speed = module.MODULE_STORAGE.statValues.currentSpeed
				if (speed > 0) then
					module.MODULE_STORAGE.sounds.Safety_Brake_Sound:Play()
					module.MODULE_STORAGE.sounds.Safety_Brake_Sound.Volume = .75+speed/2
				end
				api:Fire('onSafetyBrake')
				local decelTime = getAccelerationTime(speed, 0, .85)
				local startTime = os.clock()
				while ((os.clock()-startTime)/decelTime < 1) do
					updateCore()
					module.MODULE_STORAGE.statValues.currentSpeed = lerp(speed, 0, (os.clock()-startTime)/decelTime)
				end
				module.MODULE_STORAGE.statValues.currentSpeed = 0
				module.MODULE_STORAGE.statValues.moveValue = 0
				module.MODULE_STORAGE.statValues.moveDirection = 'N'
				setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
				preDooring = false
				overshot = false
				module.MODULE_STORAGE.statValues.leveling = false
				safetyBraking = false
				updateCore()
				removePlayerWelds()
				if (speed > 0) then
					--bounceStop(false)
				end
			end)
		end

		local function checkObstruction(parts)

			for i,p in pairs(parts) do
				local human,root = p.Name == 'HumanoidRootPart' and p,(p.Parent:FindFirstChildOfClass('Humanoid') or p.Parent.Parent:FindFirstChildOfClass('Humanoid'))
				if (human and root) then
					return true
				end
			end
			return false

		end

		local function handleNudgeReclose(doorData)

			if (doorData.nudging) then
				if (doorData.state ~= 'Open' and doorData.state ~= 'Closed') then
					local connection
					connection = doorData.Door_State_Value:GetPropertyChangedSignal('Value'):Connect(function()
						if (doorData.Door_State_Value.Value == 'Open') then
							if (doorData.Is_Obstructed) then
								return handleNudgeReclose(doorData)
							end
							connection:Disconnect()
							local isCompleted = conditionalStepWait(.5, function() return {doorData.state ~= 'Open'} end)
							if (not isCompleted) then return end
							runDoorClose(module.MODULE_STORAGE.statValues.rawFloor, doorData.Side..'Doors', true)
						elseif (doorData.Door_State_Value == 'Closed') then
							connection:Disconnect()
						end
					end)
				elseif (not doorData.Is_Obstructed) then
					local isCompleted = conditionalStepWait(.5, function() return {doorData.state ~= 'Open'} end)
					if (not isCompleted) then return end
					return runDoorClose(module.MODULE_STORAGE.statValues.rawFloor, doorData.Side..'Doors', true)
				elseif (doorData.Region_Data.Is_Enabled and (not checkIndependentService()) and (not module.MODULE_STORAGE.statValues.fireService)) then
					local region = doorData.Region_Data.Create_Region()
					local parts = region:FindPartsInRegion3WithWhiteList(humans, 1)
					local isObstructedByHuman = checkObstruction(parts)

					local lastObstructed = doorData.Is_Obstructed
					doorData.Is_Obstructed = isObstructedByHuman
					if (lastObstructed ~= doorData.Is_Obstructed and doorData.Region_Data.Door_Obstruction_Signal_Audio) then
						if (doorData.Is_Obstructed) then
							if (configFile.Sound_Database.Others.Door_Obstruction_Signal.Enable) then
								doorData.Region_Data.Door_Obstruction_Signal_Audio.Playing = true
							end
						else
							doorData.Region_Data.Door_Obstruction_Signal_Audio.Playing = false
						end
					end
					if (isObstructedByHuman) then
						doorData.doorTimerTick = os.clock()
						if (doorData.state == 'Closing' and (((doorData.nudging and configFile.Doors.Reopen_When_Nudge_Obstruction)) or (not doorData.nudging))) then
							runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, doorData.Side, doorData.nudging)
						end
					end
				end
				task.wait()
				handleNudgeReclose(doorData)
			end

		end

		local doorSensorObstructions = {}
		function runDoorOpen(floor: number, side: string, bypassNudge: boolean?)
			local function runDoor(data)
				local ran,res = pcall(function()
					local startingState = data.state
					local thisFloor = findFloor(floor)
					local function checkDoor()
						for i,v in pairs(thisFloor:GetChildren()) do
							local side = string.split(string.split(v.Name,'Doors')[1],'_')[1]
							if (side == data.side and collectionService:HasTag(v, 'IsInUse')) then return v end
						end
						return
					end
					if (getFloorDistance(module.MODULE_STORAGE.statValues.rawFloor) > .35 or (lock and (not preDooring)) or outOfService or module.MODULE_STORAGE.statValues.inspection --[[or module.MODULE_STORAGE.statValues.fireService]]) then return print((data.side) .. " doors unable to open") end
					if ((not data.doorSet) or checkDoor() or collectionService:HasTag(data.doorSet, 'IsInUse')) then return nil,print((data.side) .. " Doors are already unlocked by door key!") end
					if ((startingState ~= 'Closed' and startingState ~= 'Closing' and startingState ~= 'Stopped') or ((not car:FindFirstChild((data.side == '' and '' or data.side.."_").."Doors")) or (not thisFloor:FindFirstChild((data.side == '' and '' or data.side.."_").."Doors")))) then return end
					if (data.nudging and (not bypassNudge)) then return end

					if (startingState == 'Closing') then task.wait() end

					local function onOpened()
						task.spawn(function()
							if (startingState == 'Closed' and module.MODULE_STORAGE.statValues.queueDirection ~= 'N' and voiceConfig.Settings.Directional_Announcements) then
								local clip = voiceConfig.Settings.Directional_Announcements[(module.MODULE_STORAGE.statValues.queueDirection == 'U' and 'Up' or module.MODULE_STORAGE.statValues.queueDirection == 'D' and 'Down') .. "_Announcement"]
								if (not clip) then return end
								if (clip.Enabled) then
									playVoiceSequenceProtocolWithQueue(clip.Sequence, false)
								end
							end
						end)
						local params = OverlapParams.new()
						params.FilterType = Enum.RaycastFilterType.Whitelist
						data.doorTimerTick = os.clock()
						api:Fire('doorStateChange', {state=data.state,side=data.side,floor=floor})
						if (startingState == 'Closed') then data.nudgeTimerTick = os.clock() end
						local startRelevelTick = os.clock()
						local isObstructed = data.isObstructed
						while ((os.clock()-data.doorTimerTick)/configFile.Doors.Door_Timer <= 1 and data.state == 'Open') do
							if (os.clock()-startRelevelTick >= .25 and getFloorDistance(module.MODULE_STORAGE.statValues.currentFloor) >= configFile.Movement.Relevel_Tolerance and (not releveling)) then
								preDooring = true
								startRelevelTick = os.clock()
								task.spawn(relevel)
							end

							params.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
							local parts = workspace:GetPartBoundsInBox(data.doorSensorPart.CFrame, data.doorSensorPart.Size, params)
							data.isObstructed = #parts > 0
							if (data.isObstructed or checkIndependentService() or module.MODULE_STORAGE.statValues.fireService or configFile.Doors.Manual_Door_Controls.Enable_Close or data.doorHold) then
								data.doorTimerTick = os.clock()
							end
							if (checkIndependentService() or module.MODULE_STORAGE.statValues.fireService or configFile.Doors.Manual_Door_Controls.Enable_Close) then
								data.nudgeTimerTick = os.clock()
							end
							if (isObstructed ~= data.isObstructed) then
								data.doorSensorPart.Obstruction_Signal.Playing = data.isObstructed and configFile.Sound_Database.Others.Door_Obstruction_Signal.Enable
								api:Fire('doorObstructionStateChanged', {state=data.isObstructed,side=data.side})
							end
							isObstructed = data.isObstructed

							if ((os.clock()-data.nudgeTimerTick)/configFile.Doors.Nudge_Timer >= 1) then
								if (not data.nudging) then
									data.nudging = true
									module.MODULE_STORAGE.sounds.Nudge_Buzzer:Play()
								end
								task.spawn(runDoorClose, floor, data.side, true)
							end
							HEARTBEAT:Wait()
						end
						if (data.state == 'Open' and (not data.nudging) and (not checkIndependentService()) and (not module.MODULE_STORAGE.statValues.fireService) and (not configFile.Doors.Manual_Door_Controls.Enable_Close)) then
							task.spawn(runDoorClose, floor, data.side, data.nudging)
						end
					end

					task.spawn(function()
						if (configFile.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable and configFile.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable) then
							data:Open(floor, onOpened)
						else
							data:LegacyOpen(floor, onOpened)
						end
						api:Fire('onDoorOpen', {side=data.side,floor=floor})
						if (configFile.Sound_Database.Voice_Config.Enabled and voiceConfig.Settings.Door_Announcements.Open_Announcement.Enabled) then
							playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Open_Announcement.Sequence, false)
						end
						data.isObstructed = false
						data.doorSensorPart.Obstruction_Signal:Stop()
						api:Fire('doorObstructionStateChanged', {state=data.isObstructed,side=data.side})
					end)
				end)
				if (not ran) then return debugWarn("Error occured whilst operating " .. (side) .. " doors :: " .. (res) .. "\n" .. (debug.traceback())) end
			end

			local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', side)
			if (((not data) and side ~= 'ALL') or (stopElevator)) then return debugWarn("Error occured whilst operating " .. (side) .. " doors :: No data found halting all functions & resetting states\n" .. (debug.traceback())) end
			--if (isLevel() == false) then return task.spawn(relevel) end
			if (side ~= 'ALL') then return task.spawn(runDoor, data) end
			for i,v in next,pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData') do
				task.spawn(runDoor, v)
			end
		end

		function runDoorClose(floor: number, side: string, nudge: boolean?)
			local function runDoor(data)
				local ran,res = pcall(function()
					local startingState = data.state
					local thisFloor = findFloor(floor)
					if ((startingState ~= 'Open' and startingState ~= 'Stopped') and ((not checkIndependentService()) and ((not module.MODULE_STORAGE.statValues.fireService) or startingState == 'Closed')) or ((not car:FindFirstChild((data.side == '' and '' or data.side.."_").."Doors")) or (not thisFloor:FindFirstChild((data.side == '' and '' or data.side.."_").."Doors")))) then return end
					api:Fire('onDoorClose', {side=data.side,nudge=nudge,floor=floor})

					task.wait()

					local function onClosed()
						data.valueInstances.doorSpeedValue.Value = 0
						api:Fire('onDoorClosed', {side=data.side,nudge=nudge,floor=floor})

						local sensorPart: Part = data.doorSensorPart
						data.nudging = false
						data.isObstructed = false
						data.doorHold = false
						sensorPart.Obstruction_Signal.Playing = false

						if (not module.MODULE_STORAGE.statValues.fireService) then
							local function check()
								for _,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
									if (v.side ~= data.side and v.nudging) then return false end
								end
								return true
							end
							if (check()) then module.MODULE_STORAGE.sounds.Nudge_Buzzer:Stop() end
						end

						if (not checkDoorStates('Closed')) then return end
						api:Fire('doorStateChange', {state=data.state,side=data.side,floor=floor})
						--Move the elevator
						parkTimer()
						local directionNum = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 1 or module.MODULE_STORAGE.statValues.queueDirection == 'D' and -1 or 0
						local nextCall = checkCallInDirection(module.MODULE_STORAGE.statValues.rawFloor,directionNum) or module.MODULE_STORAGE.queue[1]
						local regFloor = findRegisteredFloor(module.MODULE_STORAGE.statValues.rawFloor)
						local function checkRun(call: any)
							if (not call) then return end
							local dir = call.directions[1]
							local regFloor = findRegisteredFloor(call.call)
							local index = table.find(regFloor.exteriorCallDirections,dir)
							if (index) then
								task.spawn(function()
									module.MODULE_STORAGE.statValues.queueDirection = dir == 1 and 'U' or dir == -1 and 'D' or 'N'
									module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
									api:Fire('onCallRespond', {floor=floor,direction=module.MODULE_STORAGE.statValues.queueDirection})
									task.spawn(updateCore)
									task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,'ALL')
									doLanterns(module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Exterior_Call,configFile.Color_Database.Lanterns.Active_After_Door_Open,dir)
									runChime(module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.Exterior_Call_Only,configFile.Sound_Database.Chime_Events.After_Open,dir)
									removeCall(call.call,dir)
								end)
							end
						end
						task.spawn(updateCore)
						if (not regFloor) then return end
						local index = table.find(regFloor.exteriorCallDirections,directionNum)
						if (index) then
							table.remove(regFloor.exteriorCallDirections,index)
						end
						if (module.MODULE_STORAGE.statValues.moveValue == 0 and nextCall and nextCall.call ~= module.MODULE_STORAGE.statValues.rawFloor) then
							local callDirection = nextCall.call > module.MODULE_STORAGE.statValues.rawFloor and 'U' or nextCall.call < module.MODULE_STORAGE.statValues.rawFloor and 'D' or 'N'
							if (callDirection ~= module.MODULE_STORAGE.statValues.queueDirection) then
								module.MODULE_STORAGE.statValues.queueDirection = 'N'
								task.spawn(updateCore)
								local hasCompleted = conditionalStepWait(1, function() return {module.MODULE_STORAGE.statValues.moveValue ~= 0} end)
								if (not hasCompleted) then return end
							end
							task.spawn(elevatorRun,nextCall.call,false)
						elseif (nextCall and nextCall.call == module.MODULE_STORAGE.statValues.rawFloor) then
							local hasCompleted = conditionalStepWait(1, function() return {module.MODULE_STORAGE.statValues.moveValue ~= 0} end)
							if (not hasCompleted) then return end
							checkRun(nextCall)
						else
							nextCall = checkCallInDirection(module.MODULE_STORAGE.statValues.rawFloor) or module.MODULE_STORAGE.queue[1]
							if (not nextCall) then return end
							local queueDir = nextCall.call > module.MODULE_STORAGE.statValues.rawFloor and 'U' or nextCall.call < module.MODULE_STORAGE.statValues.rawFloor and 'D' or 'N'
							if (queueDir ~= module.MODULE_STORAGE.statValues.queueDirection) then
								local hasCompleted = conditionalStepWait(1, function() return {module.MODULE_STORAGE.statValues.moveValue ~= 0} end)
								if (not hasCompleted) then return end
							end
							checkRun(nextCall)
						end
					end

					task.spawn(function()
						if ((not data.nudging) and nudge) then
							data.nudging = true
							module.MODULE_STORAGE.sounds.Nudge_Buzzer:Play()
						end
						for i,v in pairs(configFile.Color_Database.Lanterns) do
							if ((i == 'Interior' or i == 'Exterior') and (not configFile.Color_Database.Lanterns[i].Reset_After_Door_Close)) then
								resetLanterns(floor, {i})
							end
						end
						if (nudge) then
							if (configFile.Sound_Database.Voice_Config.Enabled and voiceConfig.Settings.Door_Announcements.Nudge_Announcement.Enabled) then
								playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Nudge_Announcement.Sequence, false)
							end
						else
							if (configFile.Sound_Database.Voice_Config.Enabled and voiceConfig.Settings.Door_Announcements.Close_Announcement.Enabled) then
								playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Close_Announcement.Sequence, false)
							end
						end
						if (configFile.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable and configFile.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable) then
							data:Close(floor, nudge, onClosed)
						else
							data:LegacyClose(floor, nudge, onClosed)
						end
					end)
					data.LanternsReset:Once(function()
						if (#module.MODULE_STORAGE.queue <= 0) then
							setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
						end
						if (configFile.Color_Database.Lanterns.Interior.Reset_After_Door_Close) then
							resetLanterns(module.MODULE_STORAGE.statValues.rawFloor, {'Interior'})
						end
						if (configFile.Color_Database.Lanterns.Exterior.Reset_After_Door_Close) then
							resetLanterns(module.MODULE_STORAGE.statValues.rawFloor, {'Exterior'})
						end
					end)
					task.spawn(function()
						local startingState = data.state
						--if (configFile.Sound_Database.Voice_Config.Options and configFile.Sound_Database.Voice_Config.Options.Door_Announcements.Close_Announcement.Enabled) then
						--	--playVoiceSequenceProtocolWithQueue(configFile.Sound_Database.Voice_Config.Options.Door_Announcements.Close_Announcement.Sequence, false)
						--end
						local isObstructed = data.isObstructed
						local sensorPart: Part = data.doorSensorPart
						local params = OverlapParams.new()
						params.FilterType = Enum.RaycastFilterType.Whitelist
						while (data.state == 'Closing') do
							params.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
							local parts = workspace:GetPartBoundsInBox(sensorPart.CFrame, sensorPart.Size, params)
							data.isObstructed = #parts > 0
							if (isObstructed ~= data.isObstructed and not (checkIndependentService() or module.MODULE_STORAGE.statValues.fireService or configFile.Doors.Manual_Door_Controls.Enable_Close) and ((data.nudging and configFile.Doors.Reopen_When_Nudge_Obstruction) or (not data.nudging))) then
								if (data.isObstructed) then task.spawn(runDoorOpen, floor, side, false) end
								sensorPart.Obstruction_Signal.Playing = data.isObstructed and configFile.Sound_Database.Others.Door_Obstruction_Signal.Enable
								api:Fire('doorObstructionStateChanged', {state=data.isObstructed,side=data.side})
							end
							isObstructed = data.isObstructed

							if (checkIndependentService() or module.MODULE_STORAGE.statValues.fireService or configFile.Doors.Manual_Door_Controls.Enable_Close) then
								data.nudgeTimerTick = os.clock()
							end

							if ((os.clock()-data.nudgeTimerTick)/configFile.Doors.Nudge_Timer >= 1) then
								if (not data.nudging) then
									data.nudging = true
									module.MODULE_STORAGE.sounds.Nudge_Buzzer:Play()
								end
							end
							HEARTBEAT:Wait()
						end
					end)
				end)
				if (not ran) then return debugWarn("Error occured whilst operating " .. (side) .. " doors :: " .. (res) .. "\n" .. (debug.traceback())) end
			end

			local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', side)
			if (((not data) and side ~= 'ALL') or (stopElevator)) then return debugWarn("Error occured whilst operating " .. (side) .. " doors :: No data found halting all functions & resetting states\n" .. (debug.traceback())) end
			if (side ~= 'ALL') then return task.spawn(runDoor, data) end
			for i,v in next,pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData') do
				task.spawn(runDoor, v)
			end
			task.spawn(updateCore)
		end

		local params = OverlapParams.new()
		params.FilterType = Enum.RaycastFilterType.Whitelist
		function doPlayerWeld()
			params.FilterDescendantsInstances = _G.ElevatorSensorHumanoids
			local partsInBounds = workspace:GetPartBoundsInBox(carRegion.CFrame, carRegion.Size, params)
			for i,v in pairs(partsInBounds) do
				local root: BasePart,human: Humanoid = findAncestor(v.Parent, 'HumanoidRootPart'),(v.Parent:FindFirstChildOfClass('Humanoid') or v.Parent.Parent:FindFirstChildOfClass('Humanoid'))
				if (root and human and (not root:FindFirstChild('Welded_By_Elevator')) and (not playerWeldData[human])) then

					if (configFile.Movement.Disable_Jumping and config.Movement.Movement_Type ~= 1) then
						human:SetAttribute('jumpPower', human.JumpPower)
						human:SetAttribute('jumpHeight', human.JumpHeight)
						human.JumpHeight = 0
						human.JumpPower = 0
					end

					if (configFile.Movement.Weld_On_Move and (not configFile.Movement.Use_New_Welding)) then
						local weld = Instance.new('Weld')
						weld.Name = root.Parent.Name
						weld.Part0 = root
						weld.C0 = CFrame.new()
						weld.C1 = platform.CFrame:ToObjectSpace(root.CFrame)
						weld.Part1 = platform
						weld.Parent = playerWeldsFolder
						human.PlatformStand = true
						playerWeldData[human] = {
							root=root,
							weld
						}
					elseif (configFile.Movement.Use_New_Welding) then
						if config.Movement.Movement_Type ~= 1 then
							human:SetAttribute('jumpPower', human.JumpPower)
							human:SetAttribute('jumpHeight', human.JumpHeight)
							human.JumpHeight = 0
							human.JumpPower = 0
						end

						local folder: Folder = Instance.new('Folder')
						folder.Name = root.Parent.Name
						folder.Parent = playerWeldsFolder

						--Part0--
						local part0 = folder:FindFirstChild('Part0') or Instance.new('Part')
						part0.Name = 'Part0'
						part0.Size = Vector3.new(1, 1, 1)*.5
						part0.Transparency = 1
						part0.CFrame = platform.CFrame*CFrame.new(0, (root.CFrame.Position.Y-(platform.CFrame.Position.Y)), 0)
						part0.CanCollide = false
						part0.BrickColor = BrickColor.new('Lime green')
						part0.Parent = folder
						weldTogether(part0, platform, true)
						--Part1--
						local part1 = folder:FindFirstChild('Part1') or Instance.new('Part')
						part1.Name = 'Part1'
						part1.Size = Vector3.new(1, 1, 1)*.5
						part1.Transparency = 1
						part1.CFrame = part0.CFrame
						part1.CanCollide = false
						part1.BrickColor = BrickColor.new('Really blue')
						part1.Parent = folder
						--Hinge part--
						local part2 = folder:FindFirstChild('Part2') or Instance.new('Part')
						part2.Name = 'Part2'
						part2.Size = Vector3.new(1, 1, 1)*.5
						part2.Transparency = 1
						part2.CFrame = root.CFrame
						part2.CFrame = CFrame.lookAt(part2.CFrame.Position, part0.CFrame.Position)
						part2.CanCollide = false
						part2.BrickColor = BrickColor.new('Really blue')
						part2.Parent = folder

						part1.CFrame = CFrame.lookAt(part1.CFrame.Position, part2.CFrame.Position)*CFrame.Angles(0, math.rad(180), 0)

						local att0,att1,att2,att3,att4,att5 =
							(part0:FindFirstChild('Attachment0') or Instance.new('Attachment', part0)),
						(part1:FindFirstChild('Attachment1') or Instance.new('Attachment', part1)),
						(part1:FindFirstChild('Attachment2') or Instance.new('Attachment', part1)),
						(part2:FindFirstChild('Attachment3') or Instance.new('Attachment', part2)),
						(root:FindFirstChild('Attachment4') or Instance.new('Attachment', root)),
						(platform:FindFirstChild('Attachment5') or Instance.new('Attachment', platform))
						att0.Name = 'Attachment0'
						att1.Name = 'Attachment1'
						att2.Name = 'Attachment2'
						att3.Name = 'Attachment3'

						att0.Orientation = Vector3.new(0, 0, 1)*90
						att1.Orientation = att1.Orientation
						att2.Orientation = Vector3.new(0, 1, 0)*90
						att3.Orientation = att2.Orientation

						local ballSocket: BallSocketConstraint = (part1:FindFirstChild('BallSocket') or Instance.new('BallSocketConstraint', part1))
						ballSocket.Attachment0,ballSocket.Attachment1 = att3,att4
						local hinge: HingeConstraint = (part0:FindFirstChild('Hinge') or Instance.new('HingeConstraint', part0))
						hinge.Name = 'Hinge'
						hinge.Attachment0,hinge.Attachment1 = att0,att1
						local prismatic0: PrismaticConstraint = (part1:FindFirstChild('Prismatic0') or Instance.new('PrismaticConstraint', part1))
						prismatic0.Name = 'Prismatic0'
						prismatic0.Attachment0,prismatic0.Attachment1 = att2,att3
						local alignPos: AlignPosition = (part1:FindFirstChild('AlignPos') or Instance.new('AlignPosition', part1))
						alignPos.Attachment0,alignPos.Attachment1 = att0,att1
						alignPos.Name = 'AlignPos'
						alignPos.MaxForce = 1e-5
						alignPos.Responsiveness = 200
						alignPos.MaxVelocity = 1e-5
						alignPos.Mode = Enum.PositionAlignmentMode.OneAttachment

						root:SetNetworkOwner(game.Players:GetPlayerFromCharacter(root.Parent))

						--local position: BodyPosition = (root:FindFirstChild('AlignPos') or Instance.new('BodyPosition', root))
						--position.Name = 'AlignPos'
						--position:SetAttribute('playerWeldHeight', (root.CFrame.Position.Y-platform.CFrame.Position.Y))
						--position.Position = platform.Position+Vector3.new(0, 1, 0)*position:GetAttribute('playerWeldHeight')
						--position.MaxForce = Vector3.new(0, 1, 0)*1e-5
						--position.D = 1

						playerWeldData[human] = {
							root=root,
							folder,
							att4,
							att5,
							position=position
						}

					end
					if (config.Movement.Weld_On_Move) then
						local val = Instance.new('ObjectValue')
						val.Name = 'Welded_By_Elevator'
						val.Value = elevator
						val.Parent = root
						human.Parent:SetAttribute('Is_On_Elevator', true)
						pcall(function()
							local charAnimate = human.Parent:FindFirstChild('Animate')
							if (charAnimate) then
								if (not idleAnimations[human]) then
									idleAnimations[human] = {}
								end
								local anims = {}
								local animSet = charAnimate:WaitForChild('idle')
								for i,v in pairs(animSet:GetChildren()) do
									if (v:IsA('Animation')) then
										local loadedAnim = human:LoadAnimation(v)
										if (not table.find(idleAnimations[human], loadedAnim)) then
											table.insert(idleAnimations[human], loadedAnim)
										end
									end
								end
								local anim = idleAnimations[human][math.random(1,#idleAnimations[human])]
								anim:Play()
							end
						end)
					end
				end
			end
		end
		function removePlayerWelds()
			for i,v in pairs(playerWeldData) do

				local human: Humanoid,root: BasePart = i,v.root
				if human and human.Parent then
					human.Parent:SetAttribute('Is_On_Elevator', nil)
				end
				if (configFile.Movement.Disable_Jumping and config.Movement.Movement_Type ~= 1) then
					human.JumpPower = human:GetAttribute('jumpPower')
					human.JumpHeight = human:GetAttribute('jumpHeight')
					human:SetAttribute('jumpPower', nil)
					human:SetAttribute('jumpHeight', nil)
				end
				if (root and root:FindFirstChild('Welded_By_Elevator')) then
					root.Welded_By_Elevator:Destroy()
				end
				if (idleAnimations[human]) then
					for i,v in pairs(idleAnimations[human]) do
						v:Stop()
					end
				end
				for _,n in pairs(v) do
					if (typeof(n) == 'Instance' and n ~= root) then
						n:Destroy()
					end
				end
				human.PlatformStand = false
				playerWeldData[i] = nil

			end
		end

		function doMotorSound()
			task.spawn(function()
				if module.MODULE_STORAGE.statValues.moveValue == 1 then
					module.MODULE_STORAGE.sounds.Motor_Start_Up:Play()
					module.MODULE_STORAGE.sounds.Motor_Run_Up:Stop()
					module.MODULE_STORAGE.sounds.Motor_Stop_Up:Stop()
					module.MODULE_STORAGE.sounds.Motor_Start_Down:Stop()
					module.MODULE_STORAGE.sounds.Motor_Run_Down:Stop()
					module.MODULE_STORAGE.sounds.Motor_Stop_Down:Stop()
					local function stop()
						module.MODULE_STORAGE.sounds.Motor_Start_Up:Stop()
						module.MODULE_STORAGE.sounds.Motor_Run_Up:Stop()
						module.MODULE_STORAGE.sounds.Motor_Stop_Up:Play()
						module.MODULE_STORAGE.sounds.Motor_Start_Down:Stop()
						module.MODULE_STORAGE.sounds.Motor_Run_Down:Stop()
						module.MODULE_STORAGE.sounds.Motor_Stop_Down:Stop()
					end
					local connect
					connect = levelingVal:GetPropertyChangedSignal('Value'):Connect(function()
						if (levelingVal.Value and not config.Movement.Motor_Stop_On_Open) then
							connect:Disconnect()
							stop()
						end
					end)
					local connect2
					connect2 = moveVal:GetPropertyChangedSignal('Value'):Connect(function()
						if (moveVal.Value == 0 and config.Movement.Motor_Stop_On_Open) then
							connect2:Disconnect()
							stop()
						end
					end)
					module.MODULE_STORAGE.sounds.Motor_Start_Up.Ended:Wait()
					if (module.MODULE_STORAGE.statValues.moveValue ~= 1 or module.MODULE_STORAGE.statValues.leveling) then connect:Disconnect() connect2:Disconnect() return end
					module.MODULE_STORAGE.sounds.Motor_Run_Up:Play()
				elseif module.MODULE_STORAGE.statValues.moveValue == -1 then
					module.MODULE_STORAGE.sounds.Motor_Start_Up:Stop()
					module.MODULE_STORAGE.sounds.Motor_Run_Up:Stop()
					module.MODULE_STORAGE.sounds.Motor_Stop_Up:Stop()
					module.MODULE_STORAGE.sounds.Motor_Start_Down:Play()
					module.MODULE_STORAGE.sounds.Motor_Run_Down:Stop()
					module.MODULE_STORAGE.sounds.Motor_Stop_Down:Stop()
					local function stop()
						module.MODULE_STORAGE.sounds.Motor_Start_Down:Stop()
						module.MODULE_STORAGE.sounds.Motor_Run_Down:Stop()
						module.MODULE_STORAGE.sounds.Motor_Stop_Down:Play()
						module.MODULE_STORAGE.sounds.Motor_Start_Up:Stop()
						module.MODULE_STORAGE.sounds.Motor_Run_Up:Stop()
						module.MODULE_STORAGE.sounds.Motor_Stop_Up:Stop()
					end
					local connect
					connect = levelingVal:GetPropertyChangedSignal('Value'):Connect(function()
						if (levelingVal.Value and not config.Movement.Motor_Stop_On_Open) then
							connect:Disconnect()
							stop()
						end
					end)
					local connect2
					connect2 = moveVal:GetPropertyChangedSignal('Value'):Connect(function()
						if (moveVal.Value == 0 and config.Movement.Motor_Stop_On_Open) then
							connect2:Disconnect()
							stop()
						end
					end)
					module.MODULE_STORAGE.sounds.Motor_Start_Down.Ended:Wait()
					if (module.MODULE_STORAGE.statValues.moveValue ~= -1 or module.MODULE_STORAGE.statValues.leveling) then connect:Disconnect() connect2:Disconnect() return end
					module.MODULE_STORAGE.sounds.Motor_Run_Down:Play()
				end
			end)
		end

		function relevel()
			local ran,msg = pcall(function()
				if (getFloorDistance(module.MODULE_STORAGE.statValues.rawFloor) < configFile.Movement.Relevel_Tolerance or module.MODULE_STORAGE.statValues.inspection or releveling or moveBrake or (not isDropKeyOnElevator()) or stopElevator) then return end
				print("Releveling on " .. (module.MODULE_STORAGE.statValues.rawFloor))
				outputElevMessage("Releveling on floor " .. (module.MODULE_STORAGE.statValues.rawFloor), 'debug')
				releveling = true
				isMoving = true
				local releveled = false
				local relevelingFloor = module.MODULE_STORAGE.statValues.rawFloor
				local landingLevel = findFloor(relevelingFloor):FindFirstChild('Level')
				module.MODULE_STORAGE.statValues.leveling = false
				local function checkPosition()
					if (level.Position.Y > landingLevel.Position.Y) then
						module.MODULE_STORAGE.statValues.moveValue = -1
						module.MODULE_STORAGE.statValues.arrowDirection = 'D'
						preDirection = 'D'
						module.MODULE_STORAGE.statValues.direction = 'D'
					elseif (level.Position.Y < landingLevel.Position.Y) then
						module.MODULE_STORAGE.statValues.moveValue = 1
						module.MODULE_STORAGE.statValues.arrowDirection = 'U'
						preDirection = 'U'
						module.MODULE_STORAGE.statValues.direction = 'U'
					end
				end

				local function getPastDirection()
					return level.Position.Y > landingLevel.Position.Y and -1 or level.Position.Y < landingLevel.Position.Y and 1 or 0
				end
				if (getFloorDistance(module.MODULE_STORAGE.statValues.rawFloor) > 1.5) then
					doPlayerWeld()
				end
				local lastSpeed = module.MODULE_STORAGE.statValues.currentSpeed
				--checkPosition()
				doMotorSound()
				updateCore()
				local lastDirection = module.MODULE_STORAGE.statValues.moveValue
				local lastPosition = platform.Position
				local relevelingSpeed = math.clamp(configFile.Movement.Releveling_Speed, .1, configFile.Movement.Travel_Speed/2)
				local stopping = false

				local previousDistanceChecked = false
				local reachedLevelingSpeed = false

				api:Fire('onRelevelStart', {direction=getPastDirection()})
				local thisLevelingStage = 1

				local pastDirection = getPastDirection()
				--module.MODULE_STORAGE.statValues.moveValue = pastDirection
				task.spawn(updateCore)

				while (not releveled) do

					if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
						if (not safetyBraking) then
							module.MODULE_STORAGE.statValues.currentSpeed = 0
							module.MODULE_STORAGE.statValues.moveValue = 0
							module.MODULE_STORAGE.statValues.moveDirection = 'N'
							lock = false
							setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
							preDooring = false
							releveling = false
							overshot = false
							module.MODULE_STORAGE.statValues.leveling = false
							preChimeFloor = nil
							safetyBraking = false
							removePlayerWelds()
							updateCore()
						end
						return
					end

					local lastPos = level.Position.Y
					local diff = math.abs(lastPos-level.Position.Y)
					local pastDirection = getPastDirection()
					local distanceFromFloor = getFloorDistance(relevelingFloor, true)
					local directionString = module.MODULE_STORAGE.statValues.moveValue == 1 and '' or module.MODULE_STORAGE.statValues.moveValue == -1 and 'Down_' or ''
					local directionString2 = module.MODULE_STORAGE.statValues.moveValue == 1 and 'Up' or module.MODULE_STORAGE.statValues.moveValue == -1 and 'Down' or 'Up'
					if (module.MODULE_STORAGE.statValues.currentSpeed <= 0) then
						module.MODULE_STORAGE.statValues.moveValue = pastDirection
					end

					local deltaTime = os.clock()-lastTick
					local elevMoveDirection = (platform.Position-lastPosition).Unit.Y
					elevMoveDirection = elevMoveDirection > 0 and 1 or elevMoveDirection < 0 and -1 or 0

					if (getPastDirection() == module.MODULE_STORAGE.statValues.moveValue and distanceFromFloor <= (math.abs(module.MODULE_STORAGE.statValues.currentSpeed)*(configFile.Sensors[string.format('%s_Level_Offset', directionString2)]*configFile.Movement.Level_Offset_Ratio))) then
						if (not previousDistanceChecked) then
							previousDistanceChecked = true
						end
					else
						--previousDistanceChecked = false
					end

					if (not reachedLevelingSpeed) then
						if (previousDistanceChecked) then
							if (not stopping) then
								stopping = true
								elevatorProcessRunStop(module.MODULE_STORAGE.statValues.rawFloor)
								releveled = distanceFromFloor <= .005
							end
						elseif (getPastDirection() ~= module.MODULE_STORAGE.statValues.moveValue or distanceFromFloor >= (math.abs(module.MODULE_STORAGE.statValues.currentSpeed)*((configFile.Sensors[string.format('%s_Level_Offset', directionString2)]*configFile.Movement.Level_Offset_Ratio)+.5*module.MODULE_STORAGE.statValues.moveValue))) then
							module.MODULE_STORAGE.statValues.currentSpeed += (getPastDirection() ~= module.MODULE_STORAGE.statValues.moveValue and 1.35 or 1)*module.MODULE_STORAGE.statValues.moveValue*getPastDirection()*configFile.Movement[string.format('%sAcceleration', directionString)]
						end
					end
					local THRESHOLD = .25
					if (getPastDirection()*module.MODULE_STORAGE.statValues.moveValue*(landingLevel.Position.Y-level.Position.Y) <= -THRESHOLD) then
						--releveling = false
						--return relevel()
					end
					--module.MODULE_STORAGE.statValues.currentSpeed = math.clamp(module.MODULE_STORAGE.statValues.currentSpeed, -relevelingSpeed, configFile.Movement.Travel_Speed)

					releveled = distanceFromFloor <= .005
					updateCore()

				end
				module.MODULE_STORAGE.statValues.currentSpeed = 0
				module.MODULE_STORAGE.statValues.moveDirection = 'N'
				module.MODULE_STORAGE.statValues.direction = 'N'
				module.MODULE_STORAGE.statValues.leveling = false
				preDooring = false
				releveling = false
				module.MODULE_STORAGE.statValues.currentFloor = relevelingFloor
				resetButtons()
				removePlayerWelds()
				if ((not module.MODULE_STORAGE.statValues.fireService) and checkDoorStates('Closed')) then
					runChime(relevelingFloor, configFile.Sound_Database.Chime_Events.On_Open, configFile.Sound_Database.Chime_Events.After_Open, true)
					doLanterns(relevelingFloor, configFile.Color_Database.Lanterns.Active_On_Door_Open, configFile.Color_Database.Lanterns.Active_After_Door_Open)
				end
				module.MODULE_STORAGE.statValues.moveValue = 0
				lock = false

				if (((not module.MODULE_STORAGE.statValues.fireService) and (not checkPhase2())) or (module.MODULE_STORAGE.statValues.fireService and fireRecallFloor == module.MODULE_STORAGE.statValues.rawFloor and (not checkPhase2()))) then
					runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, 'ALL')
				end
				if (configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Enable and (not checkPhase2()) and (not checkIndependentService())) then
					task.delay(configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Delay, function()
						addPlaySound(module.MODULE_STORAGE.sounds.Floor_Pass_Chime, platform)
					end)
				end

				task.spawn(updateCore)
				task.spawn(parkTimer)
				return
			end)
			if (not ran) then
				print("Elevator relevel failed due to an error, resetting", msg)
				return restartElevator()
			end
		end

		function safeCheckRelevel()
			if (releveling or module.MODULE_STORAGE.statValues.inspection or overshot or preDooring or stopElevator or module.MODULE_STORAGE.statValues.moveValue ~= 0) then return end
			if (getFloorDistance(module.MODULE_STORAGE.statValues.rawFloor) > .35) then
				relevel()
			else -- Audit made so the elevator doesn't 'stall'
				for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
					if (v.state == 'Closed' or v.state == 'Closing' or v.state == 'Stopped') then
						task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,v.side)
					end
				end
			end
		end

		function removePlayingSounds(obj)
			for i,v in pairs(obj:GetDescendants()) do
				if (v:IsA('Sound') and v.IsPlaying) then
					v:Destroy()
				end
			end
		end

		local chimeAfterOpenC = {}
		function runChime(flr, dataType, afterOpen, direction: any?, overrideDebounce: boolean?)
			local floor = findFloor(flr)
			if (not floor) then return end
			local regFloor = findRegisteredFloor(flr)
			if (not regFloor) then return end

			local function addChimeAudio(index, type, direction, debounceOverride: boolean?)

				local directionNum = string.sub(direction,1,1) == 'U' and 1 or string.sub(direction,1,1) == 'D' and -1 or 0
				index = (string.upper(string.sub(index,1,1))) .. (string.lower(string.sub(index,2)))
				local callOnlyMet = (type.Call_Only and (table.find(regFloor.exteriorCallDirections,directionNum) or checkCallInDirection(flr))) or (not type.Call_Only)
				if (callOnlyMet) then
					task.delay(type.Delay or 0, function()
						local lanternParts = {}
						for i,v in pairs((index == 'Exterior' and floor or index == 'Interior' and car):GetDescendants()) do
							if (v.Name == 'Lanterns') then
								for i,g in pairs(v:GetChildren()) do
									if (g.Name == direction or g.Name == 'Both') then
										for i,p in pairs(g:GetDescendants()) do
											if (p:IsA('BasePart') and p.Name == 'Light') then
												if (lanternParts[g]) then continue end
												lanternParts[g] = p
											end
										end
									end
								end
							end
						end
						if (getTableLength(lanternParts) == 0 and index == 'Interior') then
							lanternParts[1] = platform
						end
						if (not getTableLength(lanternParts)) then return end
						for _,lanternPart in pairs(lanternParts) do
							task.spawn(function()
								if (lanternPart:GetAttribute('hasSignaled') and (not debounceOverride)) then return end
								lanternPart:SetAttribute('hasSignaled', true)
								local name = (index) .. "_" .. (direction) .. "_Chime"
								local function checkLanternInstance()
									return lanternPart:FindFirstChild((name) .. "_Playing")
								end
								local chime = module.MODULE_STORAGE.sounds[name]
								if (not chime) then return end
								local function checkRecursive()
									if (not checkLanternInstance()) then
										return true
									else
										lanternPart.ChildRemoved:Wait()
										return checkRecursive()
									end
								end
								checkRecursive()
								addPlaySound(chime, lanternPart)
							end)
						end
					end)
				end
			end
			local lanternDirection = module.MODULE_STORAGE.statValues.queueDirection
			lanternDirection = lanternDirection == 'U' and 'Up' or lanternDirection == 'D' and 'Down' or nil
			if (not lanternDirection) then return end
			for index,type in pairs(typeof(dataType) == 'table' and dataType or {}) do
				if (type.Enable) then
					addChimeAudio(index, type, lanternDirection, overrideDebounce)
				end
				if (afterOpen[index] and afterOpen[index].Enable) then
					for i,v in next,pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData') do
						if (chimeAfterOpenC[v.side]) then continue end
						local connect
						connect = v.valueInstances.doorStateValue:GetPropertyChangedSignal('Value'):Connect(function()
							if (v.valueInstances.doorStateValue.Value == 'Open' or v.valueInstances.doorStateValue.Value == 'Closed') then
								for i,c in pairs(chimeAfterOpenC) do
									c:Disconnect()
									chimeAfterOpenC[i] = nil
								end
								if (v.valueInstances.doorStateValue.Value == 'Open') then
									addChimeAudio(index, afterOpen[index], lanternDirection, true)
								end
							end
						end)
						chimeAfterOpenC[v.side] = connect
					end
				end
			end
		end

		local lanternAfterOpenC = {}
		function doLanterns(floor, dataType, afterOpen, direction)
			task.spawn(function()
				local landing = findFloor(floor)
				if (not landing) then return end
				local regFloor = findRegisteredFloor(floor)
				if (not regFloor) then return end
				local lanternDirection = module.MODULE_STORAGE.statValues.queueDirection
				local ogDir = lanternDirection
				lanternDirection = lanternDirection == 'U' and 'Up' or lanternDirection == 'D' and 'Down' or nil
				if (not lanternDirection) then return end
				local directionNum = string.sub(lanternDirection,1,1) == 'U' and 1 or string.sub(lanternDirection,1,1) == 'D' and -1 or 0
				local function handle(index, _type)
					index = (string.upper(string.sub(index,1,1))) .. (string.lower(string.sub(index,2)))
					local callOnlyMet = (_type.Call_Only and (table.find(regFloor.exteriorCallDirections,directionNum) or checkCallInDirection(floor))) or (not _type.Call_Only)
					api:Fire('onElevatorLanternApi', {
						state='active',
						floor = floor,
						direction = ogDir,
						type = string.lower(index),
						eventData = _type,
						conditionMet = callOnlyMet
					})
					for i,v in pairs((index == 'Interior' and car or index == 'Exterior' and landing):GetChildren()) do
						if (v.Name == 'Lanterns') then
							for i,m in pairs(v:GetChildren()) do
								if (m.Name == lanternDirection or m.Name == 'Both') then
									if (m:GetAttribute('hasActivated')) then continue end
									m:SetAttribute('hasActivated', true)
									local function activate(state)
										for i,l in pairs(m:GetDescendants()) do
											if (l:IsA('BasePart') and l.Name == 'Light') then
												local config = configFile.Color_Database.Lanterns[index][lanternDirection][string.format('%s_State', state)]
												l.Color,l.Material = config.Color,config.Material
												for i,l2 in pairs(l:GetDescendants()) do
													if (l2.ClassName:match('Light')) then
														l2.Enabled = state == 'Lit'
													end
												end
											end
										end
									end
									if (callOnlyMet) then
										local config = configFile.Color_Database.Lanterns[index]
										if (config.Repeat_Data.Enable) then
											activate('Neautral')
										end
										task.delay(_type.Delay, function()
											activate('Lit')
											if (config.Repeat_Data.Enable and (config.Repeat_Data.Allowed_Directions and table.find(config.Repeat_Data.Allowed_Directions, string.sub(lanternDirection, 1, 1)))) then
												task.spawn(function()
													task.wait(config.Repeat_Data.Delay)
													for i=1,config.Repeat_Data.Times do
														activate('Neautral')
														task.wait(config.Repeat_Data.Delay)
														activate('Lit')
														if (config.Repeat_Data.Play_Chime_On_Light) then
															runChime(floor, {['Exterior']={['Type']='Arrival',['Enable']=true},['Interior']={['Type']='Normal',['Enable']=true}}, {['Exterior']={['Type']='Arrival',['Enable']=false},['Interior']={['Type']='Normal',['Enable']=false}}, overrideDebounce)
														end
													end
												end)
											end
										end)
									end
								end
							end
						end
					end
				end
				for index,_type in pairs(typeof(dataType) == 'table' and dataType or {}) do
					if (_type.Enable and (not afterOpen[index].Enable)) then
						handle(index, _type)
					elseif (afterOpen[index] and afterOpen[index].Enable) then
						for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
							if (lanternAfterOpenC[v.side]) then continue end
							if (v.valueInstances.doorStateValue.Value ~= 'Open') then
								local connect
								connect = v.valueInstances.doorStateValue:GetPropertyChangedSignal('Value'):Connect(function()
									if (v.valueInstances.doorStateValue.Value == 'Open' or v.valueInstances.doorStateValue.Value == 'Closed') then
										for i,c in pairs(lanternAfterOpenC) do
											c:Disconnect()
											lanternAfterOpenC[i] = nil
										end
										if (v.valueInstances.doorStateValue.Value == 'Open') then
											handle(index, afterOpen[index])
										end
									end
								end)
								lanternAfterOpenC[v.side] = connect
							elseif (v.valueInstances.doorStateValue.Value == 'Open') then
								for i,c in pairs(lanternAfterOpenC) do
									if (not c.Connected) then continue end
									c:Disconnect()
								end
								handle(index, afterOpen[index])
							end
						end
					end
				end
			end)

		end
		function resetLanterns(floor, type)
			local flr = findFloor(floor)
			if (not flr) then return end
			for index,value in pairs(typeof(type) == 'table' and type or {'Interior','Exterior'}) do
				chimingAfterOpen[value] = false
				api:Fire('onElevatorLanternApi', {state = 'neutral', floor = floor, direction = module.MODULE_STORAGE.statValues.queueDirection, type = string.lower(value)})
				for i,v in pairs((value == 'Interior' and car or value == 'Exterior' and flr):GetChildren()) do
					if (v.Name == 'Lanterns') then
						for i,m in pairs(v:GetChildren()) do
							local direction = m.Name == 'Up' and 'U' or m.Name == 'Down' and 'D' or nil
							if (string.sub(m.Name, 1, 1) == direction or m.Name == 'Both') then
								for i,l in pairs(m:GetDescendants()) do
									if (l:GetAttribute('hasSignaled')) then
										l:SetAttribute('hasSignaled', nil)
									end
									if (l:IsA('BasePart') and l.Name == 'Light') then
										local config = configFile.Color_Database.Lanterns[value][m.Name ~= 'Both' and m.Name or 'Up'].Neautral_State
										l.Color,l.Material = config.Color,config.Material
										for i,l2 in pairs(l:GetDescendants()) do
											if (l2.ClassName:match('Light')) then
												l2.Enabled = false
											end
										end
									end
								end
								m:SetAttribute('hasActivated', nil)
								removePlayingSounds(m)
							end
						end
					end
				end
			end
		end

		function elevatorProcessRunStop(floor: number, relevelBypass: boolean?)

			local dest = module.MODULE_STORAGE.statValues.destination or floor
			local directionValue = dest > module.MODULE_STORAGE.statValues.rawFloor and 1 or dest < module.MODULE_STORAGE.statValues.rawFloor and -1 or 0
			local landingLevel = findFloor(floor):FindFirstChild('Level')
			local speed,dist = module.MODULE_STORAGE.statValues.currentSpeed,getFloorDistance(floor)
			local linearModeOffset = configFile.Movement.Braking_Data[module.MODULE_STORAGE.statValues.moveValue == 1 and 'Linear_Mode_Offset_Up' or module.MODULE_STORAGE.statValues.moveValue == -1 and 'Linear_Mode_Offset_Down' or '']*module.MODULE_STORAGE.statValues.moveValue
			local levelingStage = 0
			if (configFile.Movement.Braking_Data.Mode == 'Linear') then
				dist = math.abs((landingLevel.Position.Y+linearModeOffset)-level.Position.Y)
			end
			module.MODULE_STORAGE.statValues.leveling = true
			module.MODULE_STORAGE.miscValues.leaving = false
			module.MODULE_STORAGE.statValues.arriveFloor = floor

			local destVal = module.MODULE_STORAGE.statValues.destination
			local lastDirectionNum = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 1 or module.MODULE_STORAGE.statValues.queueDirection == 'D' and -1 or 0
			local nextQueue = checkCallInDirection(floor,lastDirectionNum) --// Check for calls in current direction
			if (not nextQueue) then nextQueue = checkCallInDirection(floor,-lastDirectionNum) end --// Check for calls in opposite direction
			if (not nextQueue) then nextQueue = select(2, findCallInQueue(floor)) end --// Check for calls on current floor if no other calls can be found
			local regFloor = findRegisteredFloor(module.MODULE_STORAGE.statValues.arriveFloor)
			local thisQueue = select(2, findCallInQueue(floor))
			module.MODULE_STORAGE.statValues.queueDirection = (nextQueue and ((nextQueue.call > floor and 'U' or nextQueue.call < floor and 'D') or nextQueue.call == topFloor and 'D' or nextQueue.call == bottomFloor and 'U')) or (thisQueue and (thisQueue.directions[1] and (thisQueue.directions[1] == 1 and 'U' or thisQueue.directions[1] == -1 and 'D'))) or (floor == topFloor and 'D' or floor == bottomFloor and 'U') or 'N'
			module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
			module.MODULE_STORAGE.statValues.destination = destVal
			task.spawn(updateCore)
			api:Fire('onElevatorArrive', {floor=floor,direction=module.MODULE_STORAGE.statValues.queueDirection,parking=module.MODULE_STORAGE.statValues.parking})
			api:Fire('onCallRespond', {floor=floor,direction=module.MODULE_STORAGE.statValues.queueDirection,parking=module.MODULE_STORAGE.statValues.parking})

			if (voiceConfig.Settings.Floor_Announcements.Announce_Floor_On_Arrival and (not module.MODULE_STORAGE.statValues.parking) and (not module.MODULE_STORAGE.statValues.fireService) and (not checkIndependentService())) then
				task.spawn(function()

					playVoiceSequenceProtocolWithQueue(voiceConfig.Floor_Announcements[tostring(floor)] or {}, true)
					if (voiceConfig.Settings.Directional_Announcements.Announce_After_Floor_Announcement and module.MODULE_STORAGE.statValues.queueDirection ~= 'N') then
						local dir = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 'Up' or module.MODULE_STORAGE.statValues.queueDirection == 'D' and 'Down'
						local clip = voiceConfig.Settings.Directional_Announcements[(dir) .. "_Announcement"]
						if (clip.Enabled) then
							playVoiceSequenceProtocolWithQueue(clip.Sequence, false)
						end
					end

				end)
			end

			if ((not module.MODULE_STORAGE.statValues.fireService) and (not checkIndependentService())) then
				task.spawn(runChime, module.MODULE_STORAGE.statValues.arriveFloor, configFile.Sound_Database.Chime_Events.On_Arrival, configFile.Sound_Database.Chime_Events.After_Open, true)
				task.spawn(doLanterns, module.MODULE_STORAGE.statValues.arriveFloor, configFile.Color_Database.Lanterns.Active_On_Arrival, configFile.Color_Database.Lanterns.Active_After_Door_Open, true)
			end
			task.spawn(removeCall, module.MODULE_STORAGE.statValues.arriveFloor,module.MODULE_STORAGE.statValues.queueDirection == 'U' and 1 or module.MODULE_STORAGE.statValues.queueDirection == 'D' and -1 or 0)

			local diff = 0
			local decelSpeedPoint = configFile.Movement.Braking_Data.Smart_Linear_Transition_Dist*(speed/(configFile.Movement.Travel_Speed/3))
			local lastStage,thisLevelingStage = nil,1
			local startTick = os.clock()
			local reachedLevelingSpeed = false
			local deltaTime,elevMoveDirection = 0,0
			local STOP_OFFSET = configFile.Sensors.Stop_Offset
			local stopTargetPosition = landingLevel.Position.Y
			local targetPosition = stopTargetPosition+(linearModeOffset+STOP_OFFSET)
			local STOP_THRESHOLD = 0
			local UNDER_THRESHOLD = false
			local SMOOTH_STOP_THRESHOLD = configFile.Movement.Smooth_Stop_Threshold

			-- NEW LINEAR LEVELING CONCEPT -- IMPLEMENTED BY aaxtatious 05/03/23
			local INITIAL_SPEED = module.MODULE_STORAGE.statValues.currentSpeed
			local MIN_SPEED = configFile.Movement.Level_Speed
			local DISTANCE_TO_DECELERATE = math.abs(targetPosition-level.Position.Y)
			local lastPosition = platform.Position
			local lastTick = os.clock()

			local function getElevatorDistance(target: any, offsetFromTarget: number?)
				return math.abs((target+(typeof(offsetFromTarget) == 'number' and offsetFromTarget or 0))-level.Position.Y)
			end
			----

			while isMoving do

				local deltaTime = updateCore()
				local currentMoveValue = module.MODULE_STORAGE.statValues.moveValue
				local elevMoveDirection = (platform.Position-lastPosition).Unit.Y
				elevMoveDirection = elevMoveDirection > 0 and 1 or elevMoveDirection < 0 and -1 or 0
				if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
					if (not safetyBraking) then
						module.MODULE_STORAGE.statValues.currentSpeed = 0
						module.MODULE_STORAGE.statValues.moveValue = 0
						module.MODULE_STORAGE.statValues.moveDirection = 'N'
						lock = false
						setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
						preDooring = false
						releveling = false
						overshot = false
						module.MODULE_STORAGE.statValues.leveling = false
						preChimeFloor = nil
						safetyBraking = false
						removePlayerWelds()
						updateCore()
					end
					return
				end
				local lastStage
				local landingLevel = findFloor(module.MODULE_STORAGE.statValues.arriveFloor):FindFirstChild('Level')

				if (not UNDER_THRESHOLD) then
					UNDER_THRESHOLD = getElevatorDistance(targetPosition) <= SMOOTH_STOP_THRESHOLD
				end
				local distanceToFloor = currentMoveValue*(targetPosition-level.Position.Y)
				local stage1LvlDist = currentMoveValue*((targetPosition-(currentMoveValue*SMOOTH_STOP_THRESHOLD))-level.Position.Y)
				local absoluteDistanceToFloor = getElevatorDistance(stopTargetPosition)
				local displacement = module.MODULE_STORAGE.statValues.currentSpeed*deltaTime

				if (configFile.Movement.Braking_Data.Mode == 'Default') then
					module.MODULE_STORAGE.statValues.currentSpeed = math.max(MIN_SPEED, (speed/dist)*getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor))
				elseif (configFile.Movement.Braking_Data.Mode == 'Linear') then
					local currentSpeed = module.MODULE_STORAGE.statValues.currentSpeed
					local gradualDecelRatio = math.min(1, math.max(.1, ((distanceToFloor/(DISTANCE_TO_DECELERATE*configFile.Movement.Smooth_Stop_V2.Threshold)))/(currentSpeed/INITIAL_SPEED)))
					local deceleration = currentSpeed^2/(2*math.max(if (configFile.Movement.Enable_Smooth_Stop) then if (not UNDER_THRESHOLD) then stage1LvlDist else absoluteDistanceToFloor else distanceToFloor*(configFile.Movement.Smooth_Stop_V2.Enable and gradualDecelRatio or 1), .001))
					local SPEED = math.max(0, currentSpeed-deceleration*deltaTime)
					module.MODULE_STORAGE.statValues.currentSpeed = math.max(SPEED, ((not UNDER_THRESHOLD) and configFile.Movement.Enable_Smooth_Stop) and MIN_SPEED+((1.25*SMOOTH_STOP_THRESHOLD)) or if (configFile.Movement.Enable_Smooth_Stop) then .015 else MIN_SPEED)
				elseif (configFile.Movement.Braking_Data.Mode == 'Manual') then
					module.MODULE_STORAGE.statValues.currentSpeed = math.max(MIN_SPEED, module.MODULE_STORAGE.statValues.currentSpeed-configFile.Movement.Braking_Data.Increment*math.deg(deltaTime))
				elseif (configFile.Movement.Braking_Data.Mode == 'Advanced') then
					if (module.MODULE_STORAGE.statValues.currentSpeed > configFile.Movement.Braking_Data.Advanced_Leveling.Stage_1_Min_Speed and levelingStage ~= 2) then
						levelingStage = 1
						local currentSpeed = module.MODULE_STORAGE.statValues.currentSpeed
						local deceleration = currentSpeed^2/(2*math.max(if (configFile.Movement.Enable_Smooth_Stop) then if (not UNDER_THRESHOLD) then stage1LvlDist else absoluteDistanceToFloor else distanceToFloor, .001))
						local SPEED = math.max(0, currentSpeed-deceleration*deltaTime)
						module.MODULE_STORAGE.statValues.currentSpeed = math.max(SPEED, ((not UNDER_THRESHOLD) and configFile.Movement.Enable_Smooth_Stop) and MIN_SPEED+(1.25*SMOOTH_STOP_THRESHOLD)*math.min(absoluteDistanceToFloor/SMOOTH_STOP_THRESHOLD, 1) or .015)
					elseif (levelingStage == 1 and getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor) <= configFile.Movement.Braking_Data.Advanced_Leveling.Stage_2_Decel_Offset) then
						levelingStage = 2
						api:Fire('levelingStageChange', {brakingMode=configFile.Movement.Braking_Data.Mode,stage=levelingStage})
						speed,dist = module.MODULE_STORAGE.statValues.currentSpeed,getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor)
					elseif (levelingStage == 2) then
						local currentSpeed = module.MODULE_STORAGE.statValues.currentSpeed
						local deceleration = currentSpeed^2/(2*math.max(if (configFile.Movement.Enable_Smooth_Stop) then if (not UNDER_THRESHOLD) then stage1LvlDist else absoluteDistanceToFloor else distanceToFloor, .001))
						local SPEED = math.max(0, currentSpeed-deceleration*deltaTime)
						module.MODULE_STORAGE.statValues.currentSpeed = math.max(SPEED, ((not UNDER_THRESHOLD) and configFile.Movement.Enable_Smooth_Stop) and MIN_SPEED+(1.25*SMOOTH_STOP_THRESHOLD)*math.min(absoluteDistanceToFloor/SMOOTH_STOP_THRESHOLD, 1) or .015)
					end
				elseif (configFile.Movement.Braking_Data.Mode == 'SmartLinear') then
					if (getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor) > decelSpeedPoint and levelingStage ~= 2) then
						levelingStage = 1
						local currentSpeed = module.MODULE_STORAGE.statValues.currentSpeed
						local deceleration = currentSpeed^2/(2*math.max(if (configFile.Movement.Enable_Smooth_Stop) then if (not UNDER_THRESHOLD) then stage1LvlDist else absoluteDistanceToFloor else distanceToFloor, .001))
						local SPEED = math.max(0, currentSpeed-deceleration*deltaTime)
						module.MODULE_STORAGE.statValues.currentSpeed = math.max(SPEED, ((not UNDER_THRESHOLD) and configFile.Movement.Enable_Smooth_Stop) and MIN_SPEED+(1.25*SMOOTH_STOP_THRESHOLD)*math.min(absoluteDistanceToFloor/SMOOTH_STOP_THRESHOLD, 1) or .015)
					elseif (levelingStage == 1) then
						levelingStage = 2
						speed,dist = module.MODULE_STORAGE.statValues.currentSpeed,getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor)
						api:Fire('levelingStageChange', {brakingMode=configFile.Movement.Braking_Data.Mode,stage=levelingStage})
					elseif (levelingStage == 2) then
						module.MODULE_STORAGE.statValues.currentSpeed = math.clamp((speed/dist)*getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor), MIN_SPEED, if (speed) < MIN_SPEED then speed+MIN_SPEED else speed)
					end
				elseif (configFile.Movement.Braking_Data.Mode == 'Custom') then
					local currentLevelingStage,nextLevelingStage = configFile.Movement.Braking_Data.Custom_Leveling_Stages[thisLevelingStage],configFile.Movement.Braking_Data.Custom_Leveling_Stages[thisLevelingStage+1]
					if (currentLevelingStage) then
						if (nextLevelingStage and nextLevelingStage.Transition_Distance >= getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor)) then
							thisLevelingStage += 1
							speed = module.MODULE_STORAGE.statValues.currentSpeed
							dist = (math.abs((landingLevel.Position.Y+(module.MODULE_STORAGE.statValues.moveValue*currentLevelingStage.Offset))-level.Position.Y))
						end
						if (currentLevelingStage.Rate == 'Constant') then
							local currentSpeed = module.MODULE_STORAGE.statValues.currentSpeed
							local deceleration = currentSpeed^2/(2*math.max(if (configFile.Movement.Enable_Smooth_Stop) then if (not UNDER_THRESHOLD) then stage1LvlDist else absoluteDistanceToFloor else distanceToFloor, .001))
							print(deceleration)
							local SPEED = math.max(0, currentSpeed-deceleration*deltaTime)
							module.MODULE_STORAGE.statValues.currentSpeed = math.max(SPEED, ((not UNDER_THRESHOLD) and configFile.Movement.Enable_Smooth_Stop) and MIN_SPEED+(1.25*SMOOTH_STOP_THRESHOLD)*math.min(absoluteDistanceToFloor/SMOOTH_STOP_THRESHOLD, 1) or .015)
						else
							module.MODULE_STORAGE.statValues.currentSpeed = math.clamp((speed/dist)*getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor), MIN_SPEED, if (speed) < MIN_SPEED then speed+MIN_SPEED else speed)
						end
					end
				end
				if (module.MODULE_STORAGE.statValues.currentSpeed <= configFile.Movement.Level_Speed and (not reachedLevelingSpeed)) then
					reachedLevelingSpeed = true
					task.spawn(removePlayerWelds)
				end
				local moveValue = module.MODULE_STORAGE.statValues.moveValue
				local THRESHOLD = .25
				if (moveValue*(stopTargetPosition-level.Position.Y) <= -THRESHOLD) then
					outputElevMessage("Elevator has over/undershot during travel on floor " .. (floor) .. ", attempting to re-level")
					releveling = false
					relevel()
					return
				end
				if (configFile.Sensors.Pre_Door_Data.Enable and ((not module.MODULE_STORAGE.statValues.parking) or (#module.MODULE_STORAGE.queue > 0 and floor ~= configFile.Movement.Parking_Config.Park_Floor)) and (configFile.Movement.Open_Doors_On_Stop) and (not checkIndependentService()) and module.MODULE_STORAGE.statValues.currentSpeed <= configFile.Movement.Level_Speed+1.5 and ((not preDooring)) and (not releveling) and ((not module.MODULE_STORAGE.statValues.fireService) and (not checkPhase2())) or (module.MODULE_STORAGE.statValues.fireService and fireRecallFloor == module.MODULE_STORAGE.statValues.rawFloor and (not checkPhase2()))) and getFloorDistance(module.MODULE_STORAGE.statValues.arriveFloor) <= configFile.Sensors.Pre_Door_Data.Offset then
					preDooring = true
					lock = false
					if (module.MODULE_STORAGE.statValues.parking) then
						setDirection(module.MODULE_STORAGE.statValues.arriveFloor, 'N')
					end
					if ((not module.MODULE_STORAGE.statValues.fireService) and (not checkIndependentService())) then
						runChime(dest or module.MODULE_STORAGE.statValues.rawFloor, configFile.Sound_Database.Chime_Events.On_Open, configFile.Sound_Database.Chime_Events.After_Open, true)
						doLanterns(dest or module.MODULE_STORAGE.statValues.rawFloor, configFile.Color_Database.Lanterns.Active_On_Door_Open, configFile.Color_Database.Lanterns.Active_After_Door_Open)
					end
					if (configFile.Sound_Database.Others.Elevator_Stop_Beep.Enable) then
						module.MODULE_STORAGE.sounds.Elevator_Stop_Beep:Play()
					end
					if (configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Enable and (not checkIndependentService()) and (not module.MODULE_STORAGE.statValues.parking) and (not module.MODULE_STORAGE.statValues.fireService)) then
						task.delay(configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Delay, function()
							addPlaySound(module.MODULE_STORAGE.sounds.Floor_Pass_Chime, platform)
						end)
					end
					module.MODULE_STORAGE.statValues.currentFloor = module.MODULE_STORAGE.statValues.arriveFloor
					runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, 'ALL')
				end
				if (moveValue*(stopTargetPosition-level.Position.Y) <= STOP_THRESHOLD+(moveValue*displacement) and reachedLevelingSpeed) then break end
				lastPosition = platform.Position
			end
			removePlayerWelds()
			local isEnabled = bounceStop(false)
			if (not isEnabled) then
				module.MODULE_STORAGE.statValues.currentSpeed = 0
				module.MODULE_STORAGE.statValues.moveValue = 0
				module.MODULE_STORAGE.statValues.moveDirection = 'N'
				module.MODULE_STORAGE.statValues.direction = 'N'
				module.MODULE_STORAGE.statValues.leveling = false
				preDooring = false
			end
			api:Fire('onCallRespond', {floor=floor,direction=module.MODULE_STORAGE.statValues.queueDirection,parking=module.MODULE_STORAGE.statValues.parking})
			api:Fire('onElevatorStop', {floor=module.MODULE_STORAGE.statValues.arriveFloor})
			if (not configFile.Sensors.Pre_Door_Data.Enable) then
				conditionalStepWait(configFile.Movement.Stop_Delay, function() return {} end)
				--if (module.MODULE_STORAGE.statValues.moveValue ~= 0) then return end
			end

			if (module.MODULE_STORAGE.statValues.parking) then
				setDirection(module.MODULE_STORAGE.statValues.arriveFloor, 'N')
			end
			lock = false
			if (checkDoorStates('Closed') and (not module.MODULE_STORAGE.statValues.fireService) and (not checkPhase2()) and ((not module.MODULE_STORAGE.statValues.parking) or (#module.MODULE_STORAGE.queue > 0 and floor ~= configFile.Movement.Parking_Config.Park_Floor)) and (not checkIndependentService())) then
				if (configFile.Sound_Database.Others.Elevator_Stop_Beep.Enable) then
					module.MODULE_STORAGE.sounds.Elevator_Stop_Beep:Play()
				end
				if (configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Enable and (not checkIndependentService()) and (not module.MODULE_STORAGE.statValues.parking) and (not module.MODULE_STORAGE.statValues.fireService)) then
					task.delay(configFile.Movement.Floor_Pass_Chime_On_Stop_Config.Delay, function()
						addPlaySound(module.MODULE_STORAGE.sounds.Floor_Pass_Chime, carRegion)
					end)
				end
				runChime(dest or module.MODULE_STORAGE.statValues.rawFloor, configFile.Sound_Database.Chime_Events.On_Open, configFile.Sound_Database.Chime_Events.After_Open, true)
				doLanterns(dest or module.MODULE_STORAGE.statValues.rawFloor, configFile.Color_Database.Lanterns.Active_On_Door_Open, configFile.Color_Database.Lanterns.Active_After_Door_Open)
			end

			--if (configFile.Sound_Database.Voice_Config.Options.Floor_Announcements.Announce_Floor_On_Stop and ((not module.MODULE_STORAGE.statValues.parking) or (#module.MODULE_STORAGE.queue > 0 and floor ~= configFile.Movement.Parking_Config.Park_Floor)) and (not module.MODULE_STORAGE.statValues.fireService) and (not checkIndependentService())) then
			--	task.spawn(function()

			--		playVoiceSequenceProtocolWithQueue(voiceConfig.Voice_Config[tostring(floor)] or {}, true)
			--		if (configFile.Sound_Database.Voice_Config.Options.Directional_Announcements.Announce_After_Floor_Announcement and module.MODULE_STORAGE.statValues.queueDirection ~= 'N') then
			--			local dir = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 'Up' or module.MODULE_STORAGE.statValues.queueDirection == 'D' and 'Down'
			--			local clip = configFile.Sound_Database.Voice_Config.Options.Directional_Announcements[dir..'_Announcement']
			--			if (clip.Enabled) then
			--				playVoiceSequenceProtocolWithQueue(clip.Sequence, false)
			--			end
			--		end

			--	end)
			--end

			module.MODULE_STORAGE.statValues.currentFloor = module.MODULE_STORAGE.statValues.arriveFloor
			isMoving = false
			releveling = false
			task.spawn(updateCore)
			if ((((not module.MODULE_STORAGE.statValues.fireService) and (configFile.Movement.Open_Doors_On_Stop) and (not checkPhase2()) or checkIndependentService()) or (module.MODULE_STORAGE.statValues.fireService and fireRecallFloor == module.MODULE_STORAGE.statValues.rawFloor and (not checkPhase2()))) and ((not module.MODULE_STORAGE.statValues.parking) or (#module.MODULE_STORAGE.queue > 0 and floor ~= configFile.Movement.Parking_Config.Park_Floor))) then
				task.spawn(runDoorOpen, module.MODULE_STORAGE.statValues.rawFloor, 'ALL')
			end
			task.spawn(parkTimer)
			task.spawn(updateCore)
			module.MODULE_STORAGE.statValues.parking = false
			task.spawn(function()
				local hasPassed = conditionalStepWait(2, function() return {module.MODULE_STORAGE.statValues.moveValue ~= 0 or (not checkDoorStates('Closed'))} end)
				if (not hasPassed) then return end
				local directionNum = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 1 or module.MODULE_STORAGE.statValues.queueDirection == 'D' and -1 or 0
				local nextCall = checkCallInDirection(module.MODULE_STORAGE.statValues.rawFloor,directionNum) or module.MODULE_STORAGE.queue[1]
				local regFloor = findRegisteredFloor(module.MODULE_STORAGE.statValues.rawFloor)
				local function checkRun(call: any)
					if (not call) then return end
					local dir = call.directions[1]
					local regFloor = findRegisteredFloor(call.call)
					local index = table.find(regFloor.exteriorCallDirections,dir)
					if (index) then
						task.spawn(function()
							module.MODULE_STORAGE.statValues.queueDirection = dir == 1 and 'U' or dir == -1 and 'D' or 'N'
							module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
							api:Fire('onCallRespond', {floor=floor,direction=module.MODULE_STORAGE.statValues.queueDirection})
							task.spawn(updateCore)
							task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,'ALL')
							doLanterns(module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Exterior_Call,configFile.Color_Database.Lanterns.Active_After_Door_Open,dir)
							runChime(module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.Exterior_Call_Only,configFile.Sound_Database.Chime_Events.After_Open,dir, true)
							removeCall(call.call,dir)
						end)
					end
				end

				updateCore()

				if (not regFloor) then return end
				local index = table.find(regFloor.exteriorCallDirections,directionNum)
				if (index) then
					table.remove(regFloor.exteriorCallDirections,index)
				end
				if (module.MODULE_STORAGE.statValues.moveValue == 0 and nextCall and nextCall.call ~= module.MODULE_STORAGE.statValues.rawFloor) then
					task.spawn(elevatorRun,nextCall.call,false)
				elseif (nextCall and nextCall.call == module.MODULE_STORAGE.statValues.rawFloor) then
					local hasCompleted = conditionalStepWait(1, function() return {module.MODULE_STORAGE.statValues.moveValue ~= 0} end)
					if (not hasCompleted) then return end
					checkRun(nextCall)
				else
					nextCall = checkCallInDirection(module.MODULE_STORAGE.statValues.rawFloor) or module.MODULE_STORAGE.queue[1]
					if (not nextCall) then return end
					local queueDir = nextCall.call > module.MODULE_STORAGE.statValues.rawFloor and 'U' or nextCall.call < module.MODULE_STORAGE.statValues.rawFloor and 'D' or 'N'
					if (queueDir ~= module.MODULE_STORAGE.statValues.queueDirection) then
						local hasCompleted = conditionalStepWait(1, function() return {module.MODULE_STORAGE.statValues.moveValue ~= 0} end)
						if (not hasCompleted) then return end
					end
					checkRun(nextCall)
				end
			end)
			return
		end

		function elevatorRun(dest, park)
			if ((not findFloor(dest)) or (module.MODULE_STORAGE.statValues.moveValue ~= 0) or (moveBrake) or (lock) or (not isDropKeyOnElevator()) or (stopElevator) or module.MODULE_STORAGE.statValues.inspection or overshot or releveling) then return end
			module.MODULE_STORAGE.statValues.destination = dest
			local regFloor = findRegisteredFloor(dest)
			if (not regFloor) then return end
			if (dest == module.MODULE_STORAGE.statValues.rawFloor) then
				removeCall(dest)
				if (checkDoorStates('Closed')) then
					api:Fire('onElevatorCall', {Floor=dest})
					if ((not module.MODULE_STORAGE.statValues.fireService) and (not checkIndependentService())) then
						task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Door_Open,configFile.Color_Database.Lanterns.Active_After_Door_Open,module.MODULE_STORAGE.statValues.queueDirection)
						task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.On_Open,configFile.Sound_Database.Chime_Events.After_Open,module.MODULE_STORAGE.statValues.queueDirection, true)
						if (getTableLength(regFloor.exteriorCallDirections) > 0) then
							runChime(dest or module.MODULE_STORAGE.statValues.rawFloor, configFile.Sound_Database.Chime_Events.Exterior_Call_Only, configFile.Sound_Database.Chime_Events.After_Open, true)
							doLanterns(dest or module.MODULE_STORAGE.statValues.rawFloor, configFile.Color_Database.Lanterns.Active_On_Exterior_Call, configFile.Color_Database.Lanterns.Active_After_Door_Open)
						end
					end
					if (module.MODULE_STORAGE.statValues.moveValue == 0) then
						safeCheckRelevel()
					end
					if (configFile.Movement.Open_Doors_On_Call) then
						runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, 'ALL')
					end
				end
			else
				if ((not checkDoorStates('Closed') or lock or (module.MODULE_STORAGE.statValues.moveValue ~= 0 and (not preDooring))) or moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator())) then coroutine.yield() end

				local directionString = dest > module.MODULE_STORAGE.statValues.rawFloor and 'U' or dest < module.MODULE_STORAGE.statValues.rawFloor and 'D' or 'N'
				local directionValue = dest > module.MODULE_STORAGE.statValues.rawFloor and 1 or dest < module.MODULE_STORAGE.statValues.rawFloor and -1 or 0

				lock = true
				isMoving = true
				module.MODULE_STORAGE.statValues.moveDirection = directionString
				module.MODULE_STORAGE.statValues.queueDirection = park and 'N' or directionString
				module.MODULE_STORAGE.statValues.arrowDirection = park and 'N' or directionString
				preDirection = 'N'
				module.MODULE_STORAGE.statValues.moveValue = directionValue
				module.MODULE_STORAGE.statValues.parking = park
				api:Fire('onDepartStart', { destination = dest, directionString = directionString, directionValue = directionValue })

				outputElevMessage("Elevator is now departing from floor " .. (module.MODULE_STORAGE.statValues.rawFloor) .. " to " .. (module.MODULE_STORAGE.statValues.destination), 'debug')

				task.spawn(updateCore)
				task.spawn(doPlayerWeld)
				if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
					if (not safetyBraking) then
						module.MODULE_STORAGE.statValues.currentSpeed = 0
						module.MODULE_STORAGE.statValues.moveValue = 0
						module.MODULE_STORAGE.statValues.moveDirection = 'N'
						lock = false
						setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
						preDooring = false
						releveling = false
						overshot = false
						module.MODULE_STORAGE.statValues.leveling = false
						preChimeFloor = nil
						safetyBraking = false
						removePlayerWelds()
						updateCore()
					end
					return
				end

				task.delay(configFile.Movement.Motor_Start_Delay[module.MODULE_STORAGE.statValues.moveValue == 1 and 'Up' or module.MODULE_STORAGE.statValues.moveValue == -1 and 'Down'], function()
					if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
						if (not safetyBraking) then
							module.MODULE_STORAGE.statValues.currentSpeed = 0
							module.MODULE_STORAGE.statValues.moveValue = 0
							module.MODULE_STORAGE.statValues.moveDirection = 'N'
							lock = false
							setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
							preDooring = false
							releveling = false
							overshot = false
							module.MODULE_STORAGE.statValues.leveling = false
							preChimeFloor = nil
							safetyBraking = false
							removePlayerWelds()
							updateCore()
						end
						return
					end
					doMotorSound()
				end)
				module.MODULE_STORAGE.miscValues.leaving = true
				module.MODULE_STORAGE.statValues.departFloor = module.MODULE_STORAGE.statValues.rawFloor
				if (configFile.Movement.Pre_Start_Data.Enabled) then
					task.spawn(function()
						local hasCompleted = conditionalStepWait(configFile.Movement.Pre_Start_Data.Floor_Change_Delay, function() return {moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))} end)
						if (not hasCompleted) then return end
						repeat
							if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
								if (not safetyBraking) then
									module.MODULE_STORAGE.statValues.currentSpeed = 0
									module.MODULE_STORAGE.statValues.moveValue = 0
									module.MODULE_STORAGE.statValues.moveDirection = 'N'
									lock = false
									setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
									preDooring = false
									releveling = false
									overshot = false
									module.MODULE_STORAGE.statValues.leveling = false
									preChimeFloor = nil
									safetyBraking = false
									removePlayerWelds()
									updateCore()
								end
								return
							end
							preChimeFloor = module.MODULE_STORAGE.statValues.currentFloor
							module.MODULE_STORAGE.statValues.currentFloor += module.MODULE_STORAGE.statValues.moveValue
							updateCore()
						until (findFloor(module.MODULE_STORAGE.statValues.currentFloor))
						local hasCompleted = conditionalStepWait(configFile.Movement.Pre_Start_Data.Chime_Delay, function() return {moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))} end)
						if (not hasCompleted) then return end
						if (module.MODULE_STORAGE.statValues.currentFloor == module.MODULE_STORAGE.statValues.destination or moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring)) or checkIndependentService() or module.MODULE_STORAGE.statValues.fireService) then return end
						addPlaySound(module.MODULE_STORAGE.sounds.Floor_Pass_Chime, platform)
					end)
				end
				conditionalStepWait(configFile.Movement.Jolt_Start_Data.Enable and configFile.Movement.Jolt_Start_Data.Start_Delay or 0, function() return {moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))} end)
				if (configFile.Movement.Jolt_Start_Data.Enable and (not departPreStarting)) then
					local done = false
					local checked = false
					local lastSpeed = module.MODULE_STORAGE.statValues.currentSpeed
					local startTime = os.clock()
					while (not checked) do
						local delta = updateCore()
						if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
							if (not safetyBraking) then
								module.MODULE_STORAGE.statValues.currentSpeed = 0
								module.MODULE_STORAGE.statValues.moveValue = 0
								module.MODULE_STORAGE.statValues.moveDirection = 'N'
								lock = false
								setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
								preDooring = false
								releveling = false
								overshot = false
								module.MODULE_STORAGE.statValues.leveling = false
								preChimeFloor = nil
								safetyBraking = false
								removePlayerWelds()
								updateCore()
							end
							return
						end
						module.MODULE_STORAGE.statValues.currentSpeed = -(math.sin(math.abs(os.clock()-startTime)*math.pi*configFile.Movement.Jolt_Start_Data.Speed)*configFile.Movement.Jolt_Start_Data.Ratio)/(math.pi)
						local spd = module.MODULE_STORAGE.statValues.currentSpeed
						if ((lastSpeed-spd) > 0) then
							lastSpeed = spd
						elseif (spd >= 0) then
							checked = true
						end
					end
				end
				if (configFile.Movement.Depart_Pre_Start and configFile.Movement.Depart_Pre_Start.Enable and departPreStarting) then
					conditionalStepWait(configFile.Movement.Depart_Pre_Start.Delay, function()
						return {(moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring)))}
					end)
				elseif ((not configFile.Movement.Depart_Pre_Start) or (not configFile.Movement.Depart_Pre_Start.Enable) or configFile.Movement.Depart_Pre_Start.Ignore_Start_Delay) then
					conditionalStepWait(module.MODULE_STORAGE.statValues.moveValue == 1 and (configFile.Movement.Start_Delay or 0) or module.MODULE_STORAGE.statValues.moveValue == -1 and configFile.Movement.Down_Start_Delay or 0, function()
						return {(moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring)))}
					end)
				end
				if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
					if (not safetyBraking) then
						module.MODULE_STORAGE.statValues.currentSpeed = 0
						module.MODULE_STORAGE.statValues.moveValue = 0
						module.MODULE_STORAGE.statValues.moveDirection = 'N'
						lock = false
						setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
						preDooring = false
						releveling = false
						overshot = false
						module.MODULE_STORAGE.statValues.leveling = false
						preChimeFloor = nil
						safetyBraking = false
						removePlayerWelds()
						updateCore()
					end
					return
				end
				departPreStarting = false
				api:Fire('onElevatorMoveBegin', {directionString=directionString,directionValue=directionValue})

				local topSpeed = configFile.Movement.Travel_Speed
				local offset = math.random(1,configFile.Movement.Overdrive_Chance_Max) == 1 and 1.1 or 0
				local startTick = os.clock()
				local startingSpeed = module.MODULE_STORAGE.statValues.currentSpeed
				local rate = (module.MODULE_STORAGE.statValues.moveValue == 1 and configFile.Movement.Acceleration or module.MODULE_STORAGE.statValues.moveValue == -1 and configFile.Movement.Down_Acceleration or 0)
				local lvlOffset = module.MODULE_STORAGE.statValues.moveValue == 1 and configFile.Sensors.Up_Level_Offset or module.MODULE_STORAGE.statValues.moveValue == -1 and configFile.Sensors.Down_Level_Offset or 0
				local dynamicAccelRate = 1/math.deg(configFile.Movement.Dynamic_Acceleration_Time)
				local startT = os.clock()
				local dynamicAccelValue = 0
				while (getFloorDistance(module.MODULE_STORAGE.statValues.destination or dest) > lvlOffset*(module.MODULE_STORAGE.statValues.currentSpeed*configFile.Movement.Level_Offset_Ratio)) do
					local deltaTime = updateCore()
					dynamicAccelValue = math.clamp(dynamicAccelValue+dynamicAccelRate*math.deg(deltaTime), 0, 1)
					module.MODULE_STORAGE.statValues.currentSpeed = math.clamp(module.MODULE_STORAGE.statValues.currentSpeed+rate*dynamicAccelValue*math.deg(deltaTime), 0, topSpeed)
					lvlOffset = module.MODULE_STORAGE.statValues.moveValue == 1 and configFile.Sensors.Up_Level_Offset or module.MODULE_STORAGE.statValues.moveValue == -1 and configFile.Sensors.Down_Level_Offset or 0
					if (moveBrake or module.MODULE_STORAGE.statValues.inspection or overshot or stopElevator or (not isDropKeyOnElevator()) or ((not checkDoorStates('Closed')) and (not preDooring))) then
						if (not safetyBraking) then
							module.MODULE_STORAGE.statValues.currentSpeed = 0
							module.MODULE_STORAGE.statValues.moveValue = 0
							module.MODULE_STORAGE.statValues.moveDirection = 'N'
							lock = false
							setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
							preDooring = false
							releveling = false
							overshot = false
							module.MODULE_STORAGE.statValues.leveling = false
							preChimeFloor = nil
							safetyBraking = false
							removePlayerWelds()
							updateCore()
						end
						return
					end
				end

				elevatorProcessRunStop(module.MODULE_STORAGE.statValues.destination or dest)
				return
			end
		end

		--// 8/04/2023 -- NEW QUEUE HANDLER REVAMP & DIRECTIONAL QUEUE //--
		function checkCallInDirection(call: number, direction: number?)
			local result,index,dist = nil,nil,math.huge
			for i,c in next,module.MODULE_STORAGE.queue do
				if (math.abs(c.call-call) <= dist and c.call ~= call and (((c.call > call and direction == 1) or (c.call < call and direction == -1)) or typeof(direction) ~= 'number' or direction == 0)) then
					index,result = i,c
					dist = math.abs(c.call-call)
				end
			end
			return result,index
		end
		function findCallInQueue(call: any, direction: any?) -- Returns the queue item if queue item's floor matches the given floor. If the direction is supplied, it only returns the queue if the direction matches. Otherwise, just return the queue item
			for i,v in pairs(module.MODULE_STORAGE.queue) do
				if (v.call == call and (typeof(direction) ~= 'number' or table.find(v.directions, direction) or #v.directions == 0)) then return i,v end
			end
			return nil
		end
		function addCall(call: number, direction: number?, bypassFireRecall: boolean?, callTypes: {car: boolean?, hall: boolean?}?)
			call = tonumber(call)
			local regFloor = findRegisteredFloor(call)
			if ((not regFloor) or (module.MODULE_STORAGE.statValues.fireRecall and not bypassFireRecall)) then return end
			local result,index = findCallInQueue(call, direction)
			if (result or index) then return end
			local queueItemIndex,queueItem = findCallInQueue(call)
			if (not queueItem) then
				queueItem = { ['call']=call,['directions']=queueItem and queueItem.directions or {},['isCarCall']=if (typeof(callTypes) == 'table' and typeof(callTypes.car) == 'boolean') then callTypes.car else false,['isHallCall']=if (typeof(callTypes) == 'table' and typeof(callTypes.hall) == 'boolean') then callTypes.hall else false }
			end
			if (typeof(direction) == 'number' and direction ~= 0 and (not table.find(queueItem.directions,direction))) then
				table.insert(queueItem.directions, direction)
			end
			if (not findCallInQueue(call)) then
				table.insert(module.MODULE_STORAGE.queue,queueItem)
				api:Fire('onCallEnter', call)
				api:Fire('onCallAdded', {call=call,direction=direction})
			end
			if ((not module.MODULE_STORAGE.statValues.destination) or (
				(module.MODULE_STORAGE.statValues.queueDirection == 'U' or module.MODULE_STORAGE.statValues.moveValue == 1) and
					call > module.MODULE_STORAGE.statValues.rawFloor and
					call <= module.MODULE_STORAGE.statValues.destination
				) or
					(
						(module.MODULE_STORAGE.statValues.queueDirection == 'D' or module.MODULE_STORAGE.statValues.moveValue == -1) and
						call < module.MODULE_STORAGE.statValues.rawFloor and
						call >= module.MODULE_STORAGE.statValues.destination
					)
				) then
				module.MODULE_STORAGE.statValues.destination = call
			end
			if (module.MODULE_STORAGE.statValues.queueDirection == 'N') then
				module.MODULE_STORAGE.statValues.queueDirection = call > module.MODULE_STORAGE.statValues.rawFloor and 'U' or call < module.MODULE_STORAGE.statValues.rawFloor and 'D' or typeof(direction) == 'number' and direction == 1 and 'U' or direction == -1 and 'D' or 'N'
				module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
			end
			queueTableJSON.Value = httpService:JSONEncode(module.MODULE_STORAGE.queue)
			task.spawn(updateCore)

			if (checkDoorStates('Closed') and module.MODULE_STORAGE.statValues.moveValue == 0) then
				task.spawn(elevatorRun,call,false)
			end
			return true --// Indicating that the call has been added successfully //--
		end
		function removeCall(call: number, direction: number?)
			local regFloor = findRegisteredFloor(call)
			if (not regFloor) then return end
			local index,queueItem = findCallInQueue(call, direction)
			if ((not index) or (not queueItem)) then return --[[ warn("Failed to remove call from queue: No call for " .. (floor) .. " in current queue!") ]] end
			for i,v in pairs(module.MODULE_STORAGE.queue) do
				if (v.call == call and ((not direction) or table.find(v.directions, direction) or #v.directions == 0)) then
					local removedDirectionalCall = false
					local dirIndex = typeof(direction) == 'number' and direction ~= 0 and table.find(v.directions, direction)
					if (dirIndex) then
						table.remove(v.directions,dirIndex)
						local d = table.find(regFloor.exteriorCallDirections, direction)
						if (d) then
							--table.remove(regFloor.exteriorCallDirections, d)
							removedDirectionalCall = true
						end
						resetButtons(call)
					end
					if ((not v.directions) or #v.directions == 0) then
						table.remove(module.MODULE_STORAGE.queue, i)
						api:Fire('onCallRemove', call)
						api:Fire('onCallRemoved', {call=call,direction=direction})
						resetButtons(call)
						if (#module.MODULE_STORAGE.queue == 0 and call ~= topFloor and call ~= bottomFloor and (not removedDirectionalCall)) then
							module.MODULE_STORAGE.statValues.queueDirection = 'N'
							module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
							task.spawn(updateCore)
						end
						queueTableJSON.Value = httpService:JSONEncode(module.MODULE_STORAGE.queue)
						--[[ warn("Removed call from queue: Floor: " .. (floor), v) ]]
						return true
					end
				end
			end
			return false -- warn('Queue: No calls removed')
		end
		queueTableJSON:GetPropertyChangedSignal('Value'):Connect(function()
			queueTableJSON.Value = httpService:JSONEncode(module.MODULE_STORAGE.queue)
		end)
		local function getAllCallsByTypesAsync(types: { car: boolean?, hall: boolean? })
			if (typeof(types) ~= 'table') then return end
			local calls = {}
			for _,v in pairs(module.MODULE_STORAGE.queue) do
				if ((types.car and v.isCarCall) or (types.hall and v.isHallCall)) then
					table.insert(calls, v)
				end
			end
			return calls
		end

		----

		function updateButton(button, config, state, from)
			if typeof(button) == 'string' then -- Adding string support
				button = {['Name'] = button, ['Parent'] = {['Parent'] = from}}
			end

			for i,v in pairs(button.Parent.Parent:GetDescendants()) do
				if (v.Name == 'Buttons' or v.Name == 'Call_Buttons') then
					for i,b in pairs(v:GetDescendants()) do
						if b.Name == button.Name then
							local config = config[state]
							local buttonFloor = tonumber(string.split(b.Name,'Floor')[2]) or tonumber(string.split(b.Name,'Floor_')[2])
							local colorConfig = buttonFloor and configFile.Color_Database.Car.Custom_Color_Data[buttonFloor] or configFile.Color_Database.Car.Custom_Color_Data[tostring(buttonFloor)]
							if (colorConfig) then
								config = { Color=colorConfig[state].Color,Material=colorConfig[state].Material }
							end
							for i,t in pairs(b:GetDescendants()) do
								if (t.Name == 'Light') then
									if (t:IsA('BasePart')) then
										t.Color = config.Color
										t.Material = config.Material
									elseif (t:IsA('TextButton')) then
										t.TextColor3 = config.Color
										local sgui = t:FindFirstAncestorOfClass('SurfaceGui')
										if (sgui) then
											sgui.LightInfluence = 0
											sgui.Brightness = 2
										end
									end
								end
							end
						end
					end
				end
			end
		end

		function resetButtons(floor)
			local direction = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 'Up' or module.MODULE_STORAGE.statValues.queueDirection == 'D' and 'Down' or 'Neutral'
			for i,v in pairs(car:GetChildren()) do
				if v.Name == 'Buttons' then
					for i,t in pairs(v:GetChildren()) do
						local buttonFloor = tonumber(string.split(t.Name,'Floor')[2]) or tonumber(string.split(t.Name,'Floor_')[2])
						if (buttonFloor and buttonFloor == floor) then
							updateButton(t, configFile.Color_Database.Car.Floor_Button, 'Neautral_State')
						end
					end
				end
			end
			if (not findFloor(floor)) then return end
			for i,v in pairs(findFloor(floor):GetChildren()) do
				if v.Name == 'Call_Buttons' then
					for i,t in pairs(v:GetChildren()) do
						if (t.Name:sub(1,1) == module.MODULE_STORAGE.statValues.queueDirection) then
							updateButton(t, configFile.Color_Database.Floor[direction], 'Neautral_State')
						end
					end
				end
			end

		end

		function addGhostPart(part)
			local newPart = Instance.new('Part')
			part.Name = 'FakeButton'
			newPart.Name = 'Button'
			newPart.Transparency = 1
			newPart.CFrame = part.CFrame
			newPart.Size = part.Size*1.5
			newPart.CanCollide = false
			newPart.Anchored = true
			newPart.Parent = part.Parent
			local weld
			if (part:IsDescendantOf(car)) then
				for i,w in pairs(car:GetDescendants()) do
					if (w:IsA('Weld') and (w.Part0 == part or w.Part1 == part) and w.Name ~= 'NewWeld') then
						w:Destroy()
					end
				end
				car.DescendantAdded:Connect(function(w: Weld)
					task.wait()
					if (w:IsA('Weld') and (w.Part0 == part or w.Part1 == part) and w.Name ~= 'NewWeld') then
						w:Destroy()
					end
				end)
				weldTogether(newPart, platform, true)
			end
			local weld = weldTogether(part, newPart, false)
			weld.Name = 'NewWeld'
			weld.Parent = newPart
			return newPart, weld
		end

		for i,v in pairs(car:GetChildren()) do
			if (v.Name == 'Buttons') then
				for i,btn in pairs(v:GetChildren()) do

					local buttonPart = btn:FindFirstChild('Button')
					if (buttonPart) then
						buttonPart:SetAttribute('isACortexElevButton', true)
					end

					if (btn.Name:sub(1,5) == 'Floor' or btn.Name:sub(1,6) == 'Floor_') then
						updateButton(btn, configFile.Color_Database.Car.Floor_Button, 'Neautral_State')
					elseif (btn.Name:match('DoorHold')) then
						updateButton(btn, configFile.Color_Database.Car.Doors.Hold, 'Neutral')
					elseif (btn.Name == 'CallCancel' or btn.Name == 'Call_Cancel') then
						updateButton(btn, configFile.Color_Database.Car.Doors.Hold, 'Neutral')
					elseif (btn.Name:match('DoorOpen')) then
						updateButton(btn, configFile.Color_Database.Car.Doors.Open, 'Neutral')
					elseif (btn.Name:match('DoorClose')) then
						updateButton(btn, configFile.Color_Database.Car.Doors.Close, 'Neutral')
					elseif (btn.Name == 'Alarm') then
						updateButton(btn, configFile.Color_Database.Car.Alarm_Button, 'Neautral_State')
					end

				end
			end
			for i,f in pairs(floors:GetChildren()) do
				for i,v in pairs(f:GetChildren()) do
					if (string.match(v.Name, 'Call_Buttons')) then
						for i,btn in pairs(v:GetChildren()) do

							local buttonPart = btn:FindFirstChild('Button')
							if (buttonPart) then
								buttonPart:SetAttribute('isACortexElevButton', true)
							end

							if (btn.Name == 'Up' or btn.Name == 'Down') then
								updateButton(btn, configFile.Color_Database.Floor[btn.Name], 'Neautral_State')
							elseif (string.match(btn.Name, 'DoorOpen') or string.match(btn.Name, 'DoorClose')) then
								updateButton(btn, configFile.Color_Database.Car.Doors[string.match(btn.Name, 'DoorOpen') and 'Open' or string.match(btn.Name, 'DoorClose') and 'Close'], 'Neutral')
							elseif string.match(btn.Name, 'DoorStop') then
							end
						end
					end
				end
			end
		end

		for _, v in pairs(elevator:GetDescendants()) do
			if v:IsA('Model') and v.Name == 'Inspection_Controls' then
				for _, btn in pairs(v.Buttons:GetChildren()) do
					if (btn.Name ~= 'Inspection_Switch' and btn.Name ~= 'Up' and btn.Name ~= 'Down' and btn.Name ~= 'Common' and btn.Name ~= 'Enable' and btn.Name ~= 'Alarm' and btn.Name ~= 'Stop') then continue end
					if not btn:IsA('Model') then
						local model = Instance.new('Model')
						model.Name = btn.Name
						btn.Name = 'Button'
						model.Parent = btn.Parent
						btn.Parent = model
						btn = model
					elseif btn:IsA('Model') then
						if not btn:FindFirstChild('Button') then
							local foundPart = btn:FindFirstChildOfClass('BasePart') 
							if foundPart then
								foundPart.Name = 'Button'
							end
						end
					end

					local part, weld = addGhostPart(btn.Button)
					if btn.Name == 'Inspection_Switch' then
						local on,off = weld.C0*CFrame.Angles(0, 0, -math.rad(90)),weld.C0
						local onCF = btn:FindFirstChild("onCF") or Instance.new("CFrameValue", btn)
						onCF.Name = "onCF"
						onCF.Value = on
						local offCF = btn:FindFirstChild("offCF") or Instance.new("CFrameValue", btn)
						offCF.Name = "offCF"
						offCF.Value = off
						inspectionSwitchClick = addSound(part, 'Switch_Click', {
							Sound_Id = 9117028605,
							Volume = .5,
							Pitch = 1
						}, false, false, 40, 3)
					elseif (btn.Name == 'Up' or btn.Name == 'Down' or btn.Name == 'Common' or btn.Name == 'Enable' or btn.Name == 'Alarm' or btn.Name == 'Stop') then
						local down, up = weld.C0*CFrame.new(math.rad(1.5), 0, 0),weld.C0
						local btnSoundId = 9119719973
						local btnSoundVolume = .5

						if btn.Name == 'Stop' then
							down = weld.C0*CFrame.new(0, math.rad(1.5), 0)
							btnSoundId = 9117028605
							btnSoundVolume = .5
						end
						
						local downCF = btn:FindFirstChild("downCF") or Instance.new("CFrameValue", btn)
						downCF.Name = "downCF"
						downCF.Value = down
						local upCF = btn:FindFirstChild("upCF") or Instance.new("CFrameValue", btn)
						downCF.Name = "upCF"
						downCF.Value = up
						inspectionButtonClick[btn.Name] = addSound(part, 'Button_Click', {
							Sound_Id = btnSoundId,
							Volume = btnSoundVolume,
							Pitch = 1
						}, false, false, 40, 3)
					end
					btn.Button:SetAttribute('isACortexElevButton', true)
				end
			end
		end

		for i,v in pairs(floors:GetChildren()) do
			resetLanterns(tonumber(v.Name:sub(7)))
		end

		function findNearestFloor()
			local nFloor
			local dist = math.huge
			local carRecallPos = level.Position.Y+(module.MODULE_STORAGE.statValues.moveValue*((module.MODULE_STORAGE.statValues.currentSpeed+5)^1.5))
			for i,v in pairs(floors:GetChildren()) do

				local isAFloor = tonumber(string.split(v.Name, 'Floor_')[2])
				if (isAFloor) then
					local level = v:FindFirstChild('Level')
					if (level and math.abs(level.Position.Y-carRecallPos) <= dist) then
						dist = math.abs(level.Position.Y-carRecallPos)
						module.MODULE_STORAGE.miscValues.nFloor = isAFloor
					end
				end

			end

			return module.MODULE_STORAGE.miscValues.nFloor
		end

		--Fire recall--

		local allFireRecallEventListeners = {}

		function fireRecall(bool, floor)
			local regFloor = findRegisteredFloor(module.MODULE_STORAGE.statValues.rawFloor)
			if (not regFloor) then return end
			fireRecallFloor = floor
			module.MODULE_STORAGE.statValues.fireRecall = bool
			module.MODULE_STORAGE.statValues.fireService = bool
			module.MODULE_STORAGE.statValues.phase1 = bool
			task.spawn(updateCore)
			outputElevMessage("Elevator has been placed " .. (bool and 'into' or 'out of') .. " fire service to floor " .. (floor), 'warning')
			if (bool) then

				local function handleDoors()
					if (checkDoorStates('Open', {dontRequireAll=true,onlyPresentDoors=false})) then
						module.MODULE_STORAGE.sounds.Nudge_Buzzer.Playing = false
						module.MODULE_STORAGE.statValues.fireRecall = false
						return
					end
					for _,doorData in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
						if (not regFloor.floorInstance:FindFirstChild((doorData.side == '' and '' or doorData.side.."_").."Doors")) then continue end
						if (doorData.state ~= 'Open') then
							local connection: RBXScriptConnection
							connection = doorData.Opened:Connect(function()
								connection:Disconnect()
								if (not checkDoorStates('Open', {dontRequireAll=true,onlyPresentDoors=false})) then return end
								module.MODULE_STORAGE.sounds.Nudge_Buzzer.Playing = false
								module.MODULE_STORAGE.statValues.fireRecall = false
							end)
							table.insert(allFireRecallEventListeners, connection)
						end
					end
				end

				module.MODULE_STORAGE.statValues.queueDirection = 'N'
				task.spawn(updateCore)
				module.MODULE_STORAGE.sounds.Nudge_Buzzer.Playing = true
				for _,v in pairs(registeredFloors) do
					resetButtons(v.floorNumber)
					resetLanterns(v.floorNumber, {'Interior', 'Exterior'})
				end
				removeAllCalls()

				local isOnFloor = module.MODULE_STORAGE.statValues.rawFloor == floor and (module.MODULE_STORAGE.statValues.moveValue == 0 or module.MODULE_STORAGE.statValues.leveling)
				if (not isOnFloor) then -- // Not on floor, elevator must stop at nearest floor
					local direction = module.MODULE_STORAGE.statValues.moveValue
					local nearFloor,nearDist = nil,math.huge
					for _,flr in pairs(registeredFloors) do
						local thisDist = math.abs(flr.floorInstance.Level.Position.Y-level.Position.Y)
						if (thisDist < nearDist and ((direction == 1 and flr.floorNumber > module.MODULE_STORAGE.statValues.rawFloor) or (direction == -1 and flr.floorNumber < module.MODULE_STORAGE.statValues.rawFloor))) then
							nearDist = thisDist
							nearFloor = flr
						end
					end
					if (nearFloor and module.MODULE_STORAGE.statValues.moveValue ~= 0) then
						addCall(nearFloor.floorNumber, nil, true)
					end

					if module.MODULE_STORAGE.statValues.moveValue == 0 then
						task.spawn(runDoorClose, module.MODULE_STORAGE.statValues.rawFloor, 'ALL', true)
						addCall(floor, nil, true)
					end

					local connection: RBXScriptConnection
					connection = api.Event:Connect(function(protocol, params)
						if (protocol == 'onElevatorStop') then
							if (module.MODULE_STORAGE.statValues.rawFloor ~= floor) then
								addCall(floor, nil, true)
							else
								connection:Disconnect()
								handleDoors()
							end
						end
					end)
					table.insert(allFireRecallEventListeners, connection)
				else
					task.spawn(runDoorOpen, floor, 'ALL')
					handleDoors()
				end
			else
				for i,v in pairs(allFireRecallEventListeners) do
					v:Disconnect()
				end
				allFireRecallEventListeners = {}
			end
		end

		local prevValue = independentService
		local function setIndependentService(bool)
			independentService = bool
			outputElevMessage("Elevator has been placed " .. (bool and 'into' or 'out of') .. " independent service", 'warning')
			if (prevValue ~= independentService) then
				prevValue = independentService
				removeAllCalls()
				updateCore()
				if (bool) then
					if (configFile.Sound_Database.Voice_Config.Enabled and voiceConfig.Settings.Door_Announcements.Open_Announcement.Enabled) then
						playVoiceSequenceProtocolWithQueue(voiceConfig.Settings.Door_Announcements.Open_Announcement.Sequence, false)
					end
					--If the elevator is already on the recall floor, open the doors (if closed or closing)
					for i,doorData in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
						if (doorData.state == 'Closed' or doorData.state == 'Closing' or doorData.state == 'Stopped') then
							runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, doorData.side)
						end
					end
				end
			end
		end

		local pressDebounce,buttonPressHandlerDebounce = false,false --Soon to be replaced with collectionService tags
		local isAlarmPlaying = false --Soon to be replaced with collectionService tags


		local lastCarButtonPressed = os.clock()
		local function handleRemoteButtonInput(event: string, params: any)
			if (event ~= 'onButtonPressed' and event ~= 'onButtonReleased') then return end
			local btn = params.button
			if (not btn) then return end

			if (not btn:FindFirstAncestor('Inspection_Controls')) then
				if (event == 'onButtonPressed') then
					addPlaySound(btn:IsDescendantOf(car) and module.MODULE_STORAGE.sounds.Button_Beep or module.MODULE_STORAGE.sounds.Call_Button_Beep, btn.Button)
				end
				local buttonFloor = tonumber(string.split(btn.Name,'Floor_')[2]) or tonumber(string.split(btn.Name,'Floor')[2])
				if (buttonFloor) then
					lastCarButtonPressed = os.clock()
					local resetStatement = (not findFloor(buttonFloor))
						or (not isDropKeyOnElevator())
						or ((module.MODULE_STORAGE.statValues.rawFloor == buttonFloor or module.MODULE_STORAGE.statValues.arriveFloor == buttonFloor) and (module.MODULE_STORAGE.statValues.moveValue == 0 or module.MODULE_STORAGE.statValues.leveling))
						or (module.MODULE_STORAGE.statValues.inspection or stopElevator or (module.MODULE_STORAGE.statValues.phase1 and not checkPhase2()))
						or ((lockedFloors[tostring(buttonFloor)] and not checkPhase2()) and (not findCallInQueue(buttonFloor)))
						or (configFile.Locking.Lock_Opposite_Travel_Direction_Floors and ((module.MODULE_STORAGE.statValues.queueDirection == 'U' and (buttonFloor < module.MODULE_STORAGE.statValues.rawFloor) or (module.MODULE_STORAGE.statValues.queueDirection == 'D' and (buttonFloor > module.MODULE_STORAGE.statValues.rawFloor)) or buttonFloor == module.MODULE_STORAGE.statValues.rawFloor and checkDoorStates('Closed')))) 
						or ((not findCallInQueue(buttonFloor)) and (configFile.Call_Limiting.Enable and #getAllCallsByTypesAsync({ car = true })+1 > configFile.Call_Limiting.Max_Calls))
					if (event == 'onButtonPressed') then
						updateButton(btn, configFile.Color_Database.Car.Floor_Button, 'Lit_State')
						if (not resetStatement) then
							local inQueue = findCallInQueue(buttonFloor)
							if (not inQueue) then
								task.delay(configFile.Sound_Database.Others.Call_Recognition_Beep.Delay, function()
									if (buttonFloor == module.MODULE_STORAGE.statValues.rawFloor) then return end
									addPlaySound(module.MODULE_STORAGE.sounds.Call_Recognition_Beep, platform)
								end)
								for _,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
									if (not configFile.Doors.Close_On_Button_Press.Enable) then continue end
									task.spawn(function()
										local hasPassed = conditionalStepWait(configFile.Doors.Close_On_Button_Press.Delay, function() return {v.side == 'Open'} end)
										if (not hasPassed) then return end
										task.spawn(runDoorClose, module.MODULE_STORAGE.statValues.rawFloor, v.side)
									end)
								end
							end

							addCall(buttonFloor, nil, nil, { car = true })
							if (checkDoorStates('Closed')) then return end
							task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Call_Enter,configFile.Color_Database.Lanterns.Active_After_Door_Open,module.MODULE_STORAGE.statValues.queueDirection)
							task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.New_Call_Input,configFile.Sound_Database.Chime_Events.After_Open,module.MODULE_STORAGE.statValues.queueDirection, true)
						elseif (buttonFloor == module.MODULE_STORAGE.statValues.rawFloor and module.MODULE_STORAGE.statValues.moveValue == 0 and not module.MODULE_STORAGE.statValues.fireService) then
							for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
								if (v.state == 'Closing' or v.state == 'Closed') then
									task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,v.side)
								end
							end
						end
					elseif (resetStatement) then
						if (((not findCallInQueue(buttonFloor)) and (configFile.Call_Limiting.Enable and #getAllCallsByTypesAsync({ car = true })+1 > configFile.Call_Limiting.Max_Calls))) then
							api:Fire('Call_Limiter_Rejection', { ['Call'] = buttonFloor, ['CallLength'] = #getAllCallsByTypesAsync({ car = true })+1 })
						end
						while ((os.clock()-lastCarButtonPressed) <= configFile.Color_Database.Car.Lit_Delay) do task.wait() end
						updateButton(btn, configFile.Color_Database.Car.Floor_Button, 'Neautral_State')
					end
				elseif (string.match(btn.Name, 'DoorOpen')) then

					local isManual = configFile.Doors.Manual_Door_Controls.Enable_Open
					local sideIndex = string.split(btn.Name, 'DoorOpen')[1]
					if (event == 'onButtonPressed') then
						updateButton(btn, configFile.Color_Database.Car.Doors.Open, 'Active')
						if ((btn:IsDescendantOf(car) or (btn:IsDescendantOf(floors) and module.MODULE_STORAGE.statValues.currentFloor == tonumber(string.split(btn:FindFirstAncestor('Call_Buttons').Parent.Name,'Floor_')[2]))) and (not moveBrake) --[[and (not isManual)]] and ((not module.MODULE_STORAGE.statValues.fireService and not module.MODULE_STORAGE.statValues.phase1) or checkPhase2()) and (module.MODULE_STORAGE.statValues.moveValue == 0) and (not module.MODULE_STORAGE.statValues.inspection)
							and (not (configFile.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing and btn:IsDescendantOf(car) and (lockedFloors[tostring(module.MODULE_STORAGE.statValues.rawFloor)] and not checkPhase2()) and getDoorData(sideIndex).state == 'Closing'))
							and (not (configFile.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed and btn:IsDescendantOf(car) and (lockedFloors[tostring(module.MODULE_STORAGE.statValues.rawFloor)] and not checkPhase2()) and getDoorData(sideIndex).state == 'Closed'))
							and (not (configFile.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing and btn:IsDescendantOf(floors) and lockedHallFloors[tostring(module.MODULE_STORAGE.statValues.rawFloor)] and getDoorData(sideIndex).state == 'Closing'))
							and (not (configFile.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed and btn:IsDescendantOf(floors) and lockedHallFloors[tostring(module.MODULE_STORAGE.statValues.rawFloor)] and getDoorData(sideIndex).state == 'Closed'))
							)
						then
							if (stopElevator) then return end
							task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,sideIndex)
							btn:SetAttribute('Is_Down', true)
							local doorData = getDoorData(sideIndex)
							if (not doorData) then return end
							while (btn:GetAttribute('Is_Down')) do
								HEARTBEAT:Wait()
								doorData.doorTimerTick = os.clock()
							end
						end
					else
						task.delay(configFile.Color_Database.Car.Lit_Delay, function()
							updateButton(btn, configFile.Color_Database.Car.Doors.Open, 'Neutral')
						end)
						btn:SetAttribute('Is_Down', false)
						if (not (checkPhase2() --[[or isManual]])) then return end
						if ((btn:IsDescendantOf(car) or (btn:IsDescendantOf(floors) and module.MODULE_STORAGE.statValues.currentFloor == tonumber(string.split(btn:FindFirstAncestor('Call_Buttons').Parent.Name,'Floor_')[2]))) and (findFloor(module.MODULE_STORAGE.statValues.rawFloor) and findFloor(module.MODULE_STORAGE.statValues.rawFloor):FindFirstChild(sideIndex..(sideIndex == '' and '' or '_')..'Doors')) and getDoorState(sideIndex).state == 'Opening') then
							task.spawn(runDoorClose,module.MODULE_STORAGE.statValues.rawFloor,sideIndex)
						end
					end
				elseif (string.match(btn.Name, 'DoorClose')) then
					local isManual = configFile.Doors.Manual_Door_Controls.Enable_Close
					local sideIndex = string.split(btn.Name, 'DoorClose')[1]
					if (event == 'onButtonPressed') then
						updateButton(btn, configFile.Color_Database.Car.Doors.Close, 'Active')
						if ((btn:IsDescendantOf(car) or (btn:IsDescendantOf(floors) and module.MODULE_STORAGE.statValues.currentFloor == tonumber(string.split(btn:FindFirstAncestor('Call_Buttons').Parent.Name,'Floor_')[2]))) and (not moveBrake) --[[and (not isManual)]] and ((not module.MODULE_STORAGE.statValues.fireService and not module.MODULE_STORAGE.statValues.phase1) or checkPhase2() or checkIndependentService() or isManual) and (not module.MODULE_STORAGE.statValues.inspection) and (not getDoorState(sideIndex).Is_Obstructed) and (not stopElevator)) then
							if configFile.Doors.Disable_Door_Close and not (checkPhase2() or checkIndependentService() or isManual) then return end
							if not checkIndependentService() and not module.MODULE_STORAGE.statValues.fireService then
								local hasCompleted = conditionalStepWait(configFile.Doors.Door_Close_Button_Delay, function() return {getDoorState(sideIndex) == 'Open'} end)
								if (not hasCompleted) then return end
							end
							task.spawn(runDoorClose, module.MODULE_STORAGE.statValues.rawFloor, sideIndex)
						end
					else
						task.delay(configFile.Color_Database.Car.Lit_Delay, function()
							updateButton(btn, configFile.Color_Database.Car.Doors.Close, 'Neutral')
						end)
						if (not (checkPhase2() or checkIndependentService() or isManual)) then return end
						if ((btn:IsDescendantOf(car) or (btn:IsDescendantOf(floors) and module.MODULE_STORAGE.statValues.currentFloor == tonumber(string.split(btn:FindFirstAncestor('Call_Buttons').Parent.Name,'Floor_')[2]))) and (findFloor(module.MODULE_STORAGE.statValues.rawFloor) and findFloor(module.MODULE_STORAGE.statValues.rawFloor):FindFirstChild(sideIndex..(sideIndex == '' and '' or '_')..'Doors')) and getDoorState(sideIndex).state == 'Closing') then
							task.spawn(function()
								runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, sideIndex)
							end)
						end
					end

				elseif (btn.Name == 'Alarm') then

					if (event == 'onButtonPressed') then
						updateButton(btn, configFile.Color_Database.Car.Alarm_Button, 'Lit_State')
						if ((not configFile.Sound_Database.Others.Alarm.Pause_On_Release) or (not module.MODULE_STORAGE.sounds.Alarm.IsPlaying)) then
							module.MODULE_STORAGE.sounds.Alarm:Play()
						else
							module.MODULE_STORAGE.sounds.Alarm.Playing = true
						end
					else
						updateButton(btn, configFile.Color_Database.Car.Alarm_Button, 'Neautral_State')
						if (module.MODULE_STORAGE.sounds.Alarm.Playing) then
							module.MODULE_STORAGE.sounds.Alarm_Release:Play()
						end
						if (not configFile.Sound_Database.Others.Alarm.Pause_On_Release) then
							module.MODULE_STORAGE.sounds.Alarm:Stop()
						else
							module.MODULE_STORAGE.sounds.Alarm.Playing = false
						end
					end

				elseif (string.match(btn.Name, 'DoorHold')) then
					local isManual = configFile.Doors.Manual_Door_Controls.Enable_Close
					local sideIndex = string.split(btn.Name, 'DoorHold')[1]
					local doorData = getDoorData(sideIndex)
					if (not doorData) then return end
					if (event == 'onButtonPressed') then
						if (module.MODULE_STORAGE.statValues.moveValue ~= 0 and doorData.state == 'Closed') or (doorData.nudging) or (moveBrake) or (isManual) or (module.MODULE_STORAGE.statValues.phase1) or (module.MODULE_STORAGE.statValues.fireService) or (checkIndependentService()) or (checkPhase2()) or (module.MODULE_STORAGE.statValues.inspection) or (stopElevator) then return end
						doorData.doorHold = not doorData.doorHold
						task.spawn(updateCore)
						if (doorData.doorHold) then
							if ((not connection) or (not connection.Connected)) then
								connection = api.Event:Connect(function(protocol,params)
									if (protocol == 'onDoorClose' and params.side == sideIndex) then
										doorData.doorHold = false
										updateButton(btn, configFile.Color_Database.Car.Doors.Hold, 'Neutral')
										connection:Disconnect()
									end
								end)
							end
							doorData.doorTimerTick = os.clock()
							runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, sideIndex)
						else
							if (connection) then
								connection:Disconnect()
							end
						end
						updateButton(btn, configFile.Color_Database.Car.Doors.Hold, doorData.doorHold and 'Active' or 'Neutral')
					else
						if (not configFile.Color_Database.Car.Doors.Hold[doorData.doorHold and 'Active' or 'Neutral']) then return end
						updateButton(btn, configFile.Color_Database.Car.Doors.Hold, doorData.doorHold and 'Active' or 'Neutral')
					end
				elseif (string.match(btn.Name, 'DoorStop')) then
					local sideIndex = string.split(btn.Name, 'DoorStop')[1]
					local doorData = getDoorData(sideIndex)
					if (not doorData) then return end
					if (btn:IsDescendantOf(car) or (btn:IsDescendantOf(floors) and module.MODULE_STORAGE.statValues.currentFloor == tonumber(string.split(btn:FindFirstAncestor('Call_Buttons').Parent.Name,'Floor_')[2]))) then
						if (event == 'onButtonPressed') then
							if (doorData.nudging) then
								doorData.nudging = false
								module.MODULE_STORAGE.sounds.Nudge_Buzzer:Stop()
							end
							if (doorData.state == 'Opening' or doorData.state == 'Closing') then
								doorData.state = 'Stopped'
								HEARTBEAT:Wait()
								task.spawn(updateCore)
							end
						end
					end
				elseif (btn.Name == 'CallCancel' or btn.Name == 'Call_Cancel') then
					if (checkIndependentService() or checkPhase2()) then
						removeAllCalls()
						if (module.MODULE_STORAGE.statValues.moveValue == 1 or module.MODULE_STORAGE.statValues.moveValue == -1) then
							removeCall(module.MODULE_STORAGE.statValues.rawFloor)
						end
					end
				elseif (btn:IsDescendantOf(floors) and (btn.Name == 'Up' or btn.Name == 'Down')) then

					local floor = tonumber(string.split(btn.Parent.Parent.Name,'Floor_')[2])
					local direction = string.sub(btn.Name,1,1)
					local directionNumber = direction == 'U' and 1 or direction == 'D' and -1 or 0
					local regFloor = findRegisteredFloor(floor)
					if (not regFloor) then return end
					local isOnFloor = (floor == module.MODULE_STORAGE.statValues.rawFloor and (module.MODULE_STORAGE.statValues.moveValue == 0 or module.MODULE_STORAGE.statValues.leveling))

					if (event == 'onButtonPressed') then
						updateButton(btn, configFile.Color_Database.Floor[btn.Name], 'Lit_State', btn)

						if lockedHallFloors[tostring(floor)] or independentService or module.MODULE_STORAGE.statValues.fireService or stopElevator or outOfService then return end

						if (module.MODULE_STORAGE.statValues.rawFloor == floor and not module.MODULE_STORAGE.statValues.leveling) then
							if (configFile.Freight.Same_Floor_Call.With_Doors_Open.Enable and (checkDoorStates('Open', {dontRequireAll = true}) or checkDoorStates('Opening', {dontRequireAll = true}))) then
								if configFile.Freight.Same_Floor_Call.With_Doors_Open.Bell then
									btn:SetAttribute('AlarmRinging', true)
									module.MODULE_STORAGE.sounds.Alarm:Play()
								end
								if not configFile.Freight.Same_Floor_Call.With_Doors_Open.Call_Elevator then
									return btn:SetAttribute('NoCall', true)
								end
							elseif (configFile.Freight.Same_Floor_Call.With_Doors_Closed.Enable and (checkDoorStates('Closed') or checkDoorStates('Closing', {dontRequireAll = true}))) then
								if configFile.Freight.Same_Floor_Call.With_Doors_Closed.Bell then
									btn:SetAttribute('AlarmRinging', true)
									module.MODULE_STORAGE.sounds.Alarm:Play()
								end
								if not configFile.Freight.Same_Floor_Call.With_Doors_Closed.Call_Elevator then
									return btn:SetAttribute('NoCall', true)
								end
							end
						elseif (module.MODULE_STORAGE.statValues.rawFloor ~= floor or (module.MODULE_STORAGE.statValues.rawFloor == floor and module.MODULE_STORAGE.miscValues.leaving)) and not lockedHallFloors[tostring(floor)] then
							if (configFile.Freight.Other_Floor_Call.With_Doors_Open.Enable and (checkDoorStates('Open', {dontRequireAll = true}) or checkDoorStates('Opening', {dontRequireAll = true}))) then
								if configFile.Freight.Other_Floor_Call.With_Doors_Open.Bell then
									btn:SetAttribute('AlarmRinging', true)
									module.MODULE_STORAGE.sounds.Alarm:Play()
								end
								if not configFile.Freight.Other_Floor_Call.With_Doors_Open.Call_Elevator then
									return btn:SetAttribute('NoCall', true)
								end
							elseif (configFile.Freight.Other_Floor_Call.With_Doors_Closed.Enable and (checkDoorStates('Closed') or checkDoorStates('Closing', {dontRequireAll = true}))) then
								if configFile.Freight.Other_Floor_Call.With_Doors_Closed.Bell then
									btn:SetAttribute('AlarmRinging', true)
									module.MODULE_STORAGE.sounds.Alarm:Play()
								end
								if not configFile.Freight.Other_Floor_Call.With_Doors_Closed.Call_Elevator then
									return btn:SetAttribute('NoCall', true)
								end
							end
						end

						if (not isOnFloor) then
							addCall(floor,directionNumber,nil,{ hall = true })
							table.insert(regFloor.exteriorCallDirections,directionNumber)
						else
							if (direction == module.MODULE_STORAGE.statValues.queueDirection or module.MODULE_STORAGE.statValues.queueDirection == 'N') then
								module.MODULE_STORAGE.statValues.queueDirection = direction
								module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
								if (not table.find(regFloor.exteriorCallDirections,directionNumber)) then
									table.insert(regFloor.exteriorCallDirections,directionNumber)
								end
								task.spawn(updateCore)
								task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,'ALL')
								task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Exterior_Call,configFile.Color_Database.Lanterns.Active_After_Door_Open,direction)
								task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.Exterior_Call_Only,configFile.Sound_Database.Chime_Events.After_Open,direction)

								task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Door_Open,configFile.Color_Database.Lanterns.Active_After_Door_Open,direction)
								task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.On_Open,configFile.Sound_Database.Chime_Events.After_Open,direction)
							elseif (not table.find(regFloor.exteriorCallDirections,directionNumber)) then
								addCall(floor,directionNumber,nil,{ hall = true })
								table.insert(regFloor.exteriorCallDirections,directionNumber)
							end
						end
					else
						local resetStatement = ((isOnFloor and (direction == module.MODULE_STORAGE.statValues.queueDirection or module.MODULE_STORAGE.statValues.queueDirection == 'N'))
							or independentService
							or module.MODULE_STORAGE.statValues.inspection
							or module.MODULE_STORAGE.statValues.fireService
							or lockedHallFloors[tostring(floor)])
							and not findCallInQueue(floor, direction)


						if (btn:GetAttribute('AlarmRinging')) then
							btn:SetAttribute('AlarmRinging', nil)
							module.MODULE_STORAGE.sounds.Alarm:Stop()
							module.MODULE_STORAGE.sounds.Alarm_Release:Play()
						end
						if (resetStatement) then
							task.delay(configFile.Color_Database.Floor.Active_Duration, function()
								updateButton(btn, configFile.Color_Database.Floor[btn.Name], 'Neautral_State')
							end)
						end
					end
				end
			elseif (btn:FindFirstAncestor('Inspection_Controls')) then -- Added by ImFirstPlace
				if (inspectionLocked) then return end
				if (btn.Name == 'Inspection_Switch') then
					if (event == 'onButtonPressed') then
						module.MODULE_STORAGE.statValues.inspection = not module.MODULE_STORAGE.statValues.inspection
						api:Fire('setInspection', module.MODULE_STORAGE.statValues.inspection) -- Because it doesn't repeat code
						addPlaySound(inspectionSwitchClick, btn.Button)
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.17, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = module.MODULE_STORAGE.statValues.inspection and btn:FindFirstChild('onCF').Value or btn:FindFirstChild('offCF').Value}):Play()
					end
				elseif btn.Name == 'Common' or btn.Name == 'Enable' then
					if (event == 'onButtonPressed') then
						module.MODULE_STORAGE.miscValues.inspectionCommonEnabled = not module.MODULE_STORAGE.miscValues.inspectionCommonEnabled
						addPlaySound(inspectionButtonClick[btn.Name], btn.Button)
						if module.MODULE_STORAGE.miscValues.inspectionCommonEnabled then
							tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = btn:FindFirstChild('downCF').Value}):Play()
						end
					elseif (not module.MODULE_STORAGE.miscValues.inspectionCommonEnabled) then
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = btn:FindFirstChild('upCF').Value}):Play()
					end
				elseif (btn.Name == 'Up' or btn.Name == 'Down') then
					if (event == 'onButtonPressed') then
						addPlaySound(inspectionButtonClick[btn.Name], btn.Button)
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = btn:FindFirstChild('downCF').Value}):Play()
						if (module.MODULE_STORAGE.miscValues.inspectionCommonEnabled) then
							api:Fire('inspectionMove', {btn.Name, configFile.Movement.Inspection_Config.Max_Speed})
						end
					else
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = btn:FindFirstChild('upCF').Value}):Play()
						if (module.MODULE_STORAGE.miscValues.inspectionCommonEnabled) then
							api:Fire('inspectionStop', btn.Name)
						end
					end
				elseif (btn.Name == 'Alarm') then
					if (event == 'onButtonPressed') then
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = btn:FindFirstChild('downCF').Value}):Play()
						if ((not configFile.Sound_Database.Others.Alarm.Pause_On_Release) or (not module.MODULE_STORAGE.sounds.Alarm.IsPlaying)) then
							module.MODULE_STORAGE.sounds.Alarm:Play()
						else
							module.MODULE_STORAGE.sounds.Alarm.Pitch = configFile.Sound_Database.Others.Alarm.Pitch
						end
						isAlarmPlaying = true
					else
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = btn:FindFirstChild('upCF').Value}):Play()
						if (not configFile.Sound_Database.Others.Alarm.Pause_On_Release) then
							module.MODULE_STORAGE.sounds.Alarm:Stop()
						else
							module.MODULE_STORAGE.sounds.Alarm.Pitch = 0
						end
						if (isAlarmPlaying) then
							module.MODULE_STORAGE.sounds.Alarm_Release:Play()
						end
						isAlarmPlaying = false
					end
				elseif (btn.Name == 'Stop') then
					if (event == 'onButtonPressed') then
						addPlaySound(inspectionButtonClick[btn.Name], btn.Button)
						api:Fire('Stop', not stopElevator)
						tweenService:Create(btn.Button.NewWeld, TweenInfo.new(.08, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {C0 = stopElevator and btn:FindFirstChild('downCF').Value or btn:FindFirstChild('upCF').Value}):Play()
					end
				end
			else
				local function lerp(weld, duration, startPoint, point)
					local newCode = math.random(0,100000000)
					weld:SetAttribute('LerpCode', newCode)
					local startTime = os.clock()

					local prevLerpCode = weld:GetAttribute('LerpCode')
					while ((os.clock()-startTime)/duration <= 1) do
						local alpha = math.clamp(((os.clock()-startTime)/duration), 0, 1)
						prevLerpCode = weld:GetAttribute('LerpCode')
						if (prevLerpCode ~= newCode) then return end
						weld.C0 = weld:GetAttribute('startPoint'):Lerp(weld:GetAttribute('endPoint'), point+(startPoint-point)*alpha)
						HEARTBEAT:Wait()
					end

				end

				if (collectionService:HasTag(btn.Button, 'isInsButtonMain')) then
					addPlaySound(btn.Button.Click, btn.Button)
					lerp(btn.Button.NewWeld, .05, 1, 0)
				end
			end
		end

		local setInspectionNudgeConnections = {}
		api.Event:Connect(function(event: string, params: any, optionalFireRecallBool: boolean?)

			if (event == 'inspectionMove' or event == 'Inspection_Service_Move') then
				if (stopElevator or moveBrake) then return end
				if (not inspectionMoveDebounce) then
					local direction,maxSpeed = unpack(params)
					local dir = direction == 'Up' and 1 or direction == 'Down' and -1
					isDown = true
					if ((not module.MODULE_STORAGE.statValues.inspection) or (not isDown) or (not checkDoorStates('Closed'))) then return end
					if (isMoving) then while (isMoving and isDown and (not overshot)) do task.wait() end end
					if (initialDirection == -dir) then
						overshot = false
					end
					if ((not isDown) or overshot) then return end
					inspectionMoveDebounce = true
					isMoving = true
					stopping = false
					module.MODULE_STORAGE.statValues.moveValue = dir
					updateCore()
					doMotorSound()
					conditionalStepWait(configFile.Movement.Inspection_Start_Delay[dir == 1 and 'Up' or dir == -1 and 'Down'], function()
						return {not isDown}
					end)
					doPlayerWeld()
					while (isDown and isMoving and (not stopping) and (not overshot)) do
						local delta = updateCore()
						if (math.abs(module.MODULE_STORAGE.statValues.currentSpeed) < configFile.Movement.Inspection_Config.Max_Speed) then
							module.MODULE_STORAGE.statValues.currentSpeed += (configFile.Movement.Inspection_Config.Accceleration_Rate)*math.deg(delta)
						end
					end
				end

			end
			if (event == 'inspectionStop' or event == 'Inspection_Service_Stop') then
				stopInspection(params)
			end
			if (event == 'inspectionLock' or event == 'Inspection_Service_Lock') then
				inspectionLocked = params
			end
			if (event == 'setInspection' or event == 'Inspection_Service') then
				module.MODULE_STORAGE.statValues.inspection = params
				outputElevMessage("elevators inspection has been " .. (module.MODULE_STORAGE.statValues.inspection and 'enabled' or 'disabled') .. " by Server", 'warning')
				outOfService = params or (not isDropKeyOnElevator())
				if (module.MODULE_STORAGE.statValues.inspection) then
					releveling = false
					removeAllCalls()
					setDirection(module.MODULE_STORAGE.statValues.rawFloor, 'N')
					if (module.MODULE_STORAGE.statValues.moveValue ~= 0) then
						module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed = module.MODULE_STORAGE.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
						task.spawn(safetyBrake)
					end
					if (not checkDoorStates('Closed')) then module.MODULE_STORAGE.sounds.Nudge_Buzzer:Play() end

					for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
						local connection: RBXScriptConnection
						if (v.state ~= 'Closed' and v.state ~= 'Open') then
							v.nudging = true
							if ((not connection) or (not connection.Connected)) then
								connection = v.Opened:Connect(function()
									connection:Disconnect()
									task.spawn(function()
										local hasPassed = conditionalStepWait(1, function() return {v.state ~= 'Open'} end)
										if (not hasPassed) then return end
										task.spawn(runDoorClose, module.MODULE_STORAGE.statValues.rawFloor, v.side, true)
									end)
								end)
							end
						elseif (v.state == 'Open') then
							v.nudging = true
							if (connection) then connection:Disconnect() end
							task.spawn(function()
								local hasPassed = conditionalStepWait(1, function() return {v.state ~= 'Open'} end)
								if (not hasPassed) then return end
								task.spawn(runDoorClose, module.MODULE_STORAGE.statValues.rawFloor, v.side, true)
							end)
						end
					end
				else
					for i,v in pairs(setInspectionNudgeConnections) do
						v:Disconnect()
					end
					setInspectionNudgeConnections = {}
					stopInspection(module.MODULE_STORAGE.statValues.moveValue == 1 and 'U' or module.MODULE_STORAGE.statValues.moveValue == -1 and 'D' or 'N')
					overshot = false
					moveBrake = false
					task.spawn(safeCheckRelevel)
				end
				updateCore()
			elseif (event == 'setInspectionEnabled' or event == 'Inspection_Service_Common') then
				module.MODULE_STORAGE.miscValues.inspectionCommonEnabled = params
			end
			if (event == 'Lock_Floors') then
				if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
				outputElevMessage("Elevator floors locked with calls " .. (table.concat(params, ', ')), 'debug')
				for i,v in pairs(params) do
					lockedFloors[tostring(v)] = true
				end
			elseif (event == 'Unlock_Floors') then
				if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
				outputElevMessage("Elevator floors unlocked with calls " .. (table.concat(params, ', ')), 'debug')
				for i,v in pairs(params) do
					lockedFloors[tostring(v)] = false
				end
			end
			if (event == 'Lock_Hall_Floors') then
				if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
				outputElevMessage("Elevator floors hall locked with calls " .. (table.concat(params, ', ')), 'debug')
				for i,v in pairs(params) do
					lockedHallFloors[tostring(v)] = true
				end
			elseif (event == 'Unlock_Hall_Floors') then
				if (typeof(params) ~= 'table') then return debugWarn((event) .. " API :: Paramrters is not of type table") end
				outputElevMessage("Elevator floors hall unlocked with calls " .. (table.concat(params, ', ')), 'debug')
				for i,v in pairs(params) do
					lockedHallFloors[tostring(v)] = false
				end
			end
			if (event == 'forceChimeOnCallEnter') then

				local call = params[1]
				for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
					if (call == module.MODULE_STORAGE.statValues.rawFloor and v.state == 'Open') then
						local function runCallEnterHandler(data, fn)

							for index,v in pairs(data) do

								if (v.Enable) then
									task.delay(v.Delay, function()

										local direction = module.MODULE_STORAGE.statValues.queueDirection == 'U' and 'Up' or module.MODULE_STORAGE.statValues.queueDirection == 'D' and 'Down' or nil
										if (not module.MODULE_STORAGE.statValues.direction) then return end
										local name = string.format('%s_Chime%s', module.MODULE_STORAGE.statValues.direction, string.lower(v.Type) == 'arrival' and '_Arrival' or '')
										local chime = platform:FindFirstChild(name)
										if (not chime) then return end
										fn(module.MODULE_STORAGE.statValues.rawFloor, {[index]={['Type']=v.Type,['Enable']=v.Enable}}, {[index]={['Type']=v.Type,['Enable']=false}})

									end)
								end

							end

						end

						for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
							if (call ~= module.MODULE_STORAGE.statValues.rawFloor and v.state == 'Open') then
								runCallEnterHandler(configFile.Sound_Database.Chime_Events.New_Call_Input, runChime)
								runCallEnterHandler(configFile.Color_Database.Lanterns.Active_On_Call_Enter, doLanterns)
							end
							break
						end
						break
					end
				end

			end
			if (event == 'Phase_2' or event == 'Fire_Service_Phase_2') then
				outputElevMessage((module.MODULE_STORAGE.statValues.phase1) .. ", " .. (module.MODULE_STORAGE.statValues.phase2), 'debug')
				module.MODULE_STORAGE.statValues.phase2 = params
				updateCore()
				if (module.MODULE_STORAGE.statValues.fireService and not module.MODULE_STORAGE.statValues.phase2) then
					local recallFloor = fireRecallFloor
					fireRecall(false, module.MODULE_STORAGE.statValues.rawFloor)
					fireRecall(true, recallFloor)
				end
			end
			if (event == 'dropKeyToggle') then
				doDropKey(params)
			end
			if (event == 'Door_Open') then
				runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, typeof(params) == 'table' and params or 'ALL')
			end
			if (event == 'Door_Close') then
				runDoorClose(module.MODULE_STORAGE.statValues.rawFloor, typeof(params) == 'table' and params or 'ALL')
			end
			if (event == 'Door_Nudge') then
				runDoorClose(module.MODULE_STORAGE.statValues.rawFloor, typeof(params) == 'table' and params or 'ALL', true)
			end
			if (event == 'Request_Call_F' or event == 'Add_Call') then
				--In this case, params[1] is the call
				local call = tonumber(params) or typeof(params) == 'table' and params.call
				local direction = typeof(params) == 'table' and params.direction and (params.direction == 1 and 'U' or params.direction == -1 and 'D' or if (typeof(params.direction) == 'string') then params.direction else nil) or nil
				local directionNumber = direction == 'U' and 1 or direction == 'D' and -1 or nil
				if (findCallInQueue(call, directionNumber)) then return end
				local regFloor = findRegisteredFloor(call)
				if (not regFloor) then return end
				local isOnFloor = (call == module.MODULE_STORAGE.statValues.rawFloor and (module.MODULE_STORAGE.statValues.moveValue == 0 or module.MODULE_STORAGE.statValues.leveling))
				if (not isOnFloor) then
					addCall(call,directionNumber)
					table.insert(regFloor.exteriorCallDirections,directionNumber)
				else
					if (direction and (direction == module.MODULE_STORAGE.statValues.queueDirection or module.MODULE_STORAGE.statValues.queueDirection == 'N')) then
						module.MODULE_STORAGE.statValues.queueDirection = direction
						module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
						api:Fire('onCallRespond', {floor=call,direction=module.MODULE_STORAGE.statValues.queueDirection})
						if (not table.find(regFloor.exteriorCallDirections,directionNumber)) then
							table.insert(regFloor.exteriorCallDirections,directionNumber)
							task.spawn(updateCore)
						end
						task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,'ALL')
						doLanterns(module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Exterior_Call,configFile.Color_Database.Lanterns.Active_After_Door_Open,direction)
						runChime(module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.Exterior_Call_Only,configFile.Sound_Database.Chime_Events.After_Open,direction)
						task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Door_Open,configFile.Color_Database.Lanterns.Active_After_Door_Open,direction)
						task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.On_Open,configFile.Sound_Database.Chime_Events.After_Open,direction)
					elseif (not direction) then
						local resetStatement = (not findFloor(call))
							or (not isDropKeyOnElevator())
							or ((module.MODULE_STORAGE.statValues.rawFloor == call or module.MODULE_STORAGE.statValues.arriveFloor == call) and (module.MODULE_STORAGE.statValues.moveValue == 0 or module.MODULE_STORAGE.statValues.leveling))
							or (module.MODULE_STORAGE.statValues.inspection or stopElevator or (module.MODULE_STORAGE.statValues.phase1 and not checkPhase2()))
							or (lockedFloors[tostring(call)] and (not findCallInQueue(call)))
							or (configFile.Locking.Lock_Opposite_Travel_Direction_Floors and ((module.MODULE_STORAGE.statValues.queueDirection == 'U' and (call < module.MODULE_STORAGE.statValues.rawFloor) or (module.MODULE_STORAGE.statValues.queueDirection == 'D' and (call > module.MODULE_STORAGE.statValues.rawFloor)) or call == module.MODULE_STORAGE.statValues.rawFloor and checkDoorStates('Closed'))))
						api:Fire('onCallRespond', {floor=call,direction=module.MODULE_STORAGE.statValues.queueDirection})
						task.spawn(function()
							if (not resetStatement) then
								local inQueue = findCallInQueue(call)
								if (not inQueue) then
									task.delay(configFile.Sound_Database.Others.Call_Recognition_Beep.Delay, function()
										if (call == module.MODULE_STORAGE.statValues.rawFloor) then return end
										addPlaySound(module.MODULE_STORAGE.sounds.Call_Recognition_Beep, platform)
									end)
								end
								addCall(call)
							elseif (call == module.MODULE_STORAGE.statValues.rawFloor and module.MODULE_STORAGE.statValues.moveValue == 0) then
								for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
									if (v.state == 'Closing' or v.state == 'Closed') then
										runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, v.side)
									end
								end
							end
						end)
					elseif (not table.find(regFloor.exteriorCallDirections,directionNumber)) then
						addCall(call,directionNumber)
						table.insert(regFloor.exteriorCallDirections,directionNumber)
					end
				end

				local function handleDestinationPanelNumber(d)

					local floorChangeConnection,destroyedConnection
					local doorStateConnections = {}
					local isClosed = checkDoorStates('Closed')
					task.spawn(function()
						while (not isClosed) do
							if (isClosed or (not d)) then return end
							d.TextTransparency = 0
							task.wait(.9)
							if (isClosed or (not d)) then return end
							d.TextTransparency = 1
							task.wait(.9)
						end
					end)
					floorChangeConnection = statisticsFolder.Floor:GetPropertyChangedSignal('Value'):Connect(function()
						if (statisticsFolder.Floor.Value == call) then
							floorChangeConnection:Disconnect()
							d:Destroy()
							d = nil --Unassign the value so the loop stops properly
						end
					end)
					for i,v in pairs(doorStateValues) do
						local connection
						connection = v.Value:GetPropertyChangedSignal('Value'):Connect(function()
							if (v.Value.Value == 'Closed') then connection:Disconnect() end
							isClosed = checkDoorStates('Closed')
							tweenService:Create(d, TweenInfo.new(.45, Enum.EasingStyle.Linear, Enum.EasingDirection.InOut), {TextTransparency=0}):Play()
						end)
						doorStateConnections[v.side] = connection
					end
					destroyedConnection = d:GetPropertyChangedSignal('Parent'):Connect(function()
						if (not d.Parent) then
							destroyedConnection:Disconnect()
							if (floorChangeConnection) then floorChangeConnection:Disconnect() end
							if (doorStateConnections) then
								for i,v in pairs(doorStateConnections) do
									v:Disconnect()
								end
							end
							d = nil
						end
					end)

				end

				if (call == module.MODULE_STORAGE.statValues.rawFloor) then return end
				if (not direction) then
					updateButton(string.format('Floor_%s', tostring(call)), configFile.Color_Database.Car.Floor_Button, 'Lit_State', car)
					updateButton(string.format('Floor%s', tostring(call)), configFile.Color_Database.Car.Floor_Button, 'Lit_State', car)
				end

				for i,v in pairs(car:GetDescendants()) do
					if (v.Name == 'Destination_Panels') then
						for _,h in pairs(v:GetDescendants()) do
							if (h.Name == 'Display') then
								local d = script.Assets.destinationPanelNumber:Clone()
								d.Parent = h.SurfaceGui.Frame
								local cfl = configFile['Custom_Floor_Label'][tostring(call)] or call
								d.Text = cfl
								d.Name = tostring(call)
								handleDestinationPanelNumber(d)
							end
						end
					end
				end
			end
			if (event == 'Fire_Recall' or event == 'Fire_Service_Phase_1') then
				if (typeof(params) ~= 'table') then
					params = {
						floor=optionalFireRecallBool,
						enable=params
					}
				end
				fireRecall(params.enable, params.floor)
			end
			if (event == 'Add_Directional_Call') then
				if (not floors:FindFirstChild(string.format('Floor_%s', tostring(params[1])))) then return end
				if (tonumber(params[1]) == module.MODULE_STORAGE.statValues.rawFloor and checkDoorStates('Closing')) then
					return runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, 'ALL', false)
				end
				addCall(params[1],params[2])
				local buttonDirection = params[2] == 'U' and 'Up' or params[2] == 'D' and 'Down'
				if (params[1] ~= module.MODULE_STORAGE.statValues.rawFloor) then 
					updateButton(buttonDirection, configFile.Color_Database.Floor[buttonDirection], 'Lit_State', floors:FindFirstChild(string.format('Floor_%s', tostring(params[1]))))
				end
			end
			if (event == 'Stop') then
				if (params) then
					stopElevator = true
					module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed = module.MODULE_STORAGE.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
					task.spawn(safetyBrake)
					if (module.MODULE_STORAGE.statValues.nudging) then
						module.MODULE_STORAGE.statValues.nudging = false
						module.MODULE_STORAGE.sounds.Nudge_Buzzer:Stop()
					end
					for _, doorData in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
						if (doorData.state == 'Opening' or doorData.state == 'Closing') then
							doorData.state = 'Stopped'
						end
					end
				else
					local prevStopCheck = stopElevator
					stopElevator = false
					if (prevStopCheck) then
						moveBrake = false
						task.spawn(safeCheckRelevel)
					end
				end
				task.spawn(updateCore)
			elseif (event == 'Set_Direction') then
				setDirection(params[1], params[2])
			elseif (event == 'invokeIndependentService' or event == 'invokeIS' or event == 'Independent_Service') then
				setIndependentService(params)
			elseif (event == 'addHallCall' or event == 'Add_Hall_Call') then
				if (typeof(params) ~= 'table' or (not params.floor) or (not params.direction)) then return end
				if (params.floor == module.MODULE_STORAGE.statValues.rawFloor) then
					for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
						if (v.state == 'Closing' and (not v.nudging)) then
							runDoorOpen(module.MODULE_STORAGE.statValues.rawFloor, v.side, false)
						end
					end
				end
				if (findCallInQueue(params.floor)) then return end
				debugWarn("Added hall call for " .. (params.floor) .. " with direction " .. (params.direction))
				local call = params.floor
				local direction = params.direction
				local directionNumber = params.direction == 'U' and 1 or params.direction == 'D' and -1 or typeof(params.direction) == 'number' and params.direction or 0
				local regFloor = findRegisteredFloor(call)
				local isOnFloor = (call == module.MODULE_STORAGE.statValues.rawFloor and (module.MODULE_STORAGE.statValues.moveValue == 0 or module.MODULE_STORAGE.statValues.leveling))

				if (not isOnFloor) then
					addCall(call,directionNumber,nil,{ hall = true })
					table.insert(regFloor.exteriorCallDirections,directionNumber)
				else
					if (direction == module.MODULE_STORAGE.statValues.queueDirection or module.MODULE_STORAGE.statValues.queueDirection == 'N') then
						module.MODULE_STORAGE.statValues.queueDirection = direction
						module.MODULE_STORAGE.statValues.arrowDirection = module.MODULE_STORAGE.statValues.queueDirection
						if (not table.find(regFloor.exteriorCallDirections,directionNumber)) then
							table.insert(regFloor.exteriorCallDirections,directionNumber)
						end
						task.spawn(updateCore)
						task.spawn(runDoorOpen,module.MODULE_STORAGE.statValues.rawFloor,'ALL')
						task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Exterior_Call,configFile.Color_Database.Lanterns.Active_After_Door_Open,direction)
						task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.Exterior_Call_Only,configFile.Sound_Database.Chime_Events.After_Open,direction)

						task.spawn(doLanterns, module.MODULE_STORAGE.statValues.rawFloor,configFile.Color_Database.Lanterns.Active_On_Door_Open,configFile.Color_Database.Lanterns.Active_After_Door_Open,direction)
						task.spawn(runChime, module.MODULE_STORAGE.statValues.rawFloor,configFile.Sound_Database.Chime_Events.On_Open,configFile.Sound_Database.Chime_Events.After_Open,direction)
					elseif (not table.find(regFloor.exteriorCallDirections,directionNumber)) then
						addCall(call,directionNumber,nil,{ hall = true })
						table.insert(regFloor.exteriorCallDirections,directionNumber)
					end
				end
			elseif (event == 'Run_Chime') then
				if (typeof(params) ~= 'table' or typeof(params.types) ~= 'table') then return end
				for i,v in pairs(params.types) do
					if (v == 'interior' or v == 'exterior') then
						local data = {[v]={Enable=true,Call_Only=false,Delay=0}}
						local afterOpenData = typeof(params.afterOpen) == 'table' and {[params.afterOpen[i]]={Enable=true,Call_Only=false,Delay=0}} or {}
						runChime(tonumber(params.floor), data, typeof(params.afterOpen) ~= 'table' and {} or afterOpenData, params.direction)
					end
				end
			elseif (event == 'Activate_Lanterns') then
				if (typeof(params) ~= 'table' or typeof(params.types) ~= 'table') then return end
				for i,v in pairs(params.types) do
					if (v == 'interior' or v == 'exterior') then
						local data = {[v]={Enable=true,Call_Only=false,Delay=0}}
						local afterOpenData = typeof(params.afterOpen) == 'table' and {[params.afterOpen[i]]={Enable=true,Call_Only=false,Delay=0}} or {}
						doLanterns(tonumber(params.floor), data, typeof(params.afterOpen) ~= 'table' and {} or afterOpenData, params.direction)
					end
				end
			elseif (event == 'Fire_Button_Event') then
				handleRemoteButtonInput(params.protocol, { ['button'] = params.button })
			end
			handleRemoteButtonInput(event, params)
		end)

		remote.OnServerEvent:Connect(function(user, event, params)
			if (event == 'dropKeyToggle') then
				local isHoldingKey = user.Character and user.Character:FindFirstChild('Drop Key')
				if (not isHoldingKey) then return end
				doDropKey(params)
			elseif (event == 'addDropKeyGuiToPlayer') then
				local containsDropKey
				for i,v in pairs(user.Character:GetChildren()) do
					if (v.Name == 'Drop Key' or v:FindFirstChild('Cortex_Drop_Key')) then
						containsDropKey = v
						break
					end
				end
				local isHoldingKey = user.Character and containsDropKey
				if (not isHoldingKey) then return end
				if (not user.PlayerGui:FindFirstChild('DOOR_KEY_UI')) then

					local doorSet = params
					local thisFloorName = doorSet:IsDescendantOf(floors) and string.split(doorSet.Parent.Name, 'Floor_')[2]
					local landingLevel = doorSet.Parent.Level
					local sideIndex = doorSet.Name:split('Doors')[1]:split('_')[1]
					local fullSideName = (sideIndex == '' and 'Front' or sideIndex)
					if (collectionService:HasTag(doorSet, 'IsInUse') or table.find(dropKeyHandlers,user) or (not ((landingLevel:IsDescendantOf(car) and getDoorState(sideIndex).state == 'Closed') or ((not landingLevel:IsDescendantOf(car)) and ((getDoorState(sideIndex).state == 'Closed' and tonumber(landingLevel.Parent.Name:sub(7)) == module.MODULE_STORAGE.statValues.rawFloor) or tonumber(landingLevel.Parent.Name:sub(7)) ~= module.MODULE_STORAGE.statValues.rawFloor))))) then return end
					table.insert(dropKeyHandlers,user)
					collectionService:AddTag(doorSet, 'IsInUse')
					local boundsCFrame,boundsSize = doorSet:GetBoundingBox()
					local doorBounds = doorSet:FindFirstChild('Door_Bounds')
					if (not doorBounds) then
						doorBounds = Instance.new('Part')
						doorBounds.Name = 'Door_Bounds'
						doorBounds.CFrame,doorBounds.Size = boundsCFrame,boundsSize
						doorBounds.CanCollide = false
						doorBounds.CanTouch = false
						doorBounds.CanQuery = false
						doorBounds.Transparency = 1
						weldTogether(doorBounds, landingLevel, true, false)
						doorBounds.Anchored = false
						doorBounds.Parent = doorSet
					end
					local gui = script.Assets.DOOR_KEY_UI:Clone()
					gui.DOOR_SET.Value = doorSet
					gui.Adornee = doorBounds
					gui.Enabled = true
					gui.Parent = user.PlayerGui:WaitForChild('DOOR_KEY_UIS')
					collectionService:AddTag(gui,'ACTIVE')
					local function getOrientation(cf)
						return cf:ToOrientation()
					end
					local welds = {}
					local data = pluginModules_INTERNAL.Storage.CONTENT:get('masterDoorData', sideIndex)
					for i,v in next,data and (doorSet:IsDescendantOf(car) and data.engineWelds.car[sideIndex] or data.engineWelds.floors[thisFloorName][sideIndex]) or {} do
						table.insert(welds, v)
					end
					local function checkIfDoorIsClosed()
						for i,v in pairs(welds) do
							if (v.instance.C0 ~= v.closedPosition) then return false end
						end
						return true
					end
					addPlaySound(addSound(landingLevel, 'Interlock_Click', {
						Sound_Id = 9116323848,
						Volume = 1,
						Pitch = 1.35
					}, false, false, 40, 3), landingLevel)
					for i,v in pairs(pluginModules_INTERNAL.Storage.CONTENT:getContentInBranch('masterDoorData')) do
						v.nudging = false
					end
					module.MODULE_STORAGE.statValues.nudging = false
					task.spawn(updateCore)
					local val = gui:WaitForChild('RATIO')
					local hasStopped = false
					local lastChecked = checkIfDoorIsClosed()
					api:Fire('onElevDoorKey',{doorSet=doorSet,status='insert'})

					local update: RBXScriptConnection
					update = HEARTBEAT:Connect(function(dtTime)
						local value = val.Value
						for i,weld in pairs(welds) do
							weld.instance.C0 = weld.closedPosition:Lerp(weld.openPosition,value)
						end
						local checked = checkIfDoorIsClosed()
						if (lastChecked ~= checked) then
							lastChecked = checked
							doorSet.Drop_Key_Open.Value = not checked
							getDoorData(sideIndex).IsDropKey = not checked
							if (not checked) then
								if (not hasStopped) then
									hasStopped = true
									outOfService = true
									moveBrake = true
									module.MODULE_STORAGE.sounds.Safety_Brake_Sound.PlaybackSpeed = module.MODULE_STORAGE.sounds.Safety_Brake_Sound:GetAttribute('originalPitch')
									task.spawn(safetyBrake)
								end
							else
								hasStopped = false
								outOfService = not isDropKeyOnElevator()
								moveBrake = outOfService
								if (not outOfService) then
									task.spawn(function()
										local isCompleted = conditionalStepWait(1, function() return {moveBrake} end)
										if (not isCompleted) then return end
										task.spawn(safeCheckRelevel)
									end)
								end
								task.spawn(updateCore)
							end
						end
					end)
					if (not dropKeyUpdaters[doorSet]) then dropKeyUpdaters[doorSet] = {} end
					table.insert(dropKeyUpdaters[doorSet],update)

				end
			elseif (event == 'exit') then
				dismountDropKeyClient(user,params)
				for i,v in pairs(user.PlayerGui:WaitForChild('DOOR_KEY_UIS'):GetChildren()) do
					if (collectionService:HasTag(v,'ACTIVE')) then
						v:Destroy()
					end
				end
			end
			handleRemoteButtonInput(event, params)
		end)

		game.Players.PlayerRemoving:Connect(function(plr: Player)
			if (not table.find(dropKeyHandlers,plr)) then return end
			for i,v in pairs(collectionService:GetTagged('IsInUse')) do
				if (v:IsDescendantOf(elevator)) then
					dismountDropKeyClient(plr,v)
				end
			end
			if (module.MODULE_STORAGE.miscValues.clientRefreshHandlers[plr]) then
				module.MODULE_STORAGE.miscValues.clientRefreshHandlers[plr] = nil
			end
		end)


		api:Fire('Lock_Floors', (configFile.Locking.Locked_Floors) or {})
		api:Fire('Lock_Hall_Floors', (configFile.Locking.Locked_Hall_Floors) or {})

		--Start the elevator & set all of its values--
		updateFloor()
		module.MODULE_STORAGE.statValues.destination = module.MODULE_STORAGE.statValues.rawFloor
		updateCore()
		parkTimer()
	end)
	local ran,res = coroutine.resume(thread)
	if (not ran) then
		warn((_VERSION) .. " :: FATAL ERROR | " .. (res))
		print(debug.traceback(thread, err))
		return restartElevator()
	end
end

return module]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="Folder" referent="RBXC348A91D64594A77A04251B8AD30A445">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Assets</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="TextLabel" referent="RBX9A2CE01D88774DBAAA5094735B712D4D">
							<Properties>
								<bool name="Active">false</bool>
								<Vector2 name="AnchorPoint">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<token name="AutomaticSize">0</token>
								<Color3 name="BackgroundColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<float name="BackgroundTransparency">1</float>
								<Color3 name="BorderColor3">
									<R>0.105882362</R>
									<G>0.164705887</G>
									<B>0.207843155</B>
								</Color3>
								<token name="BorderMode">0</token>
								<int name="BorderSizePixel">1</int>
								<bool name="ClipsDescendants">false</bool>
								<bool name="Draggable">false</bool>
								<token name="Font">1</token>
								<Font name="FontFace">
									<Family><url>rbxasset://fonts/families/Arial.json</url></Family>
									<Weight>400</Weight>
									<Style>Normal</Style>
									<CachedFaceId><url>rbxasset://fonts/arial.ttf</url></CachedFaceId>
								</Font>
								<int name="LayoutOrder">0</int>
								<float name="LineHeight">1</float>
								<int name="MaxVisibleGraphemes">-1</int>
								<string name="Name">destinationPanelNumber</string>
								<Ref name="NextSelectionDown">null</Ref>
								<Ref name="NextSelectionLeft">null</Ref>
								<Ref name="NextSelectionRight">null</Ref>
								<Ref name="NextSelectionUp">null</Ref>
								<UDim2 name="Position">
									<XS>0</XS>
									<XO>0</XO>
									<YS>0</YS>
									<YO>0</YO>
								</UDim2>
								<bool name="RichText">true</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<float name="Rotation">0</float>
								<bool name="Selectable">false</bool>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<Ref name="SelectionImageObject">null</Ref>
								<int name="SelectionOrder">0</int>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>200</XO>
									<YS>0</YS>
									<YO>50</YO>
								</UDim2>
								<token name="SizeConstraint">0</token>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
								<string name="Text">1</string>
								<Color3 name="TextColor3">
									<R>1</R>
									<G>1</G>
									<B>1</B>
								</Color3>
								<bool name="TextScaled">true</bool>
								<float name="TextSize">14</float>
								<Color3 name="TextStrokeColor3">
									<R>0</R>
									<G>0</G>
									<B>0</B>
								</Color3>
								<float name="TextStrokeTransparency">1</float>
								<float name="TextTransparency">0</float>
								<token name="TextTruncate">0</token>
								<bool name="TextWrapped">true</bool>
								<token name="TextXAlignment">2</token>
								<token name="TextYAlignment">1</token>
								<bool name="Visible">true</bool>
								<int name="ZIndex">1</int>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0135483CA56D43B08F31D4BF2D28E8B9">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Queue</string>
								<string name="ScriptGuid">{D97D4970-4165-4266-8036-C8239B9C7EEC}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

module.Current_Queue = _G.Cortex_Elevator_Queue[script.Parent:GetAttribute('elevatorID')]
function module.checkQueueInDirection(floor: number, direction: string?)
	if (not floor) then return end
	local result = {}
	print(module.Current_Queue)
	for i,v in ipairs(module.Current_Queue) do
		if ((v >= floor and direction == 'U') or (v >= floor and direction == 'D') or typeof(direction) ~= 'string' or direction == 'N') then
			table.insert(result, v)
		end
	end
	return result
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX0AF5AF1BC7A54216940F36AB8DAB5B06">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">ConfigFile</string>
								<string name="ScriptGuid">{B63DDB36-B4F3-411C-A8C2-C031AA71B6A2}</string>
								<ProtectedString name="Source"><![CDATA[return function(config, coreScript)
	local DefaultConfig = {
		['Doors'] = {
			['Door_Open_Speed'] = config.Doors.Door_Open_Speed, -- Doors take 1.68 seconds to open fully.
			['Door_Close_Speed'] = config.Doors.Door_Close_Speed, -- Doors take 2.48 seconds to close fully.
			['Nudge_Speed'] = config.Doors.Nudge_Speed or config.Doors.Door_Close_Speed,

			['Door_Timer'] = if (typeof(config.Doors.Door_Timer) == 'number') then config.Doors.Door_Timer+4 else 4,
			['Call_Door_Timer'] = config.Doors.Call_Door_Timer or if (typeof(config.Doors.Door_Timer) == 'number') then config.Doors.Door_Timer+4 else 4,
			['Nudge_Timer'] = config.Doors.Nudge_Timer,

			['Use_Old_Door_Sensors'] = config.Doors.Use_Old_Door_Sensors,

			['Open_Easing_Style'] = config.Doors.Open_Easing_Style or 'In_Out_Quad',
			['Close_Easing_Style'] = config.Doors.Close_Easing_Style or 'In_Out_Sine',

			['Door_Sensors'] = config.Doors.Door_Sensors,

			['Door_Open_Delay_Pattern'] = config.Doors.Door_Open_Delay_Pattern, -- Example: ['Door_Open_Delay_Pattern'] = {'Outer', 'Inner'} - Outer doors open, then the inner doors
			['Door_Close_Delay_Pattern'] = config.Doors.Door_Close_Delay_Pattern, -- Example: ['Door_Close_Delay_Pattern'] = {'Inner', 'Outer'} - Inner doors close, then the outer doors

			['Door_Open_Pattern_Delay'] = config.Doors.Door_Open_Pattern_Delay,
			['Door_Close_Pattern_Delay'] = config.Doors.Door_Close_Pattern_Delay,

			['Door_Delay_Sequence_Config'] = {
				['Opening'] = {
					['Enable'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Enable) == 'boolean') then config.Doors.Door_Delay_Sequence_Config.Opening.Enable elseif (typeof(config.Doors.Door_Open_Delay_Pattern) == 'table') then config.Doors.Door_Open_Delay_Pattern ~= nil else false, --// Enable or disable the door delay sequence
					['Sequence_Order'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) == 'table') then config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order elseif (typeof(config.Doors.Door_Open_Delay_Pattern) == 'table') then config.Doors.Door_Open_Delay_Pattern else {'Outer', 'Inner'}, --// [Inner, Outer] - The order in which each door opens
					['Delay'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Opening and typeof(config.Doors.Door_Delay_Sequence_Config.Opening.Delay) == 'number') then config.Doors.Door_Delay_Sequence_Config.Opening.Delay elseif (typeof(config.Doors.Door_Open_Pattern_Delay) == 'number') then config.Doors.Door_Open_Speed-config.Doors.Door_Open_Pattern_Delay else 1, --// Delay in seconds the door delay lasts
				},
				['Closing'] = {
					['Enable'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Enable) == 'boolean') then config.Doors.Door_Delay_Sequence_Config.Closing.Enable elseif (typeof(config.Doors.Door_Close_Delay_Pattern) == 'table') then config.Doors.Door_Close_Delay_Pattern ~= nil else false, --// Enable or disable the door delay sequence
					['Sequence_Order'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) == 'table') then config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order elseif (typeof(config.Doors.Door_Close_Delay_Pattern) == 'table') then config.Doors.Door_Close_Delay_Pattern else {'Outer', 'Inner'}, --// [Inner, Outer] - The order in which each door opens
					['Delay'] = if (config.Doors.Door_Delay_Sequence_Config and config.Doors.Door_Delay_Sequence_Config.Closing and typeof(config.Doors.Door_Delay_Sequence_Config.Closing.Delay) == 'number') then config.Doors.Door_Delay_Sequence_Config.Closing.Delay elseif (typeof(config.Doors.Door_Close_Pattern_Delay) == 'number') then config.Doors.Door_Close_Speed-config.Doors.Door_Close_Pattern_Delay else 1, --// Delay in seconds the door delay lasts
				},
			},

			['Door_Close_Button_Delay'] = if (typeof(config.Doors.Door_Close_Button_Delay) == 'number') then config.Doors.Door_Close_Button_Delay else 0,

			['Sensor_LED_Data'] = {

				['Opening_Color'] = {
					['Delay'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Delay or .25,
					['Tween_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Tween_Time or .035, --Time in seconds for the sensor LED to change color
					['Flash_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Flash_Time or .15, --Time in seconds for flashing
					['Behavior'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Behavior or 'Solid', --Flash/Solid
					['Active'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Active.Color or Color3.fromRGB(77, 194, 56),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Active.Material or Enum.Material.Neon,
					},
					['Inactive'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Color or Color3.fromRGB(50, 50, 50),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Opening_Color.Inactive.Material or Enum.Material.SmoothPlastic,
					},
				},
				['Closing_Color'] = {
					['Delay'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Delay or .25,
					['Tween_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Tween_Time or .035, --Time in seconds for the sensor LED to change color
					['Flash_Time'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Flash_Time or .15, --Time in seconds for flashing
					['Behavior'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Behavior or 'Flash', --Flash/Solid
					['Active'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Active.Color or Color3.fromRGB(194, 81, 52),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Active.Material or Enum.Material.Neon,
					},
					['Inactive'] = {
						['Color'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Inactive.Color or Color3.fromRGB(50, 50, 50),
						['Material'] = config.Doors.Sensor_LED_Data and config.Doors.Sensor_LED_Data.Closing_Color.Inactive.Material or Enum.Material.SmoothPlastic,
					},
				},

			},
			['Realistic_Doors_Data'] = {
				['Enable_Open'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Enable_Open or false,
				['Enable_Close'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Enable_Close or false,
				['Open_Time'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Time or .5,
				['Close_Time'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Time or .6,
				['Open_Easing_Style'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Easing_Style or 'Linear',
				['Close_Easing_Style'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Easing_Style or 'Linear',
				['Open_Ratio'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Ratio and math.clamp(config.Doors.Realistic_Doors_Data.Open_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Close_Ratio'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Ratio and math.clamp(config.Doors.Realistic_Doors_Data.Close_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Open_Delay'] = {
					['Enable'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Delay and config.Doors.Realistic_Doors_Data.Open_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Open_Delay and config.Doors.Realistic_Doors_Data.Open_Delay.Duration or 0,
				},
				['Close_Delay'] = {
					['Enable'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Delay and config.Doors.Realistic_Doors_Data.Close_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Doors_Data and config.Doors.Realistic_Doors_Data.Close_Delay and config.Doors.Realistic_Doors_Data.Close_Delay.Duration or 0,
				},
			},
			['Realistic_Outer_Doors_Data'] = {
				['Enable_Open'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Enable_Open or false,
				['Enable_Close'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Enable_Close or false,
				['Open_Time'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Time or .5,
				['Close_Time'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Time or .6,
				['Open_Easing_Style'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Easing_Style or 'Linear',
				['Close_Easing_Style'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Easing_Style or 'Linear',
				['Open_Ratio'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Ratio and math.clamp(config.Doors.Realistic_Outer_Doors_Data.Open_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Close_Ratio'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Ratio and math.clamp(config.Doors.Realistic_Outer_Doors_Data.Close_Ratio, 1.0000001, math.huge) or config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Ratio or 1.05, --How much the door gaps when transitioning to the animation. The larger the value, the larger the gap gets
				['Open_Delay'] = {
					['Enable'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Delay and config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Open_Delay and config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Duration or 0,
				},
				['Close_Delay'] = {
					['Enable'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Delay and config.Doors.Realistic_Outer_Doors_Data.Close_Delay.Enable or false,
					['Duration'] = config.Doors.Realistic_Outer_Doors_Data and config.Doors.Realistic_Outer_Doors_Data.Close_Delay and config.Doors.Realistic_Outer_Doors_Data.Close_Delay.Duration or 0,
				},
			},

			['Door_Motor'] = if (typeof(config.Doors.Door_Motor) == 'boolean') then config.Doors.Door_Motor else true,

			['Open_Delay'] = if (typeof(config.Doors.Open_Delay) == 'number') then config.Doors.Open_Delay else 0,
			['Reopen_Delay'] = if (typeof(config.Doors.Reopen_Delay) == 'number') then config.Doors.Reopen_Delay else .5,
			['Close_Delay'] = if (typeof(config.Doors.Close_Delay) == 'number') then config.Doors.Close_Delay else 0,

			['Reopen_When_Nudge_Obstruction'] = config.Doors.Reopen_When_Nudge_Obstruction,
			['Hold_On_Nudge_Obstruction'] = config.Doors.Reopen_When_Nudge_Obstruction,

			['Stay_Open_When_Idle'] = config.Doors.Stay_Open_When_Idle,

			['Close_On_Button_Press'] = {
				['Enable'] = if (typeof(config.Doors.Close_On_Button_Press) == 'table' and typeof(config.Doors.Close_On_Button_Press.Enable) == 'boolean') then config.Doors.Close_On_Button_Press.Enable else false,
				['Delay'] = if (typeof(config.Doors.Close_On_Button_Press) == 'table' and typeof(config.Doors.Close_On_Button_Press.Delay) == 'number') then config.Doors.Close_On_Button_Press.Delay else 0,
			},

			['Disable_Door_Close'] = if (typeof(config.Doors.Disable_Door_Close) == 'boolean') then config.Doors.Disable_Door_Close else false,

			['Manual_Door_Controls'] = config.Doors.Manual_Door_Controls,

			['Custom_Door_Operator_Config'] = {

				['Inner'] = {
					['Opening'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Opening.Deceleration_Offset
							else 0,
					},
					['Closing'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Inner.Closing.Deceleration_Offset
							else 0,
					},
				},
				['Outer'] = {
					['Opening'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Opening.Deceleration_Offset
							else 0,
					},
					['Closing'] = {
						['Enable'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable) == 'boolean') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Enable
							else false,
						['Acceleration'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Acceleration) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Acceleration
							else 0,
						['Deceleration_Distance'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Distance) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Distance
							else 0,
						['Minimum_Speed'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Minimum_Speed) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Minimum_Speed
							else 0,
						['Deceleration_Rate'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Rate) == 'string') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Rate
							else 'Constant',
						['Custom_Acceleration_Stages'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Custom_Acceleration_Stages) == 'table') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Custom_Acceleration_Stages
							else {},
						['Deceleration_Offset'] = if (typeof(config.Doors.Custom_Door_Operator_Config) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing) == 'table' and
							typeof(config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Offset) == 'number') then
							config.Doors.Custom_Door_Operator_Config.Outer.Closing.Deceleration_Offset
							else 0,
					},
				},

			},

			['Door_Open_Sound_Delay'] = if (typeof(config.Doors.Door_Open_Sound_Delay) == 'table') then config.Doors.Door_Open_Sound_Delay elseif (typeof(config.Doors.Open_Delay) == 'table') then config.Doors.Open_Delay else 0,
			['Door_Close_Sound_Delay'] = if (typeof(config.Doors.Door_Close_Sound_Delay) == 'table') then config.Doors.Door_Close_Sound_Delay elseif (typeof(config.Doors.Close_Delay) == 'table') then config.Doors.Close_Delay else 0,

			['New_Attachment_Doors_Config'] = {
				['Enable'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Enable) == 'boolean') then config.Doors.New_Attachment_Doors_Config.Enable else false, -- When enabled, the outer doors will be "attached" to the inner doors instead of running independently
				['Attachment_Threshold'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Attachment_Threshold) == 'number') then config.Doors.New_Attachment_Doors_Config.Attachment_Threshold else .05, -- Offset in studs the outer doors are positioned when moving with the inner doors
				['Closing_Min_Threshold'] = if (typeof(config.Doors.New_Attachment_Doors_Config) == 'table' and typeof(config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold) == 'number') then config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold else 0, -- Minimum distance in studs the doors can be from the closing position before the elevator is able to move
			},

		},
		['Movement'] = {
			['Movement_Type'] = config.Movement.Movement_Type or 1, --[1]: CFrame  [2]: AlignPosition

			['Weld_On_Move'] = config.Movement.Weld_On_Move,
			['Disable_Jumping'] = config.Movement.Disable_Jumping or false,
			--['Use_New_Welding'] = config.Movement.Weld_On_Move and ((config.Movement.Weld_On_Move ~= nil and config.Movement.Weld_On_Move) or (config.Movement.Weld_On_Move == nil and false)) or false,
			['Use_New_Welding'] = config.Movement.Use_New_Welding or false,
			--['Use_New_Welding'] = false,

			['Start_Delay'] = config.Movement.Start_Delay,
			['Motor_Start_Delay'] = {
				['Up'] = if (typeof(config.Movement.Motor_Start_Delay) == 'table' and typeof(config.Movement.Motor_Start_Delay.Up) == 'number') then config.Movement.Motor_Start_Delay.Up else 0,
				['Down'] = if (typeof(config.Movement.Motor_Start_Delay) == 'table' and typeof(config.Movement.Motor_Start_Delay.Down) == 'number') then config.Movement.Motor_Start_Delay.Down else 0,
			},
			['Down_Start_Delay'] = if (typeof(config.Movement.Down_Start_Delay) == 'number') then config.Movement.Down_Start_Delay else config.Movement.Start_Delay,

			['Use_Dynamic_Acceleration'] = config.Movement.Use_Dynamic_Acceleration,
			['Dynamic_Acceleration_Time'] = if (typeof(config.Movement.Dynamic_Acceleration_Time) == 'number') then config.Movement.Dynamic_Acceleration_Time else .75,

			['Acceleration'] = config.Movement.Acceleration,
			['Down_Acceleration'] = config.Movement.Down_Acceleration or config.Movement.Acceleration,

			['Travel_Speed'] = config.Movement.Travel_Speed,
			['Level_Speed'] = config.Movement.Level_Speed,
			['Floor_Pass_Chime_On_Stop'] = if (typeof(config.Movement.Floor_Pass_Chime_On_Stop) == 'boolean') then config.Movement.Floor_Pass_Chime_On_Stop else false,

			['Braking_Data'] = {
				['Mode'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Mode) == 'string') then if (config.Movement.Braking_Data.Mode == 'Auto') then 'Default' else config.Movement.Braking_Data.Mode elseif (typeof(config.Movement.Braking_Mode) == 'string') then if (config.Movement.Braking_Mode == 'Auto') then 'Default' else config.Movement.Braking_Mode else 'Linear',
					['Increment'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Increment) == 'number') then config.Movement.Braking_Data.Increment elseif (typeof(config.Movement.Braking_Amount) == 'number') then config.Movement.Braking_Amount else 0,
					['Linear_Mode_Offset_Up'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset_Up) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset_Up elseif (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset else 0,
					['Linear_Mode_Offset_Down'] = if (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset_Down) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset_Down elseif (typeof(config.Movement.Braking_Data) == 'table' and typeof(config.Movement.Braking_Data.Linear_Mode_Offset) == 'number') then config.Movement.Braking_Data.Linear_Mode_Offset else 0,

					['Advanced_Leveling'] = {
						['Stage_1_Min_Speed'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Advanced_Leveling and config.Movement.Braking_Data.Advanced_Leveling.Stage_1_Min_Speed or 1+config.Movement.Level_Speed*2.0,
						['Stage_2_Decel_Offset'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Advanced_Leveling and config.Movement.Braking_Data.Advanced_Leveling.Stage_2_Decel_Offset or 1.6,
					},
					['Smart_Linear_Transition_Dist'] = config.Movement.Braking_Data and config.Movement.Braking_Data.Smart_Linear_Transition_Dist or 1.75,

					['Custom_Leveling_Stages'] = config.Movement.Braking_Data and typeof(config.Movement.Braking_Data.Custom_Leveling_Stages) == 'table' and config.Movement.Braking_Data.Custom_Leveling_Stages or {},

			},

			['Jolt_Start_Data'] =
				{
					['Enable'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Enable,
					['Ratio'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Ratio or 1,
					['Depth'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Depth or -1,
					['Speed'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Speed or .4,
					['Start_Delay'] = config.Movement.Jolt_Start_Data and config.Movement.Jolt_Start_Data.Start_Delay or 0
				},

			['Bounce_Stop_Config'] = {
				['Enable'] = if (typeof(config.Movement.Bounce_Stop_Config) == 'table' and typeof(config.Movement.Bounce_Stop_Config.Enable) == 'boolean') then config.Movement.Bounce_Stop_Config.Enable elseif (typeof(config.Movement.Bounce_Stop) == 'string') then config.Movement.Bounce_Stop == 'Enable' and true or false else false,
				['Amount'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Amount or .5,
				['Times'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Times or 1,
				['Stop_Sound'] = config.Movement.Bounce_Stop_Config and config.Movement.Bounce_Stop_Config.Stop_Sound or {['Enable']=false,['Sound_Id']=0,['Volume']=0,['Pitch']=0},
			},
			['Motor_Stop_On_Open'] = config.Movement.Motor_Stop_On_Open or false,

			['Enable_Smooth_Stop'] = if (typeof(config.Movement.Enable_Smooth_Stop) == 'boolean') then config.Movement.Enable_Smooth_Stop else false,
			['Smooth_Stop_Min_Speed'] = typeof(config.Movement.Smooth_Stop_Min_Speed) ~= 'number' and .0025 or config.Movement.Smooth_Stop_Min_Speed,
			-- ! SMOOTH STOP OVERHAUL - NOW AS A THRESHOLD VALUE ! --
			['Smooth_Stop_Threshold'] = typeof(config.Movement.Smooth_Stop_Threshold) == 'number' and config.Movement.Smooth_Stop_Threshold or .15, -- Distance in studs from the floor that the elevator comes to a gradual stop

			['Smooth_Stop_V2'] = {
				['Enable'] = if (typeof(config.Movement.Smooth_Stop_V2) == 'table' and typeof(config.Movement.Smooth_Stop_V2.Enable) == 'boolean') then config.Movement.Smooth_Stop_V2.Enable else false,
				['Threshold'] = if (typeof(config.Movement.Smooth_Stop_V2) == 'table' and typeof(config.Movement.Smooth_Stop_V2.Threshold) == 'number') then config.Movement.Smooth_Stop_V2.Threshold else .4,
			},

			['Overdrive_Chance_Max'] = config.Movement.Overdrive_Chance_Max or 100000000,
			['Pre_Start_Data'] = config.Movement.Pre_Start_Data or {
				['Enabled'] = false,
				['Floor_Change_Delay'] = .3,
				['Chime_Delay'] = .3,
			},
			['Motor_Sound'] = if (config.Movement.Motor_Sound == nil) then true else config.Movement.Motor_Sound,
			['Depart_Pre_Start'] = {

				['Enable'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Enable or false,
				['Delay'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Delay or .1,
				['Ignore_Start_Delay'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Ignore_Start_Delay or true,
				['Cancel_On_Door_Reopen'] = config.Movement.Depart_Pre_Start and config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen ~= nil and config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen or (not config.Movement.Depart_Pre_Start) and true or config.Movement.Depart_Pre_Start.Cancel_On_Door_Reopen,

			}, --If you enter a call while the doors are closing, the elevator ignores the start delay (like the SchindIer 5500).
			['Relevel_Tolerance'] = config.Movement.Relevel_Tolerance or .1,
			['Inspection_Start_Delay'] = {
				['Up'] = config.Movement.Inspection_Start_Delay and typeof(config.Movement.Inspection_Start_Delay) == 'table' and config.Movement.Inspection_Start_Delay.Up or config.Movement.Inspection_Start_Delay or .5,
				['Down'] = config.Movement.Inspection_Start_Delay and typeof(config.Movement.Inspection_Start_Delay) == 'table' and config.Movement.Inspection_Start_Delay.Down or config.Movement.Inspection_Start_Delay or .5,
			},

			['Inspection_Config'] = {

				['Max_Speed'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Max_Speed or config.Movement.Travel_Speed/2, --The maximum speed the elevator can travel in inspection mode
				['Accceleration_Rate'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Accceleration_Rate or config.Movement.Acceleration, --The rate of acceleration in inspection
				['Deceleration_Rate'] = config.Movement.Inspection_Config and config.Movement.Inspection_Config.Deceleration_Rate or config.Movement.Acceleration*2, --The rate of deceleration in inspection

			},
			['Level_Offset_Ratio'] = config.Movement.Level_Offset_Ratio or .2,
			['Floor_Pass_Chime_On_Stop_Config'] = {
				['Enable'] = 'UNSET',
				['Delay'] = 'UNSET',
				['Play_On_Arrival_Floor'] = 'UNSET',
			},
			['Parking_Config'] = config.Movement.Parking_Config or {

				['Enable'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Enable or false,
				['Idle_Time'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Idle_Time or 60,
				['Park_Floor'] = config.Movement.Parking_Config and config.Movement.Parking_Config.Park_Floor or 1,

			},
			['Releveling_Speed'] = typeof(config.Movement.Releveling_Speed) == 'number' and config.Movement.Releveling_Speed or config.Movement.Level_Speed,

			['Stop_Delay'] = config.Movement.Stop_Delay,

			['Open_Doors_On_Stop'] = config.Movement.Open_Doors_On_Stop,
			['Open_Doors_On_Call'] = config.Movement.Open_Doors_On_Call,

		},
		['Sensors'] = {

			['Up_Level_Offset'] = config.Sensors.Up_Level_Offset or config.Sensors.Level_Offset,
			['Down_Level_Offset'] = config.Sensors.Down_Level_Offset or config.Sensors.Level_Offset,

			['Stop_Offset'] = config.Sensors.Stop_Offset,
			['Pre_Door_Data'] = {
				['Enable'] = config.Sensors.Pre_Door,
				['Offset'] = config.Sensors.Pre_Door_Offset
			},

			['Floor_Position_Offset'] = config.Sensors.Floor_Position_Offset or 0,
			['Floor_Value_Offset'] = config.Sensors.Floor_Value_Offset or 0,

		},
		['Freight'] = {
			['Same_Floor_Call'] = {
				['With_Doors_Open'] = {
					['Enable'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Enable or false,
					['Bell'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Open and config.Freight.Same_Floor_Call.With_Doors_Open.Call_Elevator or false
				},
				['With_Doors_Closed'] = {
					['Enable'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Enable or false,
					['Bell'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Same_Floor_Call and config.Freight.Same_Floor_Call.With_Doors_Closed and config.Freight.Same_Floor_Call.With_Doors_Closed.Call_Elevator or false
				}
			},
			['Other_Floor_Call'] = {
				['With_Doors_Open'] = {
					['Enable'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Enable or false,
					['Bell'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Open and config.Freight.Other_Floor_Call.With_Doors_Open.Call_Elevator or false
				},
				['With_Doors_Closed'] = {
					['Enable'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Enable or false,
					['Bell'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Bell or false,
					['Call_Elevator'] = config.Freight and config.Freight.Other_Floor_Call and config.Freight.Other_Floor_Call.With_Doors_Closed and config.Freight.Other_Floor_Call.With_Doors_Closed.Call_Elevator or false
				}
			}
		},
		['Color_Database'] = {
			['Lanterns'] = {
				['Active_On_Door_Open'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Door_Open and config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Door_Open.Exterior.Call_Only else false,
					},
				},
				['Active_After_Door_Open'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_After_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_After_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_After_Door_Open) == 'boolean' then config.Color_Database.Lanterns.Lantern_After_Door_Open else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_After_Door_Open and config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_After_Door_Open.Exterior.Call_Only else false,
					},
				},
				['Active_On_Arrival'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Arrival) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Arrival.Exterior.Call_Only else false,
					},
				},
				['Active_On_Call_Enter'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter) == 'table' and typeof(config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Arrival) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Arrival else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Call_Enter and config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Call_Enter.Exterior.Call_Only else false,
					},
				},
				['Active_On_Button_Press'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Call_Enter) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Call_Enter else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Interior.Call_Only else false,
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Call_Enter) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Call_Enter else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Delay else 0,
						['Call_Only'] = if typeof(config.Color_Database.Lanterns.Active_On_Button_Press and config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Button_Press.Exterior.Call_Only else false,
					},
				},
				['Active_On_Exterior_Call'] = {
					['Interior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Exterior_Call) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Exterior_Call else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Interior.Call_Only else 0]],
					},
					['Exterior'] = {
						['Enable'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Enable) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Enable elseif typeof(config.Color_Database.Lanterns.Lantern_On_Exterior_Call) == 'boolean' then config.Color_Database.Lanterns.Lantern_On_Exterior_Call else false,
						['Delay'] = if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call and config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Delay) == 'number' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Delay else 0,
						['Call_Only'] = false --[[config.Color_Database.Lanterns.Active_On_Exterior_Call and if typeof(config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only) == 'boolean' then config.Color_Database.Lanterns.Active_On_Exterior_Call.Exterior.Call_Only else 0]],
					},
				},

				['Door_Distance_Reset_Ratio'] = config.Color_Database.Lanterns.Door_Distance_Reset_Ratio or 0,

				['Exterior'] = {

					['Repeat_Data'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Repeat_Data or config.Color_Database.Lanterns.Repeat_Data or {
						['Enable'] = false,
						['Times'] = 1,
						['Delay'] = .33,
						['Play_Chime_On_Light'] = false,
						['Allowed_Directions'] = {'D'} --List of elevator directions when the repeat feature is supposed to run. Available directions: U, D, N
					},

					['Up'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Up or config.Color_Database.Lanterns.Up,
					['Down'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Down or config.Color_Database.Lanterns.Down,

					['Reset_After_Door_Close'] = config.Color_Database.Lanterns.Exterior and config.Color_Database.Lanterns.Exterior.Reset_After_Door_Close,

				},
				['Interior'] = {

					['Repeat_Data'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Repeat_Data or config.Color_Database.Lanterns.Repeat_Data or {
						['Enable'] = false,
						['Times'] = 1,
						['Delay'] = .33,
						['Play_Chime_On_Light'] = false,
						['Allowed_Directions'] = {'D'} --List of elevator directions when the repeat feature is supposed to run. Available directions: U, D, N
					},

					['Up'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Up or config.Color_Database.Lanterns.Up,
					['Down'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Down or config.Color_Database.Lanterns.Down,

					['Reset_After_Door_Close'] = config.Color_Database.Lanterns.Interior and config.Color_Database.Lanterns.Interior.Reset_After_Door_Close,
				},
			},
			['Car'] = {

				['Lit_Delay'] = config.Color_Database.Car.Lit_Delay or .1,
				['Floor_Button'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Car.Floor_Button.Lit_State.Color, ['Material'] = config.Color_Database.Car.Floor_Button.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Car.Floor_Button.Neautral_State.Color, ['Material'] = config.Color_Database.Car.Floor_Button.Neautral_State.Material
					},
				},
				['Alarm_Button'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Car.Alarm_Button.Lit_State.Color, ['Material'] = config.Color_Database.Car.Alarm_Button.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Car.Alarm_Button.Neautral_State.Color, ['Material'] = config.Color_Database.Car.Alarm_Button.Neautral_State.Material
					},
				},

				['Doors'] = {

					['Open'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Open.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},
					['Close'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Close.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},
					['Hold'] = {

						['Active'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Active.Color or config.Color_Database.Car.Floor_Button.Lit_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Active.Material or config.Color_Database.Car.Floor_Button.Lit_State.Material,
						},
						['Neutral'] = {
							['Color'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Neutral.Color or config.Color_Database.Car.Floor_Button.Neautral_State.Color,
							['Material'] = config.Color_Database.Car.Doors and config.Color_Database.Car.Doors.Hold.Neutral.Material or config.Color_Database.Car.Floor_Button.Neautral_State.Material,
						}

					},

				},

				['Custom_Color_Data'] = config.Color_Database.Car.Custom_Color_Data or {},

			},
			['Floor'] = {
				['Active_Duration'] = config.Color_Database.Floor.Active_Duration or config.Color_Database.Floor.Lit_Delay or .1,
				['Up'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Floor.Up.Lit_State.Color, ['Material'] = config.Color_Database.Floor.Up.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Floor.Up.Neautral_State.Color, ['Material'] = config.Color_Database.Floor.Up.Neautral_State.Material
					},
				},
				['Down'] = {
					['Lit_State'] = {
						['Color'] = config.Color_Database.Floor.Down.Lit_State.Color, ['Material'] = config.Color_Database.Floor.Down.Lit_State.Material
					}, 
					['Neautral_State'] = {
						['Color'] = config.Color_Database.Floor.Down.Neautral_State.Color, ['Material'] = config.Color_Database.Floor.Down.Neautral_State.Material
					},
				},
			},

		},
		['Extra_Config'] = config.Extra_Config or
			{
				['Debug'] = false,
				['Enable_Parking'] = false,
				['Parking'] = {
					['Park_Floor'] = 1,
					['Park_Time'] = 1,
				},
			},
		['Locking'] = {
			['Locked_Floors'] = config.Locking and config.Locking.Locked_Floors or {},
			['Locked_Hall_Floors'] = config.Locking and config.Locking.Locked_Hall_Floors or {},
			['Disable_Door_Open_On_Locked_Floor'] = {
				['Car'] = {
					['When_Doors_Closing'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Car and config.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closing or false,
					['When_Doors_Closed'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Car and config.Locking.Disable_Door_Open_On_Locked_Floor.Car.When_Doors_Closed or false
				},
				['Hall'] = {
					['When_Doors_Closing'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closing or false,
					['When_Doors_Closed'] = config.Locking and config.Locking.Disable_Door_Open_On_Locked_Floor and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall and config.Locking.Disable_Door_Open_On_Locked_Floor.Hall.When_Doors_Closed or false
				}
			},
			['Lock_Opposite_Travel_Direction_Floors'] = config.Locking and config.Locking.Lock_Opposite_Travel_Direction_Floors or false
		},
		['Custom_Floor_Label'] = config.Custom_Floor_Label or {},
		['Camera_Force_Data'] = config.Cam_Force_Data or
			{
				['Enable'] = true, --Whether the effect is enabled or not.
				['Acceleration_Amount'] = 1, --How many times this value is multiplied by the default value.
				['Show_When_Leaving'] = true, --Whether the effect shows when the elevator accelerates (leaves a floor) or not.
				['Show_When_Leveling'] = true, --Whether the effect shows when the elevator is leveling (slowing down to a stop).
			},
		['ClientRefresh_Movement_Config'] = {
			['Enable'] = config.ClientRefresh_Movement_Config and config.ClientRefresh_Movement_Config.Enable,
			['Priority'] = 1, --Unused for now.
		},

		['Call_Limiting'] = {
			['Enable'] = if (typeof(config.Call_Limiting) == 'table' and typeof(config.Call_Limiting.Enable) == 'boolean') then config.Call_Limiting.Enable else false,
			['Max_Calls'] = if (typeof(config.Call_Limiting) == 'table' and typeof(config.Call_Limiting.Max_Calls) == 'number') then config.Call_Limiting.Max_Calls else math.huge,
		},

		['Sound_Database'] = {
			['Chime_On_Door_Open'] = config.Sound_Database.Chime_On_Door_Open,
			['Chime_After_Door_Open'] = config.Sound_Database.Chime_After_Door_Open,
			['Chime_On_Arrival'] = config.Sound_Database.Chime_On_Arrival,
			['Chime_On_Button_Press'] = config.Sound_Database.Chime_On_Button_Press,
			['Chime_On_Call_Enter'] = config.Sound_Database.Chime_On_Call_Enter,
			['Chime_On_Exterior_Call'] = config.Sound_Database.Chime_On_Exterior_Call,

			['Chime_Events'] = {

				['On_Open'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Open.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Open.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Door_Open.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Door_Open.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Door_Open.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Door_Open.Exterior.Call_Only else
							false,
					},
				},
				['After_Open'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_After_Door_Open.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_After_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_After_Door_Open.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_After_Door_Open.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_After_Door_Open) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_After_Door_Open.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_After_Door_Open) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_After_Door_Open.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_After_Door_Open.Exterior.Call_Only else
							false,
					},
				},
				['On_Arrival'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Arrival.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Arrival) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Arrival.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Arrival.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Arrival) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Arrival.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Arrival) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Arrival.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Arrival.Exterior.Call_Only else
							false,
					},
				},
				['Floor_Button_Pressed'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Call_Enter.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Call_Enter) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Call_Enter.Exterior.Call_Only else
							false,
					},
				},
				['New_Call_Input'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.New_Call_Input) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Interior) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Interior.Enable) == 'boolean') then config.Sound_Database.New_Call_Input.Interior.Enable
							elseif (typeof(config.Sound_Database.New_Call_Input) == 'boolean') then
							config.Sound_Database.New_Call_Input
							else false,

						Delay = if (typeof(config.Sound_Database.New_Call_Input) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Interior) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Interior.Delay) == 'number') then
							config.Sound_Database.New_Call_Input.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.New_Call_Input) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Interior) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.New_Call_Input.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.New_Call_Input) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Exterior) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Exterior.Enable) == 'boolean') then config.Sound_Database.New_Call_Input.Exterior.Enable
							elseif (typeof(config.Sound_Database.New_Call_Input) == 'boolean') then
							config.Sound_Database.New_Call_Input
							else false,

						Delay = if (typeof(config.Sound_Database.New_Call_Input) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Exterior) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Exterior.Delay) == 'number') then
							config.Sound_Database.New_Call_Input.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.New_Call_Input) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Exterior) == 'table' and
							typeof(config.Sound_Database.New_Call_Input.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.New_Call_Input.Exterior.Call_Only else
							false,
					},
				},
				['Exterior_Call_Only'] = {
					['Interior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Exterior_Call.Interior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Exterior_Call.Interior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Interior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call.Interior.Call_Only else
							false,
					},
					['Exterior'] = {
						Enable = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Enable) == 'boolean') then config.Sound_Database.Chime_On_Exterior_Call.Exterior.Enable
							elseif (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call
							else false,

						Delay = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Delay) == 'number') then
							config.Sound_Database.Chime_On_Exterior_Call.Exterior.Delay else
							0,
						Call_Only = if (typeof(config.Sound_Database.Chime_On_Exterior_Call) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior) == 'table' and
							typeof(config.Sound_Database.Chime_On_Exterior_Call.Exterior.Call_Only) == 'boolean') then
							config.Sound_Database.Chime_On_Exterior_Call.Exterior.Call_Only else
							false,
					},
				},

			},

			['Chime_Database'] = {
				['Interior_Up_Chime'] = {['Sound_Id'] = config.Sound_Database.Chime_Database.Up_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Chime_Database.Up_Chime.Volume, ['Pitch'] = config.Sound_Database.Chime_Database.Up_Chime.Pitch},
				['Interior_Down_Chime'] = {['Sound_Id'] = config.Sound_Database.Chime_Database.Down_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Chime_Database.Down_Chime.Volume, ['Pitch'] = config.Sound_Database.Chime_Database.Down_Chime.Pitch},
			},
			['Arrival_Chime_Database'] = {
				['Exterior_Up_Chime'] = {['Sound_Id'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Volume, ['Pitch'] = config.Sound_Database.Arrival_Chime_Database.Up_Chime.Pitch},
				['Exterior_Down_Chime'] = {['Sound_Id'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Volume, ['Pitch'] = config.Sound_Database.Arrival_Chime_Database.Down_Chime.Pitch},
			},
			['Motors'] =
				{
					['Up'] = {
						['Motor_Start_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Start.Pitch or 1},
						['Motor_Run_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Run.Pitch or 1},
						['Motor_Stop_Up'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Up.Stop.Pitch or 1},
					},
					['Down'] = {
						['Motor_Start_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Start.Pitch or 1},
						['Motor_Run_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Run.Pitch or 1},
						['Motor_Stop_Down'] = {['Sound_Id'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Sound_Id or 0, ['Volume'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Volume or 0, ['Pitch'] = config.Sound_Database.Motors and config.Sound_Database.Motors.Down.Stop.Pitch or 1},
					},
				},
			['Doors'] = {
				['Open_Sound'] = {['Sound_Id'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Sound_Id or 0, ['Volume'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Volume or 0, ['Pitch'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Open_Sound and config.Sound_Database.Doors.Open_Sound.Pitch or 0},
				['Close_Sound'] = {['Sound_Id'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Sound_Id or 0, ['Volume'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Volume or 0, ['Pitch'] = config.Sound_Database.Doors and config.Sound_Database.Doors.Close_Sound and config.Sound_Database.Doors.Close_Sound.Pitch or 0},
			},
			['Others'] = {
				['Floor_Pass_Chime'] = {['Sound_Id'] = config.Sound_Database.Others.Floor_Pass_Chime.Sound_Id, ['Volume'] = config.Sound_Database.Others.Floor_Pass_Chime.Volume, ['Pitch'] = config.Sound_Database.Others.Floor_Pass_Chime.Pitch, ['Append']=config.Sound_Database.Others.Floor_Pass_Chime.Append},
				['Nudge_Buzzer'] = {['Sound_Id'] = config.Sound_Database.Others.Nudge_Buzzer.Sound_Id, ['Volume'] = config.Sound_Database.Others.Nudge_Buzzer.Volume, ['Pitch'] = config.Sound_Database.Others.Nudge_Buzzer.Pitch},
				['Alarm'] = {['Sound_Id'] = config.Sound_Database.Others.Alarm.Sound_Id, ['Volume'] = config.Sound_Database.Others.Alarm.Volume, ['Pitch'] = config.Sound_Database.Others.Alarm.Pitch, ['Pause_On_Release'] = config.Sound_Database.Others.Alarm.Pause_On_Release},
				['Alarm_Release'] = {['Sound_Id'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Alarm_Release and config.Sound_Database.Others.Alarm_Release.Pitch or 0},
				['Button_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Button_Beep.Sound_Id, ['Volume'] = config.Sound_Database.Others.Button_Beep.Volume, ['Pitch'] = config.Sound_Database.Others.Button_Beep.Pitch},
				['Call_Button_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Sound_Id or config.Sound_Database.Others.Button_Beep.Sound_Id, ['Volume'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Volume or config.Sound_Database.Others.Button_Beep.Volume, ['Pitch'] = config.Sound_Database.Others.Call_Button_Beep and config.Sound_Database.Others.Call_Button_Beep.Pitch or config.Sound_Database.Others.Button_Beep.Pitch},

				['Button_Beep_Sound'] = {
					['Enable'] = config.Sound_Database.Others.Button_Beep_Sound and (config.Sound_Database.Others.Button_Beep_Sound.Enable ~= nil and config.Sound_Database.Others.Button_Beep_Sound.Enable or config.Sound_Database.Others.Button_Beep_Sound == nil and false or config.Sound_Database.Others.Button_Beep_Sound.Enable),
					['Delay'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Delay or 0,

					['Sound_Id'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Sound_Id or 0,
					['Volume'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Volume or 0,
					['Pitch'] = config.Sound_Database.Others.Button_Beep_Sound and config.Sound_Database.Others.Button_Beep_Sound.Pitch or 0,
				},

				['Call_Recognition_Beep'] = {['Sound_Id'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Sound_Id or 0, ['Volume'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Volume or 0, ['Pitch'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Pitch or 1, ['Delay'] = config.Sound_Database.Others.Call_Recognition_Beep and config.Sound_Database.Others.Call_Recognition_Beep.Delay or .1},
				['Door_Obstruction_Signal'] = {},
				['Door_Motor_Sound'] = {},
				['Traveling_Sound'] = {

					['Enable'] = config.Sound_Database.Others.Traveling_Sound and (config.Sound_Database.Others.Traveling_Sound.Enable ~= nil and config.Sound_Database.Others.Traveling_Sound.Enable or config.Sound_Database.Others.Traveling_Sound.Enable == nil and true) or config.Sound_Database.Others.Traveling_Sound == nil and true,
					['Sound_Id'] = config.Sound_Database.Others.Traveling_Sound and config.Sound_Database.Others.Traveling_Sound.Sound_Id or 10419439335,
					['Speed_Factor'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Speed_Factor)) and 1 or config.Sound_Database.Others.Traveling_Sound.Speed_Factor,
					['Factor_Type'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Factor_Type)) and 'Absolute_Speed' or 'Travel_Speed_Ratio',
					['Constraints'] = {
						['Volume'] = {
							['Min'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Min)) and 0 or config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Min,
							['Max'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Max)) and .2 or config.Sound_Database.Others.Traveling_Sound.Constraints.Volume.Max,
						},
						['Pitch'] = {
							['Min'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Min)) and 1 or (not config.Sound_Database.Others.Traveling_Sound.Min_Pitch) and 1 or config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Min,
							['Max'] = ((not config.Sound_Database.Others.Traveling_Sound) or (not config.Sound_Database.Others.Traveling_Sound.Constraints) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch) or (not config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Max)) and 1 or (not config.Sound_Database.Others.Traveling_Sound.Max_Pitch) and 1 or config.Sound_Database.Others.Traveling_Sound.Constraints.Pitch.Max,
						}
					},

				},
				['Safety_Brake_Sound'] = {},
				['Fire_Recall_Buzzer_Type'] = config.Sound_Database.Others.Fire_Recall_Buzzer_Type or 'Continuous', --[[
				Continuous - Buzzer plays continuously until the elevator recalls to the designated recall floor
				Repeat - Buzzer plays, then pauses, then plays again (like OTIS recall buzzers)
			]]--
				['Elevator_Stop_Beep'] = {
					['Sound_Id'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Sound_Id or 0,
					['Volume'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Volume or 0,
					['Pitch'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Pitch or 0,
					['Enable'] = config.Sound_Database.Others.Elevator_Stop_Beep and config.Sound_Database.Others.Elevator_Stop_Beep.Enable
				},
			},

			['Voice_Config'] = config.Sound_Database.Voice_Config or require(coreScript.Voice_Module.STOCK_VoiceModule),
			['Floor_Pass_Chime_Delay'] = config.Sound_Database.Floor_Pass_Chime_Delay or 0,

		}
	}
	return DefaultConfig
end]]></ProtectedString>
								<int64 name="SourceAssetId">13443177628</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="BillboardGui" referent="RBX41119B45375D403286B65DD5FCA06064">
							<Properties>
								<bool name="Active">true</bool>
								<Ref name="Adornee">null</Ref>
								<bool name="AlwaysOnTop">true</bool>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<bool name="AutoLocalize">true</bool>
								<float name="Brightness">1</float>
								<bool name="ClipsDescendants">true</bool>
								<float name="DistanceLowerLimit">0</float>
								<float name="DistanceStep">0</float>
								<float name="DistanceUpperLimit">-1</float>
								<bool name="Enabled">false</bool>
								<Vector3 name="ExtentsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="ExtentsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<float name="LightInfluence">0</float>
								<float name="MaxDistance">INF</float>
								<string name="Name">DOOR_KEY_UI</string>
								<Ref name="PlayerToHideFrom">null</Ref>
								<bool name="ResetOnSpawn">false</bool>
								<Ref name="RootLocalizationTable">null</Ref>
								<token name="SelectionBehaviorDown">0</token>
								<token name="SelectionBehaviorLeft">0</token>
								<token name="SelectionBehaviorRight">0</token>
								<token name="SelectionBehaviorUp">0</token>
								<bool name="SelectionGroup">false</bool>
								<UDim2 name="Size">
									<XS>0</XS>
									<XO>350</XO>
									<YS>0</YS>
									<YO>100</YO>
								</UDim2>
								<Vector2 name="SizeOffset">
									<X>0</X>
									<Y>0</Y>
								</Vector2>
								<int64 name="SourceAssetId">-1</int64>
								<Vector3 name="StudsOffset">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<Vector3 name="StudsOffsetWorldSpace">
									<X>0</X>
									<Y>0</Y>
									<Z>0</Z>
								</Vector3>
								<BinaryString name="Tags"></BinaryString>
								<token name="ZIndexBehavior">1</token>
							</Properties>
							<Item class="Frame" referent="RBX6DE40A195254417DA1F72AD13AA326BE">
								<Properties>
									<bool name="Active">false</bool>
									<Vector2 name="AnchorPoint">
										<X>0.5</X>
										<Y>1</Y>
									</Vector2>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="AutoLocalize">true</bool>
									<token name="AutomaticSize">0</token>
									<Color3 name="BackgroundColor3">
										<R>0.211764723</R>
										<G>0.211764723</G>
										<B>0.211764723</B>
									</Color3>
									<float name="BackgroundTransparency">0</float>
									<Color3 name="BorderColor3">
										<R>0</R>
										<G>0</G>
										<B>0</B>
									</Color3>
									<token name="BorderMode">0</token>
									<int name="BorderSizePixel">0</int>
									<bool name="ClipsDescendants">false</bool>
									<bool name="Draggable">false</bool>
									<int name="LayoutOrder">0</int>
									<string name="Name">BG</string>
									<Ref name="NextSelectionDown">null</Ref>
									<Ref name="NextSelectionLeft">null</Ref>
									<Ref name="NextSelectionRight">null</Ref>
									<Ref name="NextSelectionUp">null</Ref>
									<UDim2 name="Position">
										<XS>0.5</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>0</YO>
									</UDim2>
									<Ref name="RootLocalizationTable">null</Ref>
									<float name="Rotation">0</float>
									<bool name="Selectable">false</bool>
									<token name="SelectionBehaviorDown">0</token>
									<token name="SelectionBehaviorLeft">0</token>
									<token name="SelectionBehaviorRight">0</token>
									<token name="SelectionBehaviorUp">0</token>
									<bool name="SelectionGroup">false</bool>
									<Ref name="SelectionImageObject">null</Ref>
									<int name="SelectionOrder">0</int>
									<UDim2 name="Size">
										<XS>1</XS>
										<XO>0</XO>
										<YS>1</YS>
										<YO>-50</YO>
									</UDim2>
									<token name="SizeConstraint">0</token>
									<int64 name="SourceAssetId">-1</int64>
									<token name="Style">0</token>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Visible">true</bool>
									<int name="ZIndex">1</int>
								</Properties>
								<Item class="UICorner" referent="RBX29FD0936ABA3407DBD2FC670628CD065">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<UDim name="CornerRadius">
											<S>0</S>
											<O>10</O>
										</UDim>
										<string name="Name">UICorner</string>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
								</Item>
								<Item class="Frame" referent="RBX3D2EBF45D9FE42C49E9B0E5A1A184E3D">
									<Properties>
										<bool name="Active">true</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>0</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Slider</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">true</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">1</int>
										<UDim2 name="Size">
											<XS>0.649999976</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>3</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">2</int>
									</Properties>
									<Item class="TextButton" referent="RBX9012DD2C19E64660916AAF76149F5F60">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">false</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">3</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Button</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>35</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Button</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">1</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
									<Item class="TextButton" referent="RBXCBD192D2DB514247B02DE7E411FC5A65">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">false</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">0</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<token name="Font">3</token>
											<Font name="FontFace">
												<Family><url>rbxasset://fonts/families/SourceSansPro.json</url></Family>
												<Weight>400</Weight>
												<Style>Normal</Style>
												<CachedFaceId><url>rbxasset://fonts/SourceSansPro-Regular.ttf</url></CachedFaceId>
											</Font>
											<int name="LayoutOrder">0</int>
											<float name="LineHeight">1</float>
											<int name="MaxVisibleGraphemes">-1</int>
											<bool name="Modal">false</bool>
											<string name="Name">Select</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="RichText">false</bool>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>0</XS>
												<XO>12</XO>
												<YS>1</YS>
												<YO>35</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<string name="Text">Button</string>
											<Color3 name="TextColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<bool name="TextScaled">false</bool>
											<float name="TextSize">14</float>
											<Color3 name="TextStrokeColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<float name="TextStrokeTransparency">1</float>
											<float name="TextTransparency">1</float>
											<token name="TextTruncate">0</token>
											<bool name="TextWrapped">false</bool>
											<token name="TextXAlignment">2</token>
											<token name="TextYAlignment">1</token>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
										<Item class="UICorner" referent="RBX985E49F9F486473F995E2F776971BE06">
											<Properties>
												<BinaryString name="AttributesSerialize"></BinaryString>
												<UDim name="CornerRadius">
													<S>1</S>
													<O>0</O>
												</UDim>
												<string name="Name">UICorner</string>
												<int64 name="SourceAssetId">-1</int64>
												<BinaryString name="Tags"></BinaryString>
											</Properties>
										</Item>
									</Item>
								</Item>
								<Item class="ImageLabel" referent="RBXE038714A10EC43D69B8EDADF7C473858">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://13746787307</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Closed</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>100</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIAspectRatioConstraint" referent="RBXD746792FFEA348F0B54A72BE1582E484">
										<Properties>
											<float name="AspectRatio">1.29999995</float>
											<token name="AspectType">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="DominantAxis">1</token>
											<string name="Name">UIAspectRatioConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="ImageLabel" referent="RBXEC21EC5A6585441C97766491BE367E78">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>1</X>
											<Y>0.5</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<float name="BackgroundTransparency">1</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<Content name="Image"><url>rbxassetid://13746787390</url></Content>
										<Color3 name="ImageColor3">
											<R>1</R>
											<G>1</G>
											<B>1</B>
										</Color3>
										<Vector2 name="ImageRectOffset">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<Vector2 name="ImageRectSize">
											<X>0</X>
											<Y>0</Y>
										</Vector2>
										<float name="ImageTransparency">0</float>
										<int name="LayoutOrder">0</int>
										<string name="Name">Open</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>1</XS>
											<XO>0</XO>
											<YS>0.5</YS>
											<YO>0</YO>
										</UDim2>
										<token name="ResampleMode">0</token>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<token name="ScaleType">3</token>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>100</XO>
											<YS>0.899999976</YS>
											<YO>0</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<Rect2D name="SliceCenter">
											<min>
												<X>0</X>
												<Y>0</Y>
											</min>
											<max>
												<X>0</X>
												<Y>0</Y>
											</max>
										</Rect2D>
										<float name="SliceScale">1</float>
										<int64 name="SourceAssetId">-1</int64>
										<BinaryString name="Tags"></BinaryString>
										<UDim2 name="TileSize">
											<XS>1</XS>
											<XO>0</XO>
											<YS>1</YS>
											<YO>0</YO>
										</UDim2>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UIAspectRatioConstraint" referent="RBX49EC40DAAF7749989D4DBE83D232E40D">
										<Properties>
											<float name="AspectRatio">1.29999995</float>
											<token name="AspectType">1</token>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<token name="DominantAxis">1</token>
											<string name="Name">UIAspectRatioConstraint</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
								<Item class="Frame" referent="RBX326A0551D32245EBBC9CF7E3F3CCB04C">
									<Properties>
										<bool name="Active">false</bool>
										<Vector2 name="AnchorPoint">
											<X>0.5</X>
											<Y>1</Y>
										</Vector2>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<bool name="AutoLocalize">true</bool>
										<token name="AutomaticSize">0</token>
										<Color3 name="BackgroundColor3">
											<R>0.211764723</R>
											<G>0.211764723</G>
											<B>0.211764723</B>
										</Color3>
										<float name="BackgroundTransparency">0</float>
										<Color3 name="BorderColor3">
											<R>0</R>
											<G>0</G>
											<B>0</B>
										</Color3>
										<token name="BorderMode">0</token>
										<int name="BorderSizePixel">0</int>
										<bool name="ClipsDescendants">false</bool>
										<bool name="Draggable">false</bool>
										<int name="LayoutOrder">0</int>
										<string name="Name">Top</string>
										<Ref name="NextSelectionDown">null</Ref>
										<Ref name="NextSelectionLeft">null</Ref>
										<Ref name="NextSelectionRight">null</Ref>
										<Ref name="NextSelectionUp">null</Ref>
										<UDim2 name="Position">
											<XS>0.5</XS>
											<XO>0</XO>
											<YS>0</YS>
											<YO>13</YO>
										</UDim2>
										<Ref name="RootLocalizationTable">null</Ref>
										<float name="Rotation">0</float>
										<bool name="Selectable">false</bool>
										<token name="SelectionBehaviorDown">0</token>
										<token name="SelectionBehaviorLeft">0</token>
										<token name="SelectionBehaviorRight">0</token>
										<token name="SelectionBehaviorUp">0</token>
										<bool name="SelectionGroup">false</bool>
										<Ref name="SelectionImageObject">null</Ref>
										<int name="SelectionOrder">0</int>
										<UDim2 name="Size">
											<XS>0</XS>
											<XO>50</XO>
											<YS>0</YS>
											<YO>50</YO>
										</UDim2>
										<token name="SizeConstraint">0</token>
										<int64 name="SourceAssetId">-1</int64>
										<token name="Style">0</token>
										<BinaryString name="Tags"></BinaryString>
										<bool name="Visible">true</bool>
										<int name="ZIndex">1</int>
									</Properties>
									<Item class="UICorner" referent="RBXBE0CDA965B014BE98E3DA9AAA472D562">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<UDim name="CornerRadius">
												<S>0</S>
												<O>10</O>
											</UDim>
											<string name="Name">UICorner</string>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
									<Item class="ImageButton" referent="RBX4E85B338D99A4F7396E1357DFEEBB0E8">
										<Properties>
											<bool name="Active">true</bool>
											<Vector2 name="AnchorPoint">
												<X>0.5</X>
												<Y>0.5</Y>
											</Vector2>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<bool name="AutoButtonColor">true</bool>
											<bool name="AutoLocalize">true</bool>
											<token name="AutomaticSize">0</token>
											<Color3 name="BackgroundColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<float name="BackgroundTransparency">1</float>
											<Color3 name="BorderColor3">
												<R>0</R>
												<G>0</G>
												<B>0</B>
											</Color3>
											<token name="BorderMode">0</token>
											<int name="BorderSizePixel">0</int>
											<bool name="ClipsDescendants">false</bool>
											<bool name="Draggable">false</bool>
											<Content name="HoverImage"><null></null></Content>
											<Content name="Image"><url>rbxassetid://13745395147</url></Content>
											<Color3 name="ImageColor3">
												<R>1</R>
												<G>1</G>
												<B>1</B>
											</Color3>
											<Vector2 name="ImageRectOffset">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<Vector2 name="ImageRectSize">
												<X>0</X>
												<Y>0</Y>
											</Vector2>
											<float name="ImageTransparency">0</float>
											<int name="LayoutOrder">0</int>
											<bool name="Modal">false</bool>
											<string name="Name">Button</string>
											<Ref name="NextSelectionDown">null</Ref>
											<Ref name="NextSelectionLeft">null</Ref>
											<Ref name="NextSelectionRight">null</Ref>
											<Ref name="NextSelectionUp">null</Ref>
											<UDim2 name="Position">
												<XS>0.5</XS>
												<XO>0</XO>
												<YS>0.5</YS>
												<YO>0</YO>
											</UDim2>
											<Content name="PressedImage"><null></null></Content>
											<token name="ResampleMode">0</token>
											<Ref name="RootLocalizationTable">null</Ref>
											<float name="Rotation">0</float>
											<token name="ScaleType">3</token>
											<bool name="Selectable">true</bool>
											<bool name="Selected">false</bool>
											<token name="SelectionBehaviorDown">0</token>
											<token name="SelectionBehaviorLeft">0</token>
											<token name="SelectionBehaviorRight">0</token>
											<token name="SelectionBehaviorUp">0</token>
											<bool name="SelectionGroup">false</bool>
											<Ref name="SelectionImageObject">null</Ref>
											<int name="SelectionOrder">0</int>
											<UDim2 name="Size">
												<XS>1</XS>
												<XO>-15</XO>
												<YS>1</YS>
												<YO>-15</YO>
											</UDim2>
											<token name="SizeConstraint">0</token>
											<Rect2D name="SliceCenter">
												<min>
													<X>0</X>
													<Y>0</Y>
												</min>
												<max>
													<X>0</X>
													<Y>0</Y>
												</max>
											</Rect2D>
											<float name="SliceScale">1</float>
											<int64 name="SourceAssetId">-1</int64>
											<token name="Style">0</token>
											<BinaryString name="Tags"></BinaryString>
											<UDim2 name="TileSize">
												<XS>1</XS>
												<XO>0</XO>
												<YS>1</YS>
												<YO>0</YO>
											</UDim2>
											<bool name="Visible">true</bool>
											<int name="ZIndex">1</int>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="LocalScript" referent="RBXC4C3517F4B044522AED0D05DF0AA1024">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Disabled">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">CLIENT</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{75CD2599-F214-4307-8BEE-2E1331030384}</string>
									<ProtectedString name="Source"><![CDATA[local this = script.Parent
local remote = this:WaitForChild('RemoteEvent')
local ratio = this:WaitForChild('RATIO')
local player = game.Players.LocalPlayer
local camera = workspace.CurrentCamera
local draggableUI = require(script:WaitForChild('DraggableUI'))
local uis = game:GetService('UserInputService')
local mouse = player:GetMouse()

local doorSet = this:WaitForChild('DOOR_SET').Value or this:WaitForChild('DOOR_SET'):GetPropertyChangedSignal('Value'):Wait()

local slider,select = this.BG.Slider,this.BG.Slider.Select

local delta = Vector2.zero
local dragInput,startPos,dragStart
select.InputBegan:Connect(function(input)
	if (input.UserInputType == Enum.UserInputType.MouseButton1) then
		player:GetMouse().Icon = 'rbxasset://SystemCursors/PointingHand'
		dragInput = input
		dragStart = uis:GetMouseLocation()
		startPos = select.Position.X.Offset
		input.Changed:Connect(function()
			if (input.UserInputState == Enum.UserInputState.End) then
				dragInput = nil
				player:GetMouse().Icon = [[ ]]
			end
		end)
	end
end)
uis.InputChanged:Connect(function(input: InputObject)
	if (dragInput) then
		if (uis.MouseBehavior ~= Enum.MouseBehavior.Default) then
			delta += uis:GetMouseDelta()*3.5
		else
			delta = uis:GetMouseLocation()-dragStart
		end
		select.Position = UDim2.new(0, math.clamp(startPos+delta.X, 0, slider.AbsoluteSize.X), .5, 0)
	end
end)

this.BG.Top.Button.MouseButton1Down:Connect(function()
	local elevator = (doorSet:FindFirstAncestor('Car') or doorSet:FindFirstAncestor('Floors')).Parent
	if (not elevator) then return end
	elevator.Cortex_Remote:FireServer('exit',doorSet)
end)

local active = false
uis.InputBegan:Connect(function(input: InputObject, gameProcessed: boolean)
	if (gameProcessed) then return end
	if (input.KeyCode == Enum.KeyCode.LeftControl) then
		local zoom = (camera.CFrame.Position-camera.Focus.Position).Magnitude
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = zoom,zoom
		active = true
	elseif (input.KeyCode == Enum.KeyCode.R) then
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = game.StarterPlayer.CameraMinZoomDistance,game.StarterPlayer.CameraMaxZoomDistance
		active = false
		local elevator = (doorSet:FindFirstAncestor('Car') or doorSet:FindFirstAncestor('Floors')).Parent
		if (not elevator) then return end
		elevator.Cortex_Remote:FireServer('exit',doorSet)
	end
end)
local lastTick = tick()
uis.InputChanged:Connect(function(input: InputObject)
	if (input.UserInputType == Enum.UserInputType.MouseWheel and active) then
		if (input.Position.Z == 1 or input.Position.Z == -1) then
			local t = math.clamp((tick()-lastTick),0,.2)
			lastTick = tick()
			game:GetService('TweenService'):Create(select,TweenInfo.new(t,Enum.EasingStyle.Linear,Enum.EasingDirection.Out),{Position=UDim2.fromOffset(math.clamp(select.Position.X.Offset+input.Position.Z*7.5,0,slider.AbsoluteSize.X),0)}):Play()
		end
	end
end)
uis.InputEnded:Connect(function(input: InputObject)
	if (input.KeyCode == Enum.KeyCode.LeftControl) then
		player.CameraMinZoomDistance,player.CameraMaxZoomDistance = game.StarterPlayer.CameraMinZoomDistance,game.StarterPlayer.CameraMaxZoomDistance
		active = false
	end
end)

select:GetPropertyChangedSignal('Position'):Connect(function()
	remote:FireServer('UPDATE_RATIO_VALUE',select.Position.X.Offset/slider.AbsoluteSize.X,0,1)
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
								<Item class="ModuleScript" referent="RBXBC27100A570E463F80B96C2800277766">
									<Properties>
										<BinaryString name="AttributesSerialize"></BinaryString>
										<Content name="LinkedSource"><null></null></Content>
										<string name="Name">DraggableUI</string>
										<string name="ScriptGuid">{F48E87DC-B434-4ECE-9AB6-C2BB2B46E438}</string>
										<ProtectedString name="Source"><![CDATA[local Signal = require(script.Signal)

local TweenService = game:GetService("TweenService")
local PlayerObject = game:GetService("Players").LocalPlayer
local UserInputService = game:GetService("UserInputService")

local Mouse = PlayerObject:GetMouse()
local Camera = workspace.CurrentCamera
local PlayerGui = PlayerObject:WaitForChild("PlayerGui")

local listOfDraggable = {}

local function ValidateParametersValue(UI: GuiObject, byScale: boolean?)
	if not UI then
		error("First argument must not be empty!")
	end

	if not (typeof(UI) == "Instance") then
		error("First argument must be a type of instance!")
	end

	if not (typeof(byScale) == "boolean") then
		error("Second argument must be a type of boolean!")
	end
end

local function IsMouseOrTouch(input: InputObject, isMouseMovement: boolean?): boolean
	return input.UserInputType
		== (if isMouseMovement then Enum.UserInputType.MouseMovement else Enum.UserInputType.MouseButton1)
		or input.UserInputType == Enum.UserInputType.Touch
end

local function GetDominantObject(list: { Instance }): GuiObject
	local dominant = math.huge
	local guiObject: GuiObject

	for _, value in ipairs(listOfDraggable) do
		local index = table.find(list, value._UI)

		if index and index < dominant then
			dominant = index
			guiObject = value._UI
		end
	end

	return guiObject
end

local DraggableUI = {}
DraggableUI.__index = DraggableUI
DraggableUI.__tostring = function()
	return "Draggable"
end

function DraggableUI.new(UI: GuiObject, byScale: true?)
	byScale = byScale or true
	ValidateParametersValue(UI, byScale)

	local self = setmetatable({
		_Released = Signal.new(),
		_Started = Signal.new(),
		_Moved = Signal.new(),

		_Connections = {},
		_Overlapping = {
			Disabled = false,
		},
		_LimitBoundingBox = {
			Enabled = false,
			Type = 0,
		},

		_TweenInfo = false,
		_UI = UI,
	}, DraggableUI)

	self.Released = self._Released.Event
	self.Started = self._Started.Event
	self.Moved = self._Moved.Event

	local success, result = pcall(self._Initialize, self, UI, byScale)

	if not success then
		error(("Something went wrong: %s"):format(result))
	end

	table.insert(listOfDraggable, self)
	return self
end

function DraggableUI:_Initialize(UI: GuiObject, byScale: boolean)
	local startPosition = UI.AbsolutePosition
	local dragStartPosition = UserInputService:GetMouseLocation()

	local mouseOnUI = false
	local button1Down = false

	table.insert(
		self._Connections,
		UI.MouseEnter:Connect(function()
			mouseOnUI = true
		end)
	)

	table.insert(
		self._Connections,
		UI.MouseLeave:Connect(function()
			mouseOnUI = false
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputBegan:Connect(function(input)
			if IsMouseOrTouch(input) and mouseOnUI then
				local list = PlayerGui:GetGuiObjectsAtPosition(Mouse.X, Mouse.Y)

				if #list >= 2 then
					if not (GetDominantObject(list) == UI) then
						return
					end
				end

				for _, value in pairs(self._Overlapping) do
					if value then
						return
					end
				end

				startPosition = UI.AbsolutePosition + (UI.AbsoluteSize * UI.AnchorPoint) - UI.Parent.AbsolutePosition
				dragStartPosition = UserInputService:GetMouseLocation()
				button1Down = true

				self._Started:Fire()
			end
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputEnded:Connect(function(input)
			if IsMouseOrTouch(input) and button1Down then
				button1Down = false
				self._Released:Fire(UserInputService:GetMouseLocation())
			end
		end)
	)

	table.insert(
		self._Connections,
		UserInputService.InputChanged:Connect(function(input)
			if IsMouseOrTouch(input, true) and button1Down then
				local mousePosition = UserInputService:GetMouseLocation()
				local delta = mousePosition - dragStartPosition
				local parentSize = UI.Parent.AbsoluteSize
				local position = startPosition + delta

				position = self:_LimitPosition(UI, position, parentSize)

				if not byScale then
					position = UDim2.fromOffset(position.X, position.Y)
				else
					position /= parentSize
					position = UDim2.fromScale(position.X, position.Y)
				end

				if self._TweenInfo then
					TweenService:Create(UI, self._TweenInfo, { Position = position }):Play()
				else
					UI.Position = position
				end

				self._Moved:Fire(mousePosition)
			end
		end)
	)
end

function DraggableUI:_LimitPosition(UI: GuiObject, position: Vector2, parentSize: Vector2)
	if self._LimitBoundingBox.Enabled then
		local offset = (UI.AbsoluteSize * UI.AnchorPoint)
		local uiSize = UI.AbsoluteSize

		if self._LimitBoundingBox.Type == 0 then
			local screenSize = Camera.ViewportSize
			local max = (screenSize - uiSize) + offset

			return Vector2.new(math.clamp(position.X, offset.X, max.X), math.clamp(position.Y, offset.Y, max.Y))
		else
			local max = (parentSize - uiSize) + offset

			return Vector2.new(math.clamp(position.X, offset.X, max.X), math.clamp(position.Y, offset.Y, max.Y))
		end
	end

	return position
end

function DraggableUI:_Ignore(UI: GuiObject)
	table.insert(
		self._Connections,
		UI.MouseEnter:Connect(function()
			self._Overlapping[UI] = true
		end)
	)

	table.insert(
		self._Connections,
		UI.MouseLeave:Connect(function()
			self._Overlapping[UI] = nil
		end)
	)
end

function DraggableUI:LimitScreenBoundingBox(byParent: false?, value: boolean?): boolean
	local limitBoundingBox = self._LimitBoundingBox
	byParent = byParent or false

	limitBoundingBox.Type = if byParent then 1 else 0
	limitBoundingBox.Enabled = if typeof(value) == "boolean" then value else not limitBoundingBox.Enabled

	return limitBoundingBox.Enabled
end

function DraggableUI:Toggle(value: boolean?): boolean
	local overlapping = self._Overlapping
	overlapping.Disabled = if typeof(value) == "boolean" then value else not overlapping.Disabled

	return overlapping.Disabled
end

function DraggableUI:SetTweenInfo(tweenInfo: TweenInfo)
	if not (typeof(tweenInfo) == "TweenInfo") then
		error("Argument must be a type of TweenInfo!")
	end

	self._TweenInfo = tweenInfo
end

function DraggableUI:Ignore(list: { Instance }, instanceCheck: false?)
	instanceCheck = instanceCheck or false

	if not (typeof(list) == "table") then
		error("First argument must be a type of table!")
	end

	if not (typeof(instanceCheck) == "boolean") then
		error("Second argument must be a type of boolean!")
	end

	local success = pcall(function()
		if instanceCheck then
			for _, object in ipairs(list) do
				pcall(function()
					self:_Ignore(object)
				end)
			end
		else
			for _, object in ipairs(list) do
				self:_Ignore(object)
			end
		end
	end)

	if not success then
		error("It seems that the array contained a none type of GuiObject")
	end
end

function DraggableUI:IgnoreChildren()
	self:Ignore(self._UI:GetChildren(), true)
end

function DraggableUI:IgnoreDescendants()
	self:Ignore(self._UI:GetDescendants(), true)
end

function DraggableUI:Destroy()
	for _, connection: RBXScriptSignal in ipairs(self._Connections) do
		if typeof(connection) == "RBXScriptSignal" then
			connection:Disconnect()
		end
	end

	for key, _ in pairs(self._IgnoreList) do
		self._IgnoreList[key] = nil
	end

	self._Released:Destroy()
	self._Started:Destroy()
	self._Moved:Destroy()

	table.remove(listOfDraggable, table.find(listOfDraggable, self))
	table.clear(self)
end

setmetatable(DraggableUI, {
	__index = function(_, key)
		error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,

	__newindex = function(_, key)
		error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
	end,
})

export type Draggable = {
	LimitScreenBoundingBox: (self: { Draggable }, byParent: false?, value: boolean?) -> boolean,
	Ignore: (self: { Draggable }, list: { Frame | Instance }, instanceCheck: false?) -> (),
	SetTweenInfo: (self: { Draggable }, tweenInfo: TweenInfo) -> (),
	Toggle: (self: { Draggable }, value: boolean?) -> boolean,
	IgnoreDescendants: (self: { Draggable }) -> (),
	IgnoreChildren: (self: { Draggable }) -> (),
	Destroy: (self: { Draggable }) -> (),

	Released: Signal.Event,
	Started: Signal.Event,
	Moved: Signal.Event,
}

return DraggableUI :: {
	new: (UI: Instance, byScale: true?) -> Draggable,
}
]]></ProtectedString>
										<int64 name="SourceAssetId">11263101887</int64>
										<BinaryString name="Tags"></BinaryString>
									</Properties>
									<Item class="ModuleScript" referent="RBX858FE7240CE14FEF89392B1F8176AB17">
										<Properties>
											<BinaryString name="AttributesSerialize"></BinaryString>
											<Content name="LinkedSource"><null></null></Content>
											<string name="Name">Signal</string>
											<string name="ScriptGuid">{15BF2180-A665-4D49-B268-64C72BEE0CE7}</string>
											<ProtectedString name="Source"><![CDATA[local Signal = {}
Signal.__index = Signal
Signal.__tostring = function()
	return "Signal"
end

Signal.Event = {} :: {
	Connect: (self: { RBXScriptSignal }) -> RBXScriptConnection,
	Once: (self: { RBXScriptSignal }) -> RBXScriptConnection,
	Wait: (self: { RBXScriptSignal }) -> ...any,
}
Signal.Event.__index = Signal.Event
Signal.Event.__tostring = function()
	return "Event"
end

local Connection = {}
Connection.__index = Connection
Connection.__tostring = function()
	return "Connection"
end

local function DisableTableIndex(Table: {})
	setmetatable(Table, {
		__index = function(_, key)
			error(("Attempt to get Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,

		__newindex = function(_, key)
			error(("Attempt to set Connection::%s (not a valid member)"):format(tostring(key)), 2)
		end,
	})
end

Connection.__eq = function(self, other)
	return self._Handler == other._Handler
end

function Connection.new(Parent: {}, Handler: any): RBXScriptConnection
	return setmetatable({
		_Handler = Handler,
		_Parent = Parent,
	}, Connection)
end

function Connection:Disconnect()
	local Position = table.find(self._Parent, self)

	if Position then
		table.remove(self._Parent, Position)
	end
end

function Connection:_Fire(...)
	self._Handler(...)
end

function Signal.new()
	return setmetatable({}, Signal)
end

function Signal.Event:Connect(Handler: any): RBXScriptConnection
	local self: RBXScriptConnection = self
	local _Connection = Connection.new(self, Handler)

	table.insert(self, _Connection)

	return _Connection
end

function Signal.Event:Once(Handler: any): RBXScriptConnection
	local self: RBXScriptConnection = self

	local Fired = false
	local Connection

	Connection = self:Connect(function(...)
		if Fired then
			return
		end

		Fired = true
		Connection:Disconnect()
		Handler(...)
	end)

	return Connection
end

function Signal.Event:Wait(): ...any
	local self: RBXScriptConnection = self

	local Result = coroutine.running()
	local Fired = false
	local Connection

	Connection = self:Connect(function(...)
		if Fired then
			return
		end

		Fired = true
		Connection:Disconnect()
		task.spawn(Result, ...)
	end)

	return coroutine.yield()
end

function Signal:DisconnectAll()
	local self: RBXScriptConnection = self

	for _, Handler in ipairs(self.Event) do
		coroutine.wrap(Handler.Disconnect)(Handler)
	end
end

function Signal:Fire(...: any)
	local self: RBXScriptConnection = self
	local args = { ... }

	for _, Handler in ipairs(self.Event) do
		coroutine.wrap(Handler._Fire)(Handler, unpack(args))
	end
end

function Signal:Destroy()
	local self: RBXScriptConnection = self

	self:DisconnectAll()
	table.clear(self)
end

DisableTableIndex(Signal)
DisableTableIndex(Connection)
DisableTableIndex(Signal.Event)

export type Event = {
	Connect: (self: { Event }, func: (...any) -> ()) -> RBXScriptConnection,
	Once: (self: { Event }, func: (...any) -> ()) -> RBXScriptConnection,
	Wait: (self: { Event }) -> ...any,
}

export type Signal = {
	new: (
	) -> {
		Event: Event,
		Destroy: (self: { Signal }) -> (),
		Fire: (self: { Signal }, ...any) -> (),
		DisconnectAll: (self: { Signal }) -> (),
	},
}

return Signal :: Signal
]]></ProtectedString>
											<int64 name="SourceAssetId">-1</int64>
											<BinaryString name="Tags"></BinaryString>
										</Properties>
									</Item>
								</Item>
							</Item>
							<Item class="RemoteEvent" referent="RBXF848C5DC78774AFBAB5C91BCA1223F7A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">RemoteEvent</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="Script" referent="RBX92374DFF3A7A46A28A42A7AE53C140B3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<bool name="Disabled">false</bool>
									<Content name="LinkedSource"><null></null></Content>
									<string name="Name">SERVER</string>
									<token name="RunContext">0</token>
									<string name="ScriptGuid">{4A480959-4698-4365-A8BC-20E82E7D2347}</string>
									<ProtectedString name="Source"><![CDATA[local Connection
Connection = script.Parent.AncestryChanged:Connect(function()
	if script:IsDescendantOf(game.Players) then
		Connection:Disconnect()
	end
	local player = script:FindFirstAncestorOfClass('Player')
	script.Parent.RemoteEvent.OnServerEvent:Connect(function(user,protocol,params)
		if (protocol == 'UPDATE_RATIO_VALUE' and user == player) then
			script.Parent.RATIO.Value = params
		end
	end)
end)]]></ProtectedString>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX812AC8A9D863400EAD71BDABF69332F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">RATIO</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="ObjectValue" referent="RBX228BB7D448E44E2780A8D99064453DAD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">DOOR_SET</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<Ref name="Value">null</Ref>
								</Properties>
							</Item>
						</Item>
					</Item>
					<Item class="ModuleScript" referent="RBX63D9CAFE2B964E19AC36BEFC5EC2283D">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Voice_Module</string>
							<string name="ScriptGuid">{5A59C239-8BFA-459D-ACB3-682D32F34150}</string>
							<ProtectedString name="Source"><![CDATA[local voiceModule = {}
voiceModule.__index = voiceModule

function voiceModule.new(voiceSettings)
	local self = setmetatable(voiceModule, {})
	
	self.voiceSettings = voiceSettings
	
	return self
end

function voiceModule:PlayClip(voiceAudio, clip, pauseThread)
	
	if (not voiceAudio) then return warn('Cortex Voice voiceModule: No sound instance supplied!') end
	if (not clip) then return warn('Cortex Voice voiceModule: No voice clip supplied!') end
	
	local function run()
		voiceAudio.SoundId = clip.SoundId and "rbxassetid://" .. (clip.SoundId) or "rbxassetid://" .. (self.voiceSettings.SoundId)
		voiceAudio.Volume = clip.Volume and clip.Volume or self.voiceSettings.Volume
		voiceAudio.Pitch = clip.Pitch and clip.Pitch or self.voiceSettings.Pitch
		voiceAudio.TimePosition = clip.Start or 0
		voiceAudio:Play()
		local clipEnd = clip.End or voiceAudio.TimeLength
		while (voiceAudio.IsPlaying and voiceAudio.TimePosition < clipEnd) do game:GetService('RunService').Heartbeat:Wait() end
		voiceAudio:Stop()
		
	end
	
	if (pauseThread) then
		run()
	else
		task.spawn(run)
	end
	
end

return voiceModule]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX0239640DDEC64D2D999328F3698F6EBE">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">STOCK_VoiceModule</string>
								<string name="ScriptGuid">{060A24FF-58FC-4A85-A1D7-EAAD6C2FCDA3}</string>
								<ProtectedString name="Source"><![CDATA[return {

	['SoundId'] = 8492151402;
	['Volume'] = 2;
	['Pitch'] = 1;

	['Voice_Clips'] = {
		
		--[[ Options
			['SoundId'] = Id - Optional
			['Start'] = number -- If not provided it will default to 0
			['End'] = number -- If not provided it will default to clip time length
			['Volume'] = number - Optional
			['Pitch'] = number - Optional
			
			Optional options fallback to the main values at the top of the script if not present
		]]

		--//Floors\\--
		['1st'] = {['Start']=36.709, ['End']=37.334};
		['2nd'] = {['Start']=37.505, ['End']=38.086};
		['3rd'] = {['Start']=38.364, ['End']=38.903};
		['4th'] = {['Start']=39.142, ['End']=39.771};
		['5th'] = {['Start']=39.892, ['End']=40.430};

		--//Labels\\--
		['Floor'] = {['Start']=12.788, ['End']=13.360};
		['Level'] = {['Start']=14.657, ['End']=15.129};
		['Level_Suffix'] = {['Start']=67.700, ['End']=68.209};

		['Lobby'] = {['Start']=66.186, ['End']=66.749};
		['Parking'] = {['Start']=168.366, ['End']=168.992};

		--//Door Announcements\\--
		['Doors_Opening'] = {['Start']=165.380, ['End']=166.381};
		['Doors_Closing'] = {['Start']=166.678, ['End']=167.763};
		['Please_Remove_Obstruction'] = {['Start']=162.309, ['End']=164.397};

		--//Directional Announcements\\--
		['Going_Up'] = {['Start']=159.886, ['End']=160.686};
		['Going_Down'] = {['Start']=160.903, ['End']=161.741};

		--//Other Destination Dispatch Messages\\--
		['Select_Destination'] = {['Start']=0.022, ['End']=1.672};
		['Take_Car'] = {['Start']=1.800, ['End']=2.652};
		['Please_Scan_Access_Card'] = {['Start']=2.986, ['End']=4.469};
		['Handicap_Message'] = {['Start']=5.259, ['End']=10.653};
		['Fire_Recall'] = {['Start']=11.302, ['End']=12.227};
		['Through'] = {['Start']=15.645, ['End']=16.340};
		['And'] = {['Start']=16.456, ['End']=16.968};
		['Going_To'] = {['Start']=13.545, ['End']=14.371};

		--//DESTINATION DISPATCH LETTERING\\--
		['A'] = {['Start']=18.888, ['End']=19.326};
		['B'] = {['Start']=19.524, ['End']=19.889};
		['C'] = {['Start']=20.050, ['End']=20.543};
		['D'] = {['Start']=20.860, ['End']=21.293};
		['E'] = {['Start']=21.585, ['End']=22.033};
		['F'] = {['Start']=22.253, ['End']=22.651};
		['G'] = {['Start']=22.928, ['End']=23.366};
		['H'] = {['Start']=23.391, ['End']=24.578};

		--//FLOOR NUMBERS\\--
		['1'] = {['Start']=111.744, ['End']=112.268};
		['2'] = {['Start']=112.517, ['End']=113.019};
		['3'] = {['Start']=113.325, ['End']=113.942};

	};

	['Floor_Announcements'] = { --To add a voice segment for a floor, add: {{'Segment', ['Delay'] = .1}}
		['1'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'1', ['Delay'] = 0}};
		['2'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'2', ['Delay'] = 0}};
		['3'] = {{'Lobby', ['Delay'] = 0}, {'Level', ['Delay'] = 0}, {'3', ['Delay'] = 0}};
	};
	['Settings'] = {

		['Floor_Announcements'] = {
			['Announce_Floor_On_Arrival'] = true; --Announces the floor the elevators arriving on
			['Announce_Floor_On_Stop'] = false; --Announces the floor the elevators on when the car comes to a full stop
		};
		['Directional_Announcements'] = {
			['Announce_After_Floor_Announcement'] = false; --Announces the direction after the floor announcement
			['Announce_After_Door_Open'] = true; --Announces the direction after the doors have fully opened
			['Up_Announcement'] = {['Enabled'] = true; ['Sequence'] = {{'Going_Up', ['Delay'] = 0}}};
			['Down_Announcement'] = {['Enabled'] = true; ['Sequence'] = {{'Going_Down', ['Delay'] = 0}}};
		};
		['Door_Announcements'] = {
			['Open_Announcement'] = {['Enabled'] = false; ['Sequence'] = {{'Doors_Opening', ['Delay'] = 0}}};
			['Close_Announcement'] = {['Enabled'] = false; ['Sequence'] = {{'Doors_Closing', ['Delay'] = 0}}};
			['Nudge_Announcement'] = {['Enabled'] = true; ['Sequence'] = {{'Please_Remove_Obstruction', ['Delay'] = 0}}};
		};
		['Other_Announcements'] = {
			['Independent_Service_Announcement'] = {['Enabled'] = true; ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Fire_Recall_Announcement'] = {['Enabled'] = true; ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}},
			['Safety_Brake_Announcement'] = {['Enabled'] = true; ['Sequence'] = {{'Out_Of_Service', ['Delay'] = 0}}}
		};

	};

};]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC100BF2CE779471FB09BADB219D1580C">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">DefaultVoiceModule</string>
								<string name="ScriptGuid">{8FD003E0-7455-41AF-8EAA-4205D984B3B0}</string>
								<ProtectedString name="Source"><![CDATA[return function (config, source)
	if config.Voice_Config or config.Options then
		warn("-----------------------------------------------")
		warn("CORTEX VOICE CONFIG: Old config detected!")
		if config.Voice_Config then
			warn("Please rename 'Voice_Config' to 'Floor_Announcements'")
		end
		if config.Options then
			warn("Please rename 'Options' to 'Settings'")
		end
		warn("Or replace the whole file with the updated version")
		warn("Elevator location: " .. (source:GetFullName()))
		warn("-----------------------------------------------")
	end
	return {
		['SoundId'] = config.SoundId and config.SoundId or config.Voice_ID and config.Voice_ID or 0,
		['Volume'] = config.Volume and config.Volume or 1,
		['Pitch'] = config.Pitch and config.Pitch or 1,

		['Voice_Clips'] = config.Voice_Clips and config.Voice_Clips or {},
		['Floor_Announcements'] = config.Floor_Announcements and config.Floor_Announcements or config.Voice_Config and config.Voice_Config or {},

		['Settings'] = {
			['Floor_Announcements'] = {
				['Announce_Floor_On_Arrival'] = config.Settings and config.Settings.Floor_Announcements and config.Settings.Floor_Announcements.Announce_Floor_On_Arrival or false, --Announces the floor the elevators arriving on
				['Announce_Floor_On_Stop'] = config.Settings and config.Settings.Floor_Announcements and config.Settings.Floor_Announcements.Announce_Floor_On_Stop or false, --Announces the floor the elevators on when the car comes to a full stop
			},

			['Directional_Announcements'] = {
				['Announce_After_Floor_Announcement'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Announce_After_Floor_Announcement or false, --Announces the direction after the floor announcement
				['Announce_After_Door_Open'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Announce_After_Door_Open or false, --Announces the direction after the doors have fully opened
				['Up_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Up_Announcement and config.Settings.Directional_Announcements.Up_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Up_Announcement and config.Settings.Directional_Announcements.Up_Announcement.Sequence or {},
				},
				['Down_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Down_Announcement and config.Settings.Directional_Announcements.Down_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Directional_Announcements and config.Settings.Directional_Announcements.Down_Announcement and config.Settings.Directional_Announcements.Down_Announcement.Sequence or {},
				},
			},

			['Door_Announcements'] = {
				['Open_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Open_Announcement and config.Settings.Door_Announcements.Open_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Open_Announcement and config.Settings.Door_Announcements.Open_Announcement.Sequence or {},
				},
				['Close_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Close_Announcement and config.Settings.Door_Announcements.Close_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Close_Announcement and config.Settings.Door_Announcements.Close_Announcement.Sequence or {},
				},
				['Nudge_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Nudge_Announcement and config.Settings.Door_Announcements.Nudge_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Door_Announcements and config.Settings.Door_Announcements.Nudge_Announcement and config.Settings.Door_Announcements.Nudge_Announcement.Sequence or {},
				},
			},

			['Other_Announcements'] = {
				['Independent_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Independent_Service_Announcement and config.Settings.Other_Announcements.Independent_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Independent_Service_Announcement and config.Settings.Other_Announcements.Independent_Service_Announcement.Sequence or {},
				},
				['Fire_Recall_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Fire_Recall_Announcement and config.Settings.Other_Announcements.Fire_Recall_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Fire_Recall_Announcement and config.Settings.Other_Announcements.Fire_Recall_Announcement.Sequence or {},
				},
				['Safety_Brake_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Safety_Brake_Announcement and config.Settings.Other_Announcements.Safety_Brake_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Safety_Brake_Announcement and config.Settings.Other_Announcements.Safety_Brake_Announcement.Sequence or {},
				},
				['Inspection_Service_Announcement'] = {
					['Enabled'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Inspection_Service_Announcement and config.Settings.Other_Announcements.Inspection_Service_Announcement.Enabled or false,
					['Sequence'] = config.Settings and config.Settings.Other_Announcements and config.Settings.Other_Announcements.Inspection_Service_Announcement and config.Settings.Other_Announcements.Inspection_Service_Announcement.Sequence or {},
				}
			};
		},
	}
end]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
					<Item class="Folder" referent="RBX9A42464DF0894795951CFB11B5134C0B">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<string name="Name">Core_Modules_INTERNAL</string>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="ModuleScript" referent="RBX03950346D6CA4CEBB143B95B43FAD4AB">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Storage</string>
								<string name="ScriptGuid">{E11E82FC-6135-44FC-9142-26BCF4F9248D}</string>
								<ProtectedString name="Source"><![CDATA[local storage = {}
local mainStorage = {}

function storage:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE)
	--INDICATOR THAT THE PLUGIN IS READY TO INITIATE

	function storage:save(branch, key, value, options: {OVERWRITE: boolean | 'Overwrite existing content if keys are the same?'}, callback: any) --Saves the given data to the key in the given branch key name. Function: Master.(branch?).(key?) : {?} -> saved = Master -> branch -> key : {content}
		options = typeof(options) == 'table' and options or {OVERWRITE=true}
		local keyData = mainStorage[branch]
		if (not keyData) then mainStorage[branch] = {} end
		if (((not options.OVERWRITE) and (not mainStorage[branch][key])) or options.OVERWRITE) then
			mainStorage[branch][key] = value
			--warn("Saved data under branch " .. (branch) .. " in key " .. (key))
			if (typeof(callback) == 'function') then
				callback({BRANCH=branch,KEY=key,CONTENT=value})
			end
			return value
		end
		if (typeof(callback) == 'function') then
			callback({BRANCH=branch,KEY=key,CONTENT='NONE'})
		end
		return
	end
	function storage:get(branch, key) --Returns the stored data content using both the given branch & sub-branch key. Format: Master -> branch -> key : {content}
		local keyData = mainStorage[branch]
		if (not keyData) then return end
		return keyData[key]
	end
	function storage:getContentInBranch(branch) --Returns stored data content using the given branch key. Format: Master -> branch : {content}
		--storage.ContentLoaded:Fire({BRANCH=branch,KEY=nil,CONTENT=mainStorage[branch]})
		return mainStorage[branch]
	end
	return true
end

return storage]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX34286BE3087846F8B8D60F2C88A648D7">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Core_Functions</string>
								<string name="ScriptGuid">{3A946AEA-0837-413C-99B4-86F6B18D8BC1}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module:lerp(a: number, b: number, t: number)
	return a+(b-a)*t
end
function module:getDecelerationRate(initialSpeed: number, finalSpeed: number, distance: number)
	local si,sf = initialSpeed^2,finalSpeed^2
	local d2 = si-sf
	return math.abs(d2/math.deg(2*distance))
end
function module:getAccelerationTime(prevSpeed: number, speed: number, acceleration: number)
	return math.abs((speed-prevSpeed)/math.deg(acceleration))
end
function module:conditionalStepWait(duration: number, breakStatements: any)
	duration = math.clamp(duration, 0, math.huge)
	local startTick = tick()
	local function checkStatements()
		for i,v in pairs((breakStatements and typeof(breakStatements) == 'function') and breakStatements() or {}) do
			if (v) then return true end
		end
		return false
	end
	if (checkStatements()) then return false,(tick()-startTick) end
	while ((tick()-startTick)/duration < 1) do
		if (checkStatements()) then return false,(tick()-startTick) end
		HEARTBEAT:Wait()
	end
	return true,(tick()-startTick)
end
function module:getTableLength(t: any) --THIS IS USED FOR TABLES WITH INDEXES THAT ARE NOT NUMBERS -- #t DOES NOT WORK
	if (typeof(t) ~= 'table') then return end
	local length = 0
	for i,v in pairs(t) do
		length += 1
	end
	return length
end

function module.smoothstep(min: number, max: number, value: number)
	local t = math.clamp((value-min)/(max-min), 0, 1)
	return t*t*(3-2*t)
end

function module.addInstance(append: Instance, type: string, name: string, replaceWithSameName: boolean?, properties: any)
	if (typeof(append) ~= 'Instance') then return end
	if (typeof(type) ~= 'string') then return end
	local result = (if typeof(replaceWithSameName) == 'boolean' then (not replaceWithSameName) else false) and append:FindFirstChild(name)
	if (not result) then
		result = Instance.new(type)
		result.Parent = append
		result.Name = name
		for i,v in pairs(properties) do
			pcall(function()
				result[i] = v
			end)
		end
	end
	return result
end

function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE)

end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBXC65675982CB140EDAD96605BC310BBDE">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Signal</string>
								<string name="ScriptGuid">{26D5DE88-3482-445A-843E-FD410335058F}</string>
								<ProtectedString name="Source"><![CDATA[local HttpsService = game:GetService("HttpService")

local Signal = {}
Signal.__index = Signal

function Signal:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

local function IsFunction(func)
	if typeof(func) ~= "function" then
		error(string.format("invalid argument #1 (function expected got %s)", typeof(func)))
	end
end

function Signal.new()
	return setmetatable({
		_connections = {},
	}, Signal)
end

function Signal:Once(func)
	IsFunction(func)

	local once = nil

	once = self:Connect(function(...)
		once:Disconnect()

		func(...)
	end)

	return once
end

function Signal:Connect(func)
	IsFunction(func)

	local connection = {
		_name = HttpsService:GenerateGUID(),
		_func = func,
		_connected = true,
	}

	self._connections[connection._name] = connection

	function connection:Disconnect()
		connection._connected = false
	end

	connection.disconnect = connection.Disconnect

	return connection
end

function Signal:Wait()
	local yield = coroutine.running()

	self:Once(function(...)
		task.spawn(yield, ...)
	end)

	return coroutine.yield()
end

function Signal:Fire(...: any)
	for i, connection in pairs(self._connections) do
		if connection._connected then
			IsFunction(connection._func)

			connection._func(...)
		else
			local index = table.find(self._connections, connection._name)

			table.remove(self._connections, index)
		end
	end
end

function Signal:Destroy()
	for i, connection in pairs(self._connections) do
		connection:Disconnect()
	end
	
	self._connections = {}
end

Signal.New = Signal.new
Signal.connect = Signal.Connect
Signal.wait = Signal.Wait
Signal.fire = Signal.Fire
Signal.once = Signal.Once
Signal.destroy = Signal.Destroy

return Signal]]></ProtectedString>
								<int64 name="SourceAssetId">10568398310</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX650351D541104770832CB06EEF15A450">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMA</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Legacy_Easing</string>
								<string name="ScriptGuid">{37998A6A-2C03-43CD-8E6F-76BBAB915409}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE) end --SILENCES INITIATION ERRORS

module.easingStyles = {
	['Linear'] = {Enum.EasingStyle.Linear, Enum.EasingDirection.InOut},
	['In_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.In},
	['Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.Out},
	['In_Out_Sine'] = {Enum.EasingStyle.Sine, Enum.EasingDirection.InOut},
	['In_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.In},
	['Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.Out},
	['In_Out_Quad'] = {Enum.EasingStyle.Quad, Enum.EasingDirection.InOut},
	['In_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.In},
	['Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.Out},
	['In_Out_Quart'] = {Enum.EasingStyle.Quart, Enum.EasingDirection.InOut},
	['In_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.In},
	['Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.Out},
	['In_Out_Back'] = {Enum.EasingStyle.Back, Enum.EasingDirection.InOut},
	['In_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.In},
	['Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.Out},
	['In_Out_Bounce'] = {Enum.EasingStyle.Bounce, Enum.EasingDirection.InOut},
	['In_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.In},
	['Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.Out},
	['In_Out_Circular'] = {Enum.EasingStyle.Circular, Enum.EasingDirection.InOut},
	['In_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.In},
	['Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.Out},
	['In_Out_Cubic'] = {Enum.EasingStyle.Cubic, Enum.EasingDirection.InOut},
	['In_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.In},
	['Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.Out},
	['In_Out_Elastic'] = {Enum.EasingStyle.Elastic, Enum.EasingDirection.InOut},
	['In_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.In},
	['In_Out_Exponential'] = {Enum.EasingStyle.Exponential, Enum.EasingDirection.Out},
	['In_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.In},
	['Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.Out},
	['In_Out_Quint'] = {Enum.EasingStyle.Quint, Enum.EasingDirection.InOut},
}
module.easingStyles.functions = {
	--Linear
	Linear = function(t, b, c, d)
		return c * t / d + b 
	end,

	--Quad
	In_Quad = function(t, b, c, d) 
		return c * math.pow(t / d, 2) + b 
	end,

	Out_Quad = function(t, b, c, d)
		t = t / d
		return -c * t * (t - 2) + b
	end,

	In_Out_Quad = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 2) + b end
		return -c / 2 * ((t - 1) * (t - 3) - 1) + b
	end,

	Out_In_Quad = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuad(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuad((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Cubic
	In_Cubic = function(t, b, c, d) 
		return c * math.pow(t / d, 3) + b 
	end,

	Out_Cubic = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 3) + 1) + b 
	end,

	In_Out_Cubic = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * t * t * t + b end
		t = t - 2
		return c / 2 * (t * t * t + 2) + b
	end,

	Out_In_Cubic = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCubic(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCubic((t * 2) - d, b + c / 2, c / 2, d)
	end,


	--Quart

	On_Quart = function(t, b, c, d) 
		return c * math.pow(t / d, 4) + b 
	end,

	Out_Quart = function(t, b, c, d) 
		return -c * (math.pow(t / d - 1, 4) - 1) + b 
	end,

	In_Out_Quart = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 4) + b end
		return -c / 2 * (math.pow(t - 2, 4) - 2) + b
	end,

	Out_In_Quart = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuart(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuart((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Quint

	In_Quint = function(t, b, c, d)
		return c * math.pow(t / d, 5) + b 
	end,

	Out_Quint = function(t, b, c, d) 
		return c * (math.pow(t / d - 1, 5) + 1) + b 
	end,

	In_Out_Quint = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(t, 5) + b end
		return c / 2 * (math.pow(t - 2, 5) + 2) + b
	end,

	Out_In_Quint = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outQuint(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inQuint((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Sine

	In_Sine = function(t, b, c, d) 
		return -c * math.cos(t / d * (math.pi / 2)) + c + b 
	end,

	Out_Sine = function(t, b, c, d) 
		return c * math.sin(t / d * (math.pi / 2)) + b 
	end,

	In_Out_Sine = function(t, b, c, d) 
		return -c / 2 * (math.cos(math.pi * t / d) - 1) + b 
	end,

	Out_In_Sine = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outSine(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inSine((t * 2) -d, b + c / 2, c / 2, d)
	end,

	--Expo

	In_Expo = function(t, b, c, d)
		if t == 0 then return b end
		return c * math.pow(2, 10 * (t / d - 1)) + b - c * 0.001
	end,

	Out_Expo = function(t, b, c, d)
		if t == d then return b + c end
		return c * 1.001 * (-math.pow(2, -10 * t / d) + 1) + b
	end,

	In_Out_Expo = function(t, b, c, d)
		if t == 0 then return b end
		if t == d then return b + c end
		t = t / d * 2
		if t < 1 then return c / 2 * math.pow(2, 10 * (t - 1)) + b - c * 0.0005 end
		return c / 2 * 1.0005 * (-math.pow(2, -10 * (t - 1)) + 2) + b
	end,

	Out_In_Expo = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outExpo(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inExpo((t * 2) - d, b + c / 2, c / 2, d)
	end,

	--Circ

	In_Circ = function(t, b, c, d) 
		return(-c * (math.sqrt(1 - math.pow(t / d, 2)) - 1) + b) 
	end,

	Out_Circ = function(t, b, c, d)  
		return(c * math.sqrt(1 - math.pow(t / d - 1, 2)) + b) 
	end,

	In_Out_Circ = function(t, b, c, d)
		t = t / d * 2
		if t < 1 then return -c / 2 * (math.sqrt(1 - t * t) - 1) + b end
		t = t - 2
		return c / 2 * (math.sqrt(1 - t * t) + 1) + b
	end,

	Out_In_Circ = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outCirc(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inCirc((t * 2) - d, b + c / 2, c / 2, d)
	end,



	--Back
	Out_Back = function(t, b, c, d, s)
		s = s or 1.2
		t = t / d - 1
		return c * (t * t * ((s + 1) * t + s) + 1) + b
	end,

	In_Back = function(t, b, c, d, s)
		s = s or 1.70158
		t = t / d
		return c * t * t * ((s + 1) * t - s) + b
	end,

	In_Out_Back = function(t, b, c, d, s)
		s = (s or 1.70158) * 1.525
		t = t / d * 2
		if t < 1 then return c / 2 * (t * t * ((s + 1) * t - s)) + b end
		t = t - 2
		return c / 2 * (t * t * ((s + 1) * t + s) + 2) + b
	end,

	Out_In_Back = function(t, b, c, d, s)
		if t < d / 2 then return module.easingStyles.types.outBack(t * 2, b, c / 2, d, s) end
		return module.easingStyles.types.inBack((t * 2) - d, b + c / 2, c / 2, d, s)
	end,

	--bounce

	Out_Bounce = function(t, b, c, d)
		t = t / d
		if t < 1 / 2.75 then return c * (7.5625 * t * t) + b end
		if t < 2 / 2.75 then
			t = t - (1.5 / 2.75)
			return c * (7.5625 * t * t + 0.75) + b
		elseif t < 2.5 / 2.75 then
			t = t - (2.25 / 2.75)
			return c * (7.5625 * t * t + 0.9375) + b
		end
		t = t - (2.625 / 2.75)
		return c * (7.5625 * t * t + 0.984375) + b
	end,

	In_Bounce = function(t, b, c, d) 
		return c - module.easingStyles.types.outBounce(d - t, 0, c, d) + b 
	end,

	In_Out_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.inBounce(t * 2, 0, c, d) * 0.5 + b end
		return module.easingStyles.types.outBounce(t * 2 - d, 0, c, d) * 0.5 + c * .5 + b
	end,

	Out_In_Bounce = function(t, b, c, d)
		if t < d / 2 then return module.easingStyles.types.outBounce(t * 2, b, c / 2, d) end
		return module.easingStyles.types.inBounce((t * 2) - d, b + c / 2, c / 2, d)
	end,
}

local function checkBreakStatements(statements)
	for i,v in pairs((statements and typeof(statements) == 'function') and statements() or {}) do
		if (v) then return true end
	end
	return false
end

local codeName = 'InterpolationCode'

function module:interpolate(weld: Weld, c0: CFrame, c1: CFrame, easingStyle: any, duration: number, breakStatements: any)
	easingStyle = easingStyle or 'Linear'
	easingStyle = module.easingStyles.functions[easingStyle] or module.easingStyles.functions.Linear
	local newCode = tostring(math.random(0,1e5))
	weld:SetAttribute(codeName, newCode)
	local startTime = os.clock()
	local startC0 = weld.C0
	local startC1 = weld.C1
	local oldCode = weld:GetAttribute(codeName)
	local alpha = 0
	while (alpha <= 1 and weld.C0 ~= c0) do
		alpha = math.clamp(((os.clock()-startTime)/duration), 0, 1)
		weld.C0 = startC0:Lerp(c0, easingStyle(alpha, 0, 1, 1))
		weld.C1 = startC1:Lerp(c1, easingStyle(alpha, 0, 1, 1))
		oldCode = weld:GetAttribute(codeName)
		if (oldCode ~= newCode or checkBreakStatements(breakStatements)) then return false end
		HEARTBEAT:Wait()
	end
	return true
end

return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
						<Item class="ModuleScript" referent="RBX932123DDD355416582588502E0E163A6">
							<Properties>
								<BinaryString name="AttributesSerialize">AQAAAAsAAABvdmVycmlkYWJsZQMB</BinaryString>
								<Content name="LinkedSource"><null></null></Content>
								<string name="Name">Door_Engine</string>
								<string name="ScriptGuid">{D05F0F65-26B8-4498-B95E-F813E7D5D805}</string>
								<ProtectedString name="Source"><![CDATA[local module = {}
local doorEngineClass = {}
doorEngineClass.__index = doorEngineClass
doorEngineClass.ClassName = 'doorEngineClass'

local HEARTBEAT = _G.Cortex_SERVER.EVENTS.RUNTIME_EVENT.EVENT

function module:INITIATE_PLUGIN_INTERNAL(CORE, SOURCE)
	local storage = require(CORE.Core_Modules_INTERNAL:WaitForChild('Storage'))
	local signal = require(CORE.Core_Modules_INTERNAL:WaitForChild('Signal'))
	local coreFunctions = require(CORE.Core_Modules_INTERNAL:WaitForChild('Core_Functions'))
	local legacyEasing = require(CORE.Core_Modules_INTERNAL:WaitForChild('Legacy_Easing'))

	local runService = game:GetService('RunService')
	local collectionService = game:GetService('CollectionService')

	module.INTERNAL_STORAGE = {} --DO NOT TOUCH! INTERNAL STORAGE FOR THE MODULE

	--IMPORTING CORE FUNCTIONS FOR SHARED USE--
	local function getAccelerationTime(...)
		return coreFunctions:getAccelerationTime(...)
	end
	local function getDecelerationRate(...)
		return coreFunctions:getDecelerationRate(...)
	end
	local function lerp(...)
		return coreFunctions:lerp(...)
	end
	local function conditionalStepWait(...)
		return coreFunctions:conditionalStepWait(...)
	end
	local function getTableLength(...)
		return coreFunctions:getTableLength(...)
	end

	function module.new(side, data)
		local self = setmetatable({}, doorEngineClass)
		----------------------------------------------------
		self.doorTimerTick = 0
		self.nudgeTimerTick = 0
		self.nudgeTick = 0
		self.state = 'Closed'
		self.stopped = false
		self.isKeyed = false
		self.side = side
		self.delaying = false
		self.nudging = false
		self.doorHold = false
		self.valueInstances = {
			doorStateValue = data.values.doorStateValue,
			doorSpeedValue = data.values.doorSpeedValue
		}
		self.sounds = {
			doorMotorSound = data.sounds.doorMotorSound,
			doorOpenSound = data.sounds.doorOpenSound,
			doorCloseSound = data.sounds.doorCloseSound
		}
		self.isObstructed = false
		self.nudgeStop = false
		self.engineWelds = {car={},floors={}}
		self.doorTimerLength = {}
		self.config = data.config
		self.sensorLEDs = {}
		self.alpha = {inner=0,outer=0}
		self.velocity = {inner=0,outer=0}
		self.currentStage = {inner=1,outer=1}
		self.masterWeld = {inner={},outer={}}
		self.decelerating = {inner=false,outer=false}
		self.startTick = {inner=nil,outer=nil}
		self.decelTime = {inner=nil,outer=nil}
		self.prevSpeed = {inner=nil,outer=nil}
		self.prevDist = {inner=nil,outer=nil}
		self.lastVel = {inner=nil,outer=nil}
		self.delayTick = {inner=nil,outer=nil}
		self.doorSensorPart = data.doorSensorPart
		self.lanternsReset = false
		self.doorSet = data.doorSet

		--Door event listeners--
		self.Opening = signal.new()
		self.Opened = signal.new()

		self.Closing = signal.new()
		self.Closed = signal.new()
		self.LanternsReset = signal.new()

		--Door state internal functions--
		function self.updateDoorState(state)
			self.valueInstances.doorStateValue.Value = state
			self.state = state
		end
		function self.getDoorState()
			return self.state
		end
		function self.checkWelds(floor: number, target: string, threshold: number, checkFloorWelds: boolean?)
			for i,v in next,self.engineWelds do
				for i,w in next,(i == 'car' and self.engineWelds.car or (checkFloorWelds and self.engineWelds.floors[tostring(floor)]) or {}) do
					for i,w2 in next,w do
						if ((w2[target].Position-w2.instance.C0.Position).Magnitude > threshold) then return false end
					end
				end
			end
			return true
		end
		----------------------------------------------------

		self.statisticValues = storage:get('mainElevatorData', 'legacy')
		self.getAccelerationTime = storage:get('mainElevatorData', 'getAccelerationTime')
		self.findFloor = storage:get('mainElevatorData', 'findFloor')
		self.car = storage:get('mainElevatorData', 'car')

		function self:Open(floor: number, onOpened: (any?) -> any?)
			local startingState = self.state
			local rawFloor = floor
			local thisFloor = self.findFloor(rawFloor)
			--if ((startingState ~= 'Closed' and startingState ~= 'Closing' and startingState ~= 'Stopped') or ((not car:FindFirstChild("{self.side == '' and '' or "{self.side}_"}Doors")) or (not thisFloor:FindFirstChild("{self.side == '' and '' or "{self.side}_"}Doors")))) then return end
			self.Opening:Fire()
			self.updateDoorState('Opening')

			local duration = self.config.Doors.Door_Open_Speed
			if (not thisFloor) then return warn("Floor not found! " .. (rawFloor)) end
			local distanceFactor = 0
			for i,w in next,self.engineWelds do
				local newTable = (i == 'car' and self.engineWelds.car[self.side] or {})
				for i,weld in next,newTable do
					distanceFactor = math.clamp(distanceFactor+((weld:getCurrentDistance()/weld.distanceFromOpenPosition)/(getTableLength(self.engineWelds)*getTableLength(newTable))*2), .15, 1)
				end
			end
			---
			self.sounds.doorCloseSound:Stop()
			task.spawn(function()
				if (startingState == 'Closed') then
					local isCompleted = conditionalStepWait(self.config.Doors.Door_Open_Sound_Delay, function()
						return {self.state ~= 'Opening'}
					end)
					if (not isCompleted) then return end
				end
				self.sounds.doorOpenSound.TimePosition = (self.sounds.doorOpenSound.TimeLength*(1-distanceFactor))
				task.wait()
				self.sounds.doorOpenSound:Play()
			end)
			---
			local isCompleted = conditionalStepWait(startingState == 'Closed' and self.config.Doors.Open_Delay or startingState == 'Closing' and self.config.Doors.Reopen_Delay or 0, function()
				return {self.state ~= 'Opening'}
			end)
			if (not isCompleted) then return end

			local function runDoor(_types: {string})
				for i,doorType in pairs(typeof(_types) == 'table' and _types or {}) do
					for i,w in next,self.engineWelds do
						local newIndex = i == 'car' and 'Inner' or 'Outer'
						if (newIndex == doorType) then
							if (newIndex == 'Inner' or (newIndex == 'Outer' and (not self.config.Doors.New_Attachment_Doors_Config.Enable))) then
								local indexLower = string.lower(newIndex)
								local newWeldsList = (i == 'car' and self.engineWelds.car[self.side] or self.engineWelds.floors[tostring(rawFloor)] and self.engineWelds.floors[tostring(rawFloor)][self.side] or {})
								local floorWelds = self.engineWelds.floors[tostring(rawFloor)] and self.engineWelds.floors[tostring(rawFloor)][self.side]
								local setupConfig = self.config.Doors.Custom_Door_Operator_Config[newIndex].Opening
								if (setupConfig and setupConfig.Enable) then
									task.spawn(function()
										local distance = 0
										for i,v in next,newWeldsList do
											if ((v.openPosition.Position-v.closedPosition.Position).Magnitude >= distance and v.side == self.side and ((newIndex == 'Inner' and v.instance:IsDescendantOf(self.car)) or (newIndex == 'Outer' and v.instance:IsDescendantOf(thisFloor)))) then
												self.masterWeld[indexLower] = v
												distance = (v.openPosition.Position-v.closedPosition.Position).Magnitude
											end
										end
										if (not self.masterWeld[indexLower]) then return end
										local targetPosition = self.masterWeld[indexLower].openPosition
										local startTime = os.clock()
										local startC0 = self.masterWeld[indexLower].closedPosition

										local speed = math.clamp((distance/duration), 1, math.huge)
										local minSpeed = math.clamp(setupConfig.Minimum_Speed or .05, 0, speed)

										if (startingState == 'Closed' and self.config.Doors.New_Attachment_Doors_Config.Enable) then
											if (typeof(floorWelds) == 'table') then
												local function getEngineWeld(part: BasePart?)
													for _,v in pairs(floorWelds) do
														if (v.instance.Part0 == part) then return v end
													end
													return nil
												end
												local params = RaycastParams.new()
												params.FilterType = Enum.RaycastFilterType.Whitelist
												local list = {}
												for _,weld in pairs(floorWelds) do
													table.insert(list, weld.instance.Part0)
												end
												params.FilterDescendantsInstances = list
												for _,weld in pairs(self.engineWelds.car[self.side]) do
													local result = workspace:Blockcast(CFrame.new(weld.instance.Part0.CFrame.Position), Vector3.new(0, weld.instance.Part0.Size.Y, 0), (thisFloor.Level.Position-self.car.Level.Position).Unit*5, params)
													if ((not result) or (not result.Instance)) then continue end
													weld.floorDoorWeld = getEngineWeld(result.Instance)
												end
											end
										end

										local accelerationTime = self.getAccelerationTime(self.velocity[indexLower], speed, setupConfig.Acceleration)
										local stageAccelTime
										local startLerpTime = os.clock()
										local lastStageTick = startLerpTime
										local distOffset = math.clamp(setupConfig.Deceleration_Offset, 0, math.huge)

										self.decelerating[indexLower] = false
										self.velocity[indexLower] = -self.velocity[indexLower]
										self.lastVel[indexLower] = nil
										self.delayTick[indexLower] = nil
										local startVelocity = self.velocity[indexLower]
										if (startingState ~= 'Closed') then
											self.currentStage[indexLower] = typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and #setupConfig.Custom_Acceleration_Stages
										end

										local lastTick,delta = os.clock(),0
										local multi,multi2 = 0,0
										local reachedMinSpeed = false
										local function updateDoorSpeed()
											if (indexLower == 'inner') then
												self.valueInstances.doorSpeedValue.Value = math.abs(self.velocity[indexLower])
											elseif (indexLower == 'outer') then
												local doorSpeed = thisFloor:FindFirstChild(side ~= '' and side.."_" or ''.."Door_Speed")
												if (doorSpeed) then
													doorSpeed.Value = math.abs(self.velocity[indexLower])
												end
											end
										end
										
										local delta = 0
										while (self.alpha[indexLower] < 1 and self.masterWeld[indexLower].instance) do
											local thisDist = (targetPosition.Position-self.masterWeld[indexLower].instance.C0.Position).Magnitude
											local thisDistCheck = (thisDist/distance) <= setupConfig.Deceleration_Distance*(math.clamp((self.velocity[indexLower])/speed, 0, 1))
											local thisStage = typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and setupConfig.Custom_Acceleration_Stages[self.currentStage[indexLower]]
											if ((not thisDistCheck) and (not self.decelerating[indexLower])) then
												if (thisStage) then
													local thisAcceleration = thisStage.Acceleration == 'USE_ACCELERATION' and setupConfig.Acceleration or thisStage.Acceleration
													if (not stageAccelTime) then
														self.lastVel[indexLower] = self.velocity[indexLower]
														self.delayTick[indexLower] = os.clock()
														stageAccelTime = self.getAccelerationTime(self.lastVel[indexLower], math.clamp(thisStage.Speed, 0, speed), thisAcceleration)
														multi = 0
													end
													if ((not self.lastVel[indexLower]) or (not self.delayTick[indexLower]) or (not stageAccelTime)) then continue end
													local stageSpeed = math.clamp(thisStage.Speed, 0, speed)
													if (stageAccelTime) then
														if ((not thisStage.Acceleration_Rate) or (not thisStage.Acceleration_Rate.Rate) or thisStage.Acceleration_Rate.Rate == 'Constant') then
															self.velocity[indexLower] = lerp(self.lastVel[indexLower],stageSpeed, math.clamp((os.clock()-lastStageTick)/stageAccelTime, 0, 1))
														elseif (thisStage.Acceleration_Rate.Rate == 'Gradual') then
															local rate = 1/math.deg(thisStage.Acceleration_Rate.Gradual_Duration)
															multi = math.clamp(multi+rate*math.deg(delta), 0, 1)
															self.velocity[indexLower] = math.clamp(self.velocity[indexLower]+thisAcceleration*multi*math.deg(delta), -stageSpeed, stageSpeed)
														end
													end
													if (stageAccelTime and math.clamp((os.clock()-lastStageTick)/stageAccelTime, 0, 1) < 1 and (not thisStage.Ignore_Acceleration_Duration)) then
														self.delayTick[indexLower] = os.clock()
													elseif (self.delayTick[indexLower] and (os.clock()-self.delayTick[indexLower])/thisStage.Delay_Before_Next_Stage >= 1 and typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and setupConfig.Custom_Acceleration_Stages[self.currentStage[indexLower]+1]) then
														lastStageTick = os.clock()
														self.currentStage[indexLower] = math.clamp(self.currentStage[indexLower]+1, 1, math.huge)
														stageAccelTime = nil
													end
													self.currentStage[indexLower] = math.clamp(self.currentStage[indexLower], 0, typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and #setupConfig.Custom_Acceleration_Stages or math.huge)
												else
													if (((not setupConfig.Acceleration_Rate) or (not setupConfig.Acceleration_Rate.Rate) or setupConfig.Acceleration_Rate.Rate == 'Constant')) then
														self.velocity[indexLower] = lerp(self.lastVel[indexLower] or startVelocity, speed, math.clamp((os.clock()-startLerpTime)/accelerationTime, 0, 1))
													elseif (setupConfig.Acceleration_Rate.Rate == 'Gradual') then
														local rate = 1/math.deg(thisStage.Acceleration_Rate.Gradual_Duration)
														multi2 = math.clamp(multi2+rate*math.deg(delta), 0, 1)
														self.velocity[indexLower] = math.clamp(self.velocity[indexLower]+setupConfig.Acceleration*multi2*math.deg(delta), -speed, speed)
													end
												end
												self.velocity[indexLower] = math.clamp(self.velocity[indexLower], -speed, speed)
											end
											if (thisDistCheck or self.decelerating[indexLower] and (not reachedMinSpeed)) then
												local distOff = thisDist-distOffset
												if (not self.decelerating[indexLower]) then
													self.decelerating[indexLower] = true
													self.prevDist[indexLower] = distOff
													self.prevSpeed[indexLower] = math.abs(self.velocity[indexLower])
													self.startTick[indexLower] = os.clock()
												end
												if (setupConfig.Deceleration_Rate == 'Exponential') then
													self.velocity[indexLower] = math.clamp((self.prevSpeed[indexLower]/self.prevDist[indexLower])*distOff, minSpeed, speed)
												elseif (setupConfig.Deceleration_Rate == 'Constant') then
													local currentSpeed = self.velocity[indexLower]
													local deceleration = currentSpeed^2/(2*math.max(.001, distOff))
													local SPEED = math.max(0, currentSpeed-deceleration*delta)
													self.velocity[indexLower] = math.max(minSpeed, SPEED)
												end
												if (self.velocity[indexLower] <= minSpeed) then reachedMinSpeed = true end
											end
											self.alpha[indexLower] = math.min(1, self.alpha[indexLower]+(((self.velocity[indexLower]/speed)/duration))*delta)
											if (self.config.Doors.New_Attachment_Doors_Config.Enable) then
												for _,weld in pairs(self.engineWelds.car[self.side]) do
													_.C0 = weld.closedPosition:Lerp(weld.openPosition, self.alpha[indexLower])
													if (weld.floorDoorWeld) then
														local data = floorWelds[weld.floorDoorWeld.instance]
														if (data) then
															local goal = CFrame.new(self.config.Doors.New_Attachment_Doors_Config.Attachment_Threshold,0,0)*(data.closedPosition:Lerp(data.openPosition, self.alpha[indexLower]))
															weld.floorDoorWeld.instance.C0 = CFrame.new(
																math.clamp(goal.X,data.openPosition.X >= data.closedPosition.X and data.closedPosition.X or data.openPosition.X,data.openPosition.X <= data.closedPosition.X and data.closedPosition.X or data.openPosition.X),
																math.clamp(goal.Y,data.openPosition.Y >= data.closedPosition.Y and data.closedPosition.Y or data.openPosition.Y,data.openPosition.Y <= data.closedPosition.Y and data.closedPosition.Y or data.openPosition.Y),
																math.clamp(goal.Z,data.openPosition.Z >= data.closedPosition.Z and data.closedPosition.Z or data.openPosition.Z,data.openPosition.Z <= data.closedPosition.Z and data.closedPosition.Z or data.openPosition.Z)
															)
														end
													end
												end
											else
												for i,weld in next,newWeldsList do
													if ((indexLower == 'inner' and weld.instance:IsDescendantOf(self.car)) or (indexLower == 'outer' and weld.instance:IsDescendantOf(thisFloor))) then
														weld.instance.C0 = weld.closedPosition:Lerp(weld.openPosition, math.clamp(self.alpha[indexLower], 0, 1))
													end
												end
											end
											if (self.state ~= 'Opening' and self.state ~= 'Open') then
												self.velocity[indexLower] = 0
												self.sounds.doorOpenSound:Stop()
												self.sounds.doorCloseSound:Stop()
												task.spawn(updateDoorSpeed)
												break
											end
											task.spawn(updateDoorSpeed)
											if (self.checkWelds(rawFloor, 'openPosition', .05) and self.state == 'Opening') then
												self.updateDoorState('Open')
												if (typeof(onOpened) == 'function') then task.spawn(onOpened) end
												self.Opened:Fire()
											end
											delta = HEARTBEAT:Wait()
										end
										task.wait()
										if (self.checkWelds(rawFloor, 'openPosition', .05) and self.state == 'Opening') then
											self.updateDoorState('Open')
											if (typeof(onOpened) == 'function') then task.spawn(onOpened) end
											self.Opened:Fire()
										end
										if (self.state ~= 'Open') then return end
										self.valueInstances.doorSpeedValue.Value = 0
										for i,v in next,self.velocity do
											self.velocity[i] = 0
											self.decelerating[i] = false
										end
										task.spawn(updateDoorSpeed)
									end)
								end
							end
						end
					end
				end
			end
			if (self.config.Doors.Door_Delay_Sequence_Config.Opening.Enable) then
				if (self.state ~= 'Opening') then return end
				task.spawn(function()
					for i,part in ipairs(self.config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) do
						runDoor({part})
						local hasCompleted = conditionalStepWait(self.config.Doors.Door_Delay_Sequence_Config.Opening.Delay, function()
							return {self.state ~= 'Opening'}
						end)
						if (not hasCompleted) then return end
					end
				end)
			else
				runDoor({'Inner','Outer'})
			end
		end

		function self:Close(floor: number, NUDGE: boolean?, onClosed: (any?) -> any?)
			local startingState = self.state
			local rawFloor = floor
			local thisFloor = self.findFloor(rawFloor)
			if (not thisFloor) then return warn("Floor not found! " .. (rawFloor)) end
			--if ((startingState ~= 'Open' and startingState ~= 'Stopped') or ((not self.car:FindFirstChild("{self.side == '' and '' or "{self.side}_"}Doors")) or (not thisFloor:FindFirstChild("{self.side == '' and '' or "{self.side}_"}Doors")))) then return end
			self.Closing:Fire()
			self.updateDoorState('Closing')
			---
			self.sounds.doorOpenSound:Stop()
			task.spawn(function()
				local isCompleted = conditionalStepWait(self.config.Doors.Door_Close_Sound_Delay, function()
					return {self.state ~= 'Closing'}
				end)
				if (not isCompleted) then return end
				self.sounds.doorCloseSound:Play()
			end)
			---
			for i,w in next,self.engineWelds do
				local newIndex = i == 'car' and 'Interior' or 'Exterior'
				if (self.config.Color_Database.Lanterns[newIndex] and (not self.config.Color_Database.Lanterns[newIndex].Reset_After_Door_Close)) then
					self.lanternsReset = true
					self.LanternsReset:Fire()
				end
			end
			local duration = NUDGE and (self.config.Doors.Nudge_Speed or self.config.Doors.Door_Close_Speed*1.5) or self.config.Doors.Door_Close_Speed
			local distanceFactor = 0
			for i,w in next,self.engineWelds do
				local newTable = (i == 'car' and self.engineWelds.car[self.side] or {})
				for i,weld in next,newTable do
					distanceFactor = math.clamp(distanceFactor+(((weld.closedPosition.Position-weld.instance.C0.Position).Magnitude/weld.distanceFromOpenPosition)/(getTableLength(self.engineWelds)*getTableLength(newTable))*2), .15, 1)
				end
			end
			--duration = duration*(tonumber(distanceFactor) or 1)
			local isCompleted = conditionalStepWait(self.config.Doors.Close_Delay, function()
				return {self.state ~= 'Closing'}
			end)
			if (not isCompleted) then return end
			self.lanternsReset = false
			local function runDoor(_types: {string})
				for i,doorType in pairs(typeof(_types) == 'table' and _types or {}) do
					for i,w in next,self.engineWelds do
						local newIndex = i == 'car' and 'Inner' or 'Outer'
						if (newIndex == doorType and (newIndex == 'Inner' or (newIndex == 'Outer' and (not self.config.Doors.New_Attachment_Doors_Config.Enable)))) then
							local indexLower = string.lower(newIndex)
							local newWeldsList = (i == 'car' and self.engineWelds.car[self.side] or self.engineWelds.floors[tostring(rawFloor)] and self.engineWelds.floors[tostring(rawFloor)][self.side] or {})
							local floorWelds = self.engineWelds.floors[tostring(rawFloor)] and self.engineWelds.floors[tostring(rawFloor)][self.side]
							local setupConfig = self.config.Doors.Custom_Door_Operator_Config[newIndex].Closing
							if (setupConfig and setupConfig.Enable) then
								task.spawn(function()
									local distance = 0
									for i,v in next,newWeldsList do
										if ((v.openPosition.Position-v.closedPosition.Position).Magnitude >= distance and v.side == v.side and (newIndex == 'Inner' and v.instance:IsDescendantOf(self.car) or newIndex == 'Outer' and v.instance:IsDescendantOf(thisFloor))) then
											self.masterWeld[indexLower] = v
											distance = (v.openPosition.Position-v.closedPosition.Position).Magnitude
										end
									end
									local targetPosition = self.masterWeld[indexLower].closedPosition
									local startTime = os.clock()
									local startC0 = self.masterWeld[indexLower].openPosition

									local speed = math.clamp((distance/duration), 1, math.huge)
									local minSpeed = math.clamp(setupConfig.Minimum_Speed or .05, 0, speed)

									local accelerationTime = self.getAccelerationTime(self.velocity[indexLower], speed, setupConfig.Acceleration)
									local stageAccelTime
									local startLerpTime = os.clock()
									local lastStageTick = startLerpTime
									local distOffset = math.clamp(setupConfig.Deceleration_Offset, 0, math.huge)

									self.decelerating[indexLower] = false
									self.velocity[indexLower] = -self.velocity[indexLower]
									self.lastVel[indexLower] = nil
									self.delayTick[indexLower] = nil
									local startVelocity = self.velocity[indexLower]
									if (startingState == 'Open') then
										self.currentStage[indexLower] = typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and #setupConfig.Custom_Acceleration_Stages or 0
									end

									local lastTick,delta = os.clock(),0
									local multi,multi2 = 0,0
									local reachedMinSpeed = false
									local function updateDoorSpeed()
										if (indexLower == 'inner') then
											self.valueInstances.doorSpeedValue.Value = -math.abs(self.velocity[indexLower])
										elseif (indexLower == 'outer') then
											local doorSpeed = thisFloor:FindFirstChild(side ~= '' and side.."_" or ''.."Door_Speed")
											if (doorSpeed) then
												doorSpeed.Value = -math.abs(self.velocity[indexLower])
											end
										end
									end
									
									local delta = 0
									while (self.alpha[indexLower] > 0 and self.masterWeld[indexLower].instance) do
										local thisDist = (targetPosition.Position-self.masterWeld[indexLower].instance.C0.Position).Magnitude
										local thisDistCheck = (thisDist/distance) <= setupConfig.Deceleration_Distance*(math.clamp((self.velocity[indexLower])/speed, 0, 1))
										local thisStage = typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and setupConfig.Custom_Acceleration_Stages[#setupConfig.Custom_Acceleration_Stages-(self.currentStage[indexLower]-1)]
										if ((not thisDistCheck) and (not self.decelerating[indexLower])) then
											if (thisStage) then
												local thisAcceleration = thisStage.Acceleration == 'USE_ACCELERATION' and setupConfig.Acceleration or thisStage.Acceleration
												if (not stageAccelTime) then
													self.lastVel[indexLower] = self.velocity[indexLower]
													self.delayTick[indexLower] = os.clock()
													stageAccelTime = self.getAccelerationTime(self.lastVel[indexLower], math.clamp(thisStage.Speed, 0, speed), thisStage.Acceleration == 'USE_ACCELERATION' and setupConfig.Acceleration or thisStage.Acceleration)
													multi = 0
												end
												if ((not self.lastVel[indexLower]) or (not self.delayTick[indexLower]) or (not stageAccelTime)) then continue end
												local stageSpeed = math.clamp(thisStage.Speed, 0, speed)
												if (stageAccelTime and ((not thisStage.Acceleration_Rate) or (not thisStage.Acceleration_Rate.Rate) or thisStage.Acceleration_Rate.Rate == 'Constant')) then
													self.velocity[indexLower] = lerp(self.lastVel[indexLower], math.clamp(thisStage.Speed, 0, speed), math.clamp((os.clock()-lastStageTick)/stageAccelTime, 0, 1))
												elseif (thisStage.Acceleration_Rate.Rate == 'Gradual') then
													local rate = 1/math.deg(thisStage.Acceleration_Rate.Gradual_Duration)
													multi = math.clamp(multi+rate*math.deg(delta), 0, 1)
													self.velocity[indexLower] = math.clamp(self.velocity[indexLower]+thisAcceleration*multi*math.deg(delta), -stageSpeed, stageSpeed)
												end
												if (stageAccelTime and math.clamp((os.clock()-lastStageTick)/stageAccelTime, 0, 1) < 1 and (not thisStage.Ignore_Acceleration_Duration)) then
													self.delayTick[indexLower] = os.clock()
												elseif (self.delayTick[indexLower] and (os.clock()-self.delayTick[indexLower])/thisStage.Delay_Before_Next_Stage >= 1 and typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and setupConfig.Custom_Acceleration_Stages[self.currentStage[indexLower]-1]) then
													lastStageTick = os.clock()
													self.currentStage[indexLower] = math.clamp(self.currentStage[indexLower]-1, 1, math.huge)
													stageAccelTime = nil
												end
												self.currentStage[indexLower] = math.clamp(self.currentStage[indexLower], 0, typeof(setupConfig.Custom_Acceleration_Stages) == 'table' and #setupConfig.Custom_Acceleration_Stages or math.huge)
											else
												if (((not setupConfig.Acceleration_Rate) or (not setupConfig.Acceleration_Rate.Rate) or setupConfig.Acceleration_Rate.Rate == 'Constant')) then
													self.velocity[indexLower] = lerp(self.lastVel[indexLower] or startVelocity, speed, math.clamp((os.clock()-startLerpTime)/accelerationTime, 0, 1))
												elseif (setupConfig.Acceleration_Rate.Rate == 'Gradual') then
													local rate = 1/math.deg(thisStage.Acceleration_Rate.Gradual_Duration)
													multi2 = math.clamp(multi2+rate*math.deg(delta), 0, 1)
													self.velocity[indexLower] = math.clamp(self.velocity[indexLower]+setupConfig.Acceleration*multi2*math.deg(delta), -speed, speed)
												end
											end
											self.velocity[indexLower] = math.clamp(self.velocity[indexLower], -speed, speed)
										end
										if (thisDistCheck or self.decelerating[indexLower] and (not reachedMinSpeed)) then
											local distOff = thisDist-distOffset
											if (not self.decelerating[indexLower]) then
												self.decelerating[indexLower] = true
												self.prevDist[indexLower] = distOff
												self.prevSpeed[indexLower] = math.abs(self.velocity[indexLower])
												self.startTick[indexLower] = os.clock()
												self.decelTime[indexLower] = self.getAccelerationTime(self.prevSpeed[indexLower], minSpeed, getDecelerationRate(self.prevSpeed[indexLower], minSpeed, self.prevDist[indexLower]))
											end
											if (setupConfig.Deceleration_Rate == 'Exponential') then
												self.velocity[indexLower] = math.clamp((self.prevSpeed[indexLower]/self.prevDist[indexLower])*distOff, minSpeed, speed)
											elseif (setupConfig.Deceleration_Rate == 'Constant') then
												local currentSpeed = self.velocity[indexLower]
												local deceleration = currentSpeed^2/(2*math.max(.001, distOff))
												local SPEED = math.max(0, currentSpeed-deceleration*delta)
												self.velocity[indexLower] = math.max(minSpeed, SPEED)
											end
											if (self.velocity[indexLower] <= minSpeed) then reachedMinSpeed = true end
										end
										--RESET LANTERNS BASED ON RATIO--
										if ((thisDist/distance) <= self.config.Color_Database.Lanterns.Door_Distance_Reset_Ratio and (not self.lanternsReset)) then
											self.lanternsReset = true
											self.LanternsReset:Fire()
										end
										self.alpha[indexLower] = math.max(0, self.alpha[indexLower]-(((self.velocity[indexLower]/speed)/duration))*delta)
										if (self.config.Doors.New_Attachment_Doors_Config.Enable) then
											for _,weld in pairs(self.engineWelds.car[self.side]) do
												_.C0 = weld.closedPosition:Lerp(weld.openPosition, self.alpha[indexLower])
												if (weld.floorDoorWeld) then
													local data = floorWelds[weld.floorDoorWeld.instance]
													if (data) then
														local goal = CFrame.new(self.config.Doors.New_Attachment_Doors_Config.Attachment_Threshold,0,0)*(data.closedPosition:Lerp(data.openPosition, self.alpha[indexLower]))
														weld.floorDoorWeld.instance.C0 = CFrame.new(
															math.clamp(goal.X,data.openPosition.X >= data.closedPosition.X and data.closedPosition.X or data.openPosition.X,data.openPosition.X <= data.closedPosition.X and data.closedPosition.X or data.openPosition.X),
															math.clamp(goal.Y,data.openPosition.Y >= data.closedPosition.Y and data.closedPosition.Y or data.openPosition.Y,data.openPosition.Y <= data.closedPosition.Y and data.closedPosition.Y or data.openPosition.Y),
															math.clamp(goal.Z,data.openPosition.Z >= data.closedPosition.Z and data.closedPosition.Z or data.openPosition.Z,data.openPosition.Z <= data.closedPosition.Z and data.closedPosition.Z or data.openPosition.Z)
														)
													end
												end
											end
										else
											for i,weld in next,newWeldsList do
												if ((indexLower == 'inner' and weld.instance:IsDescendantOf(self.car)) or (indexLower == 'outer' and weld.instance:IsDescendantOf(thisFloor))) then
													weld.instance.C0 = weld.closedPosition:Lerp(weld.openPosition, math.clamp(self.alpha[indexLower], 0, 1))
												end
											end
										end
										if (self.state ~= 'Closing' and self.state ~= 'Closed') then
											self.velocity[indexLower] = 0
											self.sounds.doorOpenSound:Stop()
											self.sounds.doorCloseSound:Stop()
											task.spawn(updateDoorSpeed)
											break
										end
										task.spawn(updateDoorSpeed)
										if (self.checkWelds(rawFloor, 'closedPosition', self.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
											self.updateDoorState('Closed')
											self.nudging = false
											if (typeof(onClosed) == 'function') then task.spawn(onClosed) end
											task.spawn(function()
												if (not self.lanternsReset) then
													self.LanternsReset:Fire()
												end
												self.Closed:Fire()
											end)
										end
										delta = HEARTBEAT:Wait()
									end
									task.wait()
									if (self.checkWelds(rawFloor, 'closedPosition', self.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
										self.updateDoorState('Closed')
										self.nudging = false
										if (typeof(onClosed) == 'function') then task.spawn(onClosed) end
										task.spawn(function()
											if (not self.lanternsReset) then
												self.LanternsReset:Fire()
											end
											self.Closed:Fire()
										end)
									end
									if (self.state ~= 'Closed') then return end
									self.valueInstances.doorSpeedValue.Value = 0
									for i,v in next,self.velocity do
										self.velocity[i] = 0
										self.currentStage[i] = 1
									end
									task.spawn(updateDoorSpeed)
								end)
							end
						end
					end
				end
			end
			if (self.config.Doors.Door_Delay_Sequence_Config.Closing.Enable) then
				if (self.state ~= 'Closing') then return end
				task.spawn(function()
					for i,part in ipairs(self.config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) do
						runDoor({part})
						local hasCompleted = conditionalStepWait(self.config.Doors.Door_Delay_Sequence_Config.Closing.Delay, function()
							return {self.state ~= 'Closing'}
						end)
						if (not hasCompleted) then return end
					end
				end)
			else
				runDoor({'Inner','Outer'})
			end
		end

		function self:LegacyOpen(floor: number, onOpened: (any?) -> any?)
			local startingState = self.state
			local currentFloor = floor
			local thisFloor = self.findFloor(currentFloor)
			if ((startingState ~= 'Closed' and startingState ~= 'Closing') or ((not self.car:FindFirstChild((self.side == '' and '' or self.side.."_").."Doors")) or (not thisFloor:FindFirstChild((self.side == '' and '' or self.side.."_").."Doors")))) then return end
			self.Opening:Fire()
			self.updateDoorState('Opening')
			local duration = self.config.Doors.Door_Open_Speed
			if (not thisFloor) then return warn("Floor not found! " .. (currentFloor)) end
			local distanceFactor = 0
			for i,w in next,self.engineWelds do
				local newTable = (i == 'car' and self.engineWelds.car[self.side] or {})
				for i,weld in next,newTable do
					distanceFactor = math.clamp(distanceFactor+((weld:getCurrentDistance()/weld.distanceFromOpenPosition)/(getTableLength(self.engineWelds)*getTableLength(newTable))*2), .15, 1)
				end
			end
			---
			self.sounds.doorCloseSound:Stop()
			task.spawn(function()
				local isCompleted = conditionalStepWait(startingState == 'Closed' and self.config.Doors.Door_Open_Sound_Delay or 0, function()
					return {self.state ~= 'Opening'}
				end)
				if (not isCompleted) then return end
				self.sounds.doorOpenSound.TimePosition = self.sounds.doorOpenSound.TimeLength*(1-distanceFactor)
				task.wait()
				self.sounds.doorOpenSound:Play()
			end)
			---
			duration = duration*distanceFactor
			local isCompleted = conditionalStepWait(startingState == 'Closed' and self.config.Doors.Open_Delay or startingState == 'Closing' and self.config.Doors.Reopen_Delay or 0, function()
				return {self.state ~= 'Opening'}
			end)
			if (not isCompleted) then return end
			local function runDoor(_types: {string})
				for i,doorType in pairs(typeof(_types) == 'table' and _types or {}) do
					for i,w in next,self.engineWelds do
						local newIndex = i == 'car' and 'Inner' or 'Outer'
						if (newIndex == doorType) then
							for i,w in next,self.engineWelds do
								local newIndex = i == 'car' and 'Inner' or 'Outer'
								local indexLower = string.lower(newIndex)
								local newWeldsList = (i == 'car' and self.engineWelds.car[self.side] or self.engineWelds.floors[tostring(currentFloor)] and self.engineWelds.floors[tostring(currentFloor)][self.side] or {})
								for i,weld in next,newWeldsList do
									if (typeof(self.currentStage[indexLower]) ~= 'table') then
										self.currentStage[indexLower] = {}
									end
									if (not self.currentStage[indexLower][i]) then
										self.currentStage[indexLower][i] = 1
									end
									task.spawn(function()
										local thisWeld = weld.instance
										local startTime = tick()
										local lastStage = self.currentStage[indexLower][i]
										local dataName = (indexLower == 'inner' and thisWeld:IsDescendantOf(self.car) and 'Realistic_Doors_Data') or (indexLower == 'outer' and thisWeld:IsDescendantOf(thisFloor) and 'Realistic_Outer_Doors_Data')
										if ((startingState == 'Closed' or (startingState == 'Closing' and lastStage == 1))) then
											self.currentStage[indexLower][i] += 1
											if (dataName and self.config.Doors[dataName].Enable_Open) then
												legacyEasing:interpolate(thisWeld, weld.interlockOpenPosition, thisWeld.C1, self.config.Doors[dataName].Open_Easing_Style, self.config.Doors[dataName].Open_Time, function()
													return {self.state ~= 'Opening'}
												end)
												if (math.abs(tick()-startTime) < self.config.Doors[dataName].Open_Time) then
													conditionalStepWait(self.config.Doors[dataName].Open_Time-math.abs(tick()-startTime), function()
														return {self.state ~= 'Opening'}
													end)
												end
											end
											if ((indexLower == 'outer' and ((not self.config.Doors[dataName]) or (not self.config.Doors[dataName].Enable_Open)))) then
												conditionalStepWait(self.config.Doors.Realistic_Doors_Data.Enable_Open and self.config.Doors.Realistic_Doors_Data.Open_Time or 0, function()
													return {self.state ~= 'Opening'}
												end)
												if (typeof(self.config.Doors.Realistic_Doors_Data.Open_Delay) == 'table' and self.config.Doors.Realistic_Doors_Data.Open_Delay.Enable) then
													conditionalStepWait(if (typeof(self.config.Doors.Realistic_Doors_Data.Open_Delay.Duration) == 'number') then self.config.Doors.Realistic_Doors_Data.Open_Delay.Duration else 0, function()
														return {self.state ~= 'Opening'}
													end)
												end
											elseif ((indexLower == 'inner' and ((not self.config.Doors[dataName]) or (not self.config.Doors[dataName].Enable_Open)))) then
												conditionalStepWait(self.config.Doors.Realistic_Outer_Doors_Data.Enable_Open and self.config.Doors.Realistic_Outer_Doors_Data.Open_Time or 0, function()
													return {self.state ~= 'Opening'}
												end)
												if (typeof(self.config.Doors.Realistic_Outer_Doors_Data.Open_Delay) == 'table' and self.config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Enable) then
													conditionalStepWait(if (typeof(self.config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Duration) == 'number') then self.config.Doors.Realistic_Outer_Doors_Data.Open_Delay.Duration else 0, function()
														return {self.state ~= 'Opening'}
													end)
												end
											end
										end
										local isCompleted = conditionalStepWait(startingState == 'Closed' and self.config.Doors[dataName].Open_Delay.Enable and self.config.Doors[dataName].Open_Delay.Duration or 0, function()
											return {self.state ~= 'Opening'}
										end)
										if (not isCompleted) then return end
										self.currentStage[indexLower][i] += 1
										local isCompleted = legacyEasing:interpolate(thisWeld, weld.openPosition, thisWeld.C1, self.config.Doors.Open_Easing_Style, duration, function()
											if (self.checkWelds(currentFloor, 'openPosition', .001) and self.state == 'Opening') then
												self.updateDoorState('Open')
												if (typeof(onOpened) == 'function') then task.spawn(onOpened) end
											end
											return {self.state ~= 'Opening' and self.state ~= 'Open'}
										end)
										if (not isCompleted) then return end
										task.wait()
										if (self.checkWelds(currentFloor, 'openPosition', .001) and self.state == 'Opening') then
											self.updateDoorState('Open')
											if (typeof(onOpened) == 'function') then task.spawn(onOpened) end
											self.Opened:Fire()
										end
									end)
								end
							end
						end
					end
				end
			end
			if (self.config.Doors.Door_Delay_Sequence_Config.Opening.Enable) then
				if (self.state ~= 'Opening') then return end
				task.spawn(function()
					for i,part in ipairs(self.config.Doors.Door_Delay_Sequence_Config.Opening.Sequence_Order) do
						runDoor({part})
						local hasCompleted = conditionalStepWait(self.config.Doors.Door_Delay_Sequence_Config.Opening.Delay, function()
							return {self.state ~= 'Opening'}
						end)
						if (not hasCompleted) then return end
					end
				end)
			else
				runDoor({'Inner','Outer'})
			end
		end

		function self:LegacyClose(floor: number, NUDGE: boolean?, onClosed: (any?) -> any?)
			local startingState = self.state
			local currentFloor = floor
			local thisFloor = self.findFloor(currentFloor)
			if (not thisFloor) then return warn("Floor not found! " .. (currentFloor)) end
			if (startingState ~= 'Open' or ((not self.car:FindFirstChild((self.side == '' and '' or self.side.."_").."Doors")) or (not thisFloor:FindFirstChild((self.side == '' and '' or self.side.."_").."Doors")))) then return end
			self.Closing:Fire()
			self.updateDoorState('Closing')
			---
			self.sounds.doorOpenSound:Stop()
			task.spawn(function()
				local isCompleted = conditionalStepWait(self.config.Doors.Door_Close_Sound_Delay, function()
					return {self.state ~= 'Closing'}
				end)
				if (not isCompleted) then return end
				self.sounds.doorCloseSound:Play()
			end)
			---
			local duration = NUDGE and (self.config.Doors.Door_Nudge_Speed or self.config.Doors.Door_Close_Speed*1.5) or self.config.Doors.Door_Close_Speed
			local distanceFactor = 0
			for i,w in next,self.engineWelds do
				local newTable = (i == 'car' and self.engineWelds.car[self.side] or {})
				for i,weld in next,newTable do
					distanceFactor = math.clamp(distanceFactor+(((weld.closedPosition.Position-weld.instance.C0.Position).Magnitude/weld.distanceFromOpenPosition)/(getTableLength(self.engineWelds)*getTableLength(newTable))*2), .15, 1)
				end
			end
			duration = duration*distanceFactor
			local isCompleted = conditionalStepWait(self.config.Doors.Close_Delay, function()
				return {self.state ~= 'Closing'}
			end)
			self.lanternsReset = false
			local function runDoor(_types: {string})
				for i,doorType in pairs(typeof(_types) == 'table' and _types or {}) do
					for i,w in next,self.engineWelds do
						local newIndex = i == 'car' and 'Inner' or 'Outer'
						if (newIndex == doorType) then
							for i,w in next,self.engineWelds do
								local newIndex = i == 'car' and 'Inner' or 'Outer'
								local indexLower = string.lower(newIndex)
								local newWeldsList = (i == 'car' and self.engineWelds.car[self.side] or self.engineWelds.floors[tostring(currentFloor)] and self.engineWelds.floors[tostring(currentFloor)][self.side] or {})
								for i,weld in next,newWeldsList do
									local thisWeld = weld.instance
									local startTime = tick()
									task.spawn(function()
										local distance = (weld.openPosition.Position-weld.closedPosition.Position).Magnitude
										local lastStage = self.currentStage[indexLower][i]
										if ((startingState == 'Open' or (startingState == 'Opening' and lastStage == 0))) then
											self.currentStage[indexLower][i] -= 1
										end
										local dataName = (indexLower == 'inner' and thisWeld:IsDescendantOf(self.car) and 'Realistic_Doors_Data') or (indexLower == 'outer' and thisWeld:IsDescendantOf(thisFloor) and 'Realistic_Outer_Doors_Data')
										if (dataName) then
											local function handleLanternRatioCheck()
												local thisDist = (weld.closedPosition.Position-thisWeld.C0.Position).Magnitude
												if ((thisDist/distance) <= self.config.Color_Database.Lanterns.Door_Distance_Reset_Ratio and (not self.lanternsReset)) then
													self.lanternsReset = true
													self.LanternsReset:Fire()
												end
											end
											if ((startingState == 'Open' or (startingState == 'Opening' and lastStage == 2)) and (self.config.Doors[dataName] and self.config.Doors[dataName].Enable_Close)) then
												local isCompleted = legacyEasing:interpolate(thisWeld, weld.interlockClosePosition, thisWeld.C1, self.config.Doors.Close_Easing_Style, duration, function()
													task.spawn(handleLanternRatioCheck)
													return {self.state ~= 'Closing'}
												end)
												if (not isCompleted) then return end
												if (math.abs(tick()-startTime) < self.config.Doors[dataName].Close_Time) then
													conditionalStepWait(self.config.Doors[dataName].Close_Time-math.abs(tick()-startTime), function()
														return {self.state ~= 'Closing'}
													end)
												end
												local isCompleted = conditionalStepWait(startingState == 'Open' and self.config.Doors[dataName].Close_Delay.Enable and self.config.Doors[dataName].Close_Delay.Duration or 0, function()
													return {self.state ~= 'Closing'}
												end)
												if (not isCompleted) then return end
												self.currentStage[indexLower][i] -= 1
												local isCompleted = legacyEasing:interpolate(thisWeld, weld.closedPosition, thisWeld.C1, self.config.Doors[dataName].Close_Easing_Style, self.config.Doors[dataName].Close_Time, function()
													task.spawn(handleLanternRatioCheck)
													return {self.state ~= 'Closing'}
												end)
												if (not isCompleted) then return end
											else
												local isCompleted = legacyEasing:interpolate(thisWeld, weld.closedPosition, thisWeld.C1, self.config.Doors.Close_Easing_Style, duration, function()
													task.spawn(handleLanternRatioCheck)
													if (self.checkWelds(currentFloor, 'closedPosition', self.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
														self.updateDoorState('Closed')
														if (not self.lanternsReset) then
															self.LanternsReset:Fire()
														end
														if (typeof(onClosed) == 'function') then task.spawn(onClosed) end
														self.Closed:Fire()
													end
													return {self.state ~= 'Closing' and self.state ~= 'Closed'}
												end)
												if (not isCompleted) then return end
											end
											task.wait()
											if (self.checkWelds(currentFloor, 'closedPosition', self.config.Doors.New_Attachment_Doors_Config.Closing_Min_Threshold, true) and self.state == 'Closing') then
												self.updateDoorState('Closed')
												if (not self.lanternsReset) then
													self.LanternsReset:Fire()
												end
												if (typeof(onClosed) == 'function') then task.spawn(onClosed) end
												self.Closed:Fire()
											end
										end
									end)
								end
							end
						end
					end
				end
			end
			if (self.config.Doors.Door_Delay_Sequence_Config.Closing.Enable) then
				if (self.state ~= 'Closing') then return end
				task.spawn(function()
					for i,part in ipairs(self.config.Doors.Door_Delay_Sequence_Config.Closing.Sequence_Order) do
						runDoor({part})
						local hasCompleted = conditionalStepWait(self.config.Doors.Door_Delay_Sequence_Config.Closing.Delay, function()
							return {self.state ~= 'Closing'}
						end)
						if (not hasCompleted) then return end
					end
				end)
			else
				runDoor({'Inner','Outer'})
			end
		end

		return self
	end
end
return module]]></ProtectedString>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
						</Item>
					</Item>
				</Item>
				<Item class="ModuleScript" referent="RBX6D637E024809471C9C319418ACA837BA">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Multi_Bay</string>
						<string name="ScriptGuid">{6D647121-1BEA-462A-8801-F791BF004F19}</string>
						<ProtectedString name="Source"><![CDATA[--[[

CORTEX MULTIBAY - VER. 4
10/03/23

WRITTEN BY aaxtatious (540781721)

]]--

local module = {}
module.callFloorData = {}

return function(source)

	local collectionService = game:GetService('CollectionService')
	local replicatedStorage = game:GetService('ReplicatedStorage')

	local this = source.Parent
	local callButtons = this:FindFirstChild('Call_Buttons')
	if (not callButtons) then return warn("Cortex Multibay // GroupCalling :: " .. (this:GetFullName()) .. " :: Missing required instance Call_Buttons") end
	local elevators = this:FindFirstChild('Elevators')
	if (not callButtons) then return warn("Cortex Multibay // GroupCalling :: " .. (this:GetFullName()) .. " :: Missing required instance Elevators") end

	local allocator = require(script:WaitForChild('Allocator'))

	local configAvailable = source:FindFirstChild('Settings') ~= nil
	local config = configAvailable and require(source.Settings)

	local function setButton(button: Model, config: any, state: string, includeAllButtonsInFloorGroup: boolean?)
		if (typeof(config) ~= 'table') then return end
		local cfg = config[state]
		if (not cfg) then return end
		for _,v in pairs((includeAllButtonsInFloorGroup == true and button.Parent or button):GetDescendants()) do
			if ((includeAllButtonsInFloorGroup and v.Name == button.Name) or (not includeAllButtonsInFloorGroup)) then
				for _,light in pairs(v:GetDescendants()) do
					if ((not light:IsA('BasePart')) or light.Name ~= 'Light') then continue end
					light.Color = cfg.Color
					light.Material = cfg.Material
				end
			end
		end
	end

	for _,v in pairs(callButtons:GetChildren()) do
		local floorName = tonumber(string.split(v.Name, 'Floor_')[2]) or tonumber(string.split(v.Name, 'Floor')[2]) or tonumber(v.Name)
		if (not floorName) then continue end
		if (not module.callFloorData[tostring(floorName)]) then
			module.callFloorData[tostring(floorName)] = {}
		end
		for _,btnModel in pairs(v:GetDescendants()) do
			if (btnModel.Name ~= 'Up' and btnModel.Name ~= 'Down') then continue end
			local buttonPart: Part
			for _,v in pairs(btnModel:GetChildren()) do
				if ((not v:IsA('BasePart')) or v.Name ~= 'Button') then continue end
				buttonPart = v
				break
			end
			if (not buttonPart) then continue end
			buttonPart:SetAttribute('isACortexElevButton', true)
			--buttonPart.CollisionGroup = 'elevatorCollisionGroup'
			if (not module.callFloorData[tostring(floorName)][btnModel.Name]) then
				module.callFloorData[tostring(floorName)][btnModel.Name] = {
					elevator = nil,
					arrivalConnection = nil,
					otherConnections = {}
				}
			end
			if (config) then
				setButton(btnModel, config.Color_Config[btnModel.Name], 'Neutral_State', false)
			else
				local function getElevatorSettings(index)
					local elev = elevators:GetChildren()[index]
					if (((not elev) or (not elev:FindFirstChild('Settings'))) and elevators:GetChildren()[index+1]) then return getElevatorSettings(index+1) end
					return require(elev.Settings)
				end
				local newConfig = getElevatorSettings(1)
				if (not newConfig) then continue end
				setButton(btnModel, newConfig.Color_Database.Floor[btnModel.Name], 'Neautral_State', false)
			end
		end
	end

	local function addSound(append: Instance, name: string, soundId: number, volume: number, pitch: number, looped: boolean?, minDistance: number?, maxDistance: number?, playOnRemove: boolean?)
		if (typeof(append) ~= 'Instance') then return end
		local result = append:FindFirstChild(name)
		if (not result) then
			result = Instance.new('Sound')
			result.Name = name
			result.SoundId = "rbxassetid://" .. (soundId)
			result.Volume = volume
			result.PlaybackSpeed = pitch
			result.Looped = looped
			result.RollOffMinDistance = minDistance
			result.RollOffMaxDistance = maxDistance
			result.Parent = append
			if (playOnRemove == true) then
				result.PlayOnRemove = true
				result:Destroy()
			end
		end
		return result
	end

	local function handleButtonInput(user: Player? | any?, protocol: string, params: any)
		if (protocol ~= 'onButtonPressed' and protocol ~= 'onButtonReleased') then return end
		local button = params.button
		if (not button) then return end
		local buttonPart = button:FindFirstChild('Button')
		if (not buttonPart) then return end
		local callFloor = tonumber(string.split(button.Parent.Name, 'Floor_')[2]) or tonumber(string.split(button.Parent.Name, 'Floor')[2]) or tonumber(button.Parent.Name)
		if (not callFloor) then return end
		local callFloorData = module.callFloorData[tostring(callFloor)][button.Name]
		if (not callFloorData) then return end
		local callDirection = button.Name == 'Up' and 1 or button.Name == 'Down' and -1 or nil
		if (not callDirection) then return end

		if (protocol == 'onButtonPressed') then
			if (config) then
				setButton(button, config.Color_Config[button.Name], 'Active_State', true)
				addSound(buttonPart, 'Button_Click', config.Sound_Config.Click.Sound_Id, config.Sound_Config.Click.Volume, config.Sound_Config.Click.Pitch, false, config.Sound_Config.Click.Roll_Off.Min, config.Sound_Config.Click.Roll_Off.Max, true)
			end

			local elevator = params.elevator or allocator.findElevator(elevators:GetChildren(), callFloor, callDirection)
			if ((not config) and (elevator or callFloorData.elevator)) then
				-- // No config located in the script? Use the elevator's config // --
				local elevator = callFloorData.elevator or elevator
				local newConfig = require(elevator.Settings).Color_Database.Floor[button.Name]
				local soundConfig = require(elevator.Settings).Sound_Database.Others.Call_Button_Beep or require(elevator.Settings).Sound_Database.Others.Button_Beep
				addSound(buttonPart, 'Button_Click', soundConfig.Sound_Id, soundConfig.Volume, soundConfig.Pitch, false, 2, 50, true)
				setButton(button, newConfig, 'Lit_State', true)
			end

			if ((not elevator) or callFloorData.elevator) then return end
			if (not config) then
				-- // No config located in the script? Use the elevator's config // --
				local newConfig = require(elevator.Settings).Color_Database.Floor[button.Name]
				local soundConfig = require(elevator.Settings).Sound_Database.Others.Call_Button_Beep or require(elevator.Settings).Sound_Database.Others.Button_Beep
				addSound(buttonPart, 'Button_Click', soundConfig.Sound_Id, soundConfig.Volume, soundConfig.Pitch, false, 2, 50, true)
				setButton(button, newConfig, 'Lit_State', true)
			end
			callFloorData.elevator = elevator
			if (callFloorData.arrivalConnection) then return end
			local isIdle = (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value) and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Queue_Direction.Value == string.sub(button.Name, 1, 1) or elevator.Legacy.Queue_Direction.Value == 'N')
			if (not isIdle) then
				callFloorData.arrivalConnection = elevator.Cortex_API.Event:Connect(function(protocol, params)
					if (protocol ~= 'onCallRespond') then return end
					if (params.floor == callFloor and params.direction == string.sub(button.Name, 1, 1)) then
						for i, v in pairs(callFloorData.otherConnections) do
							callFloorData.otherConnections[i]:Disconnect()
							callFloorData.otherConnections[i] = nil
						end
						callFloorData.arrivalConnection:Disconnect()
						callFloorData.arrivalConnection = nil
						callFloorData.elevator = nil
						if (not config) then
							-- // No config located in the script? Use the elevator's config // --
							local newConfig = require(elevator.Settings).Color_Database.Floor[button.Name]
							setButton(button, newConfig, 'Neautral_State', true)
						else
							setButton(button, config.Color_Config[button.Name], 'Neutral_State', true)
						end
					end
				end)
			end

			for _, v in pairs(elevator.Legacy:GetChildren()) do
				if v.Name == 'Independent_Service' or v.Name == 'Fire_Service' or v.Name == 'Stop' or v.Name == 'Inspection' or v.Name == 'Out_Of_Service' then
					table.insert(callFloorData.otherConnections, v:GetPropertyChangedSignal('Value'):Connect(function()
						if v.Value then
							for i, v in pairs(callFloorData.otherConnections) do
								callFloorData.otherConnections[i]:Disconnect()
								callFloorData.otherConnections[i] = nil
							end
							callFloorData.arrivalConnection:Disconnect()
							callFloorData.arrivalConnection = nil
							callFloorData.elevator = nil
							if (not config) then
								-- // No config located in the script? Use the elevator's config // --
								local newConfig = require(elevator.Settings).Color_Database.Floor[button.Name]
								setButton(button, newConfig, 'Neautral_State', true)
							else
								setButton(button, config.Color_Config[button.Name], 'Neutral_State', true)
							end
						end
					end))
				end
			end

			elevator.Cortex_API:Fire('Add_Call', { ['call'] = callFloor, ['direction'] = callDirection })
		else
			local elevator = callFloorData.elevator
			if (not elevator) then
				local function getElevatorSettings(index)
					local elev = elevators:GetChildren()[index]
					if (((not elev) or (not elev:FindFirstChild('Settings'))) and elevators:GetChildren()[index+1]) then return getElevatorSettings(index+1) end
					return require(elev.Settings)
				end
				if config then
					setButton(button, config.Color_Config[button.Name], 'Neutral_State', true)
				else
					local newConfig = getElevatorSettings(1)
					if (not newConfig) then return end
					setButton(button, newConfig.Color_Database.Floor[button.Name], 'Neautral_State', false)
				end
				return
			end
			-- // Let's do an idle check, only reset the button and its values if this check passes // --
			local isIdle = (elevator.Legacy.Move_Value.Value == 0 or elevator.Legacy.Leveling.Value) and elevator.Legacy.Raw_Floor.Value == callFloor and (elevator.Legacy.Queue_Direction.Value == string.sub(button.Name, 1, 1) or elevator.Legacy.Queue_Direction.Value == 'N')
			if (isIdle) then
				for i, v in pairs(callFloorData.otherConnections) do
					callFloorData.otherConnections[i]:Disconnect()
					callFloorData.otherConnections[i] = nil
				end
				if (callFloorData.arrivalConnection) then
					callFloorData.arrivalConnection:Disconnect()
					callFloorData.arrivalConnection = nil
				end
				callFloorData.elevator = nil
				if (config) then
					setButton(button, config.Color_Config[button.Name], 'Neutral_State', true)
				else
					-- // No config located in the script? Use the elevator's config // --
					local newConfig = require(elevator.Settings).Color_Database.Floor[button.Name]
					setButton(button, newConfig, 'Neautral_State', true)
				end
			end
		end
	end

	local buttonAPI,buttonRemote,allocatorAPI = this:FindFirstChild('Button_API'),this:FindFirstChild('Button_Remote'),this:FindFirstChild('Cortex_Allocator_API')
	if (not buttonAPI) then
		buttonAPI = Instance.new('BindableEvent')
		buttonAPI.Name = 'Button_API'
		buttonAPI.Parent = this
	end
	if (not buttonRemote) then
		buttonRemote = Instance.new('RemoteEvent')
		buttonRemote.Name = 'Button_Remote'
		buttonRemote.Parent = this
	end
	if (not allocatorAPI) then
		allocatorAPI = Instance.new('BindableFunction')
		allocatorAPI.Name = 'Cortex_Allocator_API'
		allocatorAPI.Parent = this
		function allocatorAPI.OnInvoke(params)
			local elevator = allocator.findElevator(params.elevators, params.floor, params.direction)
			handleButtonInput(nil, 'onButtonPressed', {button = params.callButton, elevator = elevator})
			task.delay(.35, function()
				handleButtonInput(nil, 'onButtonReleased', {button = params.callButton})
			end)
			return elevator
		end
	end

	buttonAPI.Event:Connect(function(protocol, params)
		handleButtonInput(nil, protocol, params)
	end)
	buttonRemote.OnServerEvent:Connect(handleButtonInput)

end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
					<Item class="ModuleScript" referent="RBX10EFDF24196C48B18C79EBA21948692C">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Allocator</string>
							<string name="ScriptGuid">{1713F06B-448E-4E60-A9EA-F1F2AB7F575A}</string>
							<ProtectedString name="Source"><![CDATA[local module = {}

local function absoluteDifference(a, b)
	return math.abs(a-b)
end

local function checkElevatorStatValue(elevator, name)
	if (not elevator) then return nil end
	if ((not elevator:FindFirstChild('Legacy'))) then return nil end
	if (elevator.Legacy:FindFirstChild(name)) then return elevator.Legacy:FindFirstChild(name).Value end
	return nil
end

local function isElevatorOutOfService(elevator)
	return (checkElevatorStatValue(elevator, 'Independent_Service')
		or checkElevatorStatValue(elevator, 'Fire_Service')
		or checkElevatorStatValue(elevator, 'Stop')
		or checkElevatorStatValue(elevator, 'Inspection')
		or checkElevatorStatValue(elevator, 'Out_Of_Service')
	)
end

function module.findElevator(elevators: {}, callFloor: number, callDirection: number)
	local CALL_DIRECTION = callDirection
	local availableElevators = {}
	for i,v in pairs(elevators) do
		if isElevatorOutOfService(v) then continue end
		local floor,destination,moveDirection,queueDirection = checkElevatorStatValue(v,'Floor'),checkElevatorStatValue(v,'Destination'),checkElevatorStatValue(v,'Move_Value'),checkElevatorStatValue(v,'Queue_Direction')
		if ((not floor) or (not destination) or (not moveDirection) or (not queueDirection)) then continue end
		table.insert(availableElevators, v)
	end
	--table.sort(availableElevators, function(a,b)
	--	return a.Name < b.Name
	--end)
	local sortedElevators = {}
	local nearestElevator
	local minDistance = math.huge
	for _, elevator in ipairs(availableElevators) do
		if isElevatorOutOfService(elevator) then continue end
		local statValues = elevator.Legacy
		local floor,direction,queueDirection = statValues.Floor.Value,statValues.Move_Value.Value,statValues.Queue_Direction.Value
		queueDirection = queueDirection == 'U' and 1 or queueDirection == 'D' and -1 or 0 --// Correct queue direction
		local distance = math.abs(floor-callFloor)
		if (distance < minDistance) then
			-- // If elevator is idle on call floor
			if ((floor == callFloor and direction == 0) and (queueDirection == callDirection or queueDirection == 0)) then
				nearestElevator = elevator
				minDistance = distance
				--// Check for elevators in direction & check for their queue direction
			elseif ((callDirection == 1 and floor <= callFloor and (direction == -1 or direction == 0) and (queueDirection == 1 or queueDirection == 0)) or (callDirection == -1 and floor >= callFloor and (direction == 1 or direction == 0) and ((queueDirection == -1 or queueDirection == 0)))) then
				nearestElevator = elevator
				minDistance = distance
				-- // Check for any elevator that is idle on any floor
			elseif (direction == 0 and (queueDirection == callDirection or queueDirection == 0)) then
				nearestElevator = elevator
				minDistance = distance
			end
		end
	end
	if (not nearestElevator) then
		return availableElevators[1]
	end
	
	return nearestElevator
end

return module]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
						<Item class="Folder" referent="RBXCF632556298B4706971861E53AD05ABD">
							<Properties>
								<BinaryString name="AttributesSerialize"></BinaryString>
								<string name="Name">Legacy</string>
								<int64 name="SourceAssetId">-1</int64>
								<BinaryString name="Tags"></BinaryString>
							</Properties>
							<Item class="StringValue" referent="RBX8D81C2F713974FA7AB123D1C602B634A">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Queue</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">[]</string>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXBF7D38AA27674BE3848F81F950BE4993">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXD63D518998AA4CA3815B98B61E9EC3D0">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Raw_Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXA9E18CBEB415457F8EFDCFC4C5808C9D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Move_Value</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX55BC13F4795646F7824D87A91C558415">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Arrow_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBXDFA12EC87B3C41118D3E8812E7FB62C5">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Queue_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXB9E11A88ABC3400FA0724ADC570A9A9C">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Destination</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">1</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBXA4E47B9EC2694E5AB59F0577CDE8E3B9">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Remote_Call</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX2EB2E6EB94E44BE1BB9C1D935F9058DB">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Fire_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXD9A67E2BD30C42E39D05A079B3472C6F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Phase_1</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX382454BC15DE43B1847D360366C4FAF2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Phase_2</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX7393F5A4CE084534B5E45E41ED87B5AA">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Inspection</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX705EA4D4210B4D10A4A1F27602BC9751">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Out_Of_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX0F02C347DCB648CA87B1C0D305CE7FEE">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Independent_Service</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX40695F43AF3845799F66229F4AD4F52B">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Current_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX1D765B2296E649EB97FF8EBED35F7040">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Velocity</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX28AB317FF30845D5A2A85AD102E7D60F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Arrive_Floor</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">-100000</double>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX8436EE02182D405988B07761F49E83B4">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Leveling</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX48DC44F2DEC949C3B30656D5C29DDFB2">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Nudge</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXDFE1DB5233914F22B2005FB4E1000E45">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Stop</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX080723C7C9D64BF19C245F52C17EB2AD">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Move_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBXFF5BF925717141B790BF5408423F2865">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Pre_Direction</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">N</string>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX7E622D1B93594E8FB8D53EAF41D380D3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_State</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">Closed</string>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX2D890472185F47559929D76DE74775E1">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Hold</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXCAF8924BFF484283A559E2B8DF7BD75D">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Nudging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX438C735D528047918FF2EF0A46EA7002">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Front_Door_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
							<Item class="StringValue" referent="RBX031FC4F5015140CBB37B2F8C14ECC16F">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_State</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<string name="Value">Closed</string>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBXFF54A70FD951477798E6EB93B48B06F8">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Hold</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="BoolValue" referent="RBX3EE05AB7B09E4F498554E14CA64E2244">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Nudging</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<bool name="Value">false</bool>
								</Properties>
							</Item>
							<Item class="NumberValue" referent="RBX90B2E9E0A2A04EFA8E4BAE5679FDDEC3">
								<Properties>
									<BinaryString name="AttributesSerialize"></BinaryString>
									<string name="Name">Rear_Door_Speed</string>
									<int64 name="SourceAssetId">-1</int64>
									<BinaryString name="Tags"></BinaryString>
									<double name="Value">0</double>
								</Properties>
							</Item>
						</Item>
					</Item>
				</Item>
			</Item>
		</Item>
		<Item class="Folder" referent="RBX2E869AAA94754A7F862E85432556BACC">
			<Properties>
				<BinaryString name="AttributesSerialize"></BinaryString>
				<string name="Name">Startup_Modules</string>
				<int64 name="SourceAssetId">-1</int64>
				<BinaryString name="Tags"></BinaryString>
			</Properties>
			<Item class="ModuleScript" referent="RBXEA90C17640784868ACB47C01AFEC6ACA">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Demo</string>
					<string name="ScriptGuid">{75AEE66C-985C-4605-945B-E54C412E7761}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}

function module.init_start()
	
end
function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX279E303757464308A01CF56E90B2687A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Runtime</string>
					<string name="ScriptGuid">{E25D2F7D-3D2B-494D-AD71-6E9D010FFB41}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local RunService = game:GetService('RunService')

local module = {}

function module.init_start()
	local replicatedStorage = game:GetService('ReplicatedStorage')
	local CLIENT_FOLDER: Folder = replicatedStorage:FindFirstChild('CORTEX_CLIENT_INSTANCES') or Instance.new('Folder')
	CLIENT_FOLDER.Name = 'CORTEX_CLIENT_INSTANCES'
	CLIENT_FOLDER.Parent = replicatedStorage
	local RUNTIME_REMOTE_SIGNAL: RemoteEvent = CLIENT_FOLDER:FindFirstChild('RUNTIME_REMOTE_SIGNAL') or Instance.new('RemoteEvent')
	RUNTIME_REMOTE_SIGNAL.Name = 'RUNTIME_REMOTE_SIGNAL'
	RUNTIME_REMOTE_SIGNAL.Parent = CLIENT_FOLDER
	local serverDtTime = replicatedStorage:FindFirstChild('SERVER_DELTA_TIME')
	local serverDtTime = replicatedStorage:FindFirstChild('SERVER_DELTA_TIME')
	if (not serverDtTime) then
		serverDtTime = Instance.new('NumberValue')
		serverDtTime.Parent = replicatedStorage
		serverDtTime.Name = 'SERVER_DELTA_TIME'
	end
	local EVENT = Instance.new('BindableEvent')
	EVENT.Parent = script
	_G.Cortex_SERVER = _G.Cortex_SERVER or {
		EVENTS={
			RUNTIME_EVENT={
				INSTANCE=EVENT,
				EVENT=EVENT.Event
			},
		},
		DELTA_TIME=0,
	}

	local lastTick = os.clock()
	RunService.Heartbeat:Connect(function()
		_G.Cortex_SERVER.DELTA_TIME = os.clock()-lastTick
		lastTick = os.clock()
		serverDtTime.Value = _G.Cortex_SERVER.DELTA_TIME
		EVENT:Fire(_G.Cortex_SERVER.DELTA_TIME)
		--if (#game.Players:GetChildren() > 0) then
		--	--RUNTIME_REMOTE_SIGNAL:FireAllClients(dtTime)
		--end
	end)
end

function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX4F7F3612A8864970A5B44EC958FC9F42">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Elevator_Weldables</string>
					<string name="ScriptGuid">{46EC9ABD-B116-4E50-B6C7-85B6CE43D0B2}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}

function module.init_start()
	_G.ElevatorSensorHumanoids = _G.ElevatorSensorHumanoids or {}
	
	local function checkHuman(v)
		if (v:IsA('Humanoid') and v.Parent:FindFirstChild('HumanoidRootPart')) then v = v.Parent end
		if (v:FindFirstChildOfClass('Humanoid') and v:FindFirstChild('HumanoidRootPart') and (not table.find(_G.ElevatorSensorHumanoids, v))) then
			table.insert(_G.ElevatorSensorHumanoids, v.HumanoidRootPart)
		end
	end
	
	workspace.DescendantAdded:Connect(checkHuman)
	for i, v in pairs(workspace:GetDescendants()) do
		task.spawn(checkHuman, v)
	end
	workspace.DescendantRemoving:Connect(function(v)
		task.wait()
		local index = table.find(_G.ElevatorSensorHumanoids, v)
		if (index) then
			table.remove(_G.ElevatorSensorHumanoids, index)
		end
	end)
end
function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBXC6C1AAA0EA824183B6009959EA6F2F58">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Button_Handler</string>
					<string name="ScriptGuid">{9414006D-C3DC-4B42-A6FC-64F1AF8AE73C}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}

function module.init_start()
	task.spawn(function()
		local players = game:GetService('Players')
		
		local function loadGui(player: Player)
			task.spawn(function()
				local src = player.PlayerGui:FindFirstChild('Cortex_Buttons_Handler')
				if (not src) then
					src = Instance.new('ScreenGui')
					src.Name = 'Cortex_Buttons_Handler'
					src.ResetOnSpawn = false
					src.Parent = player.PlayerGui
					local newS = script:WaitForChild('Client_Buttons_Loader'):Clone()
					script:WaitForChild('Button_Handler'):Clone().Parent = newS
					newS.Parent = src
				end
			end)
		end
		
		players.PlayerAdded:Connect(function(player: Player)
			task.wait()
			loadGui(player)
		end)
		
		for _, v in pairs(players:GetChildren()) do
			loadGui(v)
		end
		
		require(script:WaitForChild('Button_Handler'))()
	end)
end

function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ModuleScript" referent="RBX3D153E912F4444668C23709B735AC41B">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Button_Handler</string>
						<string name="ScriptGuid">{8B3C4A09-2778-42C8-BFB1-6992D905E2F3}</string>
						<ProtectedString name="Source"><![CDATA[--[[

	!! UPDATE 09/26/2023 !!
	FIXED MAJOR MEMORY LEAK ISSUE WITH REMOTE/BINDABLE
	EVENTS BEING FIRED EVERY RENDERSTEPPED FRAME

]]--

_G.ButtonHandlerRunning = if (typeof(_G.ButtonHandlerRunning) == 'boolean') then _G.ButtonHandlerRunning else false --// Prevents multiple handlers from running at once in the same server

return function()

	if (_G.ButtonHandlerRunning) then return end
	_G.ButtonHandlerRunning = true

	local runService = game:GetService('RunService')
	local collectionService = game:GetService('CollectionService')
	local userInputService = game:GetService('UserInputService')
	local VRService = game:GetService('VRService')

	local player = game.Players.LocalPlayer
	local mouse
	if (player) then mouse = player:GetMouse() if (not player.Character) then player.CharacterAdded:Wait() end end
	local camera = workspace.CurrentCamera

	local params = RaycastParams.new()
	params.FilterType = Enum.RaycastFilterType.Blacklist

	local mouseIcon = 0 --userInputService.MouseIcon
	if player then
		mouseIcon = player:GetMouse().Icon
	end

	local distance = 15

	local function findAncestor(start: any, name: string)
		if (typeof(start) ~= 'Instance') then return end
		local result = start:FindFirstChild(name)
		if (result) then
			return result
		else
			return findAncestor(start.Parent, name)
		end
	end

	--// Updated handler to utilise if-then checks instead of returns //--
	local function checkInputEnter(input: InputObject)
		return (
			input.UserInputType == Enum.UserInputType.MouseButton1 or
				input.UserInputType == Enum.UserInputType.MouseMovement or
				input.UserInputType == Enum.UserInputType.Touch or
				input.KeyCode == Enum.KeyCode.ButtonR2 or
				input.KeyCode == Enum.KeyCode.ButtonX or
				input.UserInputType == Enum.UserInputType.Gamepad1
		)
	end

	local currentTarget = { target = nil, api = nil, remote = nil } -- Button target
	local isMouseDown = false
	local lastPressedTime = os.clock()
	local lastCheck = false

	local function handleInput(input: InputObject, gameProcessed: boolean)
		if (not checkInputEnter(input)) then return end
		if (input.UserInputState == Enum.UserInputState.Begin or ((not currentTarget.target) and (userInputService:IsMouseButtonPressed(Enum.UserInputType.MouseButton1) or userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonR2) or userInputService:IsGamepadButtonDown(Enum.UserInputType.Gamepad1, Enum.KeyCode.ButtonX)))) then
			params.FilterDescendantsInstances = player and {player.Character} or {}
			local pos = mouse and { ['X'] = mouse.X, ['Y'] = mouse.Y } or input.Position
			if (VRService.VREnabled) then
				pos = input.Position
			end
			local worldPosition = camera:ScreenPointToRay(pos.X, pos.Y, 10)
			local result = workspace:Raycast(camera.CFrame.Position, worldPosition.Direction*distance, params)
			local target = result and result.Instance
			local buttonCheck = target and target:GetAttribute('isACortexElevButton')
			local api,remote = findAncestor(target, 'Cortex_API') or findAncestor(target, 'Button_API'),findAncestor(target, 'Cortex_Remote') or findAncestor(target, 'Button_Remote')
			if ((not buttonCheck) or (not api) or (not remote) or (target.CFrame.Position-camera.CFrame.Position).Magnitude > distance) then return end
			currentTarget = { target = target, api = api, remote = remote }
			if (not currentTarget.target) then return end
			isMouseDown = true
			local info = {'onButtonPressed', {['button'] = target.Parent}}
			if ((os.clock()-lastPressedTime) <= .1) then return end
			lastPressedTime = os.clock()
			if (player) then
				remote:FireServer(unpack(info))
			else
				api:Fire(unpack(info))
			end
		else
			local lastTarget = currentTarget
			local lastMouseState = isMouseDown
			if (input.UserInputState == Enum.UserInputState.Change) then
				params.FilterDescendantsInstances = player and {player.Character} or {}
				local pos = mouse and { ['X'] = mouse.X, ['Y'] = mouse.Y } or input.Position
				local worldPosition = camera:ScreenPointToRay(pos.X, pos.Y, 10)
				local result = workspace:Raycast(camera.CFrame.Position, worldPosition.Direction*distance, params)
				local target = result and result.Instance
				local buttonCheck = target and target:GetAttribute('isACortexElevButton')
				local api,remote = findAncestor(target, 'Cortex_API') or findAncestor(target, 'Button_API'),findAncestor(target, 'Cortex_Remote') or findAncestor(target, 'Button_Remote')
				local check = buttonCheck and api and remote and (target.CFrame.Position-camera.CFrame.Position).Magnitude <= distance

				local inputType = string.match(input.UserInputType.Name, 'Mouse') and 'KeyboardMouse' or userInputService.GamepadEnabled and 'Gamepad' or 'KeyboardMouse'
				local cursorName = string.match(input.UserInputType.Name, 'Mouse') and 'ArrowCursor' or userInputService.GamepadEnabled and 'PointerOver' or 'ArrowCursor'
				if (lastCheck ~= check) then
					--userInputService.MouseIcon
					if player then
						player:GetMouse().Icon = check and "rbxasset://textures/Cursors/" .. (inputType) .. "/" .. (cursorName) .. ".png" or mouseIcon
					end
					lastCheck = check
				end
				currentTarget = { target = check and target, api = api, remote = remote }
			elseif (input.UserInputState == Enum.UserInputState.End) then
				isMouseDown = false
			end
			if not ((((currentTarget.target ~= lastTarget.target and lastMouseState) and input.UserInputState == Enum.UserInputState.Change) or input.UserInputState == Enum.UserInputState.End) and lastTarget.target) then return end
			local info = {'onButtonReleased', {['button'] = lastTarget.target.Parent}}
			if (player) then
				lastTarget.remote:FireServer(unpack(info))
			else
				lastTarget.api:Fire(unpack(info))
			end
			currentTarget = { target = nil, api = nil, remote = nil } -- // Reset the button target if mouse has left the button
		end
	end
	
	userInputService.InputBegan:Connect(handleInput)
	userInputService.InputChanged:Connect(handleInput)
	userInputService.InputEnded:Connect(handleInput)
end]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
				<Item class="LocalScript" referent="RBX658ABC06B4674623AC72DE848905C3BC">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">Client_Buttons_Loader</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{FF3DD134-BEB8-43F5-A610-7CD60DC798A5}</string>
						<ProtectedString name="Source">require(script:WaitForChild(&apos;Button_Handler&apos;))()</ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBXAE6D2D529B974C479A638AAA7EC205FB">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Door_Key</string>
					<string name="ScriptGuid">{07CCD069-2A69-48FF-9528-6FB3CE62A6C7}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}

function module.init_start()
	local players = game:GetService('Players')
	local function process(plr: Player)
		task.wait()
		local playerGui = plr:WaitForChild('PlayerGui')
		local handlerGui = playerGui:FindFirstChild('DOOR_KEY_HANDLER')
		if (not handlerGui) then
			handlerGui = Instance.new('ScreenGui')
			handlerGui.ResetOnSpawn = false
			handlerGui.Name = 'DOOR_KEY_HANDLER'
			handlerGui.Parent = playerGui
			local handlerScript = script.Parent.Parent.Dependencies.DOOR_KEY_HANDLER:Clone()
			handlerScript.Parent = handlerGui
		end
		local doorKeyUis = playerGui:FindFirstChild('DOOR_KEY_UIS')
		if (not doorKeyUis) then
			doorKeyUis = Instance.new('ScreenGui')
			doorKeyUis.Name = 'DOOR_KEY_UIS'
			doorKeyUis.ResetOnSpawn = false
			doorKeyUis.IgnoreGuiInset = false
			doorKeyUis.Parent = playerGui
		end
	end
	players.PlayerAdded:Connect(process)
	for i,v in pairs(players:GetChildren()) do
		task.spawn(process, v)
	end
end
function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX3DE73522C45C47E8985E3515492DE829">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Elevator_Storage_Manager</string>
					<string name="ScriptGuid">{B760B6C2-DCED-4555-8513-47C576A803FC}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}

local event = {} do
	event.__index = 'event'
	function event.new()
		local self = setmetatable({}, event)
		self.event = Instance.new('BindableEvent')
		return self
	end
end

function module.init_start()
	
	_G.ELEVATOR_BINDS = _G.ELEVATOR_BINDS or {}
	local addedEvent,removedEvent = event.new(),event.new()
	_G.ELEVATOR_BINDS.ElevatorAdded = addedEvent.Event
	_G.ELEVATOR_BINDS.ElevatorRemoved = removedEvent.Event
	
	local function processElevator(elev: Instance, action: string)
		task.spawn(function()
			task.wait()
			if (elev:FindFirstChild('Legacy') and elev:FindFirstChild('Cortex_API') and elev:FindFirstChild('Car') and elev:FindFirstChild('Floors')) then
				if (action == 'add') then
					_G.CortexElevatorStorage[elev] = elev
					addedEvent.event:Fire(elev)
				elseif (action == 'remove') then
					_G.CortexElevatorStorage[elev] = nil
					removedEvent.event:Fire(elev)
				end
			end
		end)
	end
	
	for _,v in pairs(workspace:GetDescendants()) do
		processElevator(v, 'add')
	end
	workspace.DescendantAdded:Connect(function(desc: Instance)
		processElevator(desc, 'add')
	end)
	workspace.DescendantRemoving:Connect(function(desc: Instance)
		processElevator(desc, 'remove')
	end)
	
end
function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
			</Item>
			<Item class="ModuleScript" referent="RBX8E89E9AE3D2F45DEA5490AAA87CA6A02">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Key_Handler</string>
					<string name="ScriptGuid">{2CA035D3-B5EE-40A1-9EE4-F5AB6DFFF917}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}
local players = game:GetService('Players')

function module.init_start()
	local function checkPlayer(player: Player)
		task.spawn(function()
			task.wait()
			local playerGui = player:WaitForChild('PlayerGui')
			local gui = playerGui:FindFirstChild('KEY_SWITCH_HANDLERS')
			if (not gui) then
				gui = Instance.new('ScreenGui')
				gui.Name = 'KEY_SWITCH_HANDLERS'
				gui.ResetOnSpawn = false
				local scr = script.KEY_CLIENT_CONTROL:Clone()
				scr.Parent = gui
				gui.Parent = playerGui
			end
		end)
	end
	players.PlayerAdded:Connect(checkPlayer)
	for _,v in pairs(players:GetChildren()) do
		checkPlayer(v)
	end
end

function module.init_core()

end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="LocalScript" referent="RBXDBE899E2CBB04F979E9D6DC8A0214306">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="Disabled">false</bool>
						<Content name="LinkedSource"><null></null></Content>
						<string name="Name">KEY_CLIENT_CONTROL</string>
						<token name="RunContext">0</token>
						<string name="ScriptGuid">{31F148B2-D2A7-4200-861D-8C9BE3733724}</string>
						<ProtectedString name="Source"><![CDATA[local Player = game.Players.LocalPlayer
local Character = Player.Character or Player.CharacterAdded:Wait()

local camera = workspace.CurrentCamera

local userInputService = game:GetService('UserInputService')

local Keys = {'Hoistway Access Key', 'Fire Service Key', 'Inspection Key', 'Logic Cabinet Key'}
local Mouse = Player:GetMouse()
local Key_Insert_Limit = false
local Target,Key_API,Hit_Target

local hoverMouseCursor = 'rbxassetid://14984615391'
local mouseCursor = Player:GetMouse().Icon

local function findKeyToolInCharacter(findName)
	if (not Character) then return end
	for i,v in pairs(Character:GetChildren()) do
		if ((table.find(Keys, v.Name) or v:GetAttribute('isACortexKey')) and v:IsA('Tool')) then
			return v
		end
	end
	return nil
end

local lastCheckBool

local params = RaycastParams.new()
params.FilterType = Enum.RaycastFilterType.Blacklist

local distance = 10

local function raycast(position: Vector3)
	params.FilterDescendantsInstances = {Player.Character}
	local worldPosition = camera:ScreenPointToRay(position.X, position.Y, distance)
	local result = workspace:Raycast(camera.CFrame.Position, worldPosition.Direction*distance, params)
	return result and result.Instance
end

local function registerTarget(input: InputObject)
	Target = raycast(input.Position)
	local foundKey = findKeyToolInCharacter('Key')
	if (Target and foundKey) then
		Key_API = (Target.Parent:FindFirstChild('Key_API') or Target.Parent:FindFirstChild('KEYSWITCH_API'))
		Hit_Target = Target.Parent:FindFirstChild('Rotate', true)
	end
	return foundKey
end

userInputService.InputChanged:Connect(function(input: InputObject, gameProcessedEvent: boolean)
	if (gameProcessedEvent or (input.UserInputType ~= Enum.UserInputType.MouseMovement)) then return end
	local foundKey = registerTarget(input)
	local thisCheckBool = Target and foundKey and Key_API and (not Key_Insert_Limit) and Hit_Target
	if (thisCheckBool ~= lastCheckBool) then
		Player:GetMouse().Icon = thisCheckBool and hoverMouseCursor or mouseCursor
	end
	lastCheckBool = thisCheckBool
end)

userInputService.InputBegan:Connect(function(input: InputObject, gameProcessedEvent: boolean)
	if (gameProcessedEvent or (input.UserInputType ~= Enum.UserInputType.MouseButton1 and input.UserInputType ~= Enum.UserInputType.Touch)) then return end
	local foundKey = registerTarget(input)
	if ((not Key_Insert_Limit) and Key_API and Hit_Target and foundKey) then
		Key_Insert_Limit = true
		local success = pcall(function()
			Key_API:InvokeServer('Activate_Key', foundKey)
		end)
		Key_Insert_Limit = false
	end
end)]]></ProtectedString>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
					</Properties>
				</Item>
			</Item>
			<Item class="ModuleScript" referent="RBX1090130B82BE44569633E66AE673572A">
				<Properties>
					<BinaryString name="AttributesSerialize"></BinaryString>
					<Content name="LinkedSource"><null></null></Content>
					<string name="Name">Player_Client_Handlers</string>
					<string name="ScriptGuid">{29031440-1BA9-4DAF-8FEE-A9F5FF314A85}</string>
					<ProtectedString name="Source"><![CDATA[--[[

	This is a demo
		
	Task: The Cortex MainModule will boot, and you can cast any errors/plugins when initiating through this module
	
	Functions:
	init_start: Starts the module only once per require cache (will only run once)
	init_core: Starts the module each time the MainModule's internal function is called

]]--

local module = {}
local players = game:GetService('Players')

function module.init_start()
	local function handle(plr: Player)
		local plrGui = plr:WaitForChild('PlayerGui')
		if (not plrGui:FindFirstChild('Cortex_Client_Weld')) then
			local handler = script.Cortex_Client_Weld:Clone()
			handler.Parent = plrGui
		end
		if (not plrGui:FindFirstChild('Cortex_Camera_Effects')) then
			local handler = script.Cortex_Camera_Effects:Clone()
			handler.Parent = plrGui
		end
	end
	
	players.PlayerAdded:Connect(handle)
	
	for i, v in pairs(players:GetChildren()) do
		task.spawn(handle, v)
	end
end

function module.init_core()
	
end

return module]]></ProtectedString>
					<int64 name="SourceAssetId">-1</int64>
					<BinaryString name="Tags"></BinaryString>
				</Properties>
				<Item class="ScreenGui" referent="RBXEEAEE87C5699458CA30C350AC1153755">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<int name="DisplayOrder">0</int>
						<bool name="Enabled">true</bool>
						<bool name="IgnoreGuiInset">false</bool>
						<string name="Name">Cortex_Client_Weld</string>
						<bool name="ResetOnSpawn">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<token name="ZIndexBehavior">1</token>
					</Properties>
					<Item class="LocalScript" referent="RBXB1B12579EB1A45C99AFE39C7BDD43E81">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Handler</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{E089DDE5-FF1F-4864-902F-26461923FDFB}</string>
							<ProtectedString name="Source"><![CDATA[local players = game:GetService('Players')
local runService = game:GetService('RunService')
local replicatedStorage = game:GetService('ReplicatedStorage')

local player = players.LocalPlayer
player.CharacterAdded:Connect(function(char)

	local root = char:WaitForChild('HumanoidRootPart')
	local humanoid: Humanoid = char:WaitForChild('Humanoid')
	root.ChildAdded:Connect(function(child: Instance)
		task.wait()
		if (child.Name ~= 'Cortex_Elevator_Weld') then return end
		local platform = child.Part1
		local settings = select(2, pcall(require, platform.Parent.Parent:FindFirstChild('Settings')))
		if ((typeof(settings) ~= 'table' or settings.Movement.Enable_New_Player_Sticking ~= true)) then return end
		local yOffset = root.CFrame.Position.Y-platform.Position.Y
		local lastPosition = platform.CFrame.Position
		child.Enabled = false
		runService:BindToRenderStep('UpdateElevatorWeld', Enum.RenderPriority.Input.Value, function()
			local diff = platform.CFrame.Position-platform.CFrame.Position
			lastPosition = platform.CFrame.Position
			root.CFrame = CFrame.new(root.CFrame.Position.X+diff.X, platform.CFrame.Position.Y+yOffset, root.CFrame.Position.Z+diff.Z)*CFrame.fromOrientation(root.CFrame:ToOrientation())
			humanoid:ChangeState(Enum.HumanoidStateType.Running)
		end)
	end)
	root.ChildRemoved:Connect(function(child: Instance)
		task.wait()
		if (child.Name ~= 'Cortex_Elevator_Weld') then return end
		runService:UnbindFromRenderStep('UpdateElevatorWeld')
	end)

end)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
				<Item class="ScreenGui" referent="RBX15AB58E345DF4CB48C4BA612A5462F51">
					<Properties>
						<BinaryString name="AttributesSerialize"></BinaryString>
						<bool name="AutoLocalize">true</bool>
						<int name="DisplayOrder">0</int>
						<bool name="Enabled">true</bool>
						<bool name="IgnoreGuiInset">false</bool>
						<string name="Name">Cortex_Camera_Effects</string>
						<bool name="ResetOnSpawn">false</bool>
						<Ref name="RootLocalizationTable">null</Ref>
						<token name="SelectionBehaviorDown">0</token>
						<token name="SelectionBehaviorLeft">0</token>
						<token name="SelectionBehaviorRight">0</token>
						<token name="SelectionBehaviorUp">0</token>
						<bool name="SelectionGroup">false</bool>
						<int64 name="SourceAssetId">-1</int64>
						<BinaryString name="Tags"></BinaryString>
						<token name="ZIndexBehavior">1</token>
					</Properties>
					<Item class="LocalScript" referent="RBXA116AD1000F64344BD6220C9579CBCAC">
						<Properties>
							<BinaryString name="AttributesSerialize"></BinaryString>
							<bool name="Disabled">false</bool>
							<Content name="LinkedSource"><null></null></Content>
							<string name="Name">Camera_Effects</string>
							<token name="RunContext">0</token>
							<string name="ScriptGuid">{6FA0870D-8089-430E-A526-39791A420F98}</string>
							<ProtectedString name="Source"><![CDATA[local runService = game:GetService('RunService')

local player = game.Players.LocalPlayer
local character = player.Character or player.CharacterAdded:Wait()

local runThread

local function handle(char)
	task.wait()
	local camera = workspace.CurrentCamera
	
	local function startupAnimation(direction: number, config)
		if ((not config) or (not config.Enable)) then return end
		local function lerp(a, b, t)
			return a+(b-a)*t
		end
		local startTime = tick()
		while ((tick()-startTime)/config.Duration < 1) do
			local dtTime = runService.RenderStepped:Wait()
			local s = math.cos((tick()-startTime)/config.Duration*5.5)*config.Amplitude*lerp(1, 0, (tick()-startTime)/config.Duration/1.45)*math.deg(dtTime)
			camera.CFrame = camera.CFrame:Lerp(camera.CFrame*CFrame.Angles(-direction*math.rad(s), 0, 0), .45)
		end
	end
	
	local root = char:WaitForChild('HumanoidRootPart')
	character.ChildAdded:Connect(function(child: any)
		if (child.Name ~= 'Cortex_Elevator_Riding') then return end
		local elevator = child.Value
		local settings = require(elevator:WaitForChild('Settings'))
		local velocity = elevator:WaitForChild('Legacy'):WaitForChild('Velocity')
		local moveValue = elevator:WaitForChild('Legacy'):WaitForChild('Move_Value')
		local topSpeed = settings.Movement.Travel_Speed
		
		local connection: RBXScriptConnection
		connection = velocity:GetPropertyChangedSignal('Value'):Connect(function()
			if (math.abs(velocity.Value) <= 0) then return end
			connection:Disconnect()
			local joltConfig = typeof(settings.Camera_Effects) == 'table' and settings.Camera_Effects["Jolt_" .. (moveValue.Value == 1 and 'Up' or moveValue.Value == -1 and 'Down' or nil)]
			local travelEffects = typeof(settings.Camera_Effects) == 'table' and settings.Camera_Effects.Movement_Effects
			task.spawn(startupAnimation, moveValue.Value, joltConfig)


			local startTime = tick()
			camera.CameraType = Enum.CameraType.Follow

			runThread = task.spawn(function()
				if ((not travelEffects) or (not travelEffects.Enable)) then return end
				local swayFrequency = travelEffects.Frequency
				local sAmplitude = travelEffects.Amplitude
				while (math.abs(velocity.Value) > 0) do
					runService.RenderStepped:Wait()

					local t = 1.5+math.cos(tick()*swayFrequency)/2
					local swayAmplitude = sAmplitude*velocity.Value/topSpeed
					local xNoise = math.noise(t)
					local yNoise = math.noise(0, t)

					local xSway = math.sin(xNoise*.05*15/.025)*swayAmplitude
					local ySway = math.cos(yNoise*.05*15/.025)*swayAmplitude

					camera.CFrame = camera.CFrame:Lerp(camera.CFrame*CFrame.Angles(math.rad(xSway), math.rad(ySway), 0), .25)
				end
			end)
		end)
	end)
	
	character.ChildRemoved:Connect(function(child: any)
		task.wait()
		if (child.Name ~= 'Cortex_Elevator_Riding' or (not runThread)) then return end
		task.cancel(runThread)
		runThread = nil
	end)
end

handle(character)

player.CharacterAdded:Connect(handle)]]></ProtectedString>
							<int64 name="SourceAssetId">-1</int64>
							<BinaryString name="Tags"></BinaryString>
						</Properties>
					</Item>
				</Item>
			</Item>
		</Item>
	</Item>
	<SharedStrings>
		<SharedString md5="R/kNg3o2+1j2PvHmTgPeDA==">Q1NHUEhTBgAAAM84j0MAAAAAAAAAAAAAAADym+VFAAAAAAAAAAB86q9FAAAAAOGwR0YQAAAA
AAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQAAACz8RZAtH/2wOGP
PT6z8RZARWDowIQJXL6z8RZAtH/2wGoqXL5CQklAcRLcwDoGXL5CQklAcRLcwDpXPT5CQklA
4DHqwCCPPT5CQklA3jHqwJQcXL6z8RZARWDowGlePT4kAAAAAAAAAAEAAAACAAAAAwAAAAIA
AAABAAAAAwAAAAEAAAAEAAAABQAAAAMAAAAEAAAABQAAAAAAAAACAAAABgAAAAIAAAADAAAA
BgAAAAMAAAAFAAAABgAAAAUAAAACAAAABwAAAAAAAAAFAAAABwAAAAUAAAAEAAAABwAAAAQA
AAABAAAABwAAAAEAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPxgAAAAEAAAASXjQwESuAsCNIVy+FkXdwESuAsCNIVy+FEXdwESuAsDEbh2/gMXVwEiu
gr+KIVy+TJLiwEiugr/Ebh2/f8XVwEiugr/Ebh2/TpLiwEiugr+KIVy+SHjQwESuAsDEbh2/
JAAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAACAAAAAQAAAAUAAAACAAAABAAAAAUA
AAAEAAAAAwAAAAUAAAADAAAAAAAAAAYAAAABAAAAAwAAAAYAAAADAAAABAAAAAYAAAAEAAAA
AQAAAAcAAAAAAAAAAgAAAAcAAAACAAAABQAAAAcAAAAFAAAAAAAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAABhF3cBErgLAiyFcvhQry8BkBUTA
iyFcvkl40MBErgLAiyFcvkl40MBErgLAxG4dvxMry8BkBUTAxG4dv97318BkBUTAxG4dvxRF
3cBErgLAxG4dv97318BkBUTAjCFcviQAAAAAAAAAAQAAAAIAAAADAAAAAgAAAAEAAAADAAAA
AAAAAAIAAAAEAAAAAQAAAAUAAAAEAAAABQAAAAMAAAAEAAAAAwAAAAEAAAAGAAAABQAAAAAA
AAAGAAAAAAAAAAMAAAAGAAAAAwAAAAUAAAAHAAAAAAAAAAUAAAAHAAAABQAAAAEAAAAHAAAA
AQAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQA
AAAYRd3ARK4CwJzDFT8UK8vAZAVEwJ7DFT9JeNDARK4CwJ3DFT9JeNDARK4CwO90PT4TK8vA
ZAVEwPF0PT7e99fAZAVEwPJ0PT4URd3ARK4CwPF0PT7e99fAZAVEwJzDFT8kAAAAAAAAAAEA
AAACAAAAAwAAAAIAAAABAAAAAwAAAAAAAAACAAAABAAAAAEAAAAFAAAABAAAAAUAAAADAAAA
BAAAAAMAAAABAAAABgAAAAUAAAAAAAAABgAAAAAAAAADAAAABgAAAAMAAAAFAAAABwAAAAAA
AAAFAAAABwAAAAUAAAABAAAABwAAAAEAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA
AAAAAAAAAAAAAAAAAACAPxgAAAAEAAAATpLiwEiugr+bwxU/SXjQwESuAsCdwxU/gMXVwEiu
gr+bwxU/f8XVwEiugr/wdD0+SHjQwESuAsDvdD0+FEXdwESuAsDwdD0+TJLiwEiugr/wdD0+
FkXdwESuAsCbwxU/JAAAAAAAAAABAAAAAgAAAAMAAAACAAAAAQAAAAMAAAAAAAAAAgAAAAQA
AAABAAAABQAAAAQAAAAFAAAAAwAAAAQAAAADAAAAAQAAAAYAAAAFAAAAAAAAAAYAAAAAAAAA
AwAAAAYAAAADAAAABQAAAAcAAAAAAAAABQAAAAcAAAAFAAAAAQAAAAcAAAABAAAAAAAAABAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAANi50cAAAIC1
nMMVP6GG3sAAAIC1nMMVP6KG3sAAAIC173Q9PjtnzMArM4M/nMMVPwg02cArM4M/7nQ9Pjpn
zMArM4M/7nQ9Pti50cAAAIC17nQ9PgM02cArM4M/nMMVPyQAAAAAAAAAAQAAAAIAAAABAAAA
AAAAAAMAAAAEAAAAAgAAAAEAAAAFAAAAAgAAAAQAAAAFAAAABAAAAAMAAAAFAAAAAwAAAAAA
AAAGAAAAAAAAAAIAAAAGAAAAAgAAAAUAAAAGAAAABQAAAAAAAAAHAAAAAQAAAAMAAAAHAAAA
AwAAAAQAAAAHAAAABAAAAAEAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAA
AAAAAIA/GAAAAAQAAADYudHAAACAtYshXL6hht7AAACAtYghXL6iht7AAACAtcVuHb87Z8zA
KzODP4shXL4INNnAKzODP8ZuHb86Z8zAKzODP8ZuHb/YudHAAACAtcVuHb8DNNnAKzODP4Uh
XL4kAAAAAAAAAAEAAAACAAAAAQAAAAAAAAADAAAABAAAAAIAAAABAAAABQAAAAIAAAAEAAAA
BQAAAAQAAAADAAAABQAAAAMAAAAAAAAABgAAAAAAAAACAAAABgAAAAIAAAAFAAAABgAAAAUA
AAAAAAAABwAAAAEAAAADAAAABwAAAAMAAAAEAAAABwAAAAQAAAABAAAAEAAAAAAAAAAAAAAA
AAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAAFTPjwHhmZr+KIVy+gMXVwEiu
gr+KIVy+2bnRwAAAgLWNIVy+2LnRwAAAgLXEbh2/TJLiwEiugr/Ebh2/pIbewAAAgLXEbh2/
gMXVwEiugr/Ebh2/o4bewAAAgLWHIVy+TpLiwEiugr+KIVy+FDPjwFhmZr/Ebh2/MAAAAAAA
AAABAAAAAgAAAAMAAAAEAAAABQAAAAMAAAAFAAAAAgAAAAMAAAACAAAAAQAAAAYAAAABAAAA
BAAAAAYAAAAEAAAAAwAAAAYAAAADAAAAAQAAAAcAAAAAAAAAAgAAAAcAAAACAAAABQAAAAcA
AAAFAAAAAAAAAAgAAAAAAAAABAAAAAgAAAAEAAAAAQAAAAgAAAABAAAAAAAAAAkAAAAEAAAA
AAAAAAkAAAAAAAAABQAAAAkAAAAFAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAA
AAAAAAAAAAAAAAAAgD8eAAAABAAAABUz48B4Zma/nMMVP4DF1cBIroK/nMMVP9m50cAAAIC1
nMMVP9i50cAAAIC17nQ9PkyS4sBIroK/73Q9PqSG3sAAAIC173Q9PoDF1cBIroK/73Q9PqOG
3sAAAIC1nMMVP06S4sBIroK/nMMVPxQz48BeZma/73Q9PjAAAAAAAAAAAQAAAAIAAAADAAAA
BAAAAAUAAAADAAAABQAAAAIAAAADAAAAAgAAAAEAAAAGAAAAAQAAAAQAAAAGAAAABAAAAAMA
AAAGAAAAAwAAAAEAAAAHAAAAAAAAAAIAAAAHAAAAAgAAAAUAAAAHAAAABQAAAAAAAAAIAAAA
AAAAAAQAAAAIAAAABAAAAAEAAAAIAAAAAQAAAAAAAAAJAAAABAAAAAAAAAAJAAAAAAAAAAUA
AAAJAAAABQAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/
HgAAAAQAAABBNtfAdldNwJzDFT/XY7vAQq6CwJ3DFT8SK8vAZAVEwJ7DFT/WY7vAQq6CwOx0
PT5Dg8nAQq6CwOh0PT7a99fAZAVEwPJ0PT5Eg8nAQq6CwJzDFT8PK8vAZAVEwPF0PT7e99fA
ZAVEwJzDFT9BNtfAdldNwPJ0PT4wAAAAAAAAAAEAAAACAAAAAwAAAAEAAAAEAAAAAwAAAAQA
AAAFAAAAAwAAAAIAAAABAAAABgAAAAAAAAAEAAAABgAAAAQAAAABAAAABgAAAAEAAAAAAAAA
BwAAAAUAAAACAAAABwAAAAIAAAADAAAABwAAAAMAAAAFAAAACAAAAAAAAAACAAAACAAAAAIA
AAAFAAAACAAAAAUAAAAAAAAACQAAAAQAAAAAAAAACQAAAAAAAAAFAAAACQAAAAUAAAAEAAAA
EAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAAQzbXwHZX
TcCPIVy+1WO7wEKugsCQIVy+EivLwGQFRMCNIVy+1GO7wEKugsDFbh2/QoPJwEKugsDFbh2/
3PfXwGQFRMDEbh2/RoPJwEKugsCPIVy+DyvLwGQFRMDEbh2/3ffXwGQFRMCPIVy+QjbXwHNX
TcDEbh2/MAAAAAAAAAABAAAAAgAAAAMAAAABAAAABAAAAAMAAAAEAAAABQAAAAMAAAACAAAA
AQAAAAYAAAAAAAAABAAAAAYAAAAEAAAAAQAAAAYAAAABAAAAAAAAAAcAAAAFAAAAAgAAAAcA
AAACAAAAAwAAAAcAAAADAAAABQAAAAgAAAAAAAAAAgAAAAgAAAACAAAABQAAAAgAAAAFAAAA
AAAAAAkAAAAEAAAAAAAAAAkAAAAAAAAABQAAAAkAAAAFAAAABAAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAEE218CISLQ/m8MVPz1nzMArM4M/
m8MVP3gMv8AvMwNAm8MVP3gMv8AvMwNA63Q9Pgg02cArM4M/7XQ9PuYrzcAuMwNA7XQ9Pjxn
zMArM4M/7XQ9PgU02cArM4M/m8MVP+QrzcAvMwNAm8MVP0I218CASLQ/7XQ9PjAAAAAAAAAA
AQAAAAIAAAADAAAABAAAAAUAAAADAAAABQAAAAIAAAADAAAAAgAAAAEAAAAGAAAAAQAAAAQA
AAAGAAAABAAAAAMAAAAGAAAAAwAAAAEAAAAHAAAAAAAAAAQAAAAHAAAABAAAAAEAAAAHAAAA
AQAAAAAAAAAIAAAAAAAAAAIAAAAIAAAAAgAAAAUAAAAIAAAABQAAAAAAAAAJAAAABAAAAAAA
AAAJAAAAAAAAAAUAAAAJAAAABQAAAAQAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAA
AAAAAAAAAAAAAIA/HgAAAAQAAAA/NtfAiEi0P4MhXL49Z8zAKzODP4shXL54DL/ALzMDQJMh
XL53DL/ALjMDQMZuHb8INNnAKzODP8ZuHb/mK83ALzMDQMZuHb88Z8zAKzODP8ZuHb8FNNnA
KzODP4UhXL7kK83ALzMDQIUhXL5DNtfAgEi0P8ZuHb8wAAAAAAAAAAEAAAACAAAAAwAAAAQA
AAAFAAAAAwAAAAUAAAACAAAAAwAAAAIAAAABAAAABgAAAAEAAAAEAAAABgAAAAQAAAADAAAA
BgAAAAMAAAABAAAABwAAAAAAAAAEAAAABwAAAAQAAAABAAAABwAAAAEAAAAAAAAACAAAAAAA
AAACAAAACAAAAAIAAAAFAAAACAAAAAUAAAAAAAAACQAAAAQAAAAAAAAACQAAAAAAAAAFAAAA
CQAAAAUAAAAEAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgA
AAAEAAAA7XGtwMjMREDrdD0+dgy/wC8zA0DrdD0+5ivNwC4zA0DtdD0+7XGtwMjMRECbwxU/
dgy/wC8zA0CbwxU/KSG9wMjMREDsdD0+JyG9wMjMRECbwxU/4ivNwC8zA0CbwxU/JAAAAAAA
AAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAACAAAAAQAAAAQAAAABAAAAAwAAAAUAAAADAAAA
AAAAAAUAAAAAAAAAAgAAAAYAAAAEAAAAAwAAAAYAAAADAAAABQAAAAYAAAAFAAAAAgAAAAcA
AAACAAAABAAAAAcAAAAEAAAABgAAAAcAAAAGAAAAAgAAABAAAAAAAAAAAAAAAAAAAAAAAAAA
EAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAO5xrcDIzERAxm4dv3UMv8AuMwNAxm4dv+Yr
zcAvMwNAxm4dv+5xrcDIzERAkiFcvuQrzcAvMwNAhiFcvikhvcDIzERAxm4dvychvcDIzERA
iiFcvnYMv8AvMwNAkiFcviQAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAMAAAAEAAAAAgAAAAEA
AAAFAAAAAgAAAAQAAAAFAAAAAwAAAAAAAAAFAAAAAAAAAAIAAAAGAAAABAAAAAMAAAAGAAAA
AwAAAAUAAAAGAAAABQAAAAQAAAAHAAAAAQAAAAMAAAAHAAAAAwAAAAQAAAAHAAAABAAAAAEA
AAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAADspY7A
2pqVQMhuHb/spY7ARiKFQMVuHb/EBqPAMTODQMhuHb/spY7A2pqVQJvDFT/ABqPAMTODQJzD
FT/UAZHAMTODQJzDFT/spY7ARyKFQJzDFT/SAZHAMTODQMduHb+Yx57AUmGIQJzDFT+ax57A
UWGIQMhuHb8wAAAAAAAAAAEAAAACAAAAAQAAAAAAAAADAAAABAAAAAIAAAAFAAAABAAAAAUA
AAADAAAABgAAAAEAAAADAAAABgAAAAMAAAAFAAAABgAAAAUAAAABAAAABwAAAAIAAAABAAAA
BwAAAAEAAAAFAAAABwAAAAUAAAACAAAACAAAAAIAAAAEAAAACAAAAAQAAAADAAAACAAAAAMA
AAAAAAAACQAAAAAAAAACAAAACQAAAAIAAAAIAAAACQAAAAgAAAAAAAAAEAAAAAAAAAAAAAAA
AAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAfhGnwEpbVEDFbh2/1AGRwDEz
g0CcwxU/fhGnwElbVECbwxU/0wGRwDEzg0DHbh2/wwajwDEzg0DIbh2/wgajwDEzg0CcwxU/
fhGnwA6KfEDIbh2/fhGnwAmKfECcwxU/JAAAAAAAAAABAAAAAgAAAAMAAAAAAAAABAAAAAMA
AAAEAAAAAQAAAAMAAAABAAAAAAAAAAUAAAACAAAAAQAAAAUAAAABAAAABAAAAAYAAAAFAAAA
BAAAAAYAAAAEAAAAAAAAAAYAAAAAAAAAAgAAAAcAAAACAAAABQAAAAcAAAAFAAAABgAAAAcA
AAAGAAAAAgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAA
BAAAAHXIS8DU2qFAmsMVP3XIS8BF+q9AmsMVP3XIS8DU2qFAyG4dv8QGI8C+8blAmsMVP8QG
I8C98blAyW4dv8QGI8BO0qtAmcMVP3XIS8BE+q9AyW4dv8QGI8BO0qtAyG4dvyQAAAAAAAAA
AQAAAAIAAAABAAAAAAAAAAMAAAAEAAAAAQAAAAMAAAAFAAAABAAAAAMAAAAFAAAAAwAAAAAA
AAAFAAAAAAAAAAIAAAAGAAAAAgAAAAEAAAAGAAAAAQAAAAQAAAAGAAAABAAAAAIAAAAHAAAA
AgAAAAQAAAAHAAAABAAAAAUAAAAHAAAABQAAAAIAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAA
AAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAADtca3AyMxEQJzDFT8mIb3AyMxEQJzDFT8oIb3A
yMxEQMVuHb9+EafAC4p8QJzDFT9+EafADop8QMhuHb9+EafASltUQMVuHb/uca3AyMxEQMVu
Hb9+EafASVtUQJvDFT9s97vAUo5JQMVuHb9p97vAUo5JQJzDFT8wAAAAAAAAAAEAAAACAAAA
AQAAAAAAAAADAAAABAAAAAMAAAAFAAAABAAAAAUAAAACAAAABgAAAAAAAAACAAAABgAAAAIA
AAAFAAAABgAAAAUAAAAAAAAABwAAAAMAAAAAAAAABwAAAAAAAAAFAAAABwAAAAUAAAADAAAA
CAAAAAMAAAAEAAAACAAAAAQAAAACAAAACAAAAAIAAAABAAAACQAAAAEAAAADAAAACQAAAAMA
AAAIAAAACQAAAAgAAAABAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPxgAAAAEAAAAJ4p0wBLXlUCcwxU/J4p0wMsCpkCawxU/J4p0wBLXlUDIbh2/dchLwEX6
r0CawxU/J4p0wMsCpkDIbh2/dchLwNXaoUDIbh2/dchLwET6r0DJbh2/dchLwNXaoUCawxU/
JAAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAACAAAAAQAAAAQAAAABAAAAAwAAAAUA
AAACAAAABAAAAAUAAAAAAAAAAgAAAAYAAAAEAAAAAwAAAAYAAAADAAAABQAAAAYAAAAFAAAA
BAAAAAcAAAADAAAAAAAAAAcAAAAAAAAABQAAAAcAAAAFAAAAAwAAABAAAAAAAAAAAAAAAAAA
AAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAEdCyT8NRv/Al8MVP0dCyT9DefLA
zG4dv0dCyT9CefLAl8MVP0pCST+WrQHBmMMVP0pCST+WrQHBzG4dv0pCST9ejvbAmMMVP01C
ST9gjvbAzG4dv0dCyT8NRv/Az24dvyQAAAAAAAAAAQAAAAIAAAADAAAABAAAAAAAAAADAAAA
AAAAAAIAAAAFAAAABAAAAAMAAAAFAAAAAwAAAAIAAAAFAAAAAgAAAAEAAAAGAAAAAQAAAAQA
AAAGAAAABAAAAAUAAAAGAAAABQAAAAEAAAAHAAAAAAAAAAQAAAAHAAAABAAAAAEAAAAHAAAA
AQAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQA
AAA/g0m/CaMAwZjDFT8/g0m/RXn0wMtuHb8/g0m/Rnn0wJnDFT9Dg8m/oi/9wJnDFT9Dg8m/
oy/9wMxuHb9Dg8m/2GLwwMpuHb8/g0m/CaMAwcxuHb9Dg8m/2WLwwJrDFT8kAAAAAAAAAAEA
AAACAAAAAwAAAAQAAAAAAAAAAwAAAAAAAAACAAAABQAAAAQAAAADAAAABQAAAAIAAAABAAAA
BQAAAAEAAAAEAAAABgAAAAAAAAAEAAAABgAAAAQAAAABAAAABgAAAAEAAAAAAAAABwAAAAMA
AAACAAAABwAAAAIAAAAFAAAABwAAAAUAAAADAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA
AAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAAAAENUGuAsGYwxU/AAD4NLOP+MDMbh2/AAAANbSP
+MCYwxU/P4NJvwmjAMGYwxU/P4NJvwmjAMHObh2/P4NJv0V59MDLbh2/AAAANUCuAsHObh2/
P4NJv0Z59MCZwxU/JAAAAAAAAAABAAAAAgAAAAMAAAAEAAAAAAAAAAMAAAAAAAAAAgAAAAUA
AAAEAAAAAwAAAAUAAAACAAAAAQAAAAUAAAABAAAABAAAAAYAAAAAAAAABAAAAAYAAAAEAAAA
AQAAAAYAAAABAAAAAAAAAAcAAAADAAAAAgAAAAcAAAACAAAABQAAAAcAAAAFAAAAAwAAABAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAOyljsBHIoVA
nMMVP+yljsDXmpVAm8MVP+yljsBGIoVAxW4dvyeKdMDLAqZAmsMVPyeKdMAS15VAyG4dv+Za
dsAjkaVAyG4dvyeKdMAS15VAnMMVP+yljsDXmpVAyG4dvyeKdMDKAqZAyG4dv+ZadsAkkaVA
msMVPzAAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAMAAAAEAAAAAgAAAAUAAAAEAAAAAAAAAAIA
AAAGAAAAAwAAAAAAAAAGAAAAAAAAAAQAAAAGAAAABAAAAAMAAAAHAAAAAgAAAAEAAAAHAAAA
AQAAAAUAAAAHAAAABQAAAAIAAAAIAAAABQAAAAMAAAAIAAAAAwAAAAQAAAAIAAAABAAAAAUA
AAAJAAAAAQAAAAMAAAAJAAAAAwAAAAUAAAAJAAAABQAAAAEAAAAQAAAAAAAAAAAAAAAAAAAA
AAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAABKQkk/mK0BwZjDFT9MQkk/Yo72wMxu
Hb9KQkk/YY72wJjDFT8AAAA1to/4wJjDFT8AAAQ1Qa4CwZjDFT8AAAA1QK4Cwc5uHb9KQkk/
mK0Bwc5uHb////c0tY/4wMxuHb9P0Ew+NTMDwZjDFT+e0Ew+NDMDwc5uHb8wAAAAAAAAAAEA
AAACAAAAAwAAAAIAAAABAAAAAwAAAAAAAAACAAAABAAAAAAAAAADAAAABAAAAAMAAAAFAAAA
BgAAAAUAAAABAAAABgAAAAEAAAAAAAAABwAAAAEAAAAFAAAABwAAAAUAAAADAAAABwAAAAMA
AAABAAAACAAAAAYAAAAAAAAACAAAAAAAAAAEAAAACAAAAAQAAAAFAAAACQAAAAUAAAAGAAAA
CQAAAAYAAAAIAAAACQAAAAgAAAAFAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAA
AAAAAAAAAACAPxgAAAAEAAAAcyIXwF5U6MDIbh2/cyIXwMxz9sDMbh2/RYNJwPkh6sDLbh2/
cyIXwF1U6MCawxU/RYNJwIwC3MDIbh2/RYNJwPkh6sCawxU/RYNJwIwC3MCawxU/cyIXwMlz
9sCawxU/JAAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAADAAAAAAAAAAQAAAAAAAAA
AgAAAAUAAAAEAAAAAgAAAAUAAAACAAAAAQAAAAYAAAADAAAABAAAAAYAAAAEAAAABQAAAAYA
AAAFAAAAAwAAAAcAAAABAAAAAwAAAAcAAAADAAAABQAAAAcAAAAFAAAAAQAAABAAAAAAAAAA
AAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAEODyb/XYvDAym4dv0OD
yb+kL/3AzG4dv3MiF8DOc/bAzG4dv0ODyb/ZYvDAmsMVP3MiF8BdVOjAmsMVP9LwBsCUafrA
msMVP3MiF8BhVOjAyG4dv0ODyb+jL/3AmcMVP3MiF8DLc/bAmsMVP9HwBsCVafrAzG4dvzAA
AAAAAAAAAQAAAAIAAAABAAAAAAAAAAMAAAAEAAAAAwAAAAAAAAAFAAAAAwAAAAQAAAAGAAAA
AAAAAAIAAAAGAAAAAgAAAAQAAAAGAAAABAAAAAAAAAAHAAAAAQAAAAMAAAAHAAAAAwAAAAUA
AAAHAAAABQAAAAEAAAAIAAAABAAAAAIAAAAIAAAAAgAAAAUAAAAIAAAABQAAAAQAAAAJAAAA
AgAAAAEAAAAJAAAAAQAAAAUAAAAJAAAABQAAAAIAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAA
AAAAAAAAAAAAAAAAAAAAAIA/JAAAAAQAAACiMhNA+LHuwMxuHb+iMhNAxX77wNBuHb9GQsk/
D0b/wM9uHb9GQsk/D0b/wJfDFT9GQsk/QnnywJfDFT+hMhNA+LHuwJbDFT9GQsk/RHnywMxu
Hb+iMhNAwn77wJbDFT+08RZARmDowIMJXL608RZARmDowGpePT608RZAtH/2wGoqXL608RZA
tH/2wN+PPT48AAAAAAAAAAEAAAACAAAAAwAAAAIAAAABAAAABAAAAAIAAAADAAAABAAAAAMA
AAAFAAAABgAAAAAAAAACAAAABgAAAAIAAAAEAAAABwAAAAUAAAADAAAABwAAAAMAAAABAAAA
CAAAAAAAAAAGAAAACAAAAAYAAAAEAAAACQAAAAQAAAAFAAAACQAAAAgAAAAEAAAACgAAAAgA
AAAJAAAACgAAAAEAAAAAAAAACgAAAAAAAAAIAAAACgAAAAcAAAABAAAACwAAAAcAAAAKAAAA
CwAAAAoAAAAJAAAACwAAAAUAAAAHAAAACwAAAAkAAAAFAAAAEAAAAAAAAAAAAAAAAAAAAAAA
AAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAA0v+swDCLnMCcwxU/Ft28wDCLnMCcwxU/
FN28wDCLnMDGbh2/12O7wEKugsCdwxU/RoPJwEKugsCcwxU/1WO7wEKugsDGbh2/z/+swDCL
nMDGbh2/RIPJwEKugsDGbh2/JAAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAACAAAA
AQAAAAQAAAABAAAAAwAAAAUAAAAEAAAAAwAAAAUAAAADAAAAAAAAAAYAAAAAAAAAAgAAAAYA
AAACAAAABQAAAAYAAAAFAAAAAAAAAAcAAAACAAAABAAAAAcAAAAEAAAABQAAAAcAAAAFAAAA
AgAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAG73
u8DCYJ7AnMMVP/TLl8AfaLbAnMMVP9L/rMAwi5zAnMMVP/PLl8AfaLbAx24dv4JEqMAfaLbA
x24dvxXdvMAwi5zAx24dv4JEqMAfaLbAnMMVP8//rMAwi5zAx24dvxfdvMAwi5zAnMMVP233
u8DCYJ7Ax24dvzAAAAAAAAAAAQAAAAIAAAADAAAAAQAAAAQAAAADAAAABAAAAAUAAAADAAAA
AgAAAAEAAAAGAAAAAAAAAAQAAAAGAAAABAAAAAEAAAAGAAAAAQAAAAAAAAAHAAAABQAAAAIA
AAAHAAAAAgAAAAMAAAAHAAAAAwAAAAUAAAAIAAAAAAAAAAIAAAAIAAAAAgAAAAUAAAAIAAAA
BQAAAAAAAAAJAAAABAAAAAAAAAAJAAAAAAAAAAUAAAAJAAAABQAAAAQAAAAQAAAAAAAAAAAA
AAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/JAAAAAQAAADJBiNAvPG5QD2APT7JBiNA
TtKrQJV+PT7jWnZAJZGlQHSOPT7JBiNAvPG5QJMHXL7JBiNATtKrQKMUXL7bAZFALDODQKYO
XL7cAZFALDODQL2OPT7GBqNALDODQHCOPT7GBqNALDODQCALXL6Zx55AUWGIQCALXL7kWnZA
JZGlQG0aXL6ax55AUWGIQHCOPT48AAAAAAAAAAEAAAACAAAAAAAAAAIAAAADAAAAAAAAAAMA
AAABAAAABAAAAAUAAAABAAAABAAAAAEAAAADAAAABgAAAAcAAAACAAAABgAAAAIAAAABAAAA
BgAAAAEAAAAFAAAABgAAAAUAAAAHAAAACAAAAAcAAAAFAAAACAAAAAkAAAAHAAAACgAAAAkA
AAAIAAAACgAAAAgAAAAFAAAACgAAAAUAAAAEAAAACgAAAAQAAAADAAAACgAAAAMAAAACAAAA
CgAAAAIAAAAJAAAACwAAAAIAAAAHAAAACwAAAAcAAAAJAAAACwAAAAkAAAACAAAAEAAAAAAA
AAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAAgkSowB1otsCcwxU/
EoOGwPXf1cCbwxU/88uXwB1otsCcwxU/8suXwB1otsDFbh2/gkSowB1otsDFbh2/EoOGwPbf
1cDJbh2/EoOGwGhnxcCbwxU/EoOGwGhnxcDHbh2/mMeewOj6wcCcwxU/mMeewOj6wcDFbh2/
MAAAAAAAAAABAAAAAgAAAAMAAAAAAAAAAgAAAAQAAAAAAAAAAwAAAAQAAAADAAAABQAAAAYA
AAADAAAAAgAAAAYAAAACAAAAAQAAAAYAAAABAAAABQAAAAcAAAAFAAAAAwAAAAcAAAADAAAA
BgAAAAcAAAAGAAAABQAAAAgAAAAAAAAABAAAAAgAAAAFAAAAAQAAAAgAAAABAAAAAAAAAAkA
AAAEAAAABQAAAAkAAAAFAAAACAAAAAkAAAAIAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAA
EAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAABKDhsD339XAm8MVP0WDScD6IerAmsMVPxKD
hsBoZ8XAm8MVPxKDhsBoZ8XAyG4dv0WDScCMAtzAyG4dv+BadsC8Kt/Aym4dv0WDScD7IerA
y24dv0WDScCMAtzAmsMVPxKDhsD439XAyW4dv+ZadsC5Kt/AmsMVPzAAAAAAAAAAAQAAAAIA
AAADAAAAAgAAAAQAAAADAAAABAAAAAUAAAADAAAAAAAAAAIAAAAGAAAAAQAAAAUAAAAGAAAA
BQAAAAQAAAAGAAAABAAAAAEAAAAHAAAAAgAAAAEAAAAHAAAAAQAAAAQAAAAHAAAABAAAAAIA
AAAIAAAABQAAAAAAAAAIAAAAAAAAAAMAAAAIAAAAAwAAAAUAAAAJAAAAAAAAAAUAAAAJAAAA
BQAAAAEAAAAJAAAAAQAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAA
AAAAAIA/KgAAAAQAAADVIrtANDODwCILXL5FQslANDODwCILXL5FQklA3THqwJYcXL5BQslA
NDODwGyOPT6ax55A6PrBwB8LXL5FQklA4THqwCCPPT6ax55A5frBwHCOPT5FQklAcRLcwDpX
PT7VIrtANDODwG+OPT5FQklAbxLcwDoGXL5v97tAwWCewGyOPT5v97tAwWCewB8LXL7nWnZA
virfwHOOPT7qWnZAtyrfwC8QXL5IAAAAAAAAAAEAAAACAAAAAAAAAAMAAAABAAAABAAAAAIA
AAABAAAABQAAAAYAAAADAAAABQAAAAcAAAACAAAACAAAAAcAAAAFAAAACAAAAAUAAAADAAAA
CAAAAAMAAAAAAAAACAAAAAAAAAAHAAAACQAAAAIAAAAHAAAACQAAAAcAAAAAAAAACQAAAAAA
AAACAAAACgAAAAYAAAAEAAAACgAAAAEAAAADAAAACgAAAAMAAAAGAAAACwAAAAQAAAABAAAA
CwAAAAEAAAAKAAAACwAAAAoAAAAEAAAADAAAAAYAAAAFAAAADAAAAAUAAAACAAAADAAAAAQA
AAAGAAAADQAAAAIAAAAEAAAADQAAAAQAAAAMAAAADQAAAAwAAAACAAAAEAAAAAAAAAAAAAAA
AAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyQAAAAEAAAAQULJQDQzg8Bujj0+1CK7QDQz
g8Bvjj0+1CK7QDQzg8AkC1y+pobeQAAAgLVrjj0+2rnRQAAAgLUnC1y+FjPjQGhmZr8nC1y+
RzbXQHRXTcAkC1y+2rnRQAAAgLVyjj0+pobeQAAAgLUnC1y+Q0LJQDQzg8AiC1y+FjPjQGhm
Zr9rjj0+RDbXQHRXTcBsjj0+PAAAAAAAAAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAAFAAAA
AgAAAAQAAAACAAAAAQAAAAYAAAACAAAABQAAAAcAAAABAAAAAwAAAAcAAAADAAAABAAAAAcA
AAAEAAAAAQAAAAgAAAADAAAABQAAAAgAAAAFAAAABAAAAAgAAAAEAAAAAwAAAAkAAAAAAAAA
AgAAAAkAAAACAAAABgAAAAkAAAAGAAAAAAAAAAoAAAAGAAAABQAAAAoAAAADAAAAAAAAAAoA
AAAFAAAAAwAAAAsAAAAAAAAABgAAAAsAAAAGAAAACgAAAAsAAAAKAAAAAAAAABAAAAAAAAAA
AAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8kAAAABAAAANwBkUAtM4NAvY49PqaG
3kAAAIC1a449PscGo0AtM4NAcI49PtsBkUAtM4NApg5cvtq50UAAAIC1JAtcvkY210CMSLQ/
JAtcvm73u0BWjklAIwtcvqaG3kAAAIC1JAtcvkY210CISLQ/a449Ptq50UAAAIC1co49PscG
o0AtM4NAIAtcvm73u0BVjklAbo49PjwAAAAAAAAAAQAAAAIAAAADAAAAAAAAAAIAAAADAAAA
BAAAAAAAAAADAAAABQAAAAQAAAAGAAAABQAAAAMAAAAHAAAAAQAAAAQAAAAHAAAABAAAAAUA
AAAHAAAABQAAAAEAAAAIAAAABQAAAAYAAAAIAAAAAgAAAAEAAAAIAAAAAQAAAAUAAAAJAAAA
AAAAAAQAAAAJAAAABAAAAAEAAAAJAAAAAQAAAAAAAAAKAAAAAwAAAAIAAAAKAAAAAgAAAAYA
AAAKAAAABgAAAAMAAAALAAAABgAAAAIAAAALAAAAAgAAAAgAAAALAAAACAAAAAYAAAAQAAAA
AAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/GAAAAAQAAADKBqM/wmy6QIjD
FT/KBqM/VRzZQDNvHb/KBqM/VRzZQIXDFT8AAAA1Hva+QIvDFT8AAAA1Gfa+QGtwHb8AAAA1
VRzZQBlvHb/KBqM/w2y6QK1wHb8AAAA1VRzZQIXDFT8kAAAAAAAAAAEAAAACAAAAAwAAAAQA
AAAAAAAAAwAAAAAAAAACAAAABQAAAAQAAAADAAAABQAAAAIAAAABAAAABQAAAAEAAAAEAAAA
BgAAAAAAAAAEAAAABgAAAAQAAAABAAAABgAAAAEAAAAAAAAABwAAAAMAAAACAAAABwAAAAIA
AAAFAAAABwAAAAUAAAADAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPx4AAAAEAAAAwQajv/BYuEAHcB2/wgYjwEzSq0CZwxU/wgYjwEzSq0DIbh2/7JjZv1Yc
2UCtbx2/wQajv/RYuECWwxU/wgajv1Yc2UCFwxU/wQajv1Yc2UCZbx2/7JjZv1Yc2UCGwxU/
wgYjwLzxuUCawxU/wgYjwLzxuUDJbh2/MAAAAAAAAAABAAAAAgAAAAAAAAACAAAAAwAAAAQA
AAAFAAAAAQAAAAQAAAABAAAAAAAAAAQAAAAAAAAABQAAAAYAAAADAAAABQAAAAYAAAAFAAAA
AAAAAAYAAAAAAAAAAwAAAAcAAAABAAAABQAAAAcAAAAFAAAAAwAAAAgAAAABAAAABwAAAAgA
AAAHAAAAAwAAAAgAAAACAAAAAQAAAAkAAAADAAAAAgAAAAkAAAACAAAACAAAAAkAAAAIAAAA
AwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAAAA
ADVYHNlAGW8dvwAAADUY9r5Aa3Adv8EGo7/xWLhAB3AdvwAAADVYHNlAhMMVP8EGo79YHNlA
l28dv8EGo7/1WLhAlsMVP8IGo79YHNlAhcMVPwAAADUd9r5AisMVPyQAAAAAAAAAAQAAAAIA
AAABAAAAAAAAAAMAAAAEAAAAAwAAAAAAAAAEAAAAAAAAAAIAAAAFAAAABAAAAAIAAAAFAAAA
AgAAAAEAAAAGAAAAAwAAAAQAAAAGAAAABAAAAAUAAAAGAAAABQAAAAMAAAAHAAAAAQAAAAMA
AAAHAAAAAwAAAAUAAAAHAAAABQAAAAEAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAA
AAAAAAAAAAAAAIA/KgAAAAQAAADLBqM/wGy6QIjDFT+iMhNAYBi1QKrDFT84ZwZAVRzZQITD
FT/LBqM/VRzZQDNvHb+jMhNALOXBQM5uHb/LBqM/w2y6QK1wHb/JBiNATtKrQKMUXL7LBqM/
VRzZQITDFT85ZwZAVRzZQChvHb+jMhNAYBi1QM5uHb/JBiNAvfG5QDyAPT7JBiNATtKrQJV+
PT7JBiNAvfG5QJMHXL6iMhNALOXBQJjDFT9IAAAAAAAAAAEAAAACAAAAAwAAAAQAAAAFAAAA
AwAAAAUAAAAAAAAABgAAAAAAAAAFAAAABwAAAAAAAAACAAAABwAAAAIAAAADAAAABwAAAAMA
AAAAAAAACAAAAAQAAAADAAAACAAAAAMAAAACAAAACQAAAAUAAAAEAAAACQAAAAQAAAAGAAAA
CQAAAAYAAAAFAAAACgAAAAgAAAACAAAACwAAAAYAAAAKAAAACwAAAAoAAAABAAAACwAAAAEA
AAAAAAAACwAAAAAAAAAGAAAADAAAAAQAAAAIAAAADAAAAAgAAAAKAAAADAAAAAYAAAAEAAAA
DAAAAAoAAAAGAAAADQAAAAIAAAABAAAADQAAAAEAAAAKAAAADQAAAAoAAAACAAAAEAAAAAAA
AAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAP0UAAAAEAAAAAAAANS4zA0Gxbx2/
AAAANVgc2UAabx2/7pjZv1gc2UCtbx2/AAAANX0G+EDmcB0/7pjZv1gc2UCGwxU/6pnKv1NT
AUGqbx2/AAAANVgc2UCFwxU/AAAANS4zA0GBwxU/VGWmvzIzA0Gwbx2/VGWmvzIzA0GAwxU/
75jZv5qZ+UCsbx2/75jZv5qZ+UCGwxU/lpa2vx/fAkGsbx2/UPjWv9Gl/UCqbx2/lpa2vx/f
AkGIwxU/TvjWv9Gl/UCGwxU/cWorvhDL3EDmcB0/AAAANRvL3EDncB0/lv/Qv59ZAEGGwxU/
6pnKv1NTAUGGwxU/TczCvwggAkGqbx2/TMzCvwggAkGFwxU/lf/Qv59ZAEGqbx2/fgAAAAAA
AAABAAAAAgAAAAEAAAAAAAAAAwAAAAQAAAACAAAAAQAAAAUAAAAAAAAAAgAAAAYAAAABAAAA
AwAAAAYAAAAEAAAAAQAAAAcAAAADAAAAAAAAAAgAAAAHAAAAAAAAAAgAAAAAAAAABQAAAAkA
AAAHAAAACAAAAAkAAAADAAAABwAAAAoAAAAFAAAAAgAAAAoAAAACAAAABAAAAAsAAAAKAAAA
BAAAAAwAAAAJAAAACAAAAAwAAAAIAAAABQAAAA0AAAAKAAAACwAAAA0AAAAFAAAACgAAAA4A
AAAJAAAADAAAAA4AAAADAAAACQAAAA8AAAANAAAACwAAABAAAAADAAAADwAAABAAAAAPAAAA
CwAAABAAAAALAAAABAAAABAAAAAEAAAABgAAABEAAAAGAAAAAwAAABEAAAADAAAAEAAAABEA
AAAQAAAABgAAABIAAAADAAAAEwAAABIAAAAPAAAAAwAAABIAAAANAAAADwAAABIAAAATAAAA
BQAAABQAAAAOAAAADAAAABQAAAAFAAAAEwAAABQAAAAMAAAABQAAABUAAAAOAAAAFAAAABUA
AAAUAAAAEwAAABUAAAATAAAAAwAAABUAAAADAAAADgAAABYAAAAFAAAADQAAABYAAAANAAAA
EgAAABYAAAASAAAABQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAA
gD9OAAAABAAAADhnBkBVHNlAhMMVPwAAADVVHNlAhMMVPwAAADVVHNlAGm8dvwAAADUuMwNB
sW8dvzwD9j8IIAJBsm8dvzlnBkBVHNlAKG8dvwAAADUuMwNBgcMVP+9nBkCamflAsG8dv+5n
BkCamflAgsMVP6qa2T8pMwNBsm8dv6qa2T8pMwNBgsMVP7wvoT79XfxA53AdP0IbAkCfWQBB
sm8dvwAAADUuGe9A53AdPwAAADUby9xA53AdP4fN6T8g3wJBsm8dvzsD9j8IIAJBgsMVP4fN
6T8e3wJBgsMVP6AXBUDRpf1Asm8dv0MbAkCfWQBBgsMVP58XBUDRpf1AgMMVP6AyhTzTFvlA
53AdPxqWEj8ly9xA53AdP9rQ/T9TUwFBsm8dv9nQ/T9TUwFBgMMVPx/8GT79XfxA53AdP5AA
AAAAAAAAAQAAAAIAAAADAAAABAAAAAIAAAADAAAAAgAAAAEAAAAFAAAAAAAAAAIAAAAFAAAA
AgAAAAQAAAAGAAAAAwAAAAEAAAAHAAAAAAAAAAUAAAAHAAAABQAAAAQAAAAIAAAAAAAAAAcA
AAAJAAAAAwAAAAYAAAAJAAAABAAAAAMAAAAKAAAACQAAAAYAAAAKAAAABgAAAAsAAAAMAAAA
BwAAAAQAAAANAAAABgAAAAEAAAAOAAAAAQAAAAAAAAAOAAAADQAAAAEAAAAOAAAACwAAAA0A
AAAPAAAACQAAAAoAAAAPAAAAEAAAAAQAAAAPAAAABAAAAAkAAAARAAAAEAAAAA8AAAARAAAA
DwAAAAoAAAARAAAACwAAABAAAAARAAAACgAAAAsAAAASAAAABwAAAAwAAAASAAAADAAAABMA
AAASAAAACAAAAAcAAAAUAAAACAAAABIAAAAUAAAAEgAAABMAAAAUAAAAEwAAAAsAAAAVAAAA
BgAAAA0AAAAVAAAADQAAAAsAAAAWAAAACAAAABQAAAAWAAAAFAAAAAsAAAAWAAAACwAAAA4A
AAAWAAAADgAAAAAAAAAWAAAAAAAAAAgAAAAXAAAAEwAAAAwAAAAXAAAADAAAAAQAAAAXAAAA
BAAAABAAAAAYAAAAEwAAABcAAAAYAAAAFwAAABAAAAAYAAAAEAAAAAsAAAAYAAAACwAAABMA
AAAZAAAACwAAAAYAAAAZAAAABgAAABUAAAAZAAAAFQAAAAsAAAA=</SharedString>
		<SharedString md5="bsGaillY16UJhg3GeV9BEw==">Q1NHUEhTBgAAAFUCKEEAAAAAAAAAAAAAAAAC/ulBAAAAAAAAAABVQvZAAAAAAJcpA0IQAAAA
AAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAAAAaKq+JhmAPwAA
azejCLK2cmZmPwAAazdPnfW+oVmSPwAAazcAAIAzfWZmPwFlBr9PnfW+mVmSPwH8/75PnfW+
9v8fPztlBr8AAIAz9v8fPz1lBr8ASEK+DEhuPwAAazdPnfW+emZmPwBlBr8AOtm+nLGJPwAA
azcwAAAAAAAAAAEAAAACAAAAAwAAAAIAAAABAAAABAAAAAUAAAACAAAABAAAAAIAAAADAAAA
BgAAAAEAAAAFAAAABgAAAAUAAAADAAAABgAAAAMAAAABAAAABwAAAAAAAAAFAAAABwAAAAUA
AAABAAAABwAAAAEAAAAAAAAACAAAAAMAAAAFAAAACAAAAAUAAAAEAAAACAAAAAQAAAADAAAA
CQAAAAUAAAAAAAAACQAAAAAAAAACAAAACQAAAAIAAAAFAAAAEAAAAAAAAAAAAAAAAAAAAAAA
AAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAAItixs2BmZr8AAIA3AACAs1hmZr//ZAa/
UJ31PqpZkr8A/P++AACAswUAIL90ZQa/UJ31PgUAIL8AZga/UJ31PrNZkr8AAIA3AGiqPiQZ
gL8AAIA3/0tCPkVIbr8AAIA3UJ31PoZmZr8AZga/ADrZPrqxib8AAIA3MAAAAAAAAAABAAAA
AgAAAAMAAAAEAAAAAQAAAAMAAAABAAAAAAAAAAMAAAAAAAAABAAAAAUAAAAGAAAAAAAAAAUA
AAAAAAAAAgAAAAUAAAACAAAABAAAAAcAAAAGAAAABAAAAAcAAAAEAAAAAAAAAAcAAAAAAAAA
BgAAAAgAAAACAAAAAQAAAAgAAAABAAAABAAAAAgAAAAEAAAAAgAAAAkAAAAEAAAABgAAAAkA
AAAGAAAABQAAAAkAAAAFAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA
AAAAAAAAgD8eAAAABAAAAFGd9T7XWZK/AAIAPwAAgLNPZma/f2cGP1Gd9T6zWZK/AACAN1Gd
9T4GACC/AGYGPwCAWDZpZma/AACANwAAgLMGACC/Q2cGPwFoqj4kGYC/AACAN/9LQj5FSG6/
AACAN1Gd9T5sZma/AGYGPwE62T66sYm/AACANzAAAAAAAAAAAQAAAAIAAAACAAAAAwAAAAAA
AAAEAAAAAgAAAAEAAAAFAAAAAQAAAAMAAAAFAAAAAwAAAAQAAAAFAAAABAAAAAEAAAAGAAAA
AgAAAAQAAAAHAAAABAAAAAMAAAAHAAAAAwAAAAYAAAAHAAAABgAAAAQAAAAIAAAAAAAAAAMA
AAAIAAAAAwAAAAEAAAAIAAAAAQAAAAAAAAAJAAAAAwAAAAIAAAAJAAAAAgAAAAYAAAAJAAAA
BgAAAAMAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQA
AAAoOIA3eWZmPwAAgDcAAIAzfWZmPwFlBr8AAIAz9/8fPz1lBr9SnfU+/VmSPwAAYTdSnfU+
fGZmPwBlBr9SnfU+9/8fPwBlBr9SnfU+8lmSPwH8/74BaKo+GBmAPwAAYTcCTEI+M0huPwAA
YTcCOtk+srGJPwAAYTcwAAAAAAAAAAEAAAACAAAAAQAAAAAAAAADAAAABAAAAAIAAAABAAAA
BQAAAAIAAAAEAAAABQAAAAQAAAADAAAABQAAAAAAAAACAAAABgAAAAEAAAADAAAABgAAAAMA
AAAEAAAABgAAAAQAAAABAAAABwAAAAMAAAAAAAAACAAAAAAAAAAFAAAACAAAAAUAAAAHAAAA
CAAAAAcAAAAAAAAACQAAAAUAAAADAAAACQAAAAMAAAAHAAAACQAAAAcAAAAFAAAAEAAAAAAA
AAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAAUZ31vsBZkj8AAgA/
AACAM3JmZj8AZwY/AACAM2RmZj8BAGs3AACAM/f/Hz8AZwY/UZ31vvf/Hz8AZwY/UZ31vqFZ
kj8BAGs3AWiqviYZgD8BAGs3AUhCvgxIbj8BAGs3UZ31voFmZj8AZwY/ATrZvp6xiT8BAGs3
MAAAAAAAAAABAAAAAgAAAAMAAAACAAAAAQAAAAMAAAABAAAABAAAAAMAAAAEAAAAAgAAAAUA
AAAEAAAAAAAAAAUAAAACAAAABgAAAAUAAAAAAAAAAgAAAAcAAAAEAAAABgAAAAcAAAAGAAAA
AgAAAAcAAAACAAAABAAAAAgAAAAEAAAAAQAAAAgAAAABAAAAAAAAAAgAAAAAAAAABAAAAAkA
AAAGAAAABAAAAAkAAAAEAAAABQAAAAkAAAAFAAAABgAAABAAAAAAAAAAAAAAAAAAAAAAAAAA
EAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAAAAgLMHACC/dGUGvwAAgLNYZma//2QGv1Kd
9b5rZma/AGYGvwKAQrZ1Zma/AABAN1Kd9b4MWpK/APz/vlKd9b4NWpK/AABAN1Kd9b4HACC/
qGUGv/9nqr4/GYC/AABANwJIQr44SG6/AABANwI62b66sYm/AABANzAAAAAAAAAAAQAAAAIA
AAABAAAAAAAAAAMAAAAEAAAAAgAAAAEAAAAEAAAAAQAAAAMAAAAFAAAAAgAAAAQAAAAFAAAA
BAAAAAMAAAAGAAAAAAAAAAIAAAAGAAAAAgAAAAUAAAAGAAAAAwAAAAAAAAAHAAAABQAAAAMA
AAAIAAAAAwAAAAYAAAAIAAAABgAAAAcAAAAIAAAABwAAAAMAAAAJAAAABgAAAAUAAAAJAAAA
BQAAAAcAAAAJAAAABwAAAAYAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAA
AAAAAIA/HgAAAAQAAABSnfU+9v8fPwBnBj9SnfU+/lmSPwAAYTdSnfU+emZmPwBnBj///38z
cmZmPwBnBj9zMnc3d2ZmPwAAYTf//38z9v8fPwBnBj9SnfU+/VmSPwACAD//Z6o+GBmAPwAA
YTcBTEI+M0huPwAAYTcAOtk+sLGJPwAAYTcwAAAAAAAAAAEAAAACAAAAAwAAAAEAAAAEAAAA
AwAAAAAAAAACAAAABQAAAAQAAAAAAAAABQAAAAAAAAADAAAABQAAAAMAAAAEAAAABgAAAAIA
AAABAAAABgAAAAEAAAADAAAABgAAAAMAAAACAAAABwAAAAQAAAABAAAACAAAAAAAAAAEAAAA
CAAAAAQAAAAHAAAACAAAAAcAAAAAAAAACQAAAAEAAAAAAAAACQAAAAAAAAAHAAAACQAAAAcA
AAABAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPx4AAAAEAAAA
VJ31vgZakr8AAgA/VJ31vgcAIL8AZgY/VJ31vhBakr8AAEA3AACAs1BmZr9/ZwY/AACAswcA
IL9EZwY/AIBCtnhmZr8AAEA3AWiqvj8ZgL8AAEA3AkhCvjpIbr8AAEA3VJ31vh1sZr8AZgY/
AjrZvrqxib8AAEA3MAAAAAAAAAABAAAAAgAAAAMAAAAAAAAAAgAAAAMAAAAEAAAAAQAAAAUA
AAAEAAAAAwAAAAUAAAADAAAAAgAAAAUAAAABAAAABAAAAAYAAAAFAAAAAgAAAAcAAAABAAAA
BQAAAAcAAAAFAAAABgAAAAcAAAAGAAAAAQAAAAgAAAABAAAAAAAAAAgAAAAAAAAAAwAAAAgA
AAADAAAAAQAAAAkAAAACAAAAAQAAAAkAAAABAAAABgAAAAkAAAAGAAAAAgAAABAAAAAAAAAA
AAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAE8sCj/7/58/AAIAPyUs
Cj/7/58/AID/N1OddT/7/58/AAIAP1hnfT/6/8c/AAIAPyMBFz/6/8c/AID/NwAAgD/6/78/
AID/NxcBFz/6/8c/AAIAP1GddT/7/58/AID/N1dnfT/6/8c/AID/NwEAgD/6/78/AAIAPzAA
AAAAAAAAAQAAAAIAAAAAAAAAAgAAAAMAAAAEAAAAAQAAAAAAAAAEAAAABQAAAAEAAAAGAAAA
AAAAAAMAAAAGAAAAAwAAAAQAAAAGAAAABAAAAAAAAAAHAAAAAgAAAAEAAAAHAAAAAQAAAAUA
AAAHAAAABQAAAAIAAAAIAAAAAwAAAAUAAAAIAAAABQAAAAQAAAAIAAAABAAAAAMAAAAJAAAA
BQAAAAMAAAAJAAAAAwAAAAIAAAAJAAAAAgAAAAUAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAA
AAAAAAAAAAAAAAAAAAAAAIA/HgAAAAQAAAAXARe/BQDIvwACAD8iLAq/BACgvwAgADhDLAq/
BACgvwACAD8BAIC/AwDAvwACAD9QnXW/BACgvwAgADhSZ32/BQDIv1oTADgiARe/BQDIvwAg
ADhTnXW/BACgvwACAD9WZ32/BQDIvwACAD8BAIC/AwDAvwAgADgwAAAAAAAAAAEAAAACAAAA
AwAAAAAAAAACAAAABAAAAAEAAAAFAAAABAAAAAIAAAABAAAABgAAAAAAAAAFAAAABgAAAAUA
AAABAAAABgAAAAEAAAAAAAAABwAAAAMAAAACAAAABwAAAAIAAAAEAAAABwAAAAQAAAADAAAA
CAAAAAUAAAAAAAAACAAAAAAAAAADAAAACAAAAAMAAAAFAAAACQAAAAUAAAADAAAACQAAAAMA
AAAEAAAACQAAAAQAAAAFAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPx4AAAAEAAAAVGd9P/r/xz8AgP83Vmd9P/r/xz8AAgA/IwEXP/r/xz8AgP835uftPvr/
7z//AQA/HIFrP/r/7z8AAgA/G4FrP/r/7z8AgP83XOjtPvr/7z8AgP83FQEXP/r/xz8AAgA/
AN1yPx566D8AgP83Ad1yPx566D8AAgA/MAAAAAAAAAABAAAAAgAAAAMAAAABAAAABAAAAAUA
AAADAAAABAAAAAUAAAAAAAAAAgAAAAYAAAACAAAAAwAAAAYAAAADAAAABQAAAAYAAAAFAAAA
AgAAAAcAAAACAAAAAQAAAAcAAAABAAAAAwAAAAcAAAADAAAAAgAAAAgAAAAAAAAABQAAAAgA
AAAFAAAABAAAAAgAAAABAAAAAAAAAAkAAAAEAAAAAQAAAAkAAAABAAAACAAAAAkAAAAIAAAA
BAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8eAAAABAAAAFDo
7b4IAPC/ACAAOO3n7b4IAPC/AAIAPxmBa78IAPC/ACAAOBcBF78GAMi/AAIAP//ccr8peui/
AQIAP1Rnfb8GAMi/WhMAOFVnfb8GAMi/AAIAPyIBF78GAMi/ACAAOBWBa78IAPC/AQIAP//c
cr8peui/AGAAODAAAAAAAAAAAQAAAAIAAAABAAAAAAAAAAMAAAAEAAAAAQAAAAMAAAAFAAAA
AAAAAAIAAAAGAAAABAAAAAMAAAAGAAAAAwAAAAUAAAAGAAAABQAAAAQAAAAHAAAAAwAAAAAA
AAAHAAAAAAAAAAUAAAAHAAAABQAAAAMAAAAIAAAAAgAAAAEAAAAIAAAAAQAAAAQAAAAIAAAA
BAAAAAIAAAAJAAAAAgAAAAQAAAAJAAAABAAAAAUAAAAJAAAABQAAAAIAAAAQAAAAAAAAAAAA
AAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/KgAAAAQAAAAWgWu/CADwvwECAD8Wgeu+
aDcYwP8BAD/t5+2+CADwvwACAD8YgWu/CADwvwAAADgWgeu+prvwvwAAADgBAQ6/UUAVwAAA
ADgWgeu+aDcYwAAAADj/BDW/P0ENwAACAD8BAVW/NoADwAAAADgBAVW/NoADwAACAD//BDW/
PkENwAAAADgBAQ6/UUAVwP8BAD9P6O2+CADwvwAAADgWgeu+iLvwvwACAD9IAAAAAAAAAAEA
AAACAAAAAwAAAAAAAAACAAAABAAAAAUAAAADAAAABgAAAAEAAAAFAAAABgAAAAUAAAAEAAAA
BgAAAAQAAAABAAAABwAAAAEAAAAAAAAACAAAAAMAAAAFAAAACAAAAAAAAAADAAAACQAAAAcA
AAAAAAAACQAAAAAAAAAIAAAACQAAAAgAAAAHAAAACgAAAAUAAAAHAAAACgAAAAcAAAAIAAAA
CgAAAAgAAAAFAAAACwAAAAUAAAABAAAACwAAAAEAAAAHAAAACwAAAAcAAAAFAAAADAAAAAMA
AAACAAAADAAAAAIAAAAEAAAADAAAAAQAAAADAAAADQAAAAIAAAABAAAADQAAAAEAAAAEAAAA
DQAAAAQAAAACAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyoA
AAAEAAAAHIHrPna78D//AQA/HIFrP/r/7z8AAgA/AQEOP05AFUABAgA/HIHrPmQ3GEAAAAA4
AAFVPzOAA0AAAAA4XejtPvr/7z8AAAA4G4FrP/r/7z8AAAA4HIHrPmQ3GEABAgA/AQFVPzOA
A0AAAgA/AAU1PztBDUAAAAA4AAU1PztBDUD/AQA/AgEOP05AFUAAAAA45+ftPvr/7z//AQA/
HIHrPpy78D8AAAA4SAAAAAAAAAABAAAAAgAAAAMAAAAEAAAABQAAAAYAAAABAAAABQAAAAYA
AAAFAAAABAAAAAYAAAAEAAAAAQAAAAcAAAAAAAAAAgAAAAcAAAACAAAAAwAAAAcAAAADAAAA
AAAAAAgAAAACAAAAAQAAAAgAAAABAAAABAAAAAkAAAAIAAAABAAAAAkAAAAEAAAAAwAAAAoA
AAACAAAACAAAAAoAAAAIAAAACQAAAAoAAAAJAAAAAgAAAAsAAAADAAAAAgAAAAsAAAACAAAA
CQAAAAsAAAAJAAAAAwAAAAwAAAAAAAAABQAAAAwAAAAFAAAAAQAAAAwAAAABAAAAAAAAAA0A
AAAFAAAAAAAAAA0AAAAAAAAAAwAAAA0AAAADAAAABQAAABAAAAAAAAAAAAAAAAAAAAAAAAAA
EAAAAAAAAAAAAAAAAAAAAAAAgD8tAAAABAAAAEDeHT/3/x8/AABhN1Gd9T79WZI/AABhN1Gd
9T73/x8/AGUGv1GddT/7/58/AABhN1CddT/7/58/APz/vi8sCj/7/58/APz/vkLeHT/3/x8/
AGUGvyUsCj/7/58/AABhN1Gd9T7yWZI/Afz/vv0AVT8d/3E/Afz/vgDNTD9dZmY/AABhNwDN
TD9cZmY/AGUGvwDdcj/ShZc/AABhN/7ccj/ShZc/APz/vlGd9T5cZmY/AGUGv04AAAAAAAAA
AQAAAAIAAAABAAAAAAAAAAMAAAAEAAAABQAAAAMAAAAGAAAAAAAAAAIAAAAHAAAAAQAAAAMA
AAAHAAAAAwAAAAUAAAAHAAAABQAAAAEAAAAIAAAAAgAAAAEAAAAIAAAAAQAAAAUAAAAJAAAA
AAAAAAYAAAAKAAAAAwAAAAAAAAAKAAAAAAAAAAkAAAALAAAACQAAAAYAAAALAAAABgAAAAIA
AAALAAAABQAAAAQAAAAMAAAAAwAAAAoAAAAMAAAACgAAAAkAAAAMAAAABAAAAAMAAAANAAAA
BAAAAAwAAAANAAAADAAAAAkAAAANAAAACQAAAAsAAAANAAAACwAAAAQAAAAOAAAABQAAAAsA
AAAOAAAACwAAAAIAAAAOAAAAAgAAAAgAAAAOAAAACAAAAAUAAAAQAAAAAAAAAAAAAAAAAAAA
AAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/MAAAAAQAAABQnXW/+/+fPwAAazc33R2/9/8fPwAA
azfLLAq/+/+fPwAAazfpLAq/+/+fPwP8/75QnXW/+/+fPwD8/75PnfW+9/8fPztlBr833R2/
9/8fPztlBr9PnfW+oVmSPwAAazdPnfW+mlmSPwP8/74OAVW/Ef9xP//7/74e72O/0UKIPwAA
azcBzEy/bWZmPwBlBr//3HK/0oWXPwD8/75PnfW++WRmPwBlBr8A3XK/1IWXPwAAazcBzEy/
bGZmPwAAazdUAAAAAAAAAAEAAAACAAAAAwAAAAAAAAACAAAABAAAAAAAAAADAAAABQAAAAEA
AAAGAAAABwAAAAIAAAABAAAABwAAAAEAAAAFAAAABwAAAAMAAAACAAAACAAAAAMAAAAHAAAA
CAAAAAcAAAAFAAAACQAAAAYAAAABAAAACgAAAAEAAAAAAAAACwAAAAYAAAAJAAAACwAAAAUA
AAAGAAAACwAAAAQAAAADAAAADAAAAAQAAAALAAAADAAAAAsAAAAJAAAADAAAAAkAAAAKAAAA
DAAAAAAAAAAEAAAADQAAAAUAAAALAAAADQAAAAsAAAADAAAADQAAAAMAAAAIAAAADQAAAAgA
AAAFAAAADgAAAAoAAAAAAAAADgAAAAAAAAAMAAAADgAAAAwAAAAKAAAADwAAAAkAAAABAAAA
DwAAAAEAAAAKAAAADwAAAAoAAAAJAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAA
AAAAAAAAAACAPzAAAAAEAAAAUZ11v/v/nz8CAGs3Up11v/v/nz8AAgA/zCwKv/v/nz8CAGs3
ON0dv/f/Hz8CAGs3rSwKv/v/nz8AAgA/UZ31voFmZj8AZwY/ON0dv/f/Hz8AZwY/UZ31vvf/
Hz8AZwY/UZ31vqFZkj8CAGs3UZ31vsBZkj8AAgA/AAFVvxv/cT8AAgA/IO9jv9FCiD8CAGs3
AcxMv2tmZj8AZwY/At1yv9aFlz8AAgA/Ad1yv9SFlz8CAGs3AsxMv2xmZj8CAGs3VAAAAAAA
AAABAAAAAgAAAAAAAAACAAAAAwAAAAQAAAABAAAABQAAAAQAAAACAAAAAQAAAAYAAAAHAAAA
BQAAAAYAAAADAAAABwAAAAgAAAACAAAABAAAAAgAAAAHAAAAAwAAAAgAAAADAAAAAgAAAAgA
AAAFAAAABwAAAAkAAAAEAAAABQAAAAkAAAAFAAAACAAAAAkAAAAIAAAABAAAAAoAAAADAAAA
BgAAAAsAAAAAAAAAAwAAAAwAAAAKAAAABgAAAAwAAAAFAAAAAQAAAAwAAAAGAAAABQAAAA0A
AAAKAAAADAAAAA0AAAAMAAAAAQAAAA0AAAALAAAACgAAAA0AAAABAAAAAAAAAA4AAAAAAAAA
CwAAAA4AAAALAAAADQAAAA4AAAANAAAAAAAAAA8AAAADAAAACgAAAA8AAAAKAAAACwAAAA8A
AAALAAAAAwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8tAAAA
BAAAAFCddT8DAKC/AAIAP6UsCj8DAKC/AAIAP8ksCj8DAKC/AACANz/eHT8GACC/AACANz/e
HT8GACC/AGYGP/8AVT8w/3G/AACAN1GddT8DAKC/AACAN0+d9T4GACC/AGYGP0+d9T6zWZK/
AACAN0+d9T7XWZK/AAIAPwABVT8w/3G/AAIAPwDNTD9rZma/AGYGP//ccj/chZe/AAIAP/7c
cj/chZe/AACAN0+d9T5rZma/AGYGP04AAAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAADAAAA
BQAAAAIAAAAGAAAAAAAAAAIAAAAGAAAAAgAAAAUAAAAHAAAABAAAAAMAAAAIAAAAAgAAAAEA
AAAIAAAAAwAAAAIAAAAIAAAABwAAAAMAAAAJAAAABwAAAAgAAAAJAAAACAAAAAEAAAAKAAAA
BQAAAAQAAAALAAAACgAAAAQAAAALAAAABAAAAAcAAAALAAAAAQAAAAAAAAAMAAAACgAAAAsA
AAAMAAAACwAAAAAAAAAMAAAABQAAAAoAAAAMAAAAAAAAAAYAAAANAAAABgAAAAUAAAANAAAA
BQAAAAwAAAANAAAADAAAAAYAAAAOAAAAAQAAAAsAAAAOAAAACwAAAAcAAAAOAAAABwAAAAkA
AAAOAAAACQAAAAEAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/
LQAAAAQAAABSnXW/BACgvwAAQDckLAq/BACgvwAAQDdB3R2/BgAgvwAAQDcqLAq/BACgvwD8
/75RnXW/BACgvwD8/74CzEy/VGZmvwBmBr9B3R2/BgAgvwBmBr9SnfW+BgAgv6hlBr9SnfW+
DlqSvwAAQDdSnfW+DVqSvwD8/74BAVW/MP9xvwAAQDcB3XK/3YWXvwD8/74C3XK/3IWXvwAA
QDdSnfW+bGZmvwBmBr8BAVW/MP9xvwD8/75OAAAAAAAAAAEAAAACAAAAAwAAAAEAAAAAAAAA
BAAAAAUAAAADAAAABAAAAAMAAAAAAAAABgAAAAIAAAAHAAAACAAAAAEAAAADAAAACAAAAAIA
AAABAAAACAAAAAcAAAACAAAACQAAAAcAAAAIAAAACQAAAAgAAAADAAAACgAAAAIAAAAGAAAA
CgAAAAAAAAACAAAACwAAAAQAAAAAAAAACwAAAAUAAAAEAAAADAAAAAAAAAAKAAAADAAAAAoA
AAALAAAADAAAAAsAAAAAAAAADQAAAAcAAAAJAAAADQAAAAkAAAADAAAADQAAAAUAAAAGAAAA
DQAAAAYAAAAHAAAADQAAAAMAAAAFAAAADgAAAAUAAAALAAAADgAAAAsAAAAKAAAADgAAAAYA
AAAFAAAADgAAAAoAAAAGAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPy0AAAAEAAAAQywKvwQAoL8AAgA/U511vwQAoL8AAgA/UZ11vwQAoL8AAEA3QN0dvwYA
IL8AAEA3U531vgYAIL8AZgY/U531vg5akr8AAEA3Gd0dvwYAIL8AZgY/JCwKvwQAoL8AAEA3
U531vgZakr8AAgA/AAFVvy3/cb8AAgA/AAFVvzD/cb8AAEA3AMxMv1ZmZr8AZgY/At1yv9uF
l78AAgA/AN1yv9yFl78AAEA3U531vh5sZr8AZgY/TgAAAAAAAAABAAAAAgAAAAMAAAAEAAAA
BQAAAAMAAAAFAAAAAgAAAAYAAAAEAAAAAwAAAAcAAAAAAAAAAgAAAAcAAAACAAAABQAAAAcA
AAAFAAAAAAAAAAgAAAAAAAAABQAAAAgAAAAFAAAABAAAAAkAAAAGAAAAAwAAAAoAAAADAAAA
AgAAAAoAAAAJAAAAAwAAAAsAAAAGAAAACQAAAAsAAAAEAAAABgAAAAsAAAABAAAAAAAAAAwA
AAABAAAACwAAAAwAAAALAAAACQAAAAwAAAAJAAAACgAAAAwAAAACAAAAAQAAAA0AAAAKAAAA
AgAAAA0AAAACAAAADAAAAA0AAAAMAAAACgAAAA4AAAAEAAAACwAAAA4AAAALAAAAAAAAAA4A
AAAAAAAACAAAAA4AAAAIAAAABAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA
AAAAAAAAgD8tAAAABAAAAE+d9T6zWZK/AACAN1GddT8DAKC/AACANz/eHT8GACC/AACAN1Cd
dT8DAKC//vv/vuksCj8DAKC/Afz/vk+d9T6IZma/AGYGv0+d9T4GACC/AGYGv0neHT8GACC/
AGYGv8ksCj8DAKC/AACAN0+d9T6sWZK/APz/vv8AVT8w/3G/AACAN/8AVT8w/3G/APz/vgDN
TD9SZma/AGYGv/7ccj/chZe//vv/vv7ccj/chZe/AACAN04AAAAAAAAAAQAAAAIAAAADAAAA
AQAAAAQAAAADAAAABAAAAAUAAAAGAAAAAgAAAAcAAAAGAAAABwAAAAUAAAAGAAAABQAAAAAA
AAAGAAAAAAAAAAIAAAAIAAAAAQAAAAAAAAAIAAAAAAAAAAQAAAAIAAAABAAAAAEAAAAJAAAA
AAAAAAUAAAAJAAAABQAAAAQAAAAJAAAABAAAAAAAAAAKAAAABwAAAAIAAAAKAAAAAgAAAAEA
AAALAAAABwAAAAoAAAAMAAAABwAAAAsAAAAMAAAAAwAAAAUAAAAMAAAABQAAAAcAAAANAAAA
AwAAAAwAAAANAAAADAAAAAsAAAANAAAACwAAAAoAAAANAAAAAQAAAAMAAAAOAAAACgAAAAEA
AAAOAAAAAQAAAA0AAAAOAAAADQAAAAoAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAA
AAAAAAAAAAAAAIA/LQAAAAQAAABRnXU/+/+fPwAAYTc/3h0/9/8fPwAAYTclLAo/+/+fPwAA
YTdPLAo/+/+fPwACAD9TnXU/+/+fPwACAD//zEw/XmZmPwBnBj9TnfU+9/8fPwBnBj8/3h0/
9/8fPwBnBj9TnfU+/lmSPwAAYTdTnfU+/VmSPwACAD/1AFU/Jf9xPwAAYTcC3XI/0oWXPwAC
AD8A3XI/0oWXPwAAYTdTnfU+XGZmPwBnBj8AAVU/G/9xPwACAD9OAAAAAAAAAAEAAAACAAAA
AwAAAAAAAAACAAAABAAAAAAAAAADAAAABAAAAAMAAAAFAAAABgAAAAcAAAAFAAAABgAAAAEA
AAAHAAAACAAAAAIAAAABAAAACAAAAAEAAAAGAAAACAAAAAMAAAACAAAACQAAAAMAAAAIAAAA
CQAAAAgAAAAGAAAACgAAAAEAAAAAAAAACgAAAAcAAAABAAAACwAAAAQAAAAFAAAACwAAAAAA
AAAEAAAADAAAAAoAAAAAAAAADAAAAAAAAAALAAAADAAAAAsAAAAKAAAADQAAAAMAAAAJAAAA
DQAAAAkAAAAGAAAADQAAAAUAAAADAAAADQAAAAYAAAAFAAAADgAAAAoAAAALAAAADgAAAAsA
AAAFAAAADgAAAAUAAAAHAAAADgAAAAcAAAAKAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAA
AAAAAAAAAAAAAAAAAACAPx4AAAAEAAAA/v//MwYAIMAAAgA//v//M2pmBsAAAAA4/v//M2pm
BsAAAgA/FoHrvoi78L8AAgA/FoHrvqa78L8AAAA4FoHrvmg3GMAAAAA4/v//MwQAIMAAAAA4
FoHrvmg3GMD/AQA//+ehvju3HMAAAAA4AOihvju3HMAAAgA/MAAAAAAAAAABAAAAAgAAAAMA
AAACAAAAAQAAAAMAAAAAAAAAAgAAAAQAAAABAAAABQAAAAQAAAAFAAAAAwAAAAQAAAADAAAA
AQAAAAYAAAAFAAAAAQAAAAYAAAABAAAAAAAAAAcAAAAAAAAAAwAAAAcAAAADAAAABQAAAAgA
AAAHAAAABQAAAAgAAAAFAAAABgAAAAgAAAAGAAAAAAAAAAkAAAAAAAAABwAAAAkAAAAHAAAA
CAAAAAkAAAAIAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAA
gD8eAAAABAAAAByB6z54u/A//wEAPxyB6z5kNxhAAAAAOByB6z5kNxhAAQIAP2LR47D9/x9A
AAIAPxyB6z6cu/A/AAAAOFJ0ljNlZgZAAAAAOFxiB7L9/x9AAAAAOB7DHjBjZgZAAAIAPwDo
oT43txxAAQIAPwDooT43txxAAAAAODAAAAAAAAAAAQAAAAIAAAADAAAAAAAAAAIAAAAEAAAA
AAAAAAUAAAAEAAAABQAAAAEAAAAEAAAAAQAAAAAAAAAGAAAAAQAAAAUAAAAGAAAABQAAAAMA
AAAHAAAABQAAAAAAAAAHAAAAAAAAAAMAAAAHAAAAAwAAAAUAAAAIAAAABgAAAAMAAAAIAAAA
AgAAAAEAAAAIAAAAAwAAAAIAAAAJAAAAAQAAAAYAAAAJAAAABgAAAAgAAAAJAAAACAAAAAEA
AAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/JAAAAAQAAABa6O0+
+f/vPwGA/zdRnXU/+/+fPwGA/zcbgWs/+f/vPwGA/zcagWs/+f/vPwH8/7696O0++f/vPwL8
/74vLAo/+/+fPwH8/75QnXU/+/+fPwH8/74lLAo/+/+fPwGA/zcBAIA/+v+/PwL8/74AAIA/
+f+/PwGA/zcA3XI/HXroPwGA/zf/3HI/HXroPwH8/748AAAAAAAAAAEAAAACAAAAAwAAAAAA
AAACAAAABAAAAAUAAAAAAAAABAAAAAAAAAADAAAABAAAAAMAAAAFAAAABgAAAAEAAAAFAAAA
BgAAAAUAAAADAAAABwAAAAAAAAAFAAAABwAAAAUAAAABAAAABwAAAAEAAAAAAAAACAAAAAEA
AAAGAAAACAAAAAYAAAADAAAACQAAAAIAAAABAAAACQAAAAEAAAAIAAAACgAAAAIAAAAJAAAA
CgAAAAkAAAAIAAAACgAAAAMAAAACAAAACwAAAAgAAAADAAAACwAAAAMAAAAKAAAACwAAAAoA
AAAIAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPyQAAAAEAAAA
AQCAvwMAwL8AIAA4UOjtvgcA8L8AIAA4IywKvwQAoL8AIAA4pOjtvgcA8L//+/++GoFrvwcA
8L8A/P++UJ11vwQAoL8A/P++KiwKvwQAoL8A/P++GYFrvwcA8L8AIAA4UZ11vwQAoL8AIAA4
AACAvwMAwL8A/P++A91yvyt66L8A/P++Ad1yvyl66L8AYAA4PAAAAAAAAAABAAAAAgAAAAMA
AAABAAAABAAAAAMAAAAEAAAABQAAAAMAAAACAAAAAQAAAAYAAAAFAAAAAgAAAAYAAAACAAAA
AwAAAAYAAAADAAAABQAAAAcAAAAEAAAAAQAAAAcAAAABAAAAAAAAAAgAAAAAAAAAAgAAAAgA
AAACAAAABQAAAAgAAAAFAAAAAAAAAAkAAAAAAAAABQAAAAkAAAAFAAAABAAAAAoAAAAAAAAA
CQAAAAoAAAAJAAAABAAAAAoAAAAEAAAABwAAAAsAAAAHAAAAAAAAAAsAAAAAAAAACgAAAAsA
AAAKAAAABwAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8kAAAA
BAAAAB+Baz8CAPC/AQIAP07n7T4CAPC/AAIAP9rm7T4CAPC/AAAAOFGddT8DAKC/AAIAP8os
Cj8DAKC/AAAAOAEAgD8CAMC/AAAAOKYsCj8DAKC/AAIAPx+Baz8CAPC/AAAAOFKddT8DAKC/
AAAAOAAAgD8CAMC/AAIAPwLdcj8qeui/AAAAOP/ccj8qeui/AQIAPzwAAAAAAAAAAQAAAAIA
AAABAAAAAAAAAAMAAAAEAAAABQAAAAIAAAAEAAAAAgAAAAEAAAAGAAAAAQAAAAMAAAAGAAAA
AwAAAAQAAAAGAAAABAAAAAEAAAAHAAAAAAAAAAIAAAAHAAAAAgAAAAUAAAAIAAAAAwAAAAUA
AAAIAAAABQAAAAQAAAAIAAAABAAAAAMAAAAJAAAAAwAAAAAAAAAJAAAABQAAAAMAAAAKAAAA
BQAAAAkAAAAKAAAAAAAAAAcAAAAKAAAABwAAAAUAAAALAAAACQAAAAAAAAALAAAAAAAAAAoA
AAALAAAACgAAAAkAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAIA/
JAAAAAQAAAAcgWs/AgDwvwAAADja5u0+AgDwvwAAADjD5u0+AgDwvwD8/75SnXU/AwCgvwAA
ADjqLAo/AwCgvwH8/74CAIA/AgDAvwD8/77JLAo/AwCgvwAAADgcgWs/AgDwvwL8/75QnXU/
AwCgv/77/74BAIA/AgDAvwAAADgA3XI/KnrovwAAADgA3XI/KXrovwL8/748AAAAAAAAAAEA
AAACAAAAAQAAAAAAAAADAAAABAAAAAUAAAACAAAABAAAAAIAAAABAAAABgAAAAEAAAADAAAA
BgAAAAMAAAAEAAAABgAAAAQAAAABAAAABwAAAAAAAAACAAAABwAAAAIAAAAFAAAACAAAAAMA
AAAFAAAACAAAAAUAAAAEAAAACAAAAAQAAAADAAAACQAAAAMAAAAAAAAACQAAAAUAAAADAAAA
CgAAAAUAAAAJAAAACgAAAAkAAAAAAAAACgAAAAAAAAAHAAAACwAAAAcAAAAFAAAACwAAAAUA
AAAKAAAACwAAAAoAAAAHAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPyQAAAAEAAAAAQCAv/n/vz8AwP83yiwKv/v/nz8AAAA41Obtvvn/7z8A4P83r+btvvn/
7z8A/P++UJ11v/v/nz8A/P++HoFrv/n/7z8A/P++6CwKv/v/nz8B/P++HYFrv/n/7z8AwP83
UJ11v/v/nz8AwP83AQCAv/r/vz8A/P++Ad1yvyF66D8AwP83At1yvx966D8A/P++PAAAAAAA
AAABAAAAAgAAAAMAAAAEAAAABQAAAAMAAAAFAAAAAgAAAAMAAAACAAAAAQAAAAYAAAABAAAA
BAAAAAYAAAAEAAAAAwAAAAYAAAADAAAAAQAAAAcAAAAAAAAAAgAAAAcAAAACAAAABQAAAAgA
AAAAAAAABAAAAAgAAAAEAAAAAQAAAAgAAAABAAAAAAAAAAkAAAAEAAAAAAAAAAkAAAAFAAAA
BAAAAAoAAAAJAAAAAAAAAAoAAAAAAAAABwAAAAoAAAAHAAAABQAAAAsAAAAFAAAACQAAAAsA
AAAJAAAACgAAAAsAAAAKAAAABQAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAA
AAAAAAAAgD8kAAAABAAAAP7/f7/5/78/AAIAP6osCr/7/58/AAIAP0fn7b75/+8//wEAP9Pm
7b75/+8/AOD/N1Cddb/7/58/AMD/NxuBa7/5/+8/AMD/N8ssCr/7/58/AAAAOBuBa7/5/+8/
/wEAP1Gddb/7/58/AAIAPwEAgL/5/78/AMD/N/7ccr8heug//wEAP//ccr8heug/AMD/NzwA
AAAAAAAAAQAAAAIAAAADAAAABAAAAAUAAAADAAAABQAAAAIAAAADAAAAAgAAAAEAAAAGAAAA
AQAAAAQAAAAGAAAABAAAAAMAAAAGAAAAAwAAAAEAAAAHAAAAAAAAAAIAAAAHAAAAAgAAAAUA
AAAIAAAAAAAAAAQAAAAIAAAABAAAAAEAAAAIAAAAAQAAAAAAAAAJAAAABAAAAAAAAAAJAAAA
BQAAAAQAAAAKAAAACQAAAAAAAAAKAAAAAAAAAAcAAAAKAAAABwAAAAUAAAALAAAABQAAAAkA
AAALAAAACQAAAAoAAAALAAAACgAAAAUAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAA
AAAAAAAAAAAAAIA/MAAAAAQAAAAAAAA0BAAgwAAAADgAAAA0amYGwAD8/74AAAA0amYGwAAA
ADgZgWu/CADwvwAAADgagWu/CADwvwD8/74CAQ6/UkAVwAD8/74AAAA0AAAgwAD8/74CAQ6/
UUAVwAAAADhQ6O2+CADwvwAAADik6O2+CADwv//7/74CAVW/NoADwAAAADgBAVW/NoADwAL8
/77/56G+OrccwP77/77/56G+OrccwAAAADgABTW/PkENwAAAADj/BDW/PkENwAD8/75UAAAA
AAAAAAEAAAACAAAAAwAAAAAAAAACAAAABAAAAAEAAAAFAAAABgAAAAUAAAABAAAABgAAAAEA
AAAAAAAABwAAAAAAAAADAAAACAAAAAQAAAADAAAACAAAAAIAAAABAAAACAAAAAMAAAACAAAA
CQAAAAEAAAAEAAAACQAAAAQAAAAIAAAACQAAAAgAAAABAAAACgAAAAcAAAADAAAACgAAAAMA
AAAEAAAACwAAAAQAAAAFAAAACwAAAAoAAAAEAAAADAAAAAcAAAAFAAAADAAAAAUAAAAGAAAA
DAAAAAYAAAAAAAAADQAAAAAAAAAHAAAADQAAAAcAAAAMAAAADQAAAAwAAAAAAAAADgAAAAoA
AAALAAAADgAAAAUAAAAHAAAADgAAAAcAAAAKAAAADwAAAAsAAAAFAAAADwAAAAUAAAAOAAAA
DwAAAA4AAAALAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPzAA
AAAEAAAAXGIHsv3/H0AAAAA4XOjtPvr/7z8AAAA4AAEOP05AFUAAAAA4GoFrP/r/7z8AAAA4
GYFrP/r/7z8A/P++AOihPje3HEAA/P++oGgtMWNmBkAA/P++i0pysv3/H0AA/P++UnSWM2Vm
BkAAAAA4vujtPvr/7z8B/P++/wQ1PztBDUAC/P++/gBVPzOAA0AAAAA4AOihPje3HEAAAAA4
AAEOP01AFUAA/P++/gBVPzOAA0AA/P++/wQ1PztBDUAAAAA4VAAAAAAAAAABAAAAAgAAAAMA
AAACAAAAAQAAAAMAAAABAAAABAAAAAUAAAAEAAAABgAAAAcAAAAGAAAAAAAAAAcAAAAAAAAA
BQAAAAcAAAAFAAAABgAAAAgAAAAGAAAAAQAAAAgAAAABAAAAAAAAAAgAAAAAAAAABgAAAAkA
AAABAAAABgAAAAkAAAAGAAAABAAAAAkAAAAEAAAAAQAAAAoAAAAEAAAABQAAAAsAAAADAAAA
BAAAAAsAAAACAAAAAwAAAAwAAAAAAAAAAgAAAAwAAAACAAAABQAAAAwAAAAFAAAAAAAAAA0A
AAAFAAAAAgAAAA0AAAACAAAACgAAAA0AAAAKAAAABQAAAA4AAAAEAAAACgAAAA4AAAAKAAAA
CwAAAA4AAAALAAAABAAAAA8AAAAKAAAAAgAAAA8AAAACAAAACwAAAA8AAAALAAAACgAAABAA
AAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAABAAAAAAAgLMJACC/
RGcGPwAAgLMBQAy4AGUGvwAAgLOnAOC0QmcGPxndHb8JACC/AGYGP0DdHb8JACC/AGYGvwAA
gLMJACC/dGUGvwHMzL4AAAC1wWUGv6nLzL4AAAC1gGYGPyQAAAAAAAAAAQAAAAIAAAADAAAA
BAAAAAAAAAADAAAAAAAAAAIAAAAFAAAAAAAAAAQAAAAFAAAABAAAAAEAAAAFAAAAAQAAAAAA
AAAGAAAABAAAAAMAAAAGAAAAAgAAAAEAAAAGAAAAAQAAAAQAAAAHAAAAAwAAAAIAAAAHAAAA
AgAAAAYAAAAHAAAABgAAAAMAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAAAAAAAAAAAAAAAAAA
AAAAAIA/GAAAAAQAAAA33R2/9/8fPwBnBj8AAIAzAAAUOEBnBj8AAIAz9/8fPwBnBj8AAIAz
9/8fPz1lBr833R2/9/8fPztlBr8AzMy+AAAAtcFlBr+AAIAzAAAAtQBlBr+py8y+AAAAtYBm
Bj8kAAAAAAAAAAEAAAACAAAAAwAAAAIAAAABAAAAAwAAAAAAAAACAAAABAAAAAUAAAAAAAAA
BAAAAAAAAAADAAAABAAAAAMAAAAFAAAABgAAAAUAAAADAAAABgAAAAMAAAABAAAABwAAAAUA
AAAGAAAABwAAAAYAAAABAAAABwAAAAAAAAAFAAAABwAAAAEAAAAAAAAAEAAAAAAAAAAAAAAA
AAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAAAACAPxgAAAAEAAAAAM7MPgAAALWBZgY/Qt4dP/f/
Hz8AZQa/QN4dP/f/Hz8BZwY/AACAM/f/Hz8BZwY/AACAM/f/Hz89ZQa/AIB0NwAAALUAZQa/
AACAMwAAFDhAZwY/AM7MPgAAALUAZQa/JAAAAAAAAAABAAAAAgAAAAMAAAACAAAAAQAAAAMA
AAAAAAAAAgAAAAQAAAABAAAABQAAAAQAAAADAAAAAQAAAAYAAAADAAAABAAAAAYAAAAEAAAA
BQAAAAYAAAAFAAAAAAAAAAYAAAAAAAAAAwAAAAcAAAAAAAAABQAAAAcAAAAFAAAAAQAAAAcA
AAABAAAAAAAAABAAAAAAAAAAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAgD8YAAAA
BAAAAEDeHT8GACC/AGYGPwAAgLMGACC/RGcGPwAAgLMGACC/dGUGvwDOzD4AAAC1gGYGP0ne
HT8GACC/AGYGvwDOzD4AAAC1AGUGvwCAhTcAAOC0QmcGPwAAgLMAQAy4AGUGvyQAAAAAAAAA
AQAAAAIAAAABAAAAAAAAAAMAAAAEAAAAAwAAAAAAAAAEAAAAAAAAAAIAAAAFAAAAAwAAAAQA
AAAFAAAABAAAAAIAAAAGAAAAAwAAAAUAAAAGAAAAAQAAAAMAAAAHAAAAAgAAAAEAAAAHAAAA
AQAAAAYAAAAHAAAABQAAAAIAAAAHAAAABgAAAAUAAAAQAAAAAAAAAAAAAAAAAAAAAAAAABAA
AAAAAAAAAAAAAAAAAAAAAIA/MAAAAAQAAAAIQQixamYGwAACAD/+AA4/UUAVwAACAD8dgWs/
AgDwvwECAD/DvCoyAQAgwAACAD9EQ98yAQAgwAD8/743ma6namYGwAD8/74dgWs/AgDwvwL8
/77+AA4/UUAVwAD8/77D5u0+AgDwvwD8/75N5+0+AgDwvwACAD8AAVU/NoADwAACAD8AAVU/
NoADwAD8/74A6KE+O7ccwAACAD8A6KE+O7ccwAD8/74ABTU/PkENwAACAD//BDU/PkENwAD8
/75UAAAAAAAAAAEAAAACAAAAAwAAAAEAAAAAAAAAAwAAAAAAAAAEAAAABQAAAAYAAAAEAAAA
BQAAAAQAAAAAAAAABwAAAAQAAAAGAAAACAAAAAYAAAAFAAAACAAAAAUAAAAAAAAACAAAAAIA
AAAGAAAACQAAAAAAAAACAAAACQAAAAIAAAAIAAAACQAAAAgAAAAAAAAACgAAAAYAAAACAAAA
CgAAAAIAAAABAAAACwAAAAcAAAAGAAAACwAAAAYAAAAKAAAADAAAAAcAAAABAAAADAAAAAEA
AAADAAAADAAAAAMAAAAEAAAADQAAAAQAAAAHAAAADQAAAAcAAAAMAAAADQAAAAwAAAAEAAAA
DgAAAAsAAAAKAAAADgAAAAEAAAAHAAAADgAAAAoAAAABAAAADwAAAAcAAAALAAAADwAAAAsA
AAAOAAAADwAAAA4AAAAHAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAQAAAAAAAAAAAAAAAAAAAA
AACAPzAAAAAEAAAAAAAAAGNmBkAAAgA/AAAAAP3/H0AB/P++AAAApf3/H0AAAgA/HoFrv/r/
7z//AQA/AACAJWNmBkAA/P++HoFrv/r/7z8A/P++AAEOv01AFUABAgA//wAOv01AFUD++/++
sObtvvr/7z8A/P++R+ftvvr/7z//AQA/AQFVvzOAA0AC/P++AQFVvzKAA0AAAgA/Auihvje3
HEAAAgA/Auihvja3HEAA/P++AgU1vztBDUAA/P++AgU1vzpBDUD/AQA/VAAAAAAAAAABAAAA
AgAAAAMAAAAAAAAAAgAAAAQAAAAFAAAAAQAAAAQAAAABAAAAAAAAAAYAAAADAAAAAgAAAAcA
AAABAAAABQAAAAgAAAAFAAAABAAAAAgAAAAEAAAAAAAAAAgAAAADAAAABQAAAAkAAAAAAAAA
AwAAAAkAAAADAAAACAAAAAkAAAAIAAAAAAAAAAoAAAAHAAAABQAAAAoAAAAFAAAAAwAAAAsA
AAADAAAABgAAAAsAAAAKAAAAAwAAAAwAAAAHAAAABgAAAAwAAAACAAAAAQAAAAwAAAAGAAAA
AgAAAA0AAAABAAAABwAAAA0AAAAHAAAADAAAAA0AAAAMAAAAAQAAAA4AAAAKAAAACwAAAA4A
AAAGAAAABwAAAA4AAAAHAAAACgAAAA8AAAALAAAABgAAAA8AAAAGAAAADgAAAA8AAAAOAAAA
CwAAAA==</SharedString>
		<SharedString md5="yuZpQdnvvUBOTYh1jqZ2cA=="></SharedString>
	</SharedStrings>
</roblox>